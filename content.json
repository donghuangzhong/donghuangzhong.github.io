{"meta":{"title":"DHZ'S BLOG","subtitle":"","description":"","author":"东皇钟","url":"https://donghuangzhong.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-02-04T08:15:42.817Z","updated":"2020-02-04T08:15:42.817Z","comments":true,"path":"about/index.html","permalink":"https://donghuangzhong.github.io/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 菜鸟程序员一名，涉及ACM算法、python传统机器学习等，2021考研党 关于主题本站主题是：Material X"},{"title":"所有分类","date":"2020-02-03T05:26:25.962Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"categories/index.html","permalink":"https://donghuangzhong.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-02-03T05:26:25.965Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"tags/index.html","permalink":"https://donghuangzhong.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"目标检测","slug":"目标检测","date":"2021-02-08T01:50:49.000Z","updated":"2021-02-09T12:29:38.828Z","comments":true,"path":"2021/02/08/目标检测/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/08/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/","excerpt":"摘要","text":"摘要 R-CNN算法流程 一张图像生成1K~2K个候选区域(使用Selective Search方法) 对每个候选区域，缩放后(277277)使用*AlexNet CNN网络**提取特征向量 (4096维)，最终得到2k * 4096大小矩阵 特征送入每一类(共20类)的SVM 分类器， 判别是否属于该类 ，得到2k * 20矩阵 对每一列进行非极大值抑制 寻找得分最高的目标 计算其他目标与该目标的iou值 删除所有iou值大于给定阈值的目标 使用回归器精细修正候选框位置 算法框架 存在的问题 测试速度慢测试一张图片约53s(CPU)。 用Selective Search算法提取候选框用时约2秒， 一张图像内候选框之间存在大量重叠， 提取特征操作冗余。 训练速度慢 训练所需空间大对于SVM和bbox回归训练， 需要从每个图像中的每个目标候选框提取特征， 并写入磁盘。 对于非常深的网络， 如VGG16， 从VOC07训练集上的5k图像上提取的特征需要数百GB的存储空间。 Fast R-CNN算法流程 一张图像生成1K~2K个候选区域(使用Selective Search方法) 整幅图像输入到网络得到特征图，将筛选后64个候选框投影到特征图后得到64个特征矩阵 特征矩阵通过ROI pooling层缩放到7x7大小的特征图，展平得到特征向量 特征向量并联分类器和边界框回归器 主要组件分类器 N+1个节点(N个类别+1个背景) 经过softmax处理 边界框回归器 (N+1)*4个节点(每个类别对应4个边界框回归参数(dx, dy, dw, dh) ) Px, Py, Pw, Ph 分别为候选框的中心x y坐标，以及宽高 Gˆx,Gˆ y,Gˆw,Gˆh 分别为最终预测的边界框中心x y坐标，以及宽高 损失函数 p : 分类器输出的softmax输出 u : 真实类别标签 算法框架 Faster R-CNN实际就是RPN + Fast R-CNN 算法流程 将图像输入网络得到相应的特征图 使用RPN结构生成候选框， 将RPN生成的候选框投影到特征图上获得相应的特征矩阵 将每个特征矩阵通过ROI pooling层缩放到7x7大小的特征图，接着将特征图展平通过一系列全连接层得到预测结果 RPNRPN在特征图的基础上用3*3的窗口(padding=1,步距为1)进行滑动，将3 * 3窗口的中心通过比例变换得到原图中的像素，以这个像素为中心生成9个anchor。去除跨越边界的anchor，对每一个anchor得到6个输出(2个表示是不是前景，后边四个表示回归参数)，采用非极大值抑制保留少数的候选框 YOLO v1算法思想 将一幅图像分成SxS个网格，如果某个类别真实候选框的中心落在这个网格中， 则这个网格就负责预测这个候选框。 每个网格要预测B个候选框和C个类别，候选框包含预测位置(x,y,w,h)和confidence值。 x,y,w,h都是相对值(相对于原图像)，都在0~1之间 网络结构 损失函数 缺点 群体性小目标检测效果不好(原论文7*7个网格，每个网格预测两个框) 目标出现新的尺寸比例的时候效果差(直接预测位置和宽高，而像R-CNN和SSD系列预测回归参数) YOLO v2算法尝试和创新 每个卷积层后加BN(Batch Normalization)层 更大的输入图片尺寸(更高分辨率) 基于Anchor Boxes，用K-means聚类得到anchor尺寸 用sigmoid函数限制变换后的位置 高层特征和底层特征(包含细节信息，解决v1小目标效果不好)结合 用4x4方格将宽高变为一半，深度变为4倍，与高层特征在深度上拼接 多尺度训练，解决输入图像尺寸固定的弊端，每迭代10个batch，随机选择图片尺寸 网络结构darknet-19 总结构 YOLO v3创新点 在三个尺度对目标进行检测 网络结构DarkNet-53 总结构) 损失函数 目标置信度损失目标置信度损失采用的是二值交叉熵损失(Binary Cross Entropy)，其中,表示预测目标边界框i中是否真实存在目标，0表示不存在，1表示存在。表示预测目标矩形框i内是否存在目标的Sigmoid概率（将预测值通过sigmoid函数得到）。 目标类别损失","categories":[{"name":"目标检测","slug":"目标检测","permalink":"https://donghuangzhong.github.io/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"目标检测","slug":"目标检测","permalink":"https://donghuangzhong.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"test","slug":"test","date":"2021-02-07T09:36:50.486Z","updated":"2021-02-07T09:57:12.775Z","comments":true,"path":"2021/02/07/test/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/07/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux_WSL","slug":"Linux-WSL","date":"2021-02-07T09:01:54.000Z","updated":"2021-02-10T04:24:48.769Z","comments":true,"path":"2021/02/07/Linux-WSL/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/07/Linux-WSL/","excerpt":"摘要","text":"摘要 常用命令版本相关linux查看当前操作系统发行信息1cat &#x2F;etc&#x2F;issue 更新阿里源 备份原先的源 1mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup 下载新的阿里源 1wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-8.repo 运行 yum makecache 生成缓存 1yum makecache 更新 1yum -y update 安装常用软件 软件地址： 安装之前上传到usr/local文件夹 安装JDK 查看jdk版本 1java –version 查看安装的jdk信息 1rpm -qa | grep java 卸载jdk 12rpm -e --nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686rpm -e --nodeps java-1.7.0-openjdk-1.7.0.79-2.5.5.4.el6.i686 进入usr/local解压JDK，通常将软件安装到/usr/local 1tar –xvf jdk.tar.gz -C 目标路径 配置JDK的环境变量 123456789vi &#x2F;etc&#x2F;profile在末尾行添加#set java environmentJAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk&#x2F;jdk1.7.0_71CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib.tools.jarPATH&#x3D;$JAVA_HOME&#x2F;bin:$PATHexport JAVA_HOME CLASSPATH PATH保存退出 安装mysql 上传后解压 将系统自带的mysql卸载 123rpm –qa | grep mysql rpm -e --nodeps 名字 安装MYSQL服务端 会在/root/.mysql_secret中生成root用户的密码 安装MYSQL客户端 查看生成的root密码 开启mysql服务 1service mysql start 设置root用户的密码 1set password&#x3D;password(&#39;root&#39;) 设置mysql远程访问 123grant all privileges on *.* to &#39;root&#39; @&#39;%&#39; identified by &#39;root&#39;;flush privileges; 防火墙设置 1234567在linux中很防火墙打开3306端口&#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 3306 -j ACCEPT&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;iptables save&#x2F;etc&#x2F;init.d&#x2F;iptables status学习阶段我们也可以直接将防火墙关闭service iptables stop;多软件的端口都被”防火墙”限止，我们需要将防火墙关闭 安装tomcat 上传解压至usr/local 在tomcat/bin目录下执行 startup.sh 安装Redisredis是C语言开发，安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境。 安装c语言环境 1yum install gcc-c++ 下载redis 1wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.0.4.tar.gz 解压 1tar -xzvf redis-3.0.4.tar.gz 编译 12cd redis-3.0.4make 安装 1make PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis install 复制配置文件到/usr/local/redis/bin目录 123cd redis-3.0.4cp redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin 启动redis 1234567cd redis&#x2F;bin指定配置文件启动服务端.&#x2F;redis-server redis.conf启动客户端.&#x2F;redis-cli 安装Nginx 安装gcc环境 1yum install gcc-c++ 安装第三方的开发包 123yum install -y pcre pcre-develyum install -y zlib zlib-develyum install -y openssl openssl-devel 上传解压安装包到usr/local 1tar -zxvf nginx-1.8.0.tar.gz 进入解压目录生成makeFile 文件，然后make 1234567891011121314151617181920cd nginx-1.8.0&#x2F;.&#x2F;configure \\--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx \\--pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx&#x2F;nginx.pid \\--lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx.lock \\--error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log \\--http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client \\--http-proxy-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;proxy \\--http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;fastcgi \\--http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;uwsgi \\--http-scgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;scgimakemake install&#x2F;&#x2F;注：四条命令都要执行，最后会生成一个usr&#x2F;local&#x2F;nginx文件夹 安装完成，创建临时目录 1mkdir &#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client -p 启动 123cd sbin&#x2F;.&#x2F;nginx 关闭、刷新命令 123.&#x2F;nginx -s quit &#x2F;&#x2F;正常关闭.&#x2F;nginx -s stop &#x2F;&#x2F;杀进程.&#x2F;nginx -s reload &#x2F;&#x2F;刷新 安装Centos8下载镜像12 用命令行安装123windows命令行(管理员)：wsl --import &lt;分发版&gt; &lt;安装位置&gt; &lt;文件名&gt; [选项]wsl --import CentOS D:\\CentOS D:\\文件路径\\centos8.tar 启动1wsl -d Centos 迁移查看当前用户名12whoami&#x2F;&#x2F;我的用户名是 DongHuangZhong 在迁移目标磁盘创建一个文件夹 ，并设置权限123icacls E:\\bianchenggongju\\Kali.windows &#x2F;grant &quot;DongHuangZhong:(OI)(CI)(F)&quot;.\\lxrunoffline move -n kali-linux -d E:\\bianchenggongju\\Kali.windows 下载解压 LxRunOffline1网址:https:&#x2F;&#x2F;github.com&#x2F;DDoSolitary&#x2F;LxRunOffline&#x2F;releases 解压后，在此目录中按shift+鼠标右键，在此处打开powershell 查看已安装的Linux发行版本1.\\lxrunoffline list 用命令迁移1.\\lxrunoffline move -n kali-linux -d E:\\bianchenggongju\\Kali.windows 确认迁移完成1.&#x2F;LxRunOffline.exe get-dir -n kali-linux","categories":[{"name":"Linux","slug":"Linux","permalink":"https://donghuangzhong.github.io/categories/Linux/"}],"tags":[{"name":"WSL","slug":"WSL","permalink":"https://donghuangzhong.github.io/tags/WSL/"}]},{"title":"python_pandas","slug":"python-pandas","date":"2021-01-28T03:27:31.000Z","updated":"2021-01-28T03:43:08.223Z","comments":true,"path":"2021/01/28/python-pandas/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/28/python-pandas/","excerpt":"摘要","text":"摘要 主体数据类型：DataFrame 名称 功能 参数 返回值 pd.read_csv() 读取csv 路径字符串 DataFrame pd.DataFrame(np.zeros(shape=[1000, 20]), columns=move_class) 创建DataFarame ndarry，列标签 DataFrame DataFrame.sum(axis) 对行或列求和 axis，0列求和，1行求和","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"https://donghuangzhong.github.io/tags/pandas/"}]},{"title":"python_ndarray","slug":"python-ndarray","date":"2021-01-28T03:14:20.000Z","updated":"2021-01-28T04:05:01.935Z","comments":true,"path":"2021/01/28/python-ndarray/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/28/python-ndarray/","excerpt":"摘要","text":"摘要 1.ndarray创建1.通过list创建1a &#x3D; np.array([[1, 2, 3], [4, 5, 6]], dtype &#x3D; np.float32) 2.ndarray的属性 属性 含义 类型 shape 形状 元组 ndim 维度 整数 size 数组中元素个数 整数 itemsize 元素的字节数 整数 dtype 元素类型 “int32” 3.ndarray的方法1.reshape() &amp;&amp; resize()reshape()不改变数据，只改变逻辑上的维数 resize()会改变数据 2.stock_change[stock_change &gt; 0.5] = 1.1将stock_change元素中&gt;0.5的置为1.1 1234567print(score.shape)print(score.ndim)print(score.size)print(score.itemsize)print(score.dtype)score2 &#x3D; score.reshape(6, 5) 4.numpy的方法1.np.random.uniform(low,high,size)均匀分布[low,high)中随机采样size次得到一维数组 2.np.unique(ndarray)返回去重后的数组 3.numpy.random.normal(loc,scale,size)loc：均值 scale：方差 size：个数 4.np.hstack(a,b)在水平方向上连接a数组和b数组 5.np.concatenate((a,b),axis=0)axis=1表示对应行的数组进行拼接 axis=0表示对应列的数组进行拼接 6.np.split()12345678x &#x3D; np.arange(9)print(x)print(np.split(x, 3))print(np.split(x, [3, 5, 7, 8]))[0 1 2 3 4 5 6 7 8][array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])][array([0, 1, 2]), array([3, 4]), array([5, 6]), array([7]), array([8])]","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://donghuangzhong.github.io/tags/numpy/"}]},{"title":"python_pyplot","slug":"python-pyplot","date":"2021-01-28T01:49:00.000Z","updated":"2021-01-28T03:27:06.885Z","comments":true,"path":"2021/01/28/python-pyplot/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/28/python-pyplot/","excerpt":"摘要","text":"摘要 1.图形属性123plt.title(&quot;matplotlib demo&quot;)plt.figure(figsize&#x3D;(20, 8), dpi&#x3D;80) &#x2F;&#x2F;dpi每英寸像素数plt.show()&#x2F;&#x2F;最后都要加才能显示 2.其他图1.二维函数图123plt.xlabel(&quot;x axis&quot;)plt.ylabel(&quot;y axis&quot;)plt.plot(x, y) 2.散点图1plt.scatter(x, y) 3.柱状图1plt.bar(x_lebel, y, color&#x3D;[&#39;b&#39;, &#39;r&#39;, &#39;g&#39;, &#39;y&#39;, &#39;c&#39;, &#39;m&#39;, &#39;y&#39;, &#39;k&#39;, &#39;c&#39;]) 4.饼图1234567plt.pie(tickets, labels&#x3D;movie_names, colors&#x3D;[&#39;b&#39;, &#39;r&#39;, &#39;g&#39;, &#39;y&#39;],autopct&#x3D;&quot;%1.2f&quot;)&#x2F;&#x2F;autopct :控制饼图内百分比设置,可以使用format字符串或者format function &#39;%1.1f&#39;指小数点前后位数(没有用空格补齐) &#x2F;&#x2F;显示图例对应关系plt.legend() 5.直方图12345plt.hist(y, bins&#x3D;10)&#x2F;&#x2F;bins：有几条柱子plt.xticks(range(min(time), max(time), distance))&#x2F;&#x2F;x轴的开始结束和步距 3.中文乱码问题 百度安装simhei.ttf字体 打开python安装目录下python\\Lib\\site-packages\\matplotlib\\mpl-data\\matplotlibrc 搜索font.sans-serif ，去掉注释，在冒号后添加SimHei 搜索axes.unicode_minus，注释去掉，Ture改为False","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"}],"tags":[{"name":"pyplot","slug":"pyplot","permalink":"https://donghuangzhong.github.io/tags/pyplot/"}]},{"title":"深度学习_keras","slug":"深度学习-keras","date":"2021-01-17T02:37:19.000Z","updated":"2021-01-18T10:22:40.295Z","comments":true,"path":"2021/01/17/深度学习-keras/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-keras/","excerpt":"摘要","text":"摘要 1.函数式编程组件1.keras.layers.Conv2D12345678tf.keras.layers.Conv2D( filters, kernel_size, strides&#x3D;(1, 1), padding&#x3D;&#39;valid&#39;, data_format&#x3D;None, dilation_rate&#x3D;(1, 1), groups&#x3D;1, activation&#x3D;None, use_bias&#x3D;True, kernel_initializer&#x3D;&#39;glorot_uniform&#39;, bias_initializer&#x3D;&#39;zeros&#39;, kernel_regularizer&#x3D;None, bias_regularizer&#x3D;None, activity_regularizer&#x3D;None, kernel_constraint&#x3D;None, bias_constraint&#x3D;None, **kwargs) 函数式编程后边必须是四维的[batch,width,height,chanel] 1.增加维度 后增 1x_train &#x3D; x_train[:, tf.newaxis] 前增 1x_train &#x3D; x_train[tf.newaxis,:] 2.keras.preprocessing.image.ImageDataGenerator123456789tf.keras.preprocessing.image.ImageDataGenerator( featurewise_center&#x3D;False, samplewise_center&#x3D;False, featurewise_std_normalization&#x3D;False, samplewise_std_normalization&#x3D;False, zca_whitening&#x3D;False, zca_epsilon&#x3D;1e-06, rotation_range&#x3D;0, width_shift_range&#x3D;0.0, height_shift_range&#x3D;0.0, brightness_range&#x3D;None, shear_range&#x3D;0.0, zoom_range&#x3D;0.0, channel_shift_range&#x3D;0.0, fill_mode&#x3D;&#39;nearest&#39;, cval&#x3D;0.0, horizontal_flip&#x3D;False, vertical_flip&#x3D;False, rescale&#x3D;None, preprocessing_function&#x3D;None, data_format&#x3D;None, validation_split&#x3D;0.0, dtype&#x3D;None) featurewise_center：布尔值，使输入数据集去中心化（均值为0）, 按feature执行。 samplewise_center：布尔值，使输入数据的每个样本均值为0。 featurewise_std_normalization：布尔值，将输入除以数据集的标准差以完成标准化, 按feature执行。 samplewise_std_normalization：布尔值，将输入的每个样本除以其自身的标准差。 zca_whitening：布尔值，对输入数据施加ZCA白化。 rotation_range：整数，数据提升时图片随机转动的角度。随机选择图片的角度，是一个0180的度数，取值为0180。 width_shift_range：浮点数，图片宽度的某个比例，数据提升时图片随机水平偏移的幅度。 height_shift_range：浮点数，图片高度的某个比例，数据提升时图片随机竖直偏移的幅度。height_shift_range和width_shift_range是用来指定水平和竖直方向随机移动的程度，这是两个0~1之间的比例。 shear_range：浮点数，剪切强度（逆时针方向的剪切变换角度）。是用来进行剪切变换的程度。 zoom_range：浮点数或形如[lower,upper]的列表，随机缩放的幅度，若为浮点数，则相当于[lower,upper] = [1 - zoom_range, 1+zoom_range]。用来进行随机的放大。 channel_shift_range：浮点数，随机通道偏移的幅度。 fill_mode：‘constant’，‘nearest’，‘reflect’或‘wrap’之一，当进行变换时超出边界的点将根据本参数给定的方法进行处理 cval：浮点数或整数，当fill_mode=constant时，指定要向超出边界的点填充的值。 horizontal_flip：布尔值，进行随机水平翻转。随机的对图片进行水平翻转，这个参数适用于水平翻转不影响图片语义的时候。 vertical_flip：布尔值，进行随机竖直翻转。 rescale: 值将在执行其他处理前乘到整个图像上，我们的图像在RGB通道都是0255的整数，这样的操作可能使图像的值过高或过低，所以我们将这个值定为01之间的数。 preprocessing_function: 将被应用于每个输入的函数。该函数将在任何其他修改之前运行。该函数接受一个参数，为一张图片（秩为3的numpy array），并且输出一个具有相同shape的numpy array data_format：字符串，“channel_first”或“channel_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channel_last”对应原本的“tf”，“channel_first”对应原本的“th”。以128x128的RGB图像为例，“channel_first”应将数据组织为（3,128,128），而“channel_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channel_last”。 1.归一化1ImageDataGenerator(rescale&#x3D;1. &#x2F; 255) 2.flow_from_directory123456789101112131415def flow_from_directory(self, directory, target_size&#x3D;(256, 256), color_mode&#x3D;&#39;rgb&#39;, classes&#x3D;None, class_mode&#x3D;&#39;categorical&#39;, batch_size&#x3D;32, shuffle&#x3D;True, seed&#x3D;None, save_to_dir&#x3D;None, save_prefix&#x3D;&#39;&#39;, save_format&#x3D;&#39;png&#39;, follow_links&#x3D;False, subset&#x3D;None, interpolation&#x3D;&#39;nearest&#39;): directory: 目标文件夹路径,此文件夹下包含分类图片的文件夹，然后再是图片，比如此文件夹名为flower,下面含有[daisy,dandelion,roses,sunflowers,tulips]5个文件夹，roses文件夹下是玫瑰花的图片 target_size: 整数tuple,默认为(256, 256). 图像将被resize成该尺寸 batch_size: batch数据的大小,默认32 shuffle: 是否打乱数据,默认为True class_mode: “categorical”, “binary”, “sparse”或None之一. 默认为”categorical. 该参数决定了返回的标签数组的形式, “categorical”会返回2D的one-hot编码标签,”binary”返回1D的二值标签.”sparse”返回1D的整数标签,如果为None则不返回任何标签, 生成器将仅仅生成batch数据, 这种情况在使用model.predict_generator()和model.evaluate_generator()等函数时会用到. color_mode: 颜色模式,为”grayscale”,”rgb”之一,默认为”rgb”.代表这些图片是否会被转换为单通道或三通道的图片. classes: 可选参数,为子文件夹的列表,如[‘dogs’,’cats’]默认为None. 若未提供,则该类别列表将从directory下的子文件夹名称/结构自动推断。每一个子文件夹都会被认为是一个新的类。(类别的顺序将按照字母表顺序映射到标签值)。通过属性class_indices可获得文件夹名与类的序号的对应字典。 seed: 可选参数,打乱数据和进行变换时的随机数种子 save_to_dir: None或字符串，该参数能让你将提升后的图片保存起来，用以可视化 save_prefix：字符串，保存提升后图片时使用的前缀, 仅当设置了save_to_dir时生效 save_format：”png”或”jpeg”之一，指定保存图片的数据格式,默认”jpeg” flollow_links: 是否访问子文件夹中的软链接 .n属性可以获得数量 2.modelloss1.categorical_crossentropy:one-hot2.SparseCategoricalCrossentropy():数字编码1.steps_per_epoch一个step就是一个batch_size 3.搭建网络流程1.列好网络中各层的网络参数2.api编程搭建model3.存在的问题1.jupyter显存占用 每次运行完都重启一下服务","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://donghuangzhong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"_keras","slug":"keras","permalink":"https://donghuangzhong.github.io/tags/keras/"}]},{"title":"深度学习","slug":"深度学习","date":"2021-01-16T10:45:07.000Z","updated":"2021-01-19T04:04:44.510Z","comments":true,"path":"2021/01/16/深度学习/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","excerpt":"摘要","text":"摘要 1.AlexNet概述1.亮点 首次使用GPU加速 使用ReLu激活函数，非传统Sigmoid或Tanh LRN局部响应归一化 全连接层前两层使用Dropout随机失活神经元减少过拟合 2.8层结构卷积层公式12output&#x3D;(W-F+2P)&#x2F;S+1W:输入图片的大小(一般Width&#x3D;Height) F:卷积核大小 S:步长 P:Padding的像素数 层数\\参数 input_size kernels kernel_size padding stride output_size Conv1 [224, 224, 3] 48 * 2 = 96 11 [1, 2] 4 [55, 55, 96] Maxpool1 [55, 55, 96] None 3 0 2 [27, 27, 96] Conv2 [27, 27, 96] 256 5 [2, 2] 1 [27,27, 256] Maxpool2 [27, 27, 256] None 3 0 2 [13, 13, 256] Conv3 [13, 13, 256] 192*2= 384 3 [1, 1] 1 [13, 13, 384] Conv4 [13, 13, 384] 192*2= 384 3 [1, 1] 1 [13, 13, 384] Conv5 [13, 13, 384] 128*2= 256 3 [1, 1] 1 [13, 13, 256] Maxpool3 [13, 13, 256] None 3 0 2 [6, 6, 256] Fc1 2048 None None None None None Fc2 2048 None None None None None Fc3 1000 None None None None None 2.VGG网络1.概述VGG 在2014年由牛津大学著名研究组 VGG（Visual Geometry Group）提出，斩获该年 ImageNet 竞赛中 Localization Task（定位任务）第一名和 Classification Task（分类任务）第二名。 2.亮点 创新点通过堆叠多个小卷积核来替代大尺度卷积核，可以减少训练参数，同时能保证相同的感受野。论文中提到，可以通过堆叠两个3×3的卷积核替代5x5的卷积核，堆叠三个3×3的卷积核替代7x7的卷积核。 1在卷积神经网络中，决定某一层输出结果中一个元素所对应的输入层的区域大小，被称作感受野（receptive field）。 计算公式：F(i)=(F(i+1)−1)×Stride +Ksize F(i) 为第 i 层感受野 Stride为第 i 层的步距 Ksize 为 卷积核 或 池化核 尺寸 3.结构 3.GoogLeNet1.概述GoogLeNet在2014年由Google团队提出（与VGG网络同年，注意GoogLeNet中的L大写是为了致敬LeNet），斩获当年ImageNet竞赛中Classification Task (分类任务) 第一名。 2.亮点创新点 引入了 Inception 结构（融合不同尺度的特征信息） 使用1x1的卷积核进行降维以及映射处理 （虽然VGG网络中也有，但该论文介绍的更详细） 添加两个辅助分类器帮助训练 丢弃全连接层，使用平均池化层（大大减少模型参数，除去两个辅助分类器，网络大小只有vgg的1/20） inception 将特征矩阵同时输入到多个分支进行处理，并将输出的特征矩阵按深度进行拼接，得到最终输出。 作用：增加网络深度和宽度的同时减少参数。 3.结构","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://donghuangzhong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AlexNet","slug":"AlexNet","permalink":"https://donghuangzhong.github.io/tags/AlexNet/"}]},{"title":"jupyter","slug":"jupyter","date":"2021-01-16T01:32:24.000Z","updated":"2021-01-17T05:10:32.032Z","comments":true,"path":"2021/01/16/jupyter/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/16/jupyter/","excerpt":"单独的python安装jupyter","text":"单独的python安装jupyter 1.pip安装最好使用中科大的源 1pip install -i https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple jupyter 2.打开1jupyter notebook 3.可能出现的问题1.kernel error FileNotFoundError: [WinError 2] 系统找不到指定的文件解决方法 查看内核安装位置 1jupyter kernelspec list 在1中的路径打开kernel.jason查看Python编译器的路径是否正确 如果不正确，运行下面这天代码自动修正路径 1python -m ipykernel install --user 4.改默认路径1.生成config文件1jupyter notebook --generate-config 2.打开配置文件，搜索notebook_dir，删去#号修改即可3.重启jupyter5.代码补全1.进入Anaconda Prompt，依次运行以下代码1234567&#x2F;&#x2F;1.安装nbextensions pip install jupyter_contrib_nbextensions -i https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simplejupyter contrib nbextension install --user&#x2F;&#x2F;2.安装nbextensions_configuratorpip install --user jupyter_nbextensions_configurator jupyter nbextensions_configurator enable --user 2.重启jupyter可以看到增加了一个Nbextensions标签页，在这个页面里，勾选Hinterland","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"}],"tags":[{"name":"jupyter","slug":"jupyter","permalink":"https://donghuangzhong.github.io/tags/jupyter/"}]},{"title":"python","slug":"python","date":"2021-01-15T07:59:53.597Z","updated":"2021-01-16T01:34:29.586Z","comments":true,"path":"2021/01/15/python/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/15/python/","excerpt":"","text":"1.设置延时1pip --default-timeout&#x3D;200 install XXX 2.清楚模块(包)缓存1路径：C:\\Users\\用户名\\AppData\\Local\\pip 3.换源123中科大：https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;清华：https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple原始官方源：https:&#x2F;&#x2F;pypi.Python.org&#x2F;simple&#x2F; 1.永久换源1pip config set global.index-url https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 原始的源 1pip config set global.index-url https:&#x2F;&#x2F;pypi.Python.org&#x2F;simple&#x2F; 2.单次换源1pip install -i https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple XXX 4.卸载所有模块12pip freeze &gt; python_modules.txtpip uninstall -r python_modules.txt -y","categories":[],"tags":[]},{"title":"Win10_GeForce940MX_TersorFlow","slug":"Win10-GeForce940MX-TersorFlow","date":"2021-01-15T01:31:12.000Z","updated":"2021-03-01T01:37:18.724Z","comments":true,"path":"2021/01/15/Win10-GeForce940MX-TersorFlow/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/15/Win10-GeForce940MX-TersorFlow/","excerpt":"win10下GeForce940MX显卡安装 概述 安装","text":"win10下GeForce940MX显卡安装 概述 安装 1.安装TensorFlow-GPU1.安装环境 win10 GeForce940MX 自己安装的python3.7.4，非集成环境 2.pip命令安装tersorflow1pip --timeout&#x3D;100 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple tensorflow 必须设置timeout不然稍微网络不好就会报错，然后需要从头开始下载。 如果还是失败，手动去清华源下载whl文件，然后本地pip安装 1https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F; 这里面有版本的问题，不建议安装最新版的tersorflow，我安装的2.x，运行不了，后来重新安装了1.5 3.安装CUDA1https:&#x2F;&#x2F;developer.nvidia.com&#x2F;cuda-toolkit-archive 运行import tersorflow，如果报错cudart64_100.dll找不到，需要将CUDA安装目录下bin添加到系统环境变量path中 4.安装cuDNN1https:&#x2F;&#x2F;developer.nvidia.com&#x2F;cudnn 是一个压缩包，解压放到任何一个目录下就行，然后把其中的bin目录路径添加到Path环境变量里。 最好也将cuDNN安装目录下bin添加到系统环境变量path中 5.测试运行123import tensorflow as tfprint(&#39;Tensorflow Version:&#123;&#125;&#39;.format(tf.__version__))print(tf.test.is_gpu_available()) yolo12python convert.py yolov3.cfg yolov3.weights model_data&#x2F;yolo.h5python convert.py -w yolov3-tiny.cfg yolov3-tiny.weights model_data&#x2F;tiny_yolo_weights.h5","categories":[{"name":"TersorFlow","slug":"TersorFlow","permalink":"https://donghuangzhong.github.io/categories/TersorFlow/"}],"tags":[{"name":"GeForce940MX","slug":"GeForce940MX","permalink":"https://donghuangzhong.github.io/tags/GeForce940MX/"}]},{"title":"hexo便捷图片解决方案","slug":"hexo便捷图片解决方案","date":"2021-01-13T03:58:22.000Z","updated":"2021-02-09T12:32:02.559Z","comments":true,"path":"2021/01/13/hexo便捷图片解决方案/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/13/hexo%E4%BE%BF%E6%8D%B7%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"使图片在本地和网站上都能显示正常 win+s截图，在Typora上粘贴即可，不需要做任何操作","text":"使图片在本地和网站上都能显示正常 win+s截图，在Typora上粘贴即可，不需要做任何操作 1.安装图片插件1npm install hexo-asset-image --save 2.配置文件_config.yml 里post_asset_folder:选项设置为true这样每次hexo n “xxx”时就会一起生成同名文件夹 3.更改Typora设置1.文件-&gt;偏好设置-&gt;图像2.点击下拉框，选择复制到指定路径，如下图设置 3.随便截图，粘贴到Typora中即可","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://donghuangzhong.github.io/categories/Hexo/"}],"tags":[{"name":"图片","slug":"图片","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%BE%E7%89%87/"}]},{"title":"VM虚拟机和物理机共享文件夹","slug":"VM虚拟机和物理机共享文件夹","date":"2021-01-12T03:46:55.000Z","updated":"2021-02-09T12:32:37.283Z","comments":true,"path":"2021/01/12/VM虚拟机和物理机共享文件夹/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/12/VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E7%89%A9%E7%90%86%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/","excerpt":"VM虚拟机和实体机共享文件夹","text":"VM虚拟机和实体机共享文件夹 1.在VM中安装VMware Tools 如果没反应，看下面的提示，按win+R,输入D:\\setup.exe手动安装,之后可能需要重启 2.在虚拟机-&gt;设置-&gt;选项-&gt;共享文件夹-&gt;总是启用在下方点添加-&gt;选路径-&gt;勾选映射为驱动器(这一步一定要做！！！)一直下一步，直至完成 3.然后就可以在虚拟机我的电脑里面看到共享的驱动器了","categories":[{"name":"VM","slug":"VM","permalink":"https://donghuangzhong.github.io/categories/VM/"}],"tags":[{"name":"VM","slug":"VM","permalink":"https://donghuangzhong.github.io/tags/VM/"},{"name":"共享文件","slug":"共享文件","permalink":"https://donghuangzhong.github.io/tags/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/"}]},{"title":"Img_test","slug":"Img-test","date":"2021-01-12T02:45:29.000Z","updated":"2021-02-09T12:25:32.761Z","comments":true,"path":"2021/01/12/Img-test/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/12/Img-test/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"hexo+github_pages+阿里云域名","slug":"hexo-github-pages-阿里云域名","date":"2021-01-02T09:46:19.000Z","updated":"2021-02-09T12:37:20.828Z","comments":true,"path":"2021/01/02/hexo-github-pages-阿里云域名/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/02/hexo-github-pages-%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/","excerpt":"hexo+github_pages+阿里云域名，整理自B站视频:https://www.bilibili.com/video/BV1Yb411a7ty","text":"hexo+github_pages+阿里云域名，整理自B站视频:https://www.bilibili.com/video/BV1Yb411a7ty 1.安装Node.js官网:https://nodejs.org/en/xia安装LTS版本即可 2.安装 Git官网:https://git-scm.com/downloads 2个都安装完成如下： 3.安装hexo1.新建一个文件夹，右键空白处点Git Bash Here 关于博客的所有文件都在这个文件夹下面，我新建的名字是dipamkar。 验证node，npm 是否安装成功，没有成功的就重新安装node。 1键入node -v和npm -v。进行验证 2.安装个cnpm提高速度，以后下载什么东西都用cnpm1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 验证cnpm是否安装成功，键入cnpm -v 3.正式安装hexo1cnpm install -g hexo-cli 验证hexo是否安装成功，键入hexo -v 4.初始化hexo1.本地初始化1hexo init 在此文件夹就会出现一堆文件 2.运行测试常用命令： 1234hexo clean #用来清理缓存文件hexo g #生成文件hexo s #运行本地服务器hexo d #上传到服务器 先运行hexo s。在浏览器中打开网址localhost:4000即可，得到下图表示成功 5.部署到github1.注册登录github网址：github.com 2.点击your repositories然后点new,新建仓库 3.Repository name必须写github账号名+github.io 填成上图即可点击create完成仓库创建 4.安装部署插件1cnpm install --save hexo-deployer-git 5.修改配置文件_config.yml 右键这个文件-&gt;编辑 或者用记事本打开 到此文件最后的位置，只改Deployment，改成下图 注意：repo按照下图从仓库中复制过来，改完不要忘了保存 6.绑定邮箱和账号名键入以下命令，引号中的信息换成你自己的 12git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 7.用hexo d正式部署到github 键入hexo d，然后会让你输入github账号密码，最后出现Deploy done表示成功 然后就可以用github账号名.github.io访问了 8.常用流程和命令1234567891011121314151617181920&#x2F;&#x2F;新建文章(默认md文件)hexo n &quot;文章名称&quot;&#x2F;&#x2F;本地调试hexo s&#x2F;&#x2F;清理文件夹hexo clean&#x2F;&#x2F;生成静态网页hexo g&#x2F;&#x2F;部署到githubhexo d&#x2F;&#x2F;必须先生成然后再部署，生成+部署可以简写成一条命令hexo g -d&#x2F;&#x2F;一般先用hexo n “”生成md文件-&gt;写文章-&gt;hexo g -d","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://donghuangzhong.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"博客搭建","slug":"个人博客/博客搭建","permalink":"https://donghuangzhong.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/tags/hexo/"},{"name":"github_pages","slug":"github-pages","permalink":"https://donghuangzhong.github.io/tags/github-pages/"}]},{"title":"计算机图形学 MFC 鼠标绘制多边形并用指定数字填充","slug":"计算机图形学-MFC-鼠标绘制多边形并用指定数字填充","date":"2020-12-31T02:37:39.000Z","updated":"2021-02-09T12:34:55.568Z","comments":true,"path":"2020/12/31/计算机图形学-MFC-鼠标绘制多边形并用指定数字填充/","link":"","permalink":"https://donghuangzhong.github.io/2020/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-MFC-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%B9%B6%E7%94%A8%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97%E5%A1%AB%E5%85%85/","excerpt":"边标志算法的实现 ，用鼠标左键单击绘制顶点最后一个顶点用双击输入，然后用任意的数字填充，用vc6.0软件做的","text":"边标志算法的实现 ，用鼠标左键单击绘制顶点最后一个顶点用双击输入，然后用任意的数字填充，用vc6.0软件做的 1.新建MFC项目 然后点finish就行 2.添加鼠标左键单击和双击的响应事件 Class name必须选View结尾的，选择WM_LBUTTONDOWN，然后必须先点Add Function，然后再点OK 这样就可以在目录结构中看到添加的事件了 同样可以添加双击的事件 3.首先实现用鼠标绘制多边形的代码首先分析一个我们要干的事，用鼠标单击事件获取到点的坐标后需要，moveto和lineto来划线，但是第一个点的时候不用划线，只有第二个点的时候才需要和上一个点划线，之后我们还需要每一个边的起点终点的位置，所以必须把所有点保存下来，同时需要记录这个多边形对应的矩形区域 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int max_x,max_y,min_x,min_y;&#x2F;&#x2F;多边形的矩形区域bool flag1&#x3D;0,flag&#x3D;0;&#x2F;&#x2F;flag1控制只进行一次画多边形，flag控制存放起点CPoint p[100];&#x2F;&#x2F;保存顶点数组，填充需要int n&#x3D;0;&#x2F;&#x2F;表示多边形顶点的的个数void CShiyan2View::OnLButtonDown(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;如果多边形已经绘制完成，再次点击则不会响应 &#123; if(!flag)&#123; max_x&#x3D;min_x&#x3D;point.x;&#x2F;&#x2F;初始化最开始的矩形区域为第一个点的横纵坐标 max_y&#x3D;min_y&#x3D;point.y; flag&#x3D;1; p[n++]&#x3D;point; &#125; else &#123; if(point.x&gt;max_x)&#x2F;&#x2F;更新矩形区域的坐标 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); p[n++]&#x3D;point; &#125; &#125; ReleaseDC(pDC); CView::OnLButtonDown(nFlags, point);&#125;void CShiyan2View::OnLButtonDblClk(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;只有没有绘制完成才会对双击进行响应 &#123; if(point.x&gt;max_x)&#x2F;&#x2F;此为最后一个顶点，同样需要更新矩形区域 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); pDC-&gt;MoveTo(point); pDC-&gt;LineTo(p[0]); flag1&#x3D;1;&#x2F;&#x2F;表示多边形已经绘制完成 p[n++]&#x3D;point; p[n]&#x3D;p[0]; &#125; ReleaseDC(pDC); CView::OnLButtonDblClk(nFlags, point);&#125; 4.用边标志法实现多边形填充(先用纯色填充)需要一个bool数组mask，初始全0，遍历每一条边上的点，将这个点右边的msak取反，最后得到的mask中为1的区域就是需要填充的区域。 从顶点数组p中获取每一条边的顶点信息，然后根据y计算x，对mask进行取反即可 要注意两点： 注意遍历点的时候要纵坐标优先，也就是纵坐标每次变化1，用纵坐标去计算横坐标 在顶点数组中，有可能出现起点的y比终点的y大的情况，这样就需要手动转换了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void CShiyan2View::OnLButtonDblClk(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;只有没有绘制完成才会对双击进行响应 &#123; if(point.x&gt;max_x)&#x2F;&#x2F;此为最后一个顶点，同样需要更新矩形区域 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); pDC-&gt;MoveTo(point); pDC-&gt;LineTo(p[0]); flag1&#x3D;1;&#x2F;&#x2F;表示多边形已经绘制完成 p[n++]&#x3D;point; p[n]&#x3D;p[0]; &#125; &#x2F;&#x2F;填充部分 for(int i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) mask[i][j]&#x3D;0;&#x2F;&#x2F;将数组全置0 for(i&#x3D;0;i&lt;n;i++)&#x2F;&#x2F;处理每一条边 &#123; int s&#x3D;p[i].y&lt;p[i+1].y?i:i+1;&#x2F;&#x2F;s保存的是较小y点的下标，e保存y较大的点的下标 int e&#x3D;2*i+1-s;&#x2F;&#x2F;由于起点终点的下标一个是i,一个是i+1，和为2*i+1，所以可以通过s计算e double dx&#x3D;(p[e].x-p[s].x)&#x2F;double(p[e].y-p[s].y);&#x2F;&#x2F;保存dx&#x2F;dy。也就是y每变化1，x的变化值 for(int y&#x3D;p[s].y;y&lt;p[e].y;y++) &#123; int x&#x3D;(y-p[s].y)*dx+p[s].x;&#x2F;&#x2F;通过y计算x。简单的直线方程 for(int t&#x3D;x;t&lt;&#x3D;max_x;t++) mask[t][y]&#x3D;!mask[t][y]; &#x2F;&#x2F;将此点右边的全取反 &#125; &#125; for(i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) if(mask[i][j]) pDC-&gt;SetPixel(i,j,RGB(100,100,100));&#x2F;&#x2F;将数组中为1的区域涂色 ReleaseDC(pDC); CView::OnLButtonDblClk(nFlags, point);&#125; 5.用任意数字填充首先要生成数字的点阵数组。然后就可以通过区域的周期性来画图。 生成指定数字的点阵数组，利用0~9镜像对称的数组来实现 1234567891011121314151617181920212223242526char a[10][8]&#x3D;&#123; &#123;0x00,0x18,0x24,0x24,0x24,0x24,0x24,0x18&#125;, &#x2F;&#x2F;0 &#123;0x00,0x18,0x1c,0x18,0x18,0x18,0x18,0x18&#125;, &#x2F;&#x2F;1 &#123;0x00,0x1e,0x30,0x30,0x1c,0x06,0x06,0x3e&#125;, &#x2F;&#x2F;2 &#123;0x00,0x1e,0x30,0x30,0x1c,0x30,0x30,0x1e&#125;, &#x2F;&#x2F;3 &#123;0x00,0x30,0x38,0x34,0x32,0x3e,0x30,0x30&#125;, &#x2F;&#x2F;4 &#123;0x00,0x1e,0x02,0x1e,0x30,0x30,0x30,0x1e&#125;, &#x2F;&#x2F;5 &#123;0x00,0x1c,0x06,0x1e,0x36,0x36,0x36,0x1c&#125;, &#x2F;&#x2F;6 &#123;0x00,0x3f,0x30,0x18,0x18,0x0c,0x0c,0x0c&#125;, &#x2F;&#x2F;7 &#123;0x00,0x1c,0x36,0x36,0x1c,0x36,0x36,0x1c&#125;, &#x2F;&#x2F;8 &#123;0x00,0x1c,0x36,0x36,0x36,0x3c,0x30,0x1c&#125;, &#x2F;&#x2F;9&#125;;&#x2F;&#x2F;数字的镜像对称数组，每个数字用8行8列的01表示，每一行看做一个8位二进制void Creat_array(int n,bool dianzhen[8][32])&#x2F;&#x2F;得到要显示四个数字的点阵数组&#123; int num[4]; for(int i&#x3D;3;i&gt;&#x3D;0;i--,n&#x2F;&#x3D;10)&#x2F;&#x2F;将这四位数放到数组中 num[i]&#x3D;n%10; for(i&#x3D;0;i&lt;8;i++)&#x2F;&#x2F;一共8行，每行显示4*8&#x3D;32个0或1 for(int j&#x3D;0;j&lt;4;j++) &#123; int x&#x3D;a[num[j]][i];&#x2F;&#x2F;得到num[j]对应的数字点阵的第i行二进制串 for(int k&#x3D;0;k&lt;8;k++,x&#x2F;&#x3D;2)&#x2F;&#x2F;依次得到二进制串的每一位 dianzhen[i][j*8+k]&#x3D;x%2?1:0;&#x2F;&#x2F;组合成指定数字的点阵数组 &#125; &#125; 利用区域的周期性填充区域 12345for(i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) if(mask[i][j]) pDC-&gt;SetPixel(i,j,(dianzhen[j%8][i%32])?RGB(230,0,0):RGB(255,255,255)); &#x2F;&#x2F;将数组中为1的区域打印成点阵数字 6.最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114int number&#x3D;1357;&#x2F;&#x2F;要显示的数字，必须填四位int max_x,max_y,min_x,min_y;&#x2F;&#x2F;多边形的矩形区域bool flag1&#x3D;0,flag&#x3D;0;&#x2F;&#x2F;flag1控制只进行一次画多边形，flag控制存放起点CPoint p[100];&#x2F;&#x2F;保存顶点数组，填充需要int n&#x3D;0;&#x2F;&#x2F;表示多边形顶点的的个数bool mask[1000][1000],dianzhen[8][32];char a[10][8]&#x3D;&#123; &#123;0x00,0x18,0x24,0x24,0x24,0x24,0x24,0x18&#125;, &#x2F;&#x2F;0 &#123;0x00,0x18,0x1c,0x18,0x18,0x18,0x18,0x18&#125;, &#x2F;&#x2F;1 &#123;0x00,0x1e,0x30,0x30,0x1c,0x06,0x06,0x3e&#125;, &#x2F;&#x2F;2 &#123;0x00,0x1e,0x30,0x30,0x1c,0x30,0x30,0x1e&#125;, &#x2F;&#x2F;3 &#123;0x00,0x30,0x38,0x34,0x32,0x3e,0x30,0x30&#125;, &#x2F;&#x2F;4 &#123;0x00,0x1e,0x02,0x1e,0x30,0x30,0x30,0x1e&#125;, &#x2F;&#x2F;5 &#123;0x00,0x1c,0x06,0x1e,0x36,0x36,0x36,0x1c&#125;, &#x2F;&#x2F;6 &#123;0x00,0x3f,0x30,0x18,0x18,0x0c,0x0c,0x0c&#125;, &#x2F;&#x2F;7 &#123;0x00,0x1c,0x36,0x36,0x1c,0x36,0x36,0x1c&#125;, &#x2F;&#x2F;8 &#123;0x00,0x1c,0x36,0x36,0x36,0x3c,0x30,0x1c&#125;, &#x2F;&#x2F;9&#125;;&#x2F;&#x2F;数字的镜像对称数组，每个数字用8行8列的01表示，每一行看做一个8位二进制void CShiyan2View::OnLButtonDown(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;如果多边形已经绘制完成，再次点击则不会响应 &#123; if(!flag)&#123; max_x&#x3D;min_x&#x3D;point.x;&#x2F;&#x2F;初始化最开始的矩形区域为第一个点的横纵坐标 max_y&#x3D;min_y&#x3D;point.y; flag&#x3D;1; p[n++]&#x3D;point; &#125; else &#123; if(point.x&gt;max_x)&#x2F;&#x2F;更新矩形区域的坐标 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); p[n++]&#x3D;point; &#125; &#125; ReleaseDC(pDC); CView::OnLButtonDown(nFlags, point);&#125;void Creat_array(int n,bool dianzhen[8][32])&#x2F;&#x2F;得到要显示四个数字的点阵数组&#123; int num[4]; for(int i&#x3D;3;i&gt;&#x3D;0;i--,n&#x2F;&#x3D;10)&#x2F;&#x2F;将这四位数放到数组中 num[i]&#x3D;n%10; for(i&#x3D;0;i&lt;8;i++)&#x2F;&#x2F;一共8行，每行显示4*8&#x3D;32个0或1 for(int j&#x3D;0;j&lt;4;j++) &#123; int x&#x3D;a[num[j]][i];&#x2F;&#x2F;得到num[j]对应的数字点阵的第i行二进制串 for(int k&#x3D;0;k&lt;8;k++,x&#x2F;&#x3D;2)&#x2F;&#x2F;依次得到二进制串的每一位 dianzhen[i][j*8+k]&#x3D;x%2?1:0;&#x2F;&#x2F;组合成指定数字的点阵数组 &#125; &#125;void CShiyan2View::OnLButtonDblClk(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;只有没有绘制完成才会对双击进行响应 &#123; if(point.x&gt;max_x)&#x2F;&#x2F;此为最后一个顶点，同样需要更新矩形区域 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); pDC-&gt;MoveTo(point); pDC-&gt;LineTo(p[0]); flag1&#x3D;1;&#x2F;&#x2F;表示多边形已经绘制完成 p[n++]&#x3D;point; p[n]&#x3D;p[0];&#x2F;&#x2F;此处将首尾相连，方便得到边的信息 &#125; &#x2F;&#x2F;填充部分 for(int i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) mask[i][j]&#x3D;0;&#x2F;&#x2F;将数组全置0 for(i&#x3D;0;i&lt;n;i++)&#x2F;&#x2F;处理每一条边 &#123; int s&#x3D;p[i].y&lt;p[i+1].y?i:i+1;&#x2F;&#x2F;s保存的是较小y点的下标，e保存y较大的点的下标 int e&#x3D;2*i+1-s;&#x2F;&#x2F;由于起点终点的下标一个是i,一个是i+1，和为2*i+1，所以可以通过s计算e double dx&#x3D;(p[e].x-p[s].x)&#x2F;double(p[e].y-p[s].y);&#x2F;&#x2F;保存dx&#x2F;dy。也就是y每变化1，x的变化值 for(int y&#x3D;p[s].y;y&lt;p[e].y;y++) &#123; int x&#x3D;(y-p[s].y)*dx+p[s].x;&#x2F;&#x2F;通过y计算x。简单的直线方程 for(int t&#x3D;x+1;t&lt;&#x3D;max_x;t++) mask[t][y]&#x3D;!mask[t][y]; &#x2F;&#x2F;将此点右边的全取反 &#125; &#125; Creat_array(number,dianzhen); for(i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) if(mask[i][j]) pDC-&gt;SetPixel(i,j,(dianzhen[j%8][i%32])?RGB(230,0,0):RGB(255,255,255)); &#x2F;&#x2F;将数组中为1的区域打印成点阵数字 ReleaseDC(pDC); CView::OnLButtonDblClk(nFlags, point);&#125;","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://donghuangzhong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"多边形填充","slug":"计算机图形学/多边形填充","permalink":"https://donghuangzhong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%A1%AB%E5%85%85/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"MFC","slug":"MFC","permalink":"https://donghuangzhong.github.io/tags/MFC/"}]},{"title":"蓝桥杯2018第九届省赛解题报告","slug":"蓝桥杯2018第九届省赛解题报告","date":"2020-04-14T00:39:21.000Z","updated":"2020-04-14T01:23:57.177Z","comments":true,"path":"2020/04/14/蓝桥杯2018第九届省赛解题报告/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/14/%E8%93%9D%E6%A1%A5%E6%9D%AF2018%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%9C%81%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"摘要","text":"摘要 第一题 标题：分数1/1 + 1/2 + 1/4 + 1/8 + 1/16 + …. 每项是前一项的一半，如果一共有20项,求这个和是多少，结果用分数表示出来。分子分母要求互质。 解题思路求和找最大公约数 答案：1048575/524288 （选中或复制后查看，下同） 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int gcd(int a,int b)&#123; return b&#x3D;&#x3D;0?a:gcd(b,a%b); &#125;int main()&#123;&#x2F;&#x2F; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int factor&#x3D;gcd((1&lt;&lt;20)-1,1&lt;&lt;19); cout&lt;&lt;(((1&lt;&lt;20)-1)&#x2F;factor)&lt;&lt;&quot;&#x2F;&quot;&lt;&lt;(1&lt;&lt;19)&#x2F;factor&lt;&lt;endl; return 0;&#125; 第二题 标题：星期一整个20世纪（1901年1月1日至2000年12月31日之间），一共有多少个星期一？ 解题思路找最后一个周一(可以查日历也可以算)，剩余天数除以7。但是因为最后一天是周日，所以可以直接除以7，有几个完整的星期就有几个周一。 答案5217 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int count_day(int year,int month,int day)&#123; int day_sum&#x3D;0; _for(i,1,month-1) &#123; if(i&#x3D;&#x3D;2) &#123; if((year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0)||year%400&#x3D;&#x3D;0) day_sum+&#x3D;29; else day_sum+&#x3D;28; &#125; else if(i&#x3D;&#x3D;4||i&#x3D;&#x3D;6||i&#x3D;&#x3D;9||i&#x3D;&#x3D;11) day_sum+&#x3D;30; else day_sum+&#x3D;31; &#125; return day_sum+day;&#125;int main()&#123; int y,m,d; &#x2F;&#x2F;while(cin&gt;&gt;y&gt;&gt;m&gt;&gt;d&amp;&amp;y) &#x2F;&#x2F; cout&lt;&lt;count_day(y,m,d); int sum_2001&#x3D;count_day(2020,4,5); _for(i,2001,2019) sum_2001+&#x3D;count_day(i,12,31); sum_2001%&#x3D;7; int zhou&#x3D;(0-sum_2001)%7+1; cout&lt;&lt;&quot;2001&#x2F;01&#x2F;01:&quot;&lt;&lt;zhou&lt;&lt;endl; int sum_21&#x3D;0; _for(i,1901,2000) sum_21+&#x3D;count_day(i,12,31); cout&lt;&lt;&quot;21 century:&quot;&lt;&lt;sum_21&lt;&lt;endl; cout&lt;&lt;&quot;answer:&quot;&lt;&lt;sum_21&#x2F;7&lt;&lt;endl; return 0;&#125; 第三题 标题：乘积尾零如下的10行数据，每行有10个整数，请你求出它们的乘积的末尾有多少个零？ 5650 4542 3554 473 946 4114 3871 9073 90 4329 2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 1486 5722 3135 1170 4014 5510 5120 729 2880 9019 2049 698 4582 4346 4427 646 9742 7340 1230 7683 5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 6701 6645 1671 5978 2704 9926 295 3125 3878 6785 2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 689 5510 8243 6114 337 4096 8199 7313 3685 211 注意：需要提交的是一个整数，表示末尾零的个数。不要填写任何多余内容。 解题思路求因数中2和5的总数的最小值 答案31 12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,factor_2&#x3D;0,factor_5&#x3D;0; while(cin&gt;&gt;n) &#123; while(n%2&#x3D;&#x3D;0) n&#x2F;&#x3D;2,factor_2++; while(n%5&#x3D;&#x3D;0) n&#x2F;&#x3D;5,factor_5++; &#125; cout&lt;&lt;min(factor_2,factor_5); return 0;&#125; 第四题 标题：第几个幸运数到x星球旅行的游客都被发给一个整数，作为游客编号。x星的国王有个怪癖，他只喜欢数字3,5和7。国王规定，游客的编号如果只含有因子：3,5,7,就可以获得一份奖品。 我们来看前10个幸运数字是：3 5 7 9 15 21 25 27 35 45。 因而第11个幸运数字是：49 小明领到了一个幸运数字 59084709587505，他去领奖的时候，人家要求他准确地说出这是第几个幸运数字，否则领不到奖品。 请你帮小明计算一下，59084709587505是第几个幸运数字。需要提交的是一个整数，请不要填写任何多余内容。 解题思路三种思路， 答案1905","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"category2","slug":"ACM/category2","permalink":"https://donghuangzhong.github.io/categories/ACM/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"洛谷_P1233 木棍加工","slug":"洛谷-P1233-木棍加工","date":"2020-04-07T04:03:48.000Z","updated":"2020-04-07T04:03:48.289Z","comments":true,"path":"2020/04/07/洛谷-P1233-木棍加工/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/07/%E6%B4%9B%E8%B0%B7-P1233-%E6%9C%A8%E6%A3%8D%E5%8A%A0%E5%B7%A5/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"洛谷_P4933 大师","slug":"洛谷-P4933-大师","date":"2020-04-06T10:11:06.000Z","updated":"2020-04-06T10:23:40.706Z","comments":true,"path":"2020/04/06/洛谷-P4933-大师/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P4933-%E5%A4%A7%E5%B8%88/","excerpt":"DP关键的是设状态。","text":"DP关键的是设状态。 题目题目背景建筑大师最近在跟着数学大师ljt12138学数学，今天他学了等差数列，ljt12138决定给他留一道练习题。 题目描述ljt12138首先建了n个特斯拉电磁塔，这些电塔排成一排，从左到右依次标号为1到n，第i个电塔的高度为h[i]。 建筑大师需要从中选出一些电塔，然后这些电塔就会缩到地下去。这时候，如果留在地上的电塔的高度，从左向右构成了一个等差数列，那么这个选择方案就会被认为是美观的。 建筑大师需要求出，一共有多少种美观的选择方案，答案模998244353。 注意，如果地上只留了一个或者两个电塔，那么这种方案也是美观的。地上没有电塔的方案被认为是不美观的。 输入格式第一行一个正整数n。 第二行n个非负整数，第i个整数是第i个电塔的高度h[i]。 输出格式输出一个整数，表示美观的方案数模998244353的值。 输入输出样例输入 #1复制 12813 14 6 20 27 34 34 41 输出 #1复制 150 输入 #2复制 1210090 1004 171 99 1835 108 81 117 141 126 135 144 81 153 193 81 962 162 1493 171 1780 864 297 180 532 1781 189 1059 198 333 1593 824 207 1877 216 270 225 1131 336 1875 362 234 81 288 1550 243 463 1755 252 406 261 270 279 288 1393 261 1263 297 135 333 872 234 881 180 198 81 225 306 180 90 315 81 81 198 252 81 297 1336 1140 1238 81 198 297 661 81 1372 469 1132 81 126 324 333 342 81 351 481 279 1770 1225 549 输出 #2复制 111153 说明/提示我们用v表示最高的电塔高度。 对于前30%的数据，n&lt;=20。 对于前60%的数据，n&lt;=100，v&lt;=2000。 对于另外20%的数据，所有电塔的高度构成一个等差数列。 对于100%的数据，n&lt;=1000，v&lt;=20000。 算法用dp[i][a[i]-a[j]+20002]表示以i点为结束公差为a[i]-a[j]的数列，加上20002是因为a[i]-a[j]最小为0-20000,为了避免出现负数，注意ans不可以加上dp[i][a[i]-a[j]+20002]，因为会出现相同塔高的塔，会重复加这些塔 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int dp[1001][40002];int a[1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; long long ans&#x3D;0; _for(i,1,n)cin&gt;&gt;a[i]; _for(i,2,n) for(int j&#x3D;i-1;j&gt;&#x3D;1;j--) &#123; dp[i][a[i]-a[j]+20002]&#x3D;(dp[i][a[i]-a[j]+20002]+dp[j][a[i]-a[j]+20002]+1)%998244353; ans&#x3D;(ans+dp[j][a[i]-a[j]+20002]+1)%998244353; &#125; ans&#x3D;(ans+n)%998244353; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"W","slug":"W","permalink":"https://donghuangzhong.github.io/tags/W/"},{"name":"设状态","slug":"设状态","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%BE%E7%8A%B6%E6%80%81/"}]},{"title":"洛谷_P1040 加分二叉树","slug":"洛谷-P1040-加分二叉树","date":"2020-04-06T08:02:34.000Z","updated":"2020-04-06T08:06:20.849Z","comments":true,"path":"2020/04/06/洛谷-P1040-加分二叉树/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P1040-%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"设计好状态就行，可以用dp也可以用记忆dfs","text":"设计好状态就行，可以用dp也可以用记忆dfs 题目题目描述设一个nn个节点的二叉树tree的中序遍历为（1,2,3,…,n1,2,3,…,n），其中数字1,2,3,…,n1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第ii个节点的分数为di,treed**i,t*ree及它的每个子树都有一个加分，任一棵子树subtreesubtree（也包含treetre*e本身）的加分计算方法如下： subtrees*ubtree的左子树的加分× subtreesubtree的右子树的加分＋subtreesubtre*e的根的分数。 若某个子树为空，规定其加分为11，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n1,2,3,…,n）且加分最高的二叉树treet*ree*。要求输出； （1）treet*ree*的最高加分 （2）treet*ree*的前序遍历 输入格式第11行：11个整数n(n&lt;30)n(n&lt;30)，为节点个数。 第22行：nn个用空格隔开的整数，为每个节点的分数（分数&lt;100&lt;100）。 输出格式第11行：11个整数，为最高加分（Ans \\le 4,000,000,000≤4,000,000,000）。 第22行：nn个用空格隔开的整数，为该树的前序遍历。 输入输出样例输入 #1复制 1255 7 1 2 10 输出 #1复制 121453 1 2 4 5 算法记忆dfs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,a[31],root[31][31],mem[31][31];int dfs(int s,int e)&#123; if(mem[s][e]) return mem[s][e]; if(s&gt;e) return 1; if(s&#x3D;&#x3D;e) return a[s]; int maxx&#x3D;-1; _for(i,s,e) &#123; int t&#x3D;(dfs(s,i-1)*dfs(i+1,e)+a[i]); if(t&gt;maxx) &#123; maxx&#x3D;t; root[s][e]&#x3D;i; &#125; &#125; return mem[s][e]&#x3D;maxx;&#125; void p(int s,int e)&#123; if(s&gt;e) return ; if(s&#x3D;&#x3D;e) &#123; cout&lt;&lt;e&lt;&lt;&quot; &quot;; return ; &#125; cout&lt;&lt;root[s][e]&lt;&lt;&quot; &quot;; p(s,root[s][e]-1); p(root[s][e]+1,e);&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) cin&gt;&gt;a[i]; cout&lt;&lt;dfs(1,n)&lt;&lt;endl; p(1,n); return 0;&#125; DP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,a[31],root[31][31],dp[31][31];void p(int s,int e)&#123; if(s&gt;e) return ; if(s&#x3D;&#x3D;e) &#123; cout&lt;&lt;e&lt;&lt;&quot; &quot;; return ; &#125; cout&lt;&lt;root[s][e]&lt;&lt;&quot; &quot;; p(s,root[s][e]-1); p(root[s][e]+1,e);&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) cin&gt;&gt;a[i];&#x2F;&#x2F; dp[i][j]&#x3D;max(dp[i][k-1]*dp[k+1][j]+a[i]); _for(i,1,n)&#123;dp[i][i]&#x3D;a[i];dp[i][i-1]&#x3D;1;&#125; for(int i&#x3D;n;i&gt;&#x3D;1;i--) &#123; for(int j&#x3D;i+1;j&lt;&#x3D;n;j++) &#123; for(int k&#x3D;i;k&lt;&#x3D;j;k++) &#123; if(dp[i][j]&lt;dp[i][k-1]*dp[k+1][j]+a[k]) &#123; dp[i][j]&#x3D;dp[i][k-1]*dp[k+1][j]+a[k]; root[i][j]&#x3D;k; &#125; &#125; &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; p(1,n); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"记忆化dfs","slug":"记忆化dfs","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96dfs/"}]},{"title":"洛谷_P2758 编辑距离","slug":"洛谷-P2758-编辑距离","date":"2020-04-06T02:48:15.000Z","updated":"2020-04-06T03:15:15.039Z","comments":true,"path":"2020/04/06/洛谷-P2758-编辑距离/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P2758-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","excerpt":"DP精髓：不确定性就是DP范围。其实DP就是记忆化递归。","text":"DP精髓：不确定性就是DP范围。其实DP就是记忆化递归。 题目题目描述设A和B是两个字符串。我们要用最少的字符操作次数，将字符串A转换为字符串B。这里所说的字符操作共有三种： 1、删除一个字符； 2、插入一个字符； 3、将一个字符改为另一个字符； ！皆为小写字母！ 输入格式第一行为字符串A；第二行为字符串B；字符串A和B的长度均小于2000。 输出格式只有一个正整数，为最少字符操作次数。 输入输出样例输入 #1复制 12sfdqxbwgfdgw 输出 #1复制 14 算法普通二维数组dp[i][j]表示的是将第一个串s1前i个字符变为第二个串s2的前j个字符的最少操作次数，那么如果s1[i]==s2[j]，那么无需对s1[i]操作，将s1前i字符转换为s2前j字符的操作次数就是将s1前i-1字符转换为s2前j-1字符的操作次数，即dp[i][j]=dp[i-1][j-1]。如果s1[i]!=s2[j]那么就需要对s1[i]进行操作，操作的目的是将第一个串s1前i个字符变为第二个串s2的前j个字符，操作有三种 1.删去s1[i]，将s1前i-1字符变为s2前j字符，dp[i][j]=dp[i-1][j]+1 2.插入，将s1前i字符变为s2前j-1字符dp[i][j]=dp[i][j-1]+1 3.替换，将s1前i-1字符变为s2前j-1字符 dp[i][j]=dp[i-1][j]+1 取最小值 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int dp[2001][2001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; for(int i&#x3D;0;i&lt;&#x3D;s1.length();i++) dp[i][0]&#x3D;i; for(int j&#x3D;0;j&lt;&#x3D;s2.length();j++) dp[0][j]&#x3D;j; _for(i,1,s1.length()) _for(j,1,s2.length()) &#123; if(s1[i-1]&#x3D;&#x3D;s2[j-1]) dp[i][j]&#x3D;dp[i-1][j-1]; else dp[i][j]&#x3D;min(min(dp[i-1][j]+1,dp[i][j-1]+1),dp[i-1][j-1]+1); &#125; cout&lt;&lt;dp[s1.length()][s2.length()]&lt;&lt;endl; _for(i,0,s1.length()) &#123; _for(j,0,s2.length()) &#123; cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 滚动数组观察到计算i行只需要i、i-1行，所以可以改造成滚动数组 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int dp[2][2001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; for(int i&#x3D;0;i&lt;&#x3D;s2.length();i++) dp[0][i]&#x3D;i; bool index; _for(i,1,s1.length()) &#123; index&#x3D;i&amp;1; dp[index][0]&#x3D;i; _for(j,1,s2.length()) &#123; if(s1[i-1]&#x3D;&#x3D;s2[j-1]) dp[index][j]&#x3D;dp[1-index][j-1]; else dp[index][j]&#x3D;min(min(dp[1-index][j]+1,dp[index][j-1]+1),dp[1-index][j-1]+1); &#125; &#125; cout&lt;&lt;dp[index][s2.length()]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"滚动数组","slug":"滚动数组","permalink":"https://donghuangzhong.github.io/tags/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"}]},{"title":"洛谷_P1280 尼克的任务","slug":"洛谷-P1280-尼克的任务","date":"2020-04-06T00:03:27.000Z","updated":"2020-04-06T00:24:51.737Z","comments":true,"path":"2020/04/06/洛谷-P1280-尼克的任务/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P1280-%E5%B0%BC%E5%85%8B%E7%9A%84%E4%BB%BB%E5%8A%A1/","excerpt":"当前时间点只有一个任务时，必须选择这个任务。当前时间点有多个任务时，选择哪个任务取决于哪个任务结束的时候有更多的空闲时间。假设当前有多个任务，开始的时间是s，结束的时间是e1,e2,e3。选择哪一个任务取决于开始时间是e1,e2,e3的时候一直到最后哪个剩余的空闲时间多。以所有的起点为基准，dp[i]表示以i为起点的时候剩余的空闲时间。那么dp[i]=max(end-start+dp[strat])，i是当前的起点，end是当前的终点，start是终点后面第一个起点。从后向前算，起点和终点好说，怎么找终点后面的第一个起点，遍历的话是k,二分查找的话是logn","text":"当前时间点只有一个任务时，必须选择这个任务。当前时间点有多个任务时，选择哪个任务取决于哪个任务结束的时候有更多的空闲时间。假设当前有多个任务，开始的时间是s，结束的时间是e1,e2,e3。选择哪一个任务取决于开始时间是e1,e2,e3的时候一直到最后哪个剩余的空闲时间多。以所有的起点为基准，dp[i]表示以i为起点的时候剩余的空闲时间。那么dp[i]=max(end-start+dp[strat])，i是当前的起点，end是当前的终点，start是终点后面第一个起点。从后向前算，起点和终点好说，怎么找终点后面的第一个起点，遍历的话是k,二分查找的话是logn 题目题目描述尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 尼克的一个工作日为 nn 分钟，从第 11 分钟开始到第 nn 分钟结束。当尼克到达单位后他就开始干活，公司一共有 kk 个任务需要完成。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第 pp 分钟开始，持续时间为 tt 分钟，则该任务将在第 (p+t-1)(p+t−1) 分钟结束。 写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。 输入格式输入数据第一行含两个用空格隔开的整数 nn 和 kk。 接下来共有 kk 行，每一行有两个用空格隔开的整数 pp 和 tt，表示该任务从第 pp 分钟开始，持续时间为 tt 分钟。 输出格式输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。 输入输出样例输入 #1复制 123456715 61 21 64 118 58 111 5 输出 #1复制 14 说明/提示数据规模与约定 对于 100%100% 的数据，保证 1 \\leq n \\leq 10^4,1 \\leq k \\leq 10^4,1 \\leq p \\leq n,1 \\leq p+t-1 \\leq n1≤n≤104,1≤k≤104,1≤p≤n,1≤p+t−1≤n。 算法为了方便把1看成一个起点为1终点为1的时间段 vector(k*n)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct Time&#123; int s,e;&#125;;vector&lt;Time&gt; v;int dp[10001];int n,k,end;int get(int e)&#123; _for(j,1,v.size()-1) &#123; if(v[j].s&gt;&#x3D;e) return v[j].s; &#125; return n;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;k; n++; v.push_back(&#123;1,1&#125;); _for(i,1,k) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; v.push_back(&#123;s,e+s&#125;); &#125; for(int i&#x3D;v.size()-1;i&gt;&#x3D;0;i--) &#123; int j&#x3D;i,maxx&#x3D;-1; while(v[j].s&#x3D;&#x3D;v[i].s) &#123; int start&#x3D;get(v[j].e); maxx&#x3D;max(maxx,start-v[j].e+dp[start]); j--; &#125; dp[v[i].s]&#x3D;maxx; i&#x3D;j+1; &#125; cout&lt;&lt;dp[1]; return 0;&#125; 结构体+二分查找(k*lgn)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct Time&#123; int s,e;&#125; v[10005];int dp[10005];int a[10005];int n,k,end;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;k; n++; int len&#x3D;0; v[0].s&#x3D;1; v[0].e&#x3D;1; _for(i,1,k) &#123; int s,t; cin&gt;&gt;s&gt;&gt;t; v[i].s&#x3D;s; v[i].e&#x3D;s+t; if(s!&#x3D;a[len]) &#123; a[++len]&#x3D;s; &#125; &#125; a[++len]&#x3D;n; for(int i&#x3D;k;i&gt;&#x3D;0;i--) &#123; int j&#x3D;i,maxx&#x3D;-1; while(v[j].s&#x3D;&#x3D;v[i].s) &#123; int start&#x3D;*lower_bound(a+1,a+len+1,v[j].e); maxx&#x3D;max(maxx,start-v[j].e+dp[start]); j--; &#125; dp[v[i].s]&#x3D;maxx; i&#x3D;j+1; &#125; cout&lt;&lt;dp[1]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"二分查找(大小于)","slug":"二分查找-大小于","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%A4%A7%E5%B0%8F%E4%BA%8E/"}]},{"title":"洛谷_P1439 【模板】最长公共子序列","slug":"洛谷-P1439-【模板】最长公共子序列","date":"2020-04-05T23:50:50.000Z","updated":"2020-04-06T00:04:23.449Z","comments":true,"path":"2020/04/06/洛谷-P1439-【模板】最长公共子序列/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P1439-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"可以用通用m*n算法。由于这两个序列都是全排列的一种，假设这两串数字分别是s1,s2。将s1的元素从第一个开始全部表示为a,b,c……。将s2中对应的数字也变为字母。比如s1:3,2,1，s2:2,3,1。将3替换为a，2替换为b，1替换为c。s1变为a,b,c。s2变为b,a,c。最长公共子序列的长度不变，现在的问题就变成了求a,b,c和b,c,a中的最长公共子序列。于是就可以转换为求最长递增子序列的长度。","text":"可以用通用m*n算法。由于这两个序列都是全排列的一种，假设这两串数字分别是s1,s2。将s1的元素从第一个开始全部表示为a,b,c……。将s2中对应的数字也变为字母。比如s1:3,2,1，s2:2,3,1。将3替换为a，2替换为b，1替换为c。s1变为a,b,c。s2变为b,a,c。最长公共子序列的长度不变，现在的问题就变成了求a,b,c和b,c,a中的最长公共子序列。于是就可以转换为求最长递增子序列的长度。 题目题目描述给出 1,2,\\ldots,n1,2,…,n 的两个排列 P_1P1 和 P_2P2 ，求它们的最长公共子序列。 输入格式第一行是一个数 nn。 接下来两行，每行为 nn 个数，为自然数 1,2,\\ldots,n1,2,…,n 的一个排列。 输出格式一个数，即最长公共子序列的长度。 输入输出样例输入 #1复制 1235 3 2 1 4 51 2 3 4 5 输出 #1复制 13 说明/提示 对于 50%50% 的数据， n \\le 10^3n≤103； 对于 100%100% 的数据， n \\le 10^5n≤105。 算法通用算法m*n123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)#define N 10001using namespace std;int lcs[N][N];int a[N];int b[N];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); &#x2F;&#x2F;lcs[i][j]&#x3D;lcs[i-1][j-1]+1; a[i]&#x3D;&#x3D;b[i] &#x2F;&#x2F;lcs[i][j]&#x3D;max(lcs[i][j-1],lcs[i-1][j]); int n; cin&gt;&gt;n; _for(i,1,n) cin&gt;&gt;a[i]; _for(i,1,n) cin&gt;&gt;b[i]; _for(i,1,n) _for(j,1,n) &#123; if(a[i]&#x3D;&#x3D;b[i]) lcs[i][j]&#x3D;lcs[i-1][j-1]+1; else lcs[i][j]&#x3D;max(lcs[i][j-1],lcs[i-1][j]); &#125; cout&lt;&lt;lcs[n][n]; return 0;&#125; 最长上升子序列nlogn123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)#define N 100001int a[N],b[N],c[N];using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) &#123; cin&gt;&gt;a[i]; c[a[i]]&#x3D;i; &#125; _for(i,1,n) cin&gt;&gt;a[i]; int len&#x3D;0; _for(i,1,n) &#123; if(c[a[i]]&gt;b[len]) b[++len]&#x3D;c[a[i]]; else *upper_bound(b+1,b+len+1,c[a[i]])&#x3D;c[a[i]]; &#125; cout&lt;&lt;len; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"最长公共子序列","slug":"最长公共子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"最长上升子序列","slug":"最长上升子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"}]},{"title":"洛谷_P1020 导弹拦截","slug":"洛谷-P1020-导弹拦截","date":"2020-04-04T07:12:04.000Z","updated":"2020-04-04T08:34:20.073Z","comments":true,"path":"2020/04/04/洛谷-P1020-导弹拦截/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/04/%E6%B4%9B%E8%B0%B7-P1020-%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/","excerpt":"第一问一眼能看出是求最大单调非递增序列；第二问可以用Dilworth定理：最长x的子序列链的个数等于最长!X链的长度。或者这么考虑，问的是最少的导弹系统的个数，所以如果用x1,x2,……xn表示导弹系统1，2，……n现在可以到达的高度，其中x1,x2……xn互不相同，假设x1=1,x2=2,现在来了一个高度为1的导弹，肯定用x1来击落它，不会浪费高的导弹系统。所以它们互不相同。对于每一个新导弹系统击落的第一个导弹来说，x1,x2,……xn都比这个导弹的高度低(如果高的话就不会动用新的导弹系统)，所以最少导弹系统的个数一定是一个上升子序列的长度。考虑到如果存在一个最长的单调递增子序列，每个元素都需要一个新的导弹系统，所以新的导弹系统的个数最少是最长上升子序列的长度，又因为最少导弹系统的个数一定是一个上升子序列的长度，所以新的导弹系统的个数就是最长上升子序列的长度。","text":"第一问一眼能看出是求最大单调非递增序列；第二问可以用Dilworth定理：最长x的子序列链的个数等于最长!X链的长度。或者这么考虑，问的是最少的导弹系统的个数，所以如果用x1,x2,……xn表示导弹系统1，2，……n现在可以到达的高度，其中x1,x2……xn互不相同，假设x1=1,x2=2,现在来了一个高度为1的导弹，肯定用x1来击落它，不会浪费高的导弹系统。所以它们互不相同。对于每一个新导弹系统击落的第一个导弹来说，x1,x2,……xn都比这个导弹的高度低(如果高的话就不会动用新的导弹系统)，所以最少导弹系统的个数一定是一个上升子序列的长度。考虑到如果存在一个最长的单调递增子序列，每个元素都需要一个新的导弹系统，所以新的导弹系统的个数最少是最长上升子序列的长度，又因为最少导弹系统的个数一定是一个上升子序列的长度，所以新的导弹系统的个数就是最长上升子序列的长度。 题目题目描述 某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度（雷达给出的高度数据是\\le 50000≤50000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入格式11行，若干个整数（个数\\le 100000≤100000） 输出格式22行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出样例输入 #1复制 1389 207 155 300 299 170 158 65 输出 #1复制 1262 说明/提示为了让大家更好地测试n方算法，本题开启spj，n方100分，nlogn200分 每点两问，按问给分 算法DP（n2）a数组存数据，b[i]/r[i]表示以a[i]结尾(包括a[i])的最大非上升/上升子序列的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int a[100001];int b[100001];int r[100001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int c&#x3D;0,ans&#x3D;0,rans&#x3D;0; while(cin&gt;&gt;a[c++]) &#123; int he&#x3D;0; for(int i&#x3D;c-1;i&gt;&#x3D;0;i--) &#123; if(a[i]&gt;a[c-1]) &#123; he&#x3D;max(he,b[i]); &#125; &#125; b[c-1]&#x3D;he+1; ans&#x3D;max(ans,b[c-1]); he&#x3D;0; for(int i&#x3D;c-1;i&gt;&#x3D;0;i--) &#123; if(a[i]&lt;a[c-1]) &#123; he&#x3D;max(he,r[i]); &#125; &#125; r[c-1]&#x3D;he+1; rans&#x3D;max(rans,r[c-1]); &#125;cout&lt;&lt;ans&lt;&lt;endl;cout&lt;&lt;rans; return 0;&#125; DP+二分查找a数组存数据，b[i]/r[i]表示长度为i的最大非上升/上升序列的最后一个元素的最大/小值。bs函数可以当做模板，参数（待查找的数组，起点，终点，要比较的数字，op）,op为1/-1表示找小/大于num的第一个数的下标。当然二分查找的前提是数组已经排好序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int a[100001];int b[100001];int r[100001];int bs(int s[],int start,int end,int num,int op)&#123; while(start&lt;&#x3D;end) &#123; int mid&#x3D;(start+end)&#x2F;2; if(op*num&lt;&#x3D;op*s[mid]) start&#x3D;mid+1; else end&#x3D;mid-1; &#125; while(op&#x3D;&#x3D;-1&amp;&amp;s[start-1]&#x3D;&#x3D;num) start--; return start;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int c&#x3D;0,len_b&#x3D;0,len_r&#x3D;0; memset(b,0x3f,sizeof(b)); while(cin&gt;&gt;a[c++]) &#123; int b_index&#x3D;bs(b,0,len_b,a[c-1],1); b[b_index]&#x3D;a[c-1]; if(b_index&gt;len_b) len_b&#x3D;b_index; int r_index&#x3D;bs(r,0,len_r,a[c-1],-1); r[r_index]&#x3D;a[c-1]; if(r_index&gt;len_r) len_r&#x3D;r_index; &#125; cout&lt;&lt;len_b&lt;&lt;endl&lt;&lt;len_r; return 0;&#125; 用STL里面的二分查找1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int a[100001];int b[100001];int r[100001];bool cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int c&#x3D;0,len_b&#x3D;0,len_r&#x3D;0; b[0]&#x3D;0x3f3f3f3f; while(cin&gt;&gt;a[c++]) &#123; if(a[c-1]&lt;&#x3D;b[len_b]) b[++len_b]&#x3D;a[c-1]; else *upper_bound(b+1,b+len_b+1,a[c-1],cmp)&#x3D;a[c-1]; if(a[c-1]&gt;r[len_r]) r[++len_r]&#x3D;a[c-1]; else *lower_bound(r+1,r+1+len_r,a[c-1])&#x3D;a[c-1]; &#125; cout&lt;&lt;len_b&lt;&lt;endl&lt;&lt;len_r; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"最长(非)单调子序列","slug":"最长-非-单调子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF-%E9%9D%9E-%E5%8D%95%E8%B0%83%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"Dilworth定理","slug":"Dilworth定理","permalink":"https://donghuangzhong.github.io/tags/Dilworth%E5%AE%9A%E7%90%86/"},{"name":"二分查找(大小于)","slug":"二分查找-大小于","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%A4%A7%E5%B0%8F%E4%BA%8E/"}]},{"title":"洛谷_P1002 过河卒","slug":"洛谷-P1002-过河卒","date":"2020-04-03T04:22:21.000Z","updated":"2020-04-03T04:25:31.362Z","comments":true,"path":"2020/04/03/洛谷-P1002-过河卒/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/03/%E6%B4%9B%E8%B0%B7-P1002-%E8%BF%87%E6%B2%B3%E5%8D%92/","excerpt":"注意初始化不能直接对起点操作，因为这样就不能判断起点是不是马的控制点。","text":"注意初始化不能直接对起点操作，因为这样就不能判断起点是不是马的控制点。 题目题目描述棋盘上 AA 点有一个过河卒，需要走到目标 BB 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 CC 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。 棋盘用坐标表示，AA 点 (0, 0)(0,0)、BB 点 (n, m)(n,m)，同样马的位置坐标是需要给出的。 现在要求你计算出卒从 AA 点能够到达 BB 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。 输入格式一行四个正整数，分别表示 BB 点坐标和马的坐标。 输出格式一个整数，表示所有的路径条数。 输入输出样例输入 #1复制 16 6 3 3 输出 #1复制 16 说明/提示对于 100 %100% 的数据，1 \\le n, m \\le 201≤n,m≤20，0 \\le0≤ 马的坐标 \\le 20≤20。 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m,horse_x,horse_y;long long map[22][22];int dir[8][2]&#x3D;&#123;1,2,1,-2,-1,2,-1,-2,2,1,2,-1,-2,1,-2,-1&#125;;bool judge(int x,int y)&#123; if(x&#x3D;&#x3D;horse_x&amp;&amp;y&#x3D;&#x3D;horse_y) return 0; _for(i,0,7) &#123; int xx&#x3D;horse_x+dir[i][0]; int yy&#x3D;horse_y+dir[i][1]; if(x&#x3D;&#x3D;xx&amp;&amp;y&#x3D;&#x3D;yy) return 0; &#125; return 1;&#125; int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input1.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m&gt;&gt;horse_x&gt;&gt;horse_y; n++;m++;horse_x++;horse_y++; map[1][0]&#x3D;1; _for(i,1,n) _for(j,1,m) if(judge(i,j)) map[i][j]&#x3D;map[i-1][j]+map[i][j-1]; cout&lt;&lt;map[n][m]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"简单DP","slug":"简单DP","permalink":"https://donghuangzhong.github.io/tags/%E7%AE%80%E5%8D%95DP/"}]},{"title":"洛谷_P1802 5倍经验日","slug":"洛谷-P1802-5倍经验日","date":"2020-04-03T01:31:44.000Z","updated":"2020-04-03T01:36:30.509Z","comments":true,"path":"2020/04/03/洛谷-P1802-5倍经验日/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/03/%E6%B4%9B%E8%B0%B7-P1802-5%E5%80%8D%E7%BB%8F%E9%AA%8C%E6%97%A5/","excerpt":"一个01可不装满背包的变形，注意循环必须[x,cost],然后[0,cost-1]，不然会重复！","text":"一个01可不装满背包的变形，注意循环必须[x,cost],然后[0,cost-1]，不然会重复！ 题目题目背景现在乐斗有活动了！每打一个人可以获得5倍经验！absi2011却无奈的看着那一些比他等级高的好友，想着能否把他们干掉。干掉能拿不少经验的。 题目描述现在absi2011拿出了x个迷你装药物(嗑药打人可耻….)，准备开始与那些人打了 由于迷你装一个只能管一次，所以absi2011要谨慎的使用这些药，悲剧的是，没到达最少打败该人所用的属性药了他打人必输&gt;.&lt;所以他用2个药去打别人，别人却表明3个药才能打过，那么相当于你输了并且这两个属性药浪费了。 现在有n个好友，有输掉拿的经验、赢了拿的经验、要嗑几个药才能打过。求出最大经验（注意，最后要乘以5） 输入格式第一行两个数，n和x 后面n行每行三个数，分别表示输了拿到的经验(lose[i])、赢了拿到的经验(win[i])、打过要至少使用的药数量(use[i])。 输出格式一个整数，最多获得的经验 输入输出样例输入 #1复制 12345676 821 52 121 70 521 48 214 38 314 36 114 36 2 输出 #1复制 11060 说明/提示【Hint】 五倍经验活动的时候，absi2011总是吃体力药水而不是这种属性药&gt;.&lt; 【数据范围】 对于10%的数据，保证x=0 对于30%的数据，保证n&lt;=10,x&lt;=20 对于60%的数据，保证n&lt;=100,x&lt;=100, 10&lt;=lose[i], win[i]&lt;=100,use[i]&lt;=5 对于100%的数据，保证n&lt;=1000,x&lt;=1000,0&lt;lose[i]&lt;=win[i]&lt;=1000000,0&lt;=use[i]&lt;=1000 【题目来源】 fight.pet.qq.com absi2011授权题目 算法12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;long long bag[1001]; int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,x; cin&gt;&gt;n&gt;&gt;x; _for(i,1,n) &#123; long long lose,win,cost; cin&gt;&gt;lose&gt;&gt;win&gt;&gt;cost; for(int j&#x3D;x;j&gt;&#x3D;cost;j--) bag[j]&#x3D;max(bag[j-cost]+win,bag[j]+lose); _for(j,0,cost-1) bag[j]+&#x3D;lose; &#125; cout&lt;&lt;bag[x]*5; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"高阶01背包","slug":"高阶01背包","permalink":"https://donghuangzhong.github.io/tags/%E9%AB%98%E9%98%B601%E8%83%8C%E5%8C%85/"}]},{"title":"洛谷_P1616 疯狂的采药","slug":"洛谷-P1616-疯狂的采药","date":"2020-04-02T10:06:29.000Z","updated":"2020-04-02T11:26:44.831Z","comments":true,"path":"2020/04/02/洛谷-P1616-疯狂的采药/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P1616-%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF/","excerpt":"无限物品的可不满背包","text":"无限物品的可不满背包 题目题目背景此题为NOIP2005普及组第三题的疯狂版。 此题为纪念LiYuxiang而生。 题目描述LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是LiYuxiang，你能完成这个任务吗？ 此题和原题的不同点： 1.每种草药可以无限制地疯狂采摘。 2.药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 输入格式输入第一行有两个整数T（1 &lt;= T &lt;= 100000）和M（1 &lt;= M &lt;= 10000），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到10000之间（包括1和10000）的整数，分别表示采摘某种草药的时间和这种草药的价值。 输出格式输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。 输入输出样例输入 #1复制 123470 371 10069 11 2 输出 #1复制 1140 说明/提示对于30%的数据，M &lt;= 1000； 对于全部的数据，M &lt;= 10000，且M*T&lt;10000000(别数了，7个0)。 加油LiYuxiang，第一个AC留给你！ 算法1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;long long bag[100001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int t,m; cin&gt;&gt;t&gt;&gt;m; _for(i,1,m) &#123; int herb_t,herb_v; cin&gt;&gt;herb_t&gt;&gt;herb_v; for(int j&#x3D;herb_t;j&lt;&#x3D;t;j++) &#123; if(bag[j-herb_t]+herb_v&gt;bag[j]) bag[j]&#x3D;bag[j-herb_t]+herb_v; &#125; &#125; cout&lt;&lt;bag[t]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"无限背包","slug":"无限背包","permalink":"https://donghuangzhong.github.io/tags/%E6%97%A0%E9%99%90%E8%83%8C%E5%8C%85/"}]},{"title":"洛谷_P1048 采药","slug":"洛谷-P1048-采药","date":"2020-04-02T07:21:21.000Z","updated":"2020-04-02T07:24:41.229Z","comments":true,"path":"2020/04/02/洛谷-P1048-采药/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P1048-%E9%87%87%E8%8D%AF/","excerpt":"简单可不装满的01背包，数组初始化全为0","text":"简单可不装满的01背包，数组初始化全为0 题目题目描述辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？ 输入格式第一行有 22 个整数 TT（1 \\le T \\le 10001≤T≤1000）和 MM（1 \\le M \\le 1001≤M≤100），用一个空格隔开，TT 代表总共能够用来采药的时间，MM 代表山洞里的草药的数目。 接下来的 MM 行每行包括两个在 11 到 100100 之间（包括 11 和 100100）的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出格式输出在规定的时间内可以采到的草药的最大总价值。 输入输出样例输入 #1复制 123470 371 10069 11 2 输出 #1复制 13 说明/提示 对于 30%30% 的数据，M \\le 10M≤10； 对于全部的数据，M \\le 100M≤100。 算法1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int bag[1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int t,m; cin&gt;&gt;t&gt;&gt;m; _for(i,1,m) &#123; int herb_t,herb_v; cin&gt;&gt;herb_t&gt;&gt;herb_v; for(int j&#x3D;t;j&gt;&#x3D;herb_t;j--) &#123; if(bag[j-herb_t]+herb_v&gt;bag[j]) bag[j]&#x3D;bag[j-herb_t]+herb_v; &#125; &#125; cout&lt;&lt;bag[t]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"01可不满背包","slug":"01可不满背包","permalink":"https://donghuangzhong.github.io/tags/01%E5%8F%AF%E4%B8%8D%E6%BB%A1%E8%83%8C%E5%8C%85/"}]},{"title":"洛谷_P4017 最大食物链计数","slug":"洛谷-P4017-最大食物链计数","date":"2020-04-02T05:50:09.000Z","updated":"2020-04-02T06:22:52.073Z","comments":true,"path":"2020/04/02/洛谷-P4017-最大食物链计数/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P4017-%E6%9C%80%E5%A4%A7%E9%A3%9F%E7%89%A9%E9%93%BE%E8%AE%A1%E6%95%B0/","excerpt":"本文用了三类方法，加上邻接表和vector的转换，一共写了五个方法，分别是优先队列，记忆dfs+vector，记忆dfs+邻接表，拓扑排序+二维数组，拓扑排序+邻接表","text":"本文用了三类方法，加上邻接表和vector的转换，一共写了五个方法，分别是优先队列，记忆dfs+vector，记忆dfs+邻接表，拓扑排序+二维数组，拓扑排序+邻接表 题目题目背景你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。 题目描述给你一个食物网，你要求出这个食物网中最大食物链的数量。 （这里的“最大食物链”，指的是生物学意义上的食物链，即最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者。） Delia 非常急，所以你只有 11 秒的时间。 由于这个结果可能过大，你只需要输出总数模上 8011200280112002 的结果。 输入格式第一行，两个正整数 n、mn、m，表示生物种类 nn 和吃与被吃的关系数 mm。 接下来 mm 行，每行两个正整数，表示被吃的生物A和吃A的生物B。 输出格式一行一个整数，为最大食物链数量模上 8011200280112002 的结果。 输入输出样例输入 #1复制 123456785 71 21 32 33 52 54 53 4 输出 #1复制 15 说明/提示各测试点满足以下约定： 【补充说明】 数据中不会出现环，满足生物学的要求。（感谢 @AKEE ） 算法优先队列这是我第一个想到的方法，因为这个题目的分类在DP中，想到把边用优先队列按照起点从小到大排序，这样就能满足这样一个转移方程 1sum[a.e]+&#x3D;(v[a.s]&#x3D;&#x3D;0)?1:sum[a.s]; 其中，v[i]=0表示纯起点，因为把边按照起点排序了，所以当前边终点的出度一定为0，起点又分为两种情况，一个是没有入度的(纯起点)，如果这样，sum[终点]应该加1。如果起点是既有入度又有出度的，sum[终点]+=sum[起点]。这个过程中还要改变点的状态，例如1-&gt;2,2标记为终点，然后1-&gt;3,3标记为终点，然后2-&gt;3,2标记为中转点，这样统计所有终点的sum值就可以得到结果。但是现实是残酷的，有500000个边，我估计队列都满了，并且时间效率也不好，失败的算法 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int sum[5001];int v[5001];&#x2F;&#x2F;0新起点，1终点，-1中转点 struct edge&#123; int s,e;&#125;;struct cmp&#123; bool operator()(edge a,edge b) &#123; return a.s&gt;b.s; &#125;&#125;;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,m; priority_queue&lt;edge ,vector&lt;edge&gt;, cmp&gt; q; cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; q.push(&#123;s,e&#125;); &#125; while(!q.empty()) &#123; edge a&#x3D;q.top(); q.pop();&#x2F;&#x2F; sum[a.e]&#x3D;(v[a.s]&#x3D;&#x3D;0)?(sum[a.e]+1):sum[a.s]; if(v[a.s]&#x3D;&#x3D;0) &#123; sum[a.e]++; &#125; else &#123; sum[a.e]+&#x3D;sum[a.s]; if(v[a.s]&#x3D;&#x3D;1) v[a.s]&#x3D;-1; &#125; v[a.e]&#x3D;1; &#125; int ans&#x3D;0; _for(i,1,n) &#123; if(v[i]&#x3D;&#x3D;1) ans+&#x3D;sum[i]; &#125; cout&lt;&lt;ans; return 0;&#125; 记忆dfs如果我们能知道以终点上一个点为终点的食物链数，那么终点的食物链数就是这些点食物链数的和。例如，知道5是其中一个终点，并且已知只有2-&gt;5,4-&gt;5，那么以5位终点的食物链数等于以2为终点的食物链数+以4为终点的食物链数。怎么知道以5为终点的边的起点呢？需要邻接表或者vector，怎么知道5是不是终点呢？需要一个数组标记一下和邻接表或者vector联合判断 记忆dfs+邻接表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct Edge&#123; int start,next;&#125; edge[5000005];int pre[5005];int num[5005];bool des[5005];int dfs(int e)&#123; if(!pre[e]) return 1; if(num[e]) return num[e]; int summ&#x3D;0; for(int i&#x3D;pre[e];i;i&#x3D;edge[i].next) &#123; summ+&#x3D;dfs(edge[i].start); summ%&#x3D;80112002; &#125; return num[e]&#x3D;summ;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,m; cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; edge[i].start&#x3D;s; edge[i].next&#x3D;pre[e]; pre[e]&#x3D;i; des[s]&#x3D;1; &#125; int ans&#x3D;0; _for(i,1,n) &#123; if(!des[i]&amp;&amp;pre[i]) &#123; ans+&#x3D;dfs(i); ans%&#x3D;80112002; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; 记忆dfs+vector12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int num[5005];bool des[5005];vector&lt;int&gt; v[5005];int dfs(int e)&#123; if(!v[e].size()) return 1; if(num[e]) return num[e]; int summ&#x3D;0; for(int i&#x3D;0;i&lt;v[e].size();i++) &#123; summ+&#x3D;dfs(v[e][i]); summ%&#x3D;80112002; &#125; return num[e]&#x3D;summ;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,m; cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; v[e].push_back(s); des[s]&#x3D;1; &#125; int ans&#x3D;0; _for(i,1,n) &#123; if(!des[i]&amp;&amp;v[i].size()) &#123; ans+&#x3D;dfs(i); ans%&#x3D;80112002; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; 拓扑排序每次取入度为0的点，也就是起点，然后把这个这个起点能到达的终点+当前食物链数目，再找入度为0的点，继续。直到只剩下终点统计一下就可以，这个需要已知起点找终点，可以用二维数组或者邻接表或者vector 拓扑+二维数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m;int map[5005][5005];int in[5005],out[5005];int sum[5005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; map[s][e]&#x3D;1; out[s]++; in[e]++; &#125; queue&lt;int&gt; q; _for(i,1,n) &#123; if(!in[i]) &#123; sum[i]&#x3D;1; q.push(i); &#125; &#125; int summ&#x3D;0; while(!q.empty()) &#123; int s&#x3D;q.front(); q.pop(); _for(i,1,n) &#123; if(map[s][i]) &#123; sum[i]+&#x3D;sum[s]; sum[i]%&#x3D;80112002; in[i]--; if(!in[i]) &#123; if(!out[i]) &#123; summ+&#x3D;sum[i]; summ%&#x3D;80112002; continue; &#125; q.push(i); &#125; &#125; &#125; &#125; cout&lt;&lt;summ; return 0;&#125; 拓扑+邻接表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct Edge&#123; int end,next;&#125; edge[5000005];int n,m;int pre[5005];int in[5005],out[5005];int sum[5005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; edge[i].end&#x3D;e; edge[i].next&#x3D;pre[s]; pre[s]&#x3D;i; out[s]++; in[e]++; &#125; queue&lt;int&gt; q; _for(i,1,n) &#123; if(!in[i]) &#123; sum[i]&#x3D;1; q.push(i); &#125; &#125; int summ&#x3D;0; while(!q.empty()) &#123; int s&#x3D;q.front(); q.pop(); for(int i&#x3D;pre[s];i;i&#x3D;edge[i].next) &#123; sum[edge[i].end]+&#x3D;sum[s]; sum[edge[i].end]%&#x3D;80112002; in[edge[i].end]--; if(!in[edge[i].end]) &#123; if(!out[edge[i].end]) &#123; summ+&#x3D;sum[edge[i].end]; summ%&#x3D;80112002; continue; &#125; q.push(edge[i].end); &#125; &#125; &#125; cout&lt;&lt;summ; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"食物链","slug":"食物链","permalink":"https://donghuangzhong.github.io/tags/%E9%A3%9F%E7%89%A9%E9%93%BE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://donghuangzhong.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"记忆化递归","slug":"记忆化递归","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92/"},{"name":"邻接表","slug":"邻接表","permalink":"https://donghuangzhong.github.io/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"},{"name":"优先队列","slug":"优先队列","permalink":"https://donghuangzhong.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"vector","slug":"vector","permalink":"https://donghuangzhong.github.io/tags/vector/"}]},{"title":"洛谷_P2196 挖地雷","slug":"洛谷-P2196-挖地雷","date":"2020-04-02T01:30:59.000Z","updated":"2020-04-02T01:36:37.696Z","comments":true,"path":"2020/04/02/洛谷-P2196-挖地雷/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P2196-%E6%8C%96%E5%9C%B0%E9%9B%B7/","excerpt":"摘要","text":"摘要 题目题目描述在一个地图上有NN个地窖(N \\le 20)(N≤20)，每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。当地窖及其连接的数据给出之后，某人可以从任一处开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。 输入格式有若干行。 第11行只有一个数字，表示地窖的个数NN。 第22行有NN个数，分别表示每个地窖中的地雷个数。 第33行至第N+1N+1行表示地窖之间的连接情况： 第33行有n-1n−1个数（00或11），表示第一个地窖至第22个、第33个、…、第nn个地窖有否路径连接。如第33行为1 1 0 0 0 … 011000…0，则表示第11个地窖至第22个地窖有路径，至第33个地窖有路径，至第44个地窖、第55个、…、第nn个地窖没有路径。 第44行有n-2n−2个数，表示第二个地窖至第33个、第44个、…、第nn个地窖有否路径连接。 … … 第n+1n+1行有11个数，表示第n-1n−1个地窖至第nn个地窖有否路径连接。（为00表示没有路径，为11表示有路径）。 输出格式有两行 第一行表示挖得最多地雷时的挖地雷的顺序，各地窖序号间以一个空格分隔，不得有多余的空格。 第二行只有一个数，表示能挖到的最多地雷数。 输入输出样例输入 #1复制 123456510 8 4 7 61 1 1 00 0 01 11 输出 #1复制 121 3 4 52 算法如果我们知道i点可以到达j点，并且知道到达i点时的最大值sum[i],那么我们就可以计算经过i点到达j点的最大值，与当前j点的最大值sum[j]做比较，取较大者。转移方程为 1sum[j]&#x3D;max(sum[i]+mines[j],sum[j]) 可行性分析：sum[i]必须是最优解，稍微分析一下能证明可行 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int mines[21]; int sum[21];int path[21];void print_path(int x)&#123; if(x&#x3D;&#x3D;0) return ; print_path(path[x]); cout&lt;&lt;x&lt;&lt;&quot; &quot;;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) &#123; cin&gt;&gt;mines[i]; sum[i]&#x3D;mines[i]; &#125; int ans&#x3D;-1; int index; _for(i,1,n-1) &#123; _for(j,i+1,n) &#123; bool connect; if(cin&gt;&gt;connect&amp;&amp;connect&amp;&amp;sum[i]+mines[j]&gt;sum[j]) &#123; sum[j]&#x3D;sum[i]+mines[j]; path[j]&#x3D;i; &#125; &#125; if(sum[i]&gt;ans) &#123; ans&#x3D;sum[i]; index&#x3D;i; &#125; &#125; if(sum[n]&gt;ans) &#123; ans&#x3D;sum[n]; index&#x3D;n; &#125; print_path(index); cout&lt;&lt;endl&lt;&lt;ans; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"正向DP","slug":"正向DP","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E5%90%91DP/"}]},{"title":"洛谷_P1434_[SHOI2002]滑雪","slug":"洛谷-P1434-SHOI2002-滑雪","date":"2020-04-01T23:45:26.000Z","updated":"2020-04-01T23:49:53.647Z","comments":true,"path":"2020/04/02/洛谷-P1434-SHOI2002-滑雪/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P1434-SHOI2002-%E6%BB%91%E9%9B%AA/","excerpt":"摘要","text":"摘要 题目题目描述Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子： 123451 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 2424－1717－1616－11（从 2424 开始，在 11 结束）。当然 2525－2424－2323－\\ldots…－33－22－11 更长。事实上，这是最长的一条。 输入格式输入的第一行为表示区域的二维数组的行数 RR 和列数 CC。下面是 RR 行，每行有 CC 个数，代表高度(两个数字之间用 11 个空格间隔)。 输出格式输出区域中最长滑坡的长度。 输入输出样例输入 #1复制 1234565 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 输出 #1复制 125 说明/提示对于 100%100% 的数据，1\\leq R,C\\leq 1001≤R,C≤100。 算法记忆化递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int map[101][101];int mem[101][101];int r,c;int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;int dfs(int x,int y)&#123; if(mem[x][y]) return mem[x][y]; int maxx&#x3D;0; _for(i,0,3) &#123; int xx&#x3D;x+dir[i][0]; int yy&#x3D;y+dir[i][1]; if(xx&gt;&#x3D;0&amp;&amp;xx&lt;r&amp;&amp;yy&gt;&#x3D;0&amp;&amp;yy&lt;c&amp;&amp;map[xx][yy]&lt;map[x][y]) &#123; maxx&#x3D;max(maxx,dfs(xx,yy)); &#125; &#125; return mem[x][y]&#x3D;maxx+1;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;r&gt;&gt;c; _for(i,0,r-1) _for(j,0,c-1) cin&gt;&gt;map[i][j]; int ans&#x3D;-1; _for(i,0,r-1) _for(j,0,c-1) ans&#x3D;max(ans,dfs(i,j)); cout&lt;&lt;ans; return 0;&#125; 优先队列DP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct node&#123; int x,y,num;&#125;;struct cmp&#123; bool operator()(node a,node b) &#123; return a.num&gt;b.num; &#125;&#125;;int r,c,map[101][101],step[101][101];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;r&gt;&gt;c; priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; q; _for(i,1,r) _for(j,1,c) &#123; step[i][j]&#x3D;1; cin&gt;&gt;map[i][j]; q.push(&#123;i,j,map[i][j]&#125;); &#125; int ans&#x3D;0; while(!q.empty()) &#123; node t&#x3D;q.top(); q.pop(); if(t.num&gt;map[t.x+1][t.y]) step[t.x][t.y]&#x3D;max(step[t.x][t.y],step[t.x+1][t.y]+1); if(t.num&gt;map[t.x-1][t.y]) step[t.x][t.y]&#x3D;max(step[t.x][t.y],step[t.x-1][t.y]+1); if(t.num&gt;map[t.x][t.y+1]) step[t.x][t.y]&#x3D;max(step[t.x][t.y],step[t.x][t.y+1]+1); if(t.num&gt;map[t.x][t.y-1]) step[t.x][t.y]&#x3D;max(step[t.x][t.y],step[t.x][t.y-1]+1); ans&#x3D;max(ans,step[t.x][t.y]); &#125; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"洛谷_P1216_数字三角形","slug":"洛谷-P1216-数字三角形","date":"2020-04-01T09:40:22.000Z","updated":"2020-04-01T10:08:26.881Z","comments":true,"path":"2020/04/01/洛谷-P1216-数字三角形/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/01/%E6%B4%9B%E8%B0%B7-P1216-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2/","excerpt":"摘要","text":"摘要 题目题目描述观察下面的数字金字塔。 写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。 12345 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 在上面的样例中,从 7 \\to 3 \\to 8 \\to 7 \\to 57→3→8→7→5 的路径产生了最大 输入格式第一个行一个正整数 rr ,表示行的数目。 后面每行为这个数字金字塔特定行包含的整数。 输出格式单独的一行,包含那个可能得到的最大的和。 输入输出样例输入 #1复制 123456573 88 1 02 7 4 44 5 2 6 5 输出 #1复制 130 说明/提示【数据范围】对于 100%100% 的数据，1\\le r \\le 10001≤r≤1000，所有输入在 [0,100][0,100] 范围内。 算法正向:计算起点到每个点的最大值从上向下走，找正向的来源，注意不能影响下一个点的来源 轴对称翻转代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int num[1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,number; cin&gt;&gt;n; _for(i,1,n) for(int j&#x3D;i;j&gt;&#x3D;1;j--) cin&gt;&gt;number,num[j]&#x3D;max(num[j],num[j-1])+number; int ans&#x3D;num[1]; _for(i,2,n) ans&#x3D;max(ans,num[i]); cout&lt;&lt;ans; return 0;&#125; 右对齐代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int num[1002];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,number; cin&gt;&gt;n; _for(i,1,n) for(int j&#x3D;n-i+1;j&lt;&#x3D;n;j++) cin&gt;&gt;number,num[j]&#x3D;max(num[j],num[j+1])+number; int ans&#x3D;num[1]; _for(i,2,n) ans&#x3D;max(ans,num[i]); cout&lt;&lt;ans; return 0;&#125; 反向：计算终点到每一个起点的最大值代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int map[1001][1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,0,n-1) _for(j,0,i) cin&gt;&gt;map[i][j]; for(int i&#x3D;n-2;i&gt;&#x3D;0;i--) for(int j&#x3D;0;j&lt;&#x3D;i;j++) map[i][j]+&#x3D;max(map[i+1][j],map[i+1][j+1]); cout&lt;&lt;map[0][0]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"数塔","slug":"数塔","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E5%A1%94/"},{"name":"正反向思考","slug":"正反向思考","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E5%8F%8D%E5%90%91%E6%80%9D%E8%80%83/"}]},{"title":"HDU_1024_Max Sum Plus Plus","slug":"HDU-1024-Max-Sum-Plus-Plus","date":"2020-04-01T07:04:24.000Z","updated":"2020-04-01T07:51:43.084Z","comments":true,"path":"2020/04/01/HDU-1024-Max-Sum-Plus-Plus/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/01/HDU-1024-Max-Sum-Plus-Plus/","excerpt":"DP最重要的是找状态转移方程，也就是怎么通过已有的状态求未知的状态","text":"DP最重要的是找状态转移方程，也就是怎么通过已有的状态求未知的状态 题目Max Sum Plus Plus\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 48103 Accepted Submission(s): 17534** Problem DescriptionNow I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem. Given a consecutive number sequence S1, S2, S3, S4 … Sx, … Sn (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ Sx ≤ 32767). We define a function sum(i, j) = Si + … + Sj (1 ≤ i ≤ j ≤ n). Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i1, j1) + sum(i2, j2) + sum(i3, j3) + … + sum(im, jm) maximal (ix ≤ iy ≤ jx or ix ≤ jy ≤ jx is not allowed). But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(ix, jx)(1 ≤ x ≤ m) instead. ^_^ InputEach test case will begin with two integers m and n, followed by n integers S1, S2, S3 … Sn.Process to the end of file. OutputOutput the maximal summation described above in one line. Sample Input121 3 1 2 32 6 -1 4 -2 3 -2 3 Sample Output1268 题目大意输入m,n,然后输入n个数。求在这n个数中，分为m个区间，区间互不重叠，对每个区间求和得到sum1~m，再对这m个sum求和，求这个和的最大值 算法先从未优化的版本开始，max_sum[i][j]表示的是将[0,j]区间分为i个互不重叠子区间得到的最优解，那么状态转移方程就可以表示为 1max_sum[i][j]&#x3D;max(max_sum[i][j-1],max_sum[i-1][k]) k属于[i-1,j-1] 然后就可以发现，求解的时候只涉及max_sum数组的两行，第i行和第i-1行，因此可以用一个两行的滚动的数组表示DP数组。也就是用其中一行计算另一行，当另一行计算好了之后，转换角色。即 1max_sum[t][j]&#x3D;max(max_sum[t][j-1],max_sum[1-t][k]) k属于[i-1,j-1] 然后就会发现，时间复杂度太高，主要是max_sum[1-t][k]耗时，于是将后面的max_sum[1-t][k]用单独一个数组max_pre[j-1]代替，并且这样做也可以舍弃max_sum的第一维了。于是就简化转移方程为 1max_sum[j]&#x3D;max(max_sum[j-1],max_pre[j-1])+num[j]; 其中max_sum[j]表示的是[0,j]区间分为i个互不重叠小区间的最优解；max_pre[j-1]表示的是终点在[i,j-1]，并且分为i-1个区间的和的最大值，其实就是刚开始的max_sum[i-1][k] k属于[i-1,j-1]的最大值，即 1max(max_sum[i-1][i-1],max_sum[i-1][i],max_sum[i-1][i+1],…………,max_sum[i-1][j-1]) 舍弃掉第一维，可以用循环次数决定max_sum数组表示的是分为几个小区间的状态，比如循环一次就表示分为1个小区间的各种状态，循环m次就表示循环m次的状态，并且当每次循环的时候需要更新max_pre，当第i次循环的时候计算max_sum[j]的时候，需要用到max_pre[j-1]，并且在第i次循环中只使用这一次，以后就用不到了，并且此时的max_pre需要更新的值已经出来了，就是max_sum[x] x属于[0,j-1]的最大值，所以我们只需要维护一个max_summ表示第i次max_sum[x] x属于[0,j-1]的最大值就能够实现这两个数组的同步更新。、 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)#define MAX 0x3f3f3f3fusing namespace std;int num[1000001];int max_sum[1000001];int max_pre[1000001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int m,n,max_summ; while(cin&gt;&gt;m&gt;&gt;n) &#123; memset(max_sum,0,sizeof(max_sum)); memset(max_pre,0,sizeof(max_pre)); _for(i,1,n) cin&gt;&gt;num[i]; _for(i,1,m) &#123; max_summ&#x3D;-MAX; _for(j,i,n) &#123; max_sum[j]&#x3D;max(max_sum[j-1],max_pre[j-1])+num[j]; max_pre[j-1]&#x3D;max_summ; if(max_sum[j]&gt;max_summ) max_summ&#x3D;max_sum[j]; &#125; &#125; cout&lt;&lt;max_summ&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"转移方程的构造","slug":"转移方程的构造","permalink":"https://donghuangzhong.github.io/tags/%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E7%9A%84%E6%9E%84%E9%80%A0/"},{"name":"极度优化","slug":"极度优化","permalink":"https://donghuangzhong.github.io/tags/%E6%9E%81%E5%BA%A6%E4%BC%98%E5%8C%96/"}]},{"title":"算法提高 秘密行动","slug":"算法提高-秘密行动","date":"2020-04-01T01:21:03.000Z","updated":"2020-04-01T01:58:28.976Z","comments":true,"path":"2020/04/01/算法提高-秘密行动/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/01/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98-%E7%A7%98%E5%AF%86%E8%A1%8C%E5%8A%A8/","excerpt":"双数组DP","text":"双数组DP 题目算法提高 秘密行动提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 小D接到一项任务，要求他爬到一座n层大厦的顶端与神秘人物会面。这座大厦有一个神奇的特点，每层的高度都不一样，同时，小D也拥有一项特殊能力，可以一次向上跳跃一层或两层，但是这项能力无法连续使用。已知向上1高度消耗的时间为1，跳跃不消耗时间。由于事态紧急，小D想知道他最少需要多少时间到达顶层。 输入格式 第一行包含一个整数n，代表楼的高度。 接下来n行每行一个整数ai，代表i层的楼层高度（ai &lt;= 100）。 输出格式 输出1行，包含一个整数，表示所需的最短时间。 样例输入535184 样例输出1 数据规模和约定 对20%的数据,n&lt;=10 对40%的数据,n&lt;=100 对60%的数据,n&lt;=5000 对100%的数据,n&lt;=10000 算法通用做法(三个数组)三个数组，height[i]表示第i层楼的高度，climb[i]表示爬上第i层楼的最短时间，jump[i]表示跳到第i层楼的时间。显然，如果是爬到第i层楼，那它的起点只能是从第i-1层楼，所以如果知道到i-1层的最短时间就能知道爬到第i层楼的最短时间，到第i-1层楼的方式可能是爬，也可能是跳跃。所以就有了爬楼的转移方程 1climb[i]&#x3D;min(climb[i-1],jump[i-1])+height[i] 同理，跳跃的上一步只能是爬，因为题目说了不能连续跳跃，但是跳跃的起点有两个，所以转移方程为 1jump[i]&#x3D;min(climb[i-1],climb[i-2]) 所以i要从2开始，同时要初始化好climb[0],climb[1]和jump[1] 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int jump[10001];int climb[10001];int height[10001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) cin&gt;&gt;height[i]; climb[0]&#x3D;jump[0]&#x3D;0; climb[1]&#x3D;height[1]; _for(i,2,n) &#123; climb[i]&#x3D;min(climb[i-1],jump[i-1])+height[i]; jump[i]&#x3D;min(climb[i-1],climb[i-2]); &#125; cout&lt;&lt;min(climb[n],jump[n]); return 0;&#125; 两个数组的做法观察转移方程，hight[i]可以直接输入，不用保存。也就是说输入第i层楼的高度的时候，climb[i]和jump[i]已经可以算出来了 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int jump[10001];int climb[10001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; climb[0]&#x3D;jump[0]&#x3D;0; cin&gt;&gt;climb[1]; _for(i,2,n) &#123; int height; cin&gt;&gt;height; climb[i]&#x3D;min(climb[i-1],jump[i-1])+height; jump[i]&#x3D;min(climb[i-1],climb[i-2]); &#125; cout&lt;&lt;min(climb[n],jump[n]); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"多数组DP","slug":"多数组DP","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%9A%E6%95%B0%E7%BB%84DP/"}]},{"title":"HDU-1114_Piggy-Bank","slug":"HDU-1114-Piggy-Bank","date":"2020-04-01T01:01:31.000Z","updated":"2020-04-01T01:07:13.004Z","comments":true,"path":"2020/04/01/HDU-1114-Piggy-Bank/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/01/HDU-1114-Piggy-Bank/","excerpt":"简单背包","text":"简单背包 题目Piggy-Bank\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 46180 Accepted Submission(s): 22736** Problem DescriptionBefore ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid. But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs! InputThe input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams. OutputPrint exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”. Sample Input12345678910111213310 11021 130 5010 11021 150 301 6210 320 4 Sample Output123The minimum amount of money in the piggy-bank is 60.The minimum amount of money in the piggy-bank is 100.This is impossible. 题目大意输入空的存钱罐的重量和装满钱的存钱罐的重量，然后再输入硬币的面值和重量，要求输出这个存钱罐恰好能够装的最小金钱的值 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int dp[10001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int t; cin&gt;&gt;t; while(t--) &#123; memset(dp,0x3f,sizeof(dp)); dp[0]&#x3D;0; int empty_w,full_w; cin&gt;&gt;empty_w&gt;&gt;full_w; int w&#x3D;full_w-empty_w; int coin_n; cin&gt;&gt;coin_n; while(coin_n--) &#123; int v,coin_w; cin&gt;&gt;v&gt;&gt;coin_w; for(int i&#x3D;coin_w;i&lt;&#x3D;w;i++) &#123; if(dp[i]&gt;dp[i-coin_w]+v) dp[i]&#x3D;dp[i-coin_w]+v; &#125; &#125; if(dp[w]&#x3D;&#x3D;0x3f3f3f3f) &#123; cout&lt;&lt;&quot;This is impossible.&quot;&lt;&lt;endl; continue; &#125; cout&lt;&lt;&quot;The minimum amount of money in the piggy-bank is &quot;&lt;&lt;dp[w]&lt;&lt;&quot;.&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"背包","slug":"背包","permalink":"https://donghuangzhong.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"算法训练 小生物的逃逸","slug":"算法训练-小生物的逃逸","date":"2020-03-31T09:09:29.000Z","updated":"2020-03-31T09:11:59.153Z","comments":true,"path":"2020/03/31/算法训练-小生物的逃逸/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/31/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%B0%8F%E7%94%9F%E7%89%A9%E7%9A%84%E9%80%83%E9%80%B8/","excerpt":"水","text":"水 题目算法训练 小生物的逃逸提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 空间中有n个球，这些球不相交也不相切。有m个可以视为质点的小生物，可能在某些球内，也可能在所有球之外，但不会在球面上。问这些生物从原来的地方逃逸到所有球外面的空间，至少要经过多少层球面。 输入格式 第一行两个数n、m：表示球的数量和小生物的数量； 接下来n行每行四个整数Xi、Yi、Zi和Ri：表示一个球的三维坐标和半径； 接下来m行每行三个整数Xi、Yi、Zi：表示一个生物的坐标。 输出格式 一行m个数：表示每个小生物逃逸时至少经过的球面数。 样例输入2 20 0 0 20 0 0 40 0 10 0 3 样例输出2 1 算法12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m;struct aa&#123; int x,y,z,r;&#125;;aa a[101];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input10.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m; _for(i,0,n-1) cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].z&gt;&gt;a[i].r; _for(i,1,m) &#123; int sum&#x3D;0; long long x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; _for(j,0,n-1) if((x-a[j].x)*(x-a[j].x)+(y-a[j].y)*(y-a[j].y)+(z-a[j].z)*(z-a[j].z)&lt;a[j].r*a[j].r) sum++; cout&lt;&lt;sum&lt;&lt;&quot; &quot;; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[]},{"title":"算法训练 相邻字母","slug":"算法训练-相邻字母","date":"2020-03-31T00:22:47.000Z","updated":"2020-03-31T00:24:38.853Z","comments":true,"path":"2020/03/31/算法训练-相邻字母/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/31/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E7%9B%B8%E9%82%BB%E5%AD%97%E6%AF%8D/","excerpt":"简单水题","text":"简单水题 题目算法训练 相邻字母提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 【问题描述】 从键盘输入一个英文字母，要求按字母的顺序打印出3个相邻的字母，指定的字母在中间。若指定的字母为Z，则打印YZA，若为A则打印ZAB。注意：需要区分大小写。 【输入格式】 一行，仅包含一个英文字母。 【输出格式】 一行，包含三个字母。 【样例输入**1****】 a 【样例输出**1****】 zab 【样例输入**2****】 B 【样例输出**2****】 ABC 算法12345678910111213141516171819202122#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int main()&#123; char c; cin&gt;&gt;c; if(c&#x3D;&#x3D;&#39;a&#39;||c&#x3D;&#x3D;&#39;A&#39;) printf(&quot;%c&quot;,c+25); else printf(&quot;%c&quot;,c-1); cout&lt;&lt;c; if(c&#x3D;&#x3D;&#39;z&#39;||c&#x3D;&#x3D;&#39;Z&#39;) printf(&quot;%c&quot;,c-25); else printf(&quot;%c&quot;,c+1); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"},{"name":"字母","slug":"字母","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E6%AF%8D/"}]},{"title":"算法训练 奇变的字符串","slug":"算法训练-奇变的字符串","date":"2020-03-31T00:06:56.000Z","updated":"2020-03-31T00:08:43.521Z","comments":true,"path":"2020/03/31/算法训练-奇变的字符串/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/31/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%A5%87%E5%8F%98%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"摘要","text":"摘要 题目算法训练 奇变的字符串提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 将一个字符串的奇数位（首位为第0位）取出，将其顺序弄反，再放回原字符串的原位置上。 如字符串”abcdefg”，奇数位为”bdf”，顺序弄反后为”fdb”，最后得到字符串”afcdebg”。 输入格式 输入共一行，为一个字符串，字符串中无空格。 输出格式 输出共一行，为一个字符串，即最后得到的字符串。 样例输入abcdefg 样例输出afcdebg 数据规模和约定 字符串长度不超过255. 算法1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); string a; cin&gt;&gt;a; int l&#x3D;0,r&#x3D;a.length()-1; while(r&gt;l) &#123; if((l&amp;1)&#x3D;&#x3D;0) l++; if((r&amp;1)&#x3D;&#x3D;0) r--; swap(a[l],a[r]); l+&#x3D;2; r-&#x3D;2; &#125; cout&lt;&lt;a; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"字符串","slug":"ACM/字符串","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"算法训练 自行车停放","slug":"算法训练-自行车停放","date":"2020-03-30T11:00:24.000Z","updated":"2020-03-30T11:11:58.852Z","comments":true,"path":"2020/03/30/算法训练-自行车停放/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E8%87%AA%E8%A1%8C%E8%BD%A6%E5%81%9C%E6%94%BE/","excerpt":"看数据规模，10的5次方，用数组的话大于是(n(n+1)/2)n^2级别的，实测12秒。只能转向双向链表！","text":"看数据规模，10的5次方，用数组的话大于是(n(n+1)/2)n^2级别的，实测12秒。只能转向双向链表！ 题目算法训练 自行车停放提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 有n辆自行车依次来到停车棚，除了第一辆自行车外，每辆自行车都会恰好停放在已经在停车棚里的某辆自行车的左边或右边。(e.g.停车棚里已经有3辆自行车，从左到右编号为：3,5,1。现在编号为2的第4辆自行车要停在5号自行车的左边，所以现在停车棚里的自行车编号是：3,2,5,1)。给定n辆自行车的停放情况，按顺序输出最后停车棚里的自行车编号。 输入格式 第一行一个整数n。 第二行一个整数x。表示第一辆自行车的编号。 以下n-1行，每行3个整数x,y,z。 z=0时，表示编号为x的自行车恰停放在编号为y的自行车的左边 z=1时，表示编号为x的自行车恰停放在编号为y的自行车的右边 输出格式 从左到右输出停车棚里的自行车编号 样例输入431 3 12 1 05 2 1 样例输出3 2 5 1 数据规模和约定 n&lt;=100000 自行车编号为不超过100000的正整数。 算法数组版(12秒)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int a[100001],b[100001];void insert(int n,int num,int sum)&#123; &#x2F;&#x2F;memcpy(a+n+1,a+n,4*(sum-n)); for(int i&#x3D;sum-1;i&gt;&#x3D;n;i--) &#123; a[i+1]&#x3D;a[i]; b[a[i]]++; &#125; a[n]&#x3D;num; b[num]&#x3D;n;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int n; int cc&#x3D;clock(); cin&gt;&gt;n&gt;&gt;a[0]; b[a[0]]&#x3D;0; int now_sum&#x3D;1; int t&#x3D;n-1; while(t--) &#123; int x,y,z,i; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; i&#x3D;b[y]; int index_move&#x3D;z?i+1:i; insert(index_move,x,now_sum++); &#125; _for(i,0,now_sum-1) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; PP(&quot;time&#x3D;&quot;,clock()-cc); return 0;&#125; 双向链表版用的是带头结点和尾结点的双向链表，单纯是为了方便插入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct L&#123; L * pre; int n; L *next;&#125;;L* d[100001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); L *head&#x3D;(L *)malloc(sizeof(L)); L *t1&#x3D;(L *)malloc(sizeof(L)); L * wei&#x3D;(L *)malloc(sizeof(L)); head-&gt;next&#x3D;t1; t1-&gt;pre&#x3D;head; t1-&gt;next&#x3D;wei; wei-&gt;pre&#x3D;t1; wei-&gt;next&#x3D;NULL; int n; cin&gt;&gt;n&gt;&gt;t1-&gt;n; d[t1-&gt;n]&#x3D;t1; int t&#x3D;n-1; while(t--) &#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; L* node&#x3D;(L *)malloc(sizeof(L)); node-&gt;n&#x3D;x; d[x]&#x3D;node; L* temp&#x3D;d[y]; if(z) &#123; node-&gt;pre&#x3D;temp; node-&gt;next&#x3D;temp-&gt;next; temp-&gt;next-&gt;pre&#x3D;node; temp-&gt;next&#x3D;node; &#125; else &#123; node-&gt;next&#x3D;temp; node-&gt;pre&#x3D;temp-&gt;pre; temp-&gt;pre-&gt;next&#x3D;node; temp-&gt;pre&#x3D;node; &#125; &#125; t1&#x3D;head-&gt;next; while(t1-&gt;next!&#x3D;NULL) &#123; cout&lt;&lt;t1-&gt;n&lt;&lt;&quot; &quot;; t1&#x3D;t1-&gt;next; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"双向链表","slug":"ACM/双向链表","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"双向链表","slug":"双向链表","permalink":"https://donghuangzhong.github.io/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"索引表","slug":"索引表","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A2%E5%BC%95%E8%A1%A8/"}]},{"title":"算法训练 数组逆序排列","slug":"算法训练-数组逆序排列","date":"2020-03-30T09:18:16.000Z","updated":"2020-03-30T09:19:37.871Z","comments":true,"path":"2020/03/30/算法训练-数组逆序排列/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E6%95%B0%E7%BB%84%E9%80%86%E5%BA%8F%E6%8E%92%E5%88%97/","excerpt":"摘要","text":"摘要 题目算法训练 数组逆序排列提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 编写一个程序，读入一组整数（不超过20个），并把它们保存在一个整型数组中。当用户输入0时，表示输入结束。然后程序将把这个数组中的值按逆序重新存放，并打印出来。要求：(1)只能定义一个数组；(2)在交换两个数组元素的值时，必须使用单独定义的一个函数swap。例如：假设用户输入了一组数据：7 19 -5 6 2 0，那么程序将会把前五个有效数据保存在一个数组中，即7 19 -5 6 2，然后把这个数组中的值按逆序重新存放，即变成了2 6 -5 19 7，然后把它们打印出来。 输入格式：输入只有一行，包括若干个整数，最后一个整数是0。 输出格式：输出只有一行，包括若干个整数，即逆序排列后的结果。 输入输出样例样例输入7 19 -5 6 2 0 样例输出2 6 -5 19 7 算法123456789101112131415161718192021222324#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int a[21]; int index&#x3D;1; while(cin&gt;&gt;a[index++]&amp;&amp;a[index-1]); index-&#x3D;2; _for(i,1,index&#x2F;2) swap(a[i],a[index+1-i]); _for(i,1,index) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"整除2","slug":"整除2","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B4%E9%99%A42/"}]},{"title":"算法训练 字符串比较","slug":"算法训练-字符串比较","date":"2020-03-30T08:50:22.000Z","updated":"2020-03-30T09:07:55.217Z","comments":true,"path":"2020/03/30/算法训练-字符串比较/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/","excerpt":"我也不知道怎么错的，测试用例都对了，但就是通不过！最后附上官方的代码！！","text":"我也不知道怎么错的，测试用例都对了，但就是通不过！最后附上官方的代码！！ 题目算法训练 字符串比较提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 strncmp函数的原型为：int strncmp(char *s, char *t, int n);，其功能是比较字符串s和t的前n个字符。如果s&lt;t，返回-1；如果s=t，返回0；如果s&gt;t，返回1。请自己编程实现该函数，并编写一个程序来测试其正确性。 输入格式：输入有三行，第一行为字符串s，第二行为字符串t，第三行为整数n。 输出格式：输出只有一个整数，即比较结果。 输入输出样例样例输入worldword4 样例输出1 代码测试用例在win10 下都能通过，但在蓝桥就是错误 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int cmp(string a,string b,int n)&#123; for(int i&#x3D;0;i&lt;&#x3D;n-1;i++) &#123; if(i&#x3D;&#x3D;a.length()||i&#x3D;&#x3D;b.length()) &#123; if(i!&#x3D;a.length()) return -1; else if(i!&#x3D;b.length()) return 1; else return 0; &#125; if(a[i]&gt;b[i]) return 1; if(a[i]&lt;b[i]) return -1; &#125; &#125;int main()&#123;&#x2F;&#x2F; ios::sync_with_stdio(0);&#x2F;&#x2F; cin.tie(0);&#x2F;&#x2F; cout.tie(0); freopen(&quot;input6.txt&quot;,&quot;r&quot;,stdin); string a,b; int n; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n;&#x2F;&#x2F; cout&lt;&lt;cmp(a,b,n)&lt;&lt;endl;&#x2F;&#x2F; printf(&quot;%d&quot;,cmp(a,b,n)); int c&#x3D;cmp(a,b,n); if(c&#x3D;&#x3D;0) cout&lt;&lt;&quot;0&quot;; else cout&lt;&lt;c; return 0;&#125; 这个是官方版，但是我觉得错误太明显了，应该是题目叙述错了，有改动，比如a,b的大小关系和az和ba的关系应该是一样的，但是官方给的程序测试结果不一样 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[10000],t[10000]; int i,n,a&#x3D;0,k&#x3D;1; scanf(&quot;%s&quot;,&amp;s); scanf(&quot;%s&quot;,&amp;t); scanf(&quot;%d&quot;,&amp;n); for(i&#x3D;n-1;i&gt;&#x3D;0;i--)&#123; a&#x3D;a+s[i]*k-t[i]*k; k&#x3D;k*10; &#125; if(a&gt;0)&#123; printf(&quot;1&quot;); &#125; else if(a&lt;0)&#123; printf(&quot;-1&quot;); &#125; else&#123; printf(&quot;0&quot;); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"字符串","slug":"ACM/字符串","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串比较","slug":"字符串比较","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"}]},{"title":"算法训练 石子游戏","slug":"算法训练-石子游戏","date":"2020-03-30T04:21:07.000Z","updated":"2020-03-30T04:29:41.805Z","comments":true,"path":"2020/03/30/算法训练-石子游戏/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/","excerpt":"分析时间复杂度n^2=10^6,一秒不会超时。这个题的样例还好，给出了要用long long的暗示，并且给出这个测试用例摆明给你降低难度。这个题应该数组合sum全部用long long，因为a=b+c，先是计算b+c存到一个和b一样的数据类型中，如果a是long long，b,c是int，先计算b+c存到一个int的数据类型里，然后再赋值给c，如果溢出的话，b+c已经溢出了，此时在赋值给c还是溢出。所以需要全部置为long long!","text":"分析时间复杂度n^2=10^6,一秒不会超时。这个题的样例还好，给出了要用long long的暗示，并且给出这个测试用例摆明给你降低难度。这个题应该数组合sum全部用long long，因为a=b+c，先是计算b+c存到一个和b一样的数据类型中，如果a是long long，b,c是int，先计算b+c存到一个int的数据类型里，然后再赋值给c，如果溢出的话，b+c已经溢出了，此时在赋值给c还是溢出。所以需要全部置为long long! 题目算法训练 石子游戏提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 石子游戏的规则如下： 地上有n堆石子，每次操作可选取两堆石子（石子个数分别为x和y）并将它们合并，操作的得分记为(x+1)×(y+1)，对地上的石子堆进行操作直到只剩下一堆石子时停止游戏。 请问在整个游戏过程中操作的总得分的最大值是多少？ 输入格式 输入数据的第一行为整数n，表示地上的石子堆数；第二行至第n+1行是每堆石子的个数。 输出格式 程序输出一行，为游戏总得分的最大值。 样例输入10510519400273091989227814251291927212517254194053 样例输出15212676150 数据规模和约定 1≤n≤1000，1≤一堆中石子数≤50000 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;long long a[1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,0,n-1) cin&gt;&gt;a[i]; long long sum&#x3D;0; _for(i,1,n-1) &#123; int index1&#x3D;a[0]&gt;a[1]?0:1; int index2&#x3D;1-index1; _for(j,2,n-1) &#123; if(a[j]&gt;a[index2]) &#123; if(a[j]&gt;a[index1]) &#123; index2&#x3D;index1; index1&#x3D;j; &#125; else index2&#x3D;j; &#125; &#125; sum+&#x3D;(a[index1]+1)*(a[index2]+1); a[index1]+&#x3D;a[index2]; a[index2]&#x3D;-1; &#125; cout&lt;&lt;sum; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"贪心","slug":"ACM/贪心","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%B4%AA%E5%BF%83/"}],"tags":[{"name":"大数陷阱","slug":"大数陷阱","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%99%B7%E9%98%B1/"},{"name":"溢出陷阱","slug":"溢出陷阱","permalink":"https://donghuangzhong.github.io/tags/%E6%BA%A2%E5%87%BA%E9%99%B7%E9%98%B1/"}]},{"title":"算法训练 最大获利","slug":"算法训练-最大获利","date":"2020-03-30T03:52:59.000Z","updated":"2020-03-30T03:58:28.610Z","comments":true,"path":"2020/03/30/算法训练-最大获利/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E6%9C%80%E5%A4%A7%E8%8E%B7%E5%88%A9/","excerpt":"看数据规模，计算中会超过10的9次方，所以应该选择long long。","text":"看数据规模，计算中会超过10的9次方，所以应该选择long long。 题目算法训练 最大获利提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 Chakra是一位年轻有为的企业家，最近他在进军餐饮行业。他在各地开拓市场，共买下了N个饭店。在初期的市场调研中，他将一天划分为M个时间段，并且知道第i个饭店在第j个时间段内，会有Aij位服务员当值和Bij位客户光临。他还分析了不同饭店不同时间段客户的需求，得到第i个饭店在第j个时间段内，平均每位客户消费Cij元。为了创设品牌形象，Chakra决定每个饭店每天只选择一个时间段营业，每个服务员至多接待一位顾客（若顾客数多于服务员数，超过部分的顾客当天就无法在该店消费了）。 企业家的目的终究还是获利。请你安排营业时间，并告诉Chakra每天消费总额最多为多少。 输入格式 第一行两个整数，N、M。 第二行开始依次给出三个矩阵A(NM)、B(NM)、C(N*M)。 输出格式 一行一个整数，最大消费总额。 样例输入2 31 2 33 2 13 2 11 2 34 5 23 1 6 样例输出16 数据规模和约定 1 &lt;= M,N &lt;= 100 1 &lt;= Aij, Bij &lt;= 5000 0 &lt;= Cij &lt;= 10^9 算法根据一位服务员只能服务一名顾客可以计算出，顾客人数矩阵，然后在根据顾客平均消费矩阵计算出总额矩阵，每行选一个求和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;long long st[3][101][101];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input3.txt&quot;,&quot;r&quot;,stdin); int n,m; cin&gt;&gt;n&gt;&gt;m; _for(j,0,2) _for(i,1,n) _for(k,1,m) cin&gt;&gt;st[j][i][k]; _for(i,1,n) _for(k,1,m) if(st[0][i][k]&lt;st[1][i][k]) st[1][i][k]&#x3D;st[0][i][k]; _for(i,1,n) _for(k,1,m) st[2][i][k]*&#x3D;st[1][i][k]; long long sum&#x3D;0; _for(i,1,n) &#123; long long max&#x3D;-1; _for(j,1,m) &#123; if(st[2][i][j]&gt;max) max&#x3D;st[2][i][j]; &#125; sum+&#x3D;max; &#125; cout&lt;&lt;sum; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://donghuangzhong.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数据规模","slug":"数据规模","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1/"}]},{"title":"算法训练 乘法次数","slug":"算法训练-乘法次数","date":"2020-03-30T03:19:42.000Z","updated":"2020-03-30T03:30:49.993Z","comments":true,"path":"2020/03/30/算法训练-乘法次数/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E4%B9%98%E6%B3%95%E6%AC%A1%E6%95%B0/","excerpt":"已知x^n次方的情况下获取x^(2n)的最少途径就是x^n*x^n。要求x^n的最小乘法次数，就是不断的求x^2,x^4,x^8……，找到小于x^n的那个x^y次方(y是2的幂），这样就解决了大头，至于剩下的小头，在重复上述操作。其实就是基于二进制优化的快速幂！！","text":"已知x^n次方的情况下获取x^(2n)的最少途径就是x^n*x^n。要求x^n的最小乘法次数，就是不断的求x^2,x^4,x^8……，找到小于x^n的那个x^y次方(y是2的幂），这样就解决了大头，至于剩下的小头，在重复上述操作。其实就是基于二进制优化的快速幂！！ 题目算法训练 乘法次数提交此题 资源限制 时间限制：1.0s 内存限制：999.4MB 问题描述 给你一个非零整数，让你求这个数的n次方，每次相乘的结果可以在后面使用，求至少需要多少次乘。如24：22=22（第一次乘），2222=24（第二次乘），所以最少共2次； 输入格式 第一行m表示有m(1&lt;=m&lt;=100)组测试数据； 每一组测试数据有一整数n（0&lt;n&lt;=100000000）; 输出格式 输出每组测试数据所需次数s; 样例输入3234 样例输出122 题目大意在已知有一个数x的情况下，求x^n需要经过的最少的乘法次数。 算法123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,c; cin&gt;&gt;c; while(c--) &#123; cin&gt;&gt;n; int t&#x3D;n; int count_1&#x3D;0; while(t) &#123; bool wei&#x3D;t&amp;1; if(wei) count_1++; t&gt;&gt;&#x3D;1; &#125; int high_wei&#x3D;log(n)&#x2F;log(2); cout&lt;&lt;high_wei+count_1-1&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"快速幂","slug":"ACM/快速幂","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"tags":[{"name":"二进制优化","slug":"二进制优化","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"}]},{"title":"C++坑点","slug":"C-坑点","date":"2020-03-29T08:22:05.000Z","updated":"2020-03-29T08:22:05.302Z","comments":true,"path":"2020/03/29/C-坑点/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/29/C-%E5%9D%91%E7%82%B9/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"python爬虫爬取wallpapers壁纸","slug":"python爬虫爬取wallpapers壁纸","date":"2020-03-28T11:55:30.000Z","updated":"2020-03-28T11:58:01.004Z","comments":true,"path":"2020/03/28/python爬虫爬取wallpapers壁纸/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/28/python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96wallpapers%E5%A3%81%E7%BA%B8/","excerpt":"python爬虫爬取wallpapers最新壁纸","text":"python爬虫爬取wallpapers最新壁纸 详细教程请访问：https://www.bilibili.com/video/av58978561/详细教程请访问：https://www.bilibili.com/video/av58978561/123456789101112131415161718192021222324252627import requests #这个包里有打开网页的包from bs4 import BeautifulSoup #这个包里有html解析器def getimg(url,path,name):#将步骤3封装成函数 参数（图片网址，路径，名字） with requests.get(url) as resp:#打开图片 with open(path+'/'+name+'.jpg','wb') as f:#打开路径，准备写入图片 f.write(resp.content)#将图片以传进来的名字以wb(w:写入 b:二进制方式)写入路径def getdurl(url,l,w):#步骤2 参数（每一页的网址，图片长度，图片宽度） with requests.get(url) as resp:#打开网址 html=resp.text#获取html代码 soup=BeautifulSoup(html,'html.parser')#将代码用bs4进行解析 h1=soup.select('h1')#找到html代码中标签为h1（html中h1代表标题）的赋值给变量h1 这样我们就找到了所有图片的名字，但是还有一个网页的标题Latest Wallpapers for i in h1:#for循环 if i.text=='Latest Wallpapers': continue#去掉网页标题 n=i.text imgurl='http://wallpaperswide.com/download/'+n.replace(' ','_').lower()+'-'+str(l)+'x'+str(w) #拼接网址，将名字中空格换成下划线，所有字母换小写 # print(imgurl) print('正在下载'+n+'。。。')#提示信息 getimg(imgurl,'D:\\编程\\python\\wallpapers',n)#调用步骤三函数循环下载 print(n+'下载完成。。。')#提示信息 # url='http://wallpaperswide.com/download/Cyberpunk2077-800x480'if __name__=='__main__':#此程序作为主程序运行 for i in range(2):#外循环，从第一页循环至第十页，这里的10可以改成别的 getdurl('http://wallpaperswide.com/latest_wallpapers/page/'+str(i+1)+'.html',1366,768)#拼接网址调用步骤二函数","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"},{"name":"爬虫","slug":"python/爬虫","permalink":"https://donghuangzhong.github.io/categories/python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"wallpapers","slug":"wallpapers","permalink":"https://donghuangzhong.github.io/tags/wallpapers/"},{"name":"壁纸","slug":"壁纸","permalink":"https://donghuangzhong.github.io/tags/%E5%A3%81%E7%BA%B8/"}]},{"title":"蓝桥模拟_第十题_晚会节目单","slug":"蓝桥模拟-第十题-晚会节目单","date":"2020-03-27T10:20:44.000Z","updated":"2020-03-29T08:16:40.829Z","comments":true,"path":"2020/03/27/蓝桥模拟-第十题-晚会节目单/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/27/%E8%93%9D%E6%A1%A5%E6%A8%A1%E6%8B%9F-%E7%AC%AC%E5%8D%81%E9%A2%98-%E6%99%9A%E4%BC%9A%E8%8A%82%E7%9B%AE%E5%8D%95/","excerpt":"频繁的查询区间最值对于遍历来说开销非常大，所以产生了一种区间最值查询这种算法，本文只讲ST+RMQ，ST是稀疏矩阵的意思，这种方法要求数据必须是静态的不能变化的。","text":"频繁的查询区间最值对于遍历来说开销非常大，所以产生了一种区间最值查询这种算法，本文只讲ST+RMQ，ST是稀疏矩阵的意思，这种方法要求数据必须是静态的不能变化的。 问题引入有一个一位数组(长度为n)，频繁的查询[s,e]区间的最值。 算法详解定义一个二维数组ST(大小[n,lgn])。ST[i][j]表示的是从i开始(包括i)向后2^j个元素区间的最值，即区间[i,i+2^j-1]的最值，那么很明显ST[i][0]=a[i](因为[i,i]只有一个值)。现在我们开始推导递推式,[i,i+2^j-1]可以按照中间分为两个大小为2^(j-1)的区间[i,i+2^(j-1)-1]和[i+2^(j-1),i+2^j-1]，那么[i,i+2^j-1]的最值为这两个区间再求最值，即[i,i+2^j-1]=min/max([i,i+2^(j-1)-1],[i+2^(j-1),i+2^j-1])也就是： 1ST[i][j]&#x3D;min&#x2F;max(ST[i][j-1],ST[i+2^j][j-1]) 那么就可以发现第j列某个元素值的计算只跟它前一列的某两个值有关，并且刚刚我们已经算好了第一列，由第一列可以计算第二列，由第二列可以计算第三列……那么要算到哪一列呢？ST[i][j]表示的区间是[i,i+2^j-1]很明显i+2^j-1&lt;=n-1(n个元素，下标0~n-1)所以就有了建ST的模板： 123456789101112void cal(int a[],int n)&#123; for(int i&#x3D;0;i&lt;&#x3D;n-1;i++) ST[i][0]&#x3D;a[i]; for(int j&#x3D;1;(1&lt;&lt;(j))&lt;&#x3D;n;j++) &#123; for(int i&#x3D;0;i+(1&lt;&lt;j)-1&lt;&#x3D;n-1;i++) &#123; st[i][j]&#x3D;max&#x2F;min(st[i][j-1],st[i+1&lt;&lt;(j-1)][j-1]); &#125; &#125; &#125; 说了半天有了这个表该怎么用呢？假如我们要计算区间[s,e]的最值该怎么算呢？我们能够利用的是ST[此处可为任意数][此处必须为2的幂]如果我们能够找到一个k，使得区间[s,e]变成[s,s+2^k-1]和[s+2^k][e]，我们就可以利用表了，但是你会发现第二个区间没法表示，我们只能表示长度为2的幂的区间。于是聪明人就会发现用e减去2的幂不就行了！于是将[s,e]变成[s,s+2^k-1]和[e-2^k+1,e]，这样区间[s][e]的最值就可以变为min/max(ST[s][k],ST[e-2^K+1][e])但是可能有人又会提出疑问了，如果这两个集合没有交集怎么办？比如[2,6]分为[2,3]和[5,6] (k=1)，这样得到话明显不对啊！所以我们需要找一个比较大的k值，[s,s+2^k-1]必须包含在[s][e]里面,也就是s+2^k-1&lt;=e 解得$$k&lt;=log_2(e-s+1),令k=log_2(e-s+1)$$并且(int)k去除了k的小数部分，也就是说0&lt;=k-(int)k&lt;1，所以k-1&lt;(int)k&lt;=k，代入原式：$$2^{k-1}-1&lt;2^{(int)k}-1&lt;=2^k-1将k=log_2(e-s+1)代入得$$ $$(e-s)/2-1/2&lt;2^{(int)k}-1，此处2^{(int)k}-1是整数，所以(e-s)/2=&lt;2^{(int)k}-1$$ $$所以s+2^{(int)k}-1&gt;=s+(e-s)/2=(e+s)/2(中点)且e-2^k+1&lt;=e-(e+s)/2=(e+s)/2(中点)$$ 所以当k=(int)(log2(e-s+1))时，ST[s][k],ST[e-2^K+1][e]表示的区间一定有交集。所以要求[s,e]区间最值只需要计算min/max(ST[s][k],ST[e-2^K+1][e]),k=(int)(log2(e-s+1)) 例题第十题 晚会节目单题目【问题描述】小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。小明发现，观众对于晚会的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。 【输入格式】输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。第二行包含 n 个整数，依次为每个节目的好看值。 【输出格式】输出一行包含 m 个整数，为选出的节目的好看值。 【样例输入】5 33 1 2 5 4 【样例输出】3 5 4 【样例说明】选择了第1, 4, 5个节目。 【评测用例规模与约定】对于 30% 的评测用例，1 &lt;= n &lt;= 20；对于 60% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。 思路 O(N^2)ST+RMQ 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m;int a[100001];int tree[400001];int st[100001][20];int pow_2(int p) &#123; return 1 &lt;&lt; p;&#125;void cal(int a[],int n)&#123; for(int j&#x3D;1;(1&lt;&lt;(j-1))&lt;&#x3D;n;j++) &#123; for(int i&#x3D;0;i+(1&lt;&lt;j)-1&lt;&#x3D;n-1;i++) &#123; st[i][j]&#x3D;a[st[i][j-1]]&gt;a[st[i+pow_2(j-1)][j-1]]?st[i][j-1]:st[i+pow_2(j-1)][j-1]; &#125; &#125; &#125;int query(int s,int e)&#123; int t&#x3D;(int)(log(e-s+1)&#x2F;log(2)); return a[st[s][t]]&gt;a[st[e-(1&lt;&lt;t)+1][t]]?st[s][t]:st[e-(1&lt;&lt;t)+1][t];&#125; void build_tree(int s,int e,int node)&#123; if(s&#x3D;&#x3D;e) &#123; tree[node]&#x3D;s; return ; &#125; int mid&#x3D;(s+e)&#x2F;2; build_tree(s,mid,2*node+1); build_tree(mid+1,e,2*node+2); tree[node]&#x3D;a[tree[2*node+1]]&gt;a[tree[2*node+2]]?tree[2*node+1]:tree[2*node+2];&#125;int query_tree(int s,int e,int node,int l,int r)&#123; if(e&lt;l||s&gt;r) return 0; if(s&gt;&#x3D;l&amp;&amp;e&lt;&#x3D;r) return tree[node]; int mid&#x3D;(s+e)&#x2F;2; int ln&#x3D;query_tree(s,mid,2*node+1,l,r); int rn&#x3D;query_tree(mid+1,e,2*node+2,l,r); return a[ln]&gt;a[rn]?ln:rn;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; _for(i,0,n-1) &#123; cin&gt;&gt;a[i]; st[i][0]&#x3D;i; &#125; int c&#x3D;clock(); cal(a,n); int s&#x3D;0,k&#x3D;m; while(k!&#x3D;0) &#123; int z&#x3D;query(s,n-1-k+1); cout&lt;&lt;a[z]&lt;&lt;&quot; &quot;; s&#x3D;z+1; k--; &#125; P(&quot;&quot;); PP(&quot;time&#x3D;&quot;,clock()-c); c&#x3D;clock(); build_tree(0,n-1,0); cout&lt;&lt;&quot;tree:&quot;; s&#x3D;0;k&#x3D;m; while(k!&#x3D;0) &#123; int z&#x3D;query_tree(0,n-1,0,s,n-1-k+1); cout&lt;&lt;a[z]&lt;&lt;&quot; &quot;; s&#x3D;z+1; k--; &#125; cout&lt;&lt;endl&lt;&lt;&quot;time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"RMQ","slug":"ACM/RMQ","permalink":"https://donghuangzhong.github.io/categories/ACM/RMQ/"}],"tags":[{"name":"ST","slug":"ST","permalink":"https://donghuangzhong.github.io/tags/ST/"}]},{"title":"C++_string","slug":"C-STL","date":"2020-03-26T02:54:47.000Z","updated":"2020-04-04T08:40:41.759Z","comments":true,"path":"2020/03/26/C-STL/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/26/C-STL/","excerpt":"简要记录C家族有效方法","text":"简要记录C家族有效方法 字符串strlen()返回的是’\\0’的位置加1 sprintfsprintf(char a[],”%d”,10) 各种形式转换成字符数组，可以string str(a)转换成string,然后用string的方法 123char s[5];sprintf(s, &quot;%d&quot;, i);string str(s); stringstr.find()找字符参数:(字符，起点下标(缺省0)) 找字符串参数：(字符串，起点坐标(缺省0)，找字符串的前n个字符串(缺省)) 12345string s&#x3D;&quot;helollo&quot;;cout&lt;&lt;s.find(&#39;l&#39;,3)&lt;&lt;endl;cout&lt;&lt;s.find(&quot;ll&quot;,0,1)&lt;&lt;endl;&#x2F;&#x2F;4&#x2F;&#x2F;2 str.find_first_of宏定义#的用法有时候我们想在打印变量前标明一下变量名字，如果一个一个手打非常的不方便，于是我们可以用宏定义中的#代表加引号的变量 123#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endlprint(s.find(&#39;l&#39;,3));&#x2F;&#x2F;s.find(&#39;l&#39;,3)&#x3D;4 二分查找upper_bound lower_bound123456bool cmp(int a,int b) &#123;return a&gt;b&#125;;int a[];查找区间[a,a+len+1)upper_bound(a,a+len+1,x) &#x2F;&#x2F;默认升序 第一个大于x的地址lower_bound(a,a+len+1,x) &#x2F;&#x2F;默认升序 第一个大于等于x的地址upper_bound(a,a+len+1,x,cmp) &#x2F;&#x2F;降序 第一个小于x的地址lower_bound(a,a+len+1,x,cmp) &#x2F;&#x2F;降序 第一个小于等于x的地址","categories":[{"name":"tools","slug":"tools","permalink":"https://donghuangzhong.github.io/categories/tools/"},{"name":"C++","slug":"tools/C","permalink":"https://donghuangzhong.github.io/categories/tools/C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://donghuangzhong.github.io/tags/STL/"}]},{"title":"蓝桥杯2020三月模拟赛解题报告","slug":"蓝桥杯2020三月模拟赛解题报告","date":"2020-03-26T02:33:02.000Z","updated":"2020-03-29T08:16:50.738Z","comments":true,"path":"2020/03/26/蓝桥杯2020三月模拟赛解题报告/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/26/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E4%B8%89%E6%9C%88%E6%A8%A1%E6%8B%9F%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"摘要","text":"摘要 第一题 单位变换题目【问题描述】在计算机存储中，15.125GB是多少MB？ 【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 思路1G=1024M 答案15488 第二题 约数个数题目【问题描述】1200000有多少个约数（只计算正约数）。 【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 思路枚举+检查 参考代码123456789101112131415161718#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input2.txt&quot;,&quot;r&quot;,stdin); int i&#x3D;1200000,sum&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;i;j++) &#123; if(i%j&#x3D;&#x3D;0) sum++; &#125; cout&lt;&lt;sum; return 0;&#125; 答案96 第三题 叶结点数题目【问题描述】一棵包含有2019个结点的二叉树，最多包含多少个叶结点？ 【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 思路ni为出度为i的节点，二叉树只有三种节点，出度为0,1,2的三种。并且有下面的关系 n=n0+n1+n2 n0=n2+1 证明法1：n个节点的二叉树共有n-1条边，n-1=2*n2+n1,带入1式得：n0=n2+1 证明法2:n0为叶子节点的个数，每两个叶子节点经过一次合并产生一个n2，得到一个新的叶子节点，也就是说每两个叶子节点经过一次合并减少一个叶子节点，产生一个n2。所以需要n-1次合并产生n-1个n2得到根节点，所以n0=n2+1 为使叶子节点数（n0）最多，必须n1最小，设为0，而n0=n2+1，得n2=(2019-1)/2=1009所以n0=1010 答案1010 第四题 数字9题目【问题描述】在1至2019中，有多少个数的数位中包含数字9？注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算时只是算一个数。 【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 思路两个方法 (1)分别计算各个位上的数字然后判断 (2)字符串 伪代码123for i from 9 to 2019 if str(i).contains(&#39;9&#39;) ans++ 参考代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;time.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;bool check(int i) &#123; char s[5]; sprintf(s, &quot;%d&quot;, i); string str(s); return str.find(&#39;9&#39;) !&#x3D; string::npos;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input2.txt&quot;,&quot;r&quot;,stdin); int n&#x3D;2019,sum&#x3D;0; int a&#x3D;clock(); for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; int g&#x3D;j%10; int s&#x3D;(j&#x2F;10)%10; int b&#x3D;(j&#x2F;100)%10; int q&#x3D;(j&#x2F;1000)%10; if(g&#x3D;&#x3D;9||s&#x3D;&#x3D;9||b&#x3D;&#x3D;9||q&#x3D;&#x3D;9) sum++; &#x2F;&#x2F;cout&lt;&lt;q&lt;&lt;b&lt;&lt;s&lt;&lt;g&lt;&lt;endl; &#125; cout&lt;&lt;sum&lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-a&lt;&lt;endl; a&#x3D;clock(); sum&#x3D;0;char s[10]; for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123; sprintf(s,&quot;%d&quot;,i); string str(s);; if(str.find(&#39;9&#39;)!&#x3D;string::npos) sum++; &#125; cout &lt;&lt; sum &lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-a&lt;&lt;endl; return 0; &#125; 答案544 第五题 数位递增的数题目【问题描述】一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？ 【输入格式】输入的第一行包含一个整数 n。 【输出格式】输出一行包含一个整数，表示答案。 【样例输入】30 【样例输出】26【评测用例规模与约定】对于 40% 的评测用例，1 &lt;= n &lt;= 1000。对于 80% 的评测用例，1 &lt;= n &lt;= 100000。对于所有评测用例，1 &lt;= n &lt;= 1000000。 思路 O(kN)两个方法 (1)计算每一位，判断 (2)迭代1~n 转换为字符串 迭代字符串的每一位，判断是否满足要求 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;time.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input2.txt&quot;,&quot;r&quot;,stdin); int n,sum&#x3D;0; cin&gt;&gt;n; int c&#x3D;clock(); for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int t&#x3D;i,lwei&#x3D;10,j; for(j&#x3D;1;j&lt;&#x3D;7;j++) &#123; int wei&#x3D;t%10; t&#x2F;&#x3D;10; if(wei&gt;lwei) break; lwei&#x3D;wei; &#125; if(j&gt;7) sum++; &#125; cout&lt;&lt;sum&lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-c&lt;&lt;endl; sum&#x3D;0; c&#x3D;clock(); char a[7]; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int j; sprintf(a,&quot;%d&quot;,i); for(j&#x3D;1;j&lt;strlen(a);j++) if(a[j-1]&gt;a[j]) break; if(j&#x3D;&#x3D;strlen(a)) sum++; &#125; cout&lt;&lt;sum&lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0; &#125; 第六题 递增三元组题目【问题描述】在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。 【输入格式】输入的第一行包含一个整数 n。第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。 【输出格式】输出一行包含一个整数，表示答案。 【样例输入】51 2 5 3 5 【样例输出】2 【样例说明】a[2] 和 a[4] 可能是三元组的中心。 【评测用例规模与约定】对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。 思路 O(N^2)枚举每个元素 该元素与前面的元素比较，找到小的即可 该元素与后面的元素比较，找到大的即可 上面两项为真，即说明当前元素可以作为三元组的中心O(N^2)，因为N最大为1000，所以1秒内可以解决战斗。 参考代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;time.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,sum&#x3D;0,a[10000],j,k; cin&gt;&gt;n; for(int i&#x3D;0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; int c&#x3D;clock(); for(int i&#x3D;1;i&lt;&#x3D;n-2;i++) &#123; for(j&#x3D;0;j&lt;i;j++) &#123; if(a[j]&lt;a[i]) break; &#125; if(j&#x3D;&#x3D;i) continue; for(k&#x3D;i+1;k&lt;n;k++) &#123; if(a[i]&lt;a[k]) break; &#125; if(k&#x3D;&#x3D;n) continue; sum++; &#125; cout&lt;&lt;sum&lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-c; return 0;&#125; 第七题 音节判断题目【问题描述】小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。 【输入格式】输入一行，包含一个单词，单词中只包含小写英文字母。 【输出格式】输出答案，或者为yes，或者为no。 【样例输入】lanqiao 【样例输出】yes 【样例输入】world 【样例输出】no 【评测用例规模与约定】对于所有评测用例，单词中的字母个数不超过100。 思路三个方法 (1)遍历字符串，如果是辅音就设y(bool)为0，直到找到元音，记录下标，继续遍历，找到第二个元音，然后判断第一个元音的下标是不是0，必须非0并且第二个元音之后的都是辅音 (2)逻辑和:遍历字符串，计算(judge(s[i])+judge(s[i+1]))==1的次数，如果最后次数==3，说明合题意 (3)字符串现成的方法 找到第一个元音的下标index1，必须大于0，且能找到沿着index1继续找下一个非元音得到index2，必须能找到沿着index2继续找下一个元音得到index3，必须能找到最后判断index3-1位置的字符应该是从后往前第一个非元音（因为index3及以后的字符都必须是元音了） 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&#x2F;&#x2F;qwrtypsdfghjklzxcvbnmaeiouuoieamnbvcxzlkjhgfdspytrwqaaeeiioouu&#x2F;&#x2F;yes time&#x3D;0&#x2F;&#x2F;yes time&#x3D;0&#x2F;&#x2F;yes time&#x3D;0#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;time.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;bool judge(char c)&#123; if(c&#x3D;&#x3D;&#39;a&#39;||c&#x3D;&#x3D;&#39;e&#39;||c&#x3D;&#x3D;&#39;i&#39;||c&#x3D;&#x3D;&#39;o&#39;||c&#x3D;&#x3D;&#39;u&#39;) return 1; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); string s; int index[2]; int in&#x3D;0,sum&#x3D;0,k; bool y&#x3D;0,flag&#x3D;0; cin&gt;&gt;s; int c&#x3D;clock(); for(int i&#x3D;0;i&lt;s.length();i++) &#123; if(judge(s[i])) &#123; if(y&#x3D;&#x3D;0) &#123; y&#x3D;1; index[in++]&#x3D;i; if(in&#x3D;&#x3D;2) &#123; if(index[0]&#x3D;&#x3D;0) &#123; flag&#x3D;0; break; &#125; for(k&#x3D;index[1];k&lt;s.length();k++) &#123; if(!judge(s[k])) &#123; flag&#x3D;0; break; &#125; &#125; if(k&#x3D;&#x3D;s.length()) flag&#x3D;1; else break; &#125; &#125; else continue; &#125; else y&#x3D;0; &#125; if(flag) cout&lt;&lt;&quot;yes&quot;; else cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; c&#x3D;clock(); int jiao&#x3D;0; for(int i&#x3D;0;i&lt;s.length()-1;i++) &#123; if((judge(s[i])+judge(s[i+1]))&#x3D;&#x3D;1) jiao++; &#125; if(jiao&#x3D;&#x3D;3) cout&lt;&lt;&quot;yes&quot;; else cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; c&#x3D;clock(); int index1&#x3D;s.find_first_of(&quot;aeiou&quot;); if(!index1||index1&#x3D;&#x3D;string::npos) &#123; cout&lt;&lt;&quot;no&quot;; return 0; &#125; int index2&#x3D;s.find_first_not_of(&quot;aeiou&quot;,index1+1); if(index2&#x3D;&#x3D;string::npos) &#123; cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0; &#125; int index3&#x3D;s.find_first_of(&quot;aeiou&quot;,index2+1); if(index3&#x3D;&#x3D;string::npos) &#123; cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0; &#125; int index4&#x3D;s.find_last_not_of(&quot;aeiou&quot;); if(index4!&#x3D;index3-1) &#123; cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0; &#125; cout&lt;&lt;&quot;yes&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0;&#125; 第八题 长草题目【问题描述】小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。请告诉小明，k 个月后空地上哪些地方有草。 【输入格式】输入的第一行包含两个整数 n, m。接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。接下来包含一个整数 k。 【输出格式】输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。 【样例输入】4 5.g……....g..…..2 【样例输出】gggg.gggg.ggggg.ggg. 【评测用例规模与约定】对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= k &lt;= 1000。 思路 O(N*M)(1)dfs有可能会超时 (2)典型的多入口bfs，基本是个模板题。时间复杂度最多为O(N*M)。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;cstdio&gt;#include&lt;time.h&gt;#include&lt;memory&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;struct Point&#123; int x,y,kk;&#125;;char map[1010][1010],save[1010][1010];int m,n,k;queue&lt;Point&gt; q; int dir[4][2]&#x3D;&#123;0,1,0,-1,1,0,-1,0&#125;;void manyan(int x,int y)&#123; for(int i&#x3D;0;i&lt;4;i++) &#123; int xx&#x3D;x+dir[i][0]; int yy&#x3D;y+dir[i][1]; if(xx&gt;&#x3D;0&amp;&amp;xx&lt;m&amp;&amp;yy&gt;&#x3D;0&amp;&amp;yy&lt;n) &#123; if(map[xx][yy]&#x3D;&#x3D;&#39;.&#39;) map[xx][yy]&#x3D;&#39;d&#39;; &#125; &#125;&#125;void bfs()&#123; Point a,b; while(!q.empty()) &#123; a&#x3D;q.front(); if(a.kk&#x3D;&#x3D;k) return ; q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(b.x&gt;&#x3D;0&amp;&amp;b.x&lt;m&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;n&amp;&amp;map[b.x][b.y]&#x3D;&#x3D;&#39;.&#39;) &#123; b.kk&#x3D;a.kk+1; map[b.x][b.y]&#x3D;&#39;g&#39;; q.push(b); &#125; &#125; &#125;&#125;void show(char map[1010][1010])&#123; for(int i&#x3D;0;i&lt;m;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; cout&lt;&lt;map[i][j]; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;m&gt;&gt;n; for(int i&#x3D;0;i&lt;m;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]&#x3D;&#x3D;&#39;g&#39;) q.push(&#123;i,j,0&#125;); &#125; &#125; memcpy(save,map,sizeof(map)); cin&gt;&gt;k; int c&#x3D;clock(); bfs(); cout&lt;&lt;&quot;time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; show(map); memcpy(map,save,sizeof(map)); c&#x3D;clock(); for(int i&#x3D;0;i&lt;k;i++) &#123; for(int ii&#x3D;0;ii&lt;m;ii++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; if(map[ii][j]&#x3D;&#x3D;&#39;g&#39;) manyan(ii,j); &#125; &#125; for(int ii&#x3D;0;ii&lt;m;ii++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; if(map[ii][j]&#x3D;&#x3D;&#39;d&#39;) map[ii][j]&#x3D;&#39;g&#39;; &#125; &#125; &#125; cout&lt;&lt;&quot;time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; show(map); return 0;&#125; 第九题 序列计数题目【问题描述】小明想知道，满足以下条件的正整数序列的数量： 第一项为 n； 第二项不超过 n； 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。 【输入格式】输入一行包含一个整数 n。 【输出格式】输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。 【样例输入】4 【样例输出】7 【样例说明】以下是满足条件的序列：4 14 1 14 1 24 24 2 14 34 4 【评测用例规模与约定】对于 20% 的评测用例，1 &lt;= n &lt;= 5；对于 50% 的评测用例，1 &lt;= n &lt;= 10；对于 80% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 1000。 思路：void dfs1(当前选择的点，下一次选择的范围)正向思维，注意这里每次都可以选择不向下找了，将后面补0，直接递归看做结束的条件(严重超时) int dfs2(上上一个选择的数字,上一个选择的数据)逆向思维，和第一个半斤八两，初始化为1是因为本身就是一种情况 记忆性递归(O(n^3)) 参数和第二个相同从第一、二种中可以看出有可能重复，所以加上一个矩阵记录 递归优化dfs4(i,j) 表示前一个点是i,后一个点是[1,j]这些可能性的总和，显然dfs4(i,j)=dfs4(i,j-1)+1+dfs4(j,|i-j|)，为什么要加1？问的好，因为1表示的是(i,j(后面没有了))这一种情况 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int mem[1001][1001],sum;void dfs1(int aa,int jue)&#123; if(aa&#x3D;&#x3D;0) &#123; sum++; return ; &#125; dfs1(0,aa); _for(i,1,jue-1) &#123; int t&#x3D;(aa&gt;&#x3D;i)?(aa-i):(i-aa); dfs1(i,t); &#125;&#125;int dfs2(int a,int b)&#123; int t&#x3D;(a&gt;&#x3D;b?(a-b):(b-a)); int ans&#x3D;1; _for(i,1,t-1) ans+&#x3D;dfs2(b,i); return ans%10000; &#125;int dfs3(int a,int b)&#123; if(mem[a][b]) return mem[a][b]; int cha&#x3D;a&gt;&#x3D;b?(a-b):(b-a); int ans&#x3D;1; _for(i,1,cha-1) ans+&#x3D;dfs3(b,i); ans%&#x3D;10000; mem[a][b]&#x3D;ans; return ans;&#125; int dfs4(int a,int b)&#123; if(b&lt;&#x3D;0) return 0; if(mem[a][b]) return mem[a][b]; int t&#x3D;(a&gt;&#x3D;b?(a-b):(b-a)); return mem[a][b]&#x3D;(dfs4(a,b-1)+1+dfs4(b,t-1))%10000;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; int c&#x3D;clock(); sum&#x3D;0; _for(j,1,n) dfs1(j,n-j); P(sum%10000); PP(&quot;time&quot;,clock()-c); c&#x3D;clock(); sum&#x3D;0; _for(i,1,n) sum+&#x3D;dfs2(n,i); P(sum%10000); PP(&quot;time&quot;,clock()-c); c&#x3D;clock(); sum&#x3D;0; _for(i,1,n) sum+&#x3D;dfs3(n,i); P(sum%10000); PP(&quot;time&quot;,clock()-c); memset(mem,0,sizeof(mem)); c&#x3D;clock(); P(dfs4(n,n)); PP(&quot;time&quot;,clock()-c); return 0;&#125; 第十题 晚会节目单题目【问题描述】小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。小明发现，观众对于晚会的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。 【输入格式】输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。第二行包含 n 个整数，依次为每个节目的好看值。 【输出格式】输出一行包含 m 个整数，为选出的节目的好看值。 【样例输入】5 33 1 2 5 4 【样例输出】3 5 4 【样例说明】选择了第1, 4, 5个节目。 【评测用例规模与约定】对于 30% 的评测用例，1 &lt;= n &lt;= 20；对于 60% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。 错误思路如果用两次排序求解，那就错了。因为并不是要选出的方案的好看值总和最大，而是要从前往后尽量好看。即选出的M个数字典序最大 思路 O(N^2)ST+RMQ 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m;int a[100001];int tree[400001];int st[100001][20];int pow_2(int p) &#123; return 1 &lt;&lt; p;&#125;void cal(int a[],int n)&#123; for(int j&#x3D;1;(1&lt;&lt;(j-1))&lt;&#x3D;n;j++) &#123; for(int i&#x3D;0;i+(1&lt;&lt;j)-1&lt;&#x3D;n-1;i++) &#123; st[i][j]&#x3D;a[st[i][j-1]]&gt;a[st[i+pow_2(j-1)][j-1]]?st[i][j-1]:st[i+pow_2(j-1)][j-1]; &#125; &#125; &#125;int query(int s,int e)&#123; int t&#x3D;(int)(log(e-s+1)&#x2F;log(2)); return a[st[s][t]]&gt;a[st[e-(1&lt;&lt;t)+1][t]]?st[s][t]:st[e-(1&lt;&lt;t)+1][t];&#125; void build_tree(int s,int e,int node)&#123; if(s&#x3D;&#x3D;e) &#123; tree[node]&#x3D;s; return ; &#125; int mid&#x3D;(s+e)&#x2F;2; build_tree(s,mid,2*node+1); build_tree(mid+1,e,2*node+2); tree[node]&#x3D;a[tree[2*node+1]]&gt;a[tree[2*node+2]]?tree[2*node+1]:tree[2*node+2];&#125;int query_tree(int s,int e,int node,int l,int r)&#123; if(e&lt;l||s&gt;r) return 0; if(s&gt;&#x3D;l&amp;&amp;e&lt;&#x3D;r) return tree[node]; int mid&#x3D;(s+e)&#x2F;2; int ln&#x3D;query_tree(s,mid,2*node+1,l,r); int rn&#x3D;query_tree(mid+1,e,2*node+2,l,r); return a[ln]&gt;a[rn]?ln:rn;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; _for(i,0,n-1) &#123; cin&gt;&gt;a[i]; st[i][0]&#x3D;i; &#125; int c&#x3D;clock(); cal(a,n); int s&#x3D;0,k&#x3D;m; while(k!&#x3D;0) &#123; int z&#x3D;query(s,n-1-k+1); cout&lt;&lt;a[z]&lt;&lt;&quot; &quot;; s&#x3D;z+1; k--; &#125; P(&quot;&quot;); PP(&quot;time&#x3D;&quot;,clock()-c); c&#x3D;clock(); build_tree(0,n-1,0); cout&lt;&lt;&quot;tree:&quot;; s&#x3D;0;k&#x3D;m; while(k!&#x3D;0) &#123; int z&#x3D;query_tree(0,n-1,0,s,n-1-k+1); cout&lt;&lt;a[z]&lt;&lt;&quot; &quot;; s&#x3D;z+1; k--; &#125; cout&lt;&lt;endl&lt;&lt;&quot;time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"解题报告","slug":"ACM/解题报告","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"蓝桥杯2020模拟赛","slug":"蓝桥杯2020模拟赛","permalink":"https://donghuangzhong.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}]},{"title":"UVA-1052-算法训练-Bit Compressor","slug":"UVA-1052-算法训练-Bit-Compressor","date":"2020-03-25T08:23:34.000Z","updated":"2020-03-26T02:19:58.169Z","comments":true,"path":"2020/03/25/UVA-1052-算法训练-Bit-Compressor/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/25/UVA-1052-%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-Bit-Compressor/","excerpt":"dfs奥义:不确定性即可能性！并且有时候可能性可以没有顺序！本文的不确定性在于对于前面有1的0，不确定是分隔符还是二进制中的一部分。这就是不确定性，也就是可能性。本程序还利用了二进制的动态计算。","text":"dfs奥义:不确定性即可能性！并且有时候可能性可以没有顺序！本文的不确定性在于对于前面有1的0，不确定是分隔符还是二进制中的一部分。这就是不确定性，也就是可能性。本程序还利用了二进制的动态计算。 试题 算法训练 Bit Compressor提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 数据压缩的目的是为了减少存储和交换数据时出现的冗余。这增加了有效数据的比重并提高了传输速率。有一种压缩二进制串的方法是这样的： 将连续的n个1替换为n的二进制表示（注：替换发生当且仅当这种替换减少了二进制串的总长度） （译者注：连续的n个1的左右必须是0或者是串的开头、结尾） 比如：11111111001001111111111111110011会被压缩成10000010011110011。原串长为32,被压缩后串长为17. 这种方法的弊端在于，有时候解压缩算法会得到不止一个可能的原串，使得我们无法确定原串究竟是什么。请你写一个程序来判定我们能否利用压缩后的信息来确定原串。给出原串长L，原串中1的个数N，以及压缩后的串。 L&lt;=16 Kbytes，压缩后的串长度&lt;=40 bits。 输入格式 第一行两个整数L,N，含义同问题描述 第二行一个二进制串，表示压缩后的串 输出格式 输出”YES”或”NO”或”NOT UNIQUE”（不包含引号） 分别表示： YES：原串唯一 NO：原串不存在 NOT UNIQUE：原串存在但不唯一 样例输入样例1：32 2610000010011110011样例2：9 71010101样例3：14 14111111 样例输出样例1：YES样例2：NOT UNIQUE样例3：NO 算法先说二进制的动态计算，你可能会说我还不会二进制转十进制吗？例如1101，分别计算1,11,110,1101。每一个的前面都是重复的，我们可以用到前面的计算结果，这样可以避免重复计算，提高效率。 dfs参数(要处理的位置下标，已经处理的原串中的字符个数，已经处理的原串中的1的个数)。后两个参数是为了剪枝的。如果碰到前面没有1的0直接跳过，因为肯定是原串中的0，对于每个前面有1的0我们提供两种选择，一是作为原串中的0(把前面的反编码成二进制个1)，二是作为二进制中的0。但是这样会出现一个棘手的问题，一是10不能反编码回去，因为反编码得到11，长度都是2，不合题意，你可能说1也不能反编码回去，但是1无论是反编码还是不反编码得到的都是一样的结果，既然这样为什么还认为1不能反编码增加额外代码量呢？也就是说原串中的11是不能编码成10的，所以编码后的串中如果出现11不能确定是原串中的是11还是111，也就是说按照碰到前面有1的0就提供两种可能性的策略，对于10不能进去，对于11少算了一个。对于少算的可以额外增加，因为可能性的顺序没关系。但是对于多算的我们要加条件过滤。于是代码就产生了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;#define maxn 50int n,m; string s;int answer&#x3D;0; void dfs(int pos,int len,int len_1)&#123; if(pos&#x3D;&#x3D;s.length()&amp;&amp;len&#x3D;&#x3D;n&amp;&amp;len_1&#x3D;&#x3D;m) &#123; answer++; return ; &#125; if(pos&gt;&#x3D;s.length()||len&gt;n||len_1&gt;m) return ; if(s[pos]&#x3D;&#x3D;&#39;0&#39;) &#123; dfs(pos+1,len+1,len_1); return ; &#125; int t&#x3D;0; for(int i&#x3D;pos;i&lt;s.length();i++) &#123; t*&#x3D;2; t+&#x3D;s[i]-&#39;0&#39;; if(len_1+t&gt;m||len+t&gt;n) break; if(s[i+1]!&#x3D;&#39;1&#39;&amp;&amp;(t!&#x3D;2)) dfs(i+1,len+t,len_1+t); &#125; if(s[pos+1]&#x3D;&#x3D;&#39;1&#39;&amp;&amp;s[pos+2]!&#x3D;&#39;1&#39;) dfs(pos+2,len+2,len_1+2);&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int e&#x3D;1; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n)&#123; answer&#x3D;0; cin&gt;&gt;s; dfs(0,0,0); printf(&quot;Case #%d: &quot;,e++); if(answer&#x3D;&#x3D;0) printf(&quot;NO\\n&quot;); else if(answer&#x3D;&#x3D;1) printf(&quot;YES\\n&quot;); else printf(&quot;NOT UNIQUE\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"高级dfs","slug":"ACM/高级dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%AB%98%E7%BA%A7dfs/"}],"tags":[{"name":"编码","slug":"编码","permalink":"https://donghuangzhong.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"动态二进制","slug":"动态二进制","permalink":"https://donghuangzhong.github.io/tags/%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"算法训练 cNteSahruPfefrlefe","slug":"算法训练-cNteSahruPfefrlefe","date":"2020-03-20T09:09:31.000Z","updated":"2020-03-20T09:09:31.642Z","comments":true,"path":"2020/03/20/算法训练-cNteSahruPfefrlefe/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/20/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-cNteSahruPfefrlefe/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"算法训练 Sticks","slug":"算法训练-Sticks","date":"2020-03-18T11:08:24.000Z","updated":"2020-03-18T11:38:23.496Z","comments":true,"path":"2020/03/18/算法训练-Sticks/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/18/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-Sticks/","excerpt":"还记得dfs的入门题吗？输入n个数和一个结果m,问这n个数能不能组合成m。这个题就是在能凑成m的基础上再从头开始搜索，注意不能运行多次dfs，而是要递归调用，因为不能确定找到一个m就是其中的一个m，有可能不合法。dfs的代码风格有两种，一种是正序，一种是倒序","text":"还记得dfs的入门题吗？输入n个数和一个结果m,问这n个数能不能组合成m。这个题就是在能凑成m的基础上再从头开始搜索，注意不能运行多次dfs，而是要递归调用，因为不能确定找到一个m就是其中的一个m，有可能不合法。dfs的代码风格有两种，一种是正序，一种是倒序 问题试题 算法训练 Sticks提交此题 资源限制 时间限制：1.0s 内存限制：999.4MB Sticks Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 113547 Accepted: 26078 问题描述 George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero. 输入格式 The input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the file contains zero. 输出格式 The output should contains the smallest possible length of original sticks, one per line. 样例输入95 2 1 5 2 1 5 2 141 2 3 40 样例输出56 题目大意多个测试用例，第一行输入木棒的个数n，下一行输入n个数代表不同木棒的长度，这些木棒可以组成m个长度为k的长木棒，输出k的最小值","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dfs","slug":"ACM/dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/dfs/"}],"tags":[{"name":"高级dfs","slug":"高级dfs","permalink":"https://donghuangzhong.github.io/tags/%E9%AB%98%E7%BA%A7dfs/"}]},{"title":"基础练习 字符串对比","slug":"基础练习-字符串对比","date":"2020-03-14T10:12:05.000Z","updated":"2020-03-14T10:18:28.577Z","comments":true,"path":"2020/03/14/基础练习-字符串对比/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E6%AF%94/","excerpt":"首先1很好判断，并且1和234对立(一组if else)，再看2，需要全部对比完才能；而34只要一个不满足就可以输出，所以34的判断在2的前面，根据题目逻辑，4要在三的前面。于是逻辑就清楚了。","text":"首先1很好判断，并且1和234对立(一组if else)，再看2，需要全部对比完才能；而34只要一个不满足就可以输出，所以34的判断在2的前面，根据题目逻辑，4要在三的前面。于是逻辑就清楚了。 问题试题 基础练习 字符串对比提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4中情况之一： 1：两个字符串长度不等。比如 Beijing 和 Hebei 2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如 Beijing 和 Beijing 3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如 beijing 和 BEIjing 4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing 编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。 输入格式 包括两行，每行都是一个字符串 输出格式 仅有一个数字，表明这两个字符串的关系编号 样例输入BEIjing 1beiJing 样例输出3 算法12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); char a[10],b[10]; cin&gt;&gt;a&gt;&gt;b; if(strlen(a)!&#x3D;strlen(b)) cout&lt;&lt;&quot;1&quot;; else&#123; for(int i&#x3D;0;i&lt;strlen(a);i++) &#123; int t&#x3D;a[i]-b[i]; if(!(t&#x3D;&#x3D;32||t&#x3D;&#x3D;-32||t&#x3D;&#x3D;0)) &#123;cout&lt;&lt;&quot;4&quot;;return 0; &#125; else if(t!&#x3D;0) &#123; cout&lt;&lt;&quot;3&quot;; return 0; &#125; &#125; cout&lt;&lt;&quot;2&quot;; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"判断条件的先后","slug":"判断条件的先后","permalink":"https://donghuangzhong.github.io/tags/%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%88%E5%90%8E/"}]},{"title":"基础练习 完美的代价","slug":"基础练习-完美的代价","date":"2020-03-14T09:59:56.000Z","updated":"2020-03-14T10:11:24.635Z","comments":true,"path":"2020/03/14/基础练习-完美的代价/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7/","excerpt":"注意交换方式是相邻互换，每次处理的范围都是[i,j]，k=j,k&gt;=i,k–。从j往前找和i一样的字符，找到了就k,j交换，记录交换次数，j–,i++；找不到则判断总数奇偶，偶则直接输出不可能，奇则做一个标记(因为总数是奇数可以允许一个字符不成对，但这个字符必须在中间)，然后记录将i移动到中间的步数(注意只是记录而不移动，因为移动了也会被再次打乱)，i++，继续从下一个找,如果有遇到一个找不到的，直接输出不可能","text":"注意交换方式是相邻互换，每次处理的范围都是[i,j]，k=j,k&gt;=i,k–。从j往前找和i一样的字符，找到了就k,j交换，记录交换次数，j–,i++；找不到则判断总数奇偶，偶则直接输出不可能，奇则做一个标记(因为总数是奇数可以允许一个字符不成对，但这个字符必须在中间)，然后记录将i移动到中间的步数(注意只是记录而不移动，因为移动了也会被再次打乱)，i++，继续从下一个找,如果有遇到一个找不到的，直接输出不可能 问题试题 基础练习 完美的代价提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。 交换的定义是：交换两个相邻的字符 例如mamad 第一次交换 ad : mamda 第二次交换 md : madma 第三次交换 ma : madam (回文！完美！) 输入格式 第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000) 第二行是一个字符串，长度为N.只包含小写字母 输出格式 如果可能，输出最少的交换次数。 否则输出Impossible 样例输入5mamad 样例输出3 算法1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n; char s[8001]; cin&gt;&gt;n&gt;&gt;s; int j&#x3D;n-1,sum&#x3D;0; bool flag&#x3D;0; for(int i&#x3D;0;i&lt;&#x3D;j;i++) &#123; for(int k&#x3D;j;k&gt;&#x3D;i;k--) &#123; if(i&#x3D;&#x3D;k) &#123; if(flag||(n&amp;1)&#x3D;&#x3D;0) &#123; cout &lt;&lt; &quot;Impossible&quot;; return 0; &#125; flag&#x3D;1; sum+&#x3D;n&#x2F;2-i; &#125; else if(s[i]&#x3D;&#x3D;s[k]) &#123; for(int i&#x3D;k;i&lt;&#x3D;j-1;i++) &#123; swap(s[i],s[i+1]); sum++; &#125; j--; break; &#125; &#125; &#125; cout&lt;&lt;sum;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"回文","slug":"ACM/回文","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%9B%9E%E6%96%87/"}],"tags":[{"name":"移动成回文最短","slug":"移动成回文最短","permalink":"https://donghuangzhong.github.io/tags/%E7%A7%BB%E5%8A%A8%E6%88%90%E5%9B%9E%E6%96%87%E6%9C%80%E7%9F%AD/"}]},{"title":"基础练习 数的读法","slug":"基础练习-数的读法","date":"2020-03-14T09:21:46.000Z","updated":"2020-03-14T09:59:32.837Z","comments":true,"path":"2020/03/14/基础练习-数的读法/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E6%95%B0%E7%9A%84%E8%AF%BB%E6%B3%95/","excerpt":"先看题目的规模，最大到十亿的单位。中文的数字单位有个特点，个十百千一组，万一组，亿一组。也就是读一个数先读亿前面的个十百千读法，然后加上亿，然后再读亿到万的个十百千读法，然后再读万，然后再读个十百千。比如12 3456 7890，先读亿前面的数字，十二，然后加上亿，在读亿和万之间的数字，三千四百五十六，然后加上万，然后读七千八百九十，最终读十二亿三千四百五十六万七千八百九十。还有一些其他的一些细节。","text":"先看题目的规模，最大到十亿的单位。中文的数字单位有个特点，个十百千一组，万一组，亿一组。也就是读一个数先读亿前面的个十百千读法，然后加上亿，然后再读亿到万的个十百千读法，然后再读万，然后再读个十百千。比如12 3456 7890，先读亿前面的数字，十二，然后加上亿，在读亿和万之间的数字，三千四百五十六，然后加上万，然后读七千八百九十，最终读十二亿三千四百五十六万七千八百九十。还有一些其他的一些细节。 问题试题 基础练习 数的读法提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 Tom教授正在给研究生讲授一门关于基因的课程，有一件事情让他颇为头疼：一条染色体上有成千上万个碱基对，它们从0开始编号，到几百万，几千万，甚至上亿。 比如说，在对学生讲解第1234567009号位置上的碱基时，光看着数字是很难准确的念出来的。 所以，他迫切地需要一个系统，然后当他输入12 3456 7009时，会给出相应的念法： 十二亿三千四百五十六万七千零九 用汉语拼音表示为 shi er yi san qian si bai wu shi liu wan qi qian ling jiu 这样他只需要照着念就可以了。 你的任务是帮他设计这样一个系统：给定一个阿拉伯数字串，你帮他按照中文读写的规范转为汉语拼音字串，相邻的两个音节用一个空格符格开。 注意必须严格按照规范，比如说“10010”读作“yi wan ling yi shi”而不是“yi wan ling shi”，“100000”读作“shi wan”而不是“yi shi wan”，“2000”读作“er qian”而不是“liang qian”。 输入格式 有一个数字串，数值大小不超过2,000,000,000。 输出格式 是一个由小写英文字母，逗号和空格组成的字符串，表示该数的英文读法。 样例输入1234567009 样例输出shi er yi san qian si bai wu shi liu wan qi qian ling jiu 算法知道了大概的读法之后就可以写了，于是就需要一个数组存数字的读法，一个数组存单位的读法，这里不需要个位，将个位置空就行，因为我们平时也不读个位。然后判断输入的规模到亿了吗？如果到亿(倒数第九位)了就将单位数组和亿对齐，并将个位置“yi”,到万(倒数第五位)则跟万对齐，个位置“wan”，否则对齐最后一位,个位置空。例如 12 3456 7890 10 ​ 3210 ​ 3210 第二三四行代表数组单位的下标，此时的对齐的标准是亿，个位置“yi”,然后读一个数字读一个单位，读出&quot;yi shi er yi&quot;，注意此时的个位置&quot;yi&quot;，所以读出&quot;yi&quot;。这样就可以读出数来了，然而还是存在一些问题，比如，12(仅限开头，412中的1还是要读的)应读作”shi er”而不是“yi shi er”,这个问题很好解决，加一个判断的条件，开头为1单位是“shi”的时候不读yi”。102应读作“yi bai ling er”而不是“yi bai ling shi er”,这个问题也很好解决，零的时候数字和单位都不读，如果遇到非零数字的上一个数字是零就多读一个“ling ”。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; char s[11]; cin&gt;&gt;s; string shu[10]&#x3D;&#123;&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;&#125;; string d[6]&#x3D;&#123;&quot;&quot;,&quot;shi&quot;,&quot;bai&quot;,&quot;qian&quot;,&quot;wan&quot;,&quot;yi&quot;&#125;; int len&#x3D;strlen(s); int p; for(int i&#x3D;0;i&lt;strlen(s);i++) &#123; if(strlen(s)-i&gt;&#x3D;9) p&#x3D;9; else if(strlen(s)-i&gt;&#x3D;5) p&#x3D;5; else p&#x3D;1; int j&#x3D;strlen(s)-p-i; if(s[i]!&#x3D;&#39;0&#39;) &#123; if(p&#x3D;&#x3D;9) d[0]&#x3D;&quot;yi &quot;; else if(p&#x3D;&#x3D;5) d[0]&#x3D;&quot;wan &quot;; else d[0]&#x3D;&quot;&quot;; if(i&gt;&#x3D;1&amp;&amp;s[i-1]&#x3D;&#x3D;&#39;0&#39;) cout&lt;&lt;&quot;ling&quot;&lt;&lt;&quot; &quot;; if(!(i&#x3D;&#x3D;0&amp;&amp;s[i]&#x3D;&#x3D;&#39;1&#39;&amp;&amp;j&#x3D;&#x3D;1)) cout&lt;&lt;shu[s[i]-&#39;0&#39;]&lt;&lt;&quot; &quot;; if(j!&#x3D;0) cout&lt;&lt;d[j]&lt;&lt;&quot; &quot;; &#125; if(j&#x3D;&#x3D;0) &#123; cout&lt;&lt;d[0]; d[0]&#x3D;&quot;&quot;; &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"读数字","slug":"读数字","permalink":"https://donghuangzhong.github.io/tags/%E8%AF%BB%E6%95%B0%E5%AD%97/"}]},{"title":"基础练习 时间转换","slug":"基础练习-时间转换","date":"2020-03-14T09:10:50.000Z","updated":"2020-03-14T09:21:25.741Z","comments":true,"path":"2020/03/14/基础练习-时间转换/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/","excerpt":"十进制转六十进制的倒数第三位","text":"十进制转六十进制的倒数第三位 题目试题 基础练习 时间转换提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 给定一个以秒为单位的时间t，要求用“::”的格式来表示这个时间。表示时间，表示分钟，而表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。 输入格式 输入只有一行，是一个整数t（0&lt;=t&lt;=86399）。 输出格式 输出只有一行，是以“::”的格式所表示的时间，不包括引号。 样例输入0 样例输出0:0:0 样例输入5436 样例输出1:30:36 算法1234567891011121314#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int t; cin&gt;&gt;t; int h&#x3D;t&#x2F;(60*60); t-&#x3D;h*(60*60); int m&#x3D;t&#x2F;60; t-&#x3D;m*60; cout&lt;&lt;h&lt;&lt;&quot;:&quot;&lt;&lt;m&lt;&lt;&quot;:&quot;&lt;&lt;t;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"进制","slug":"ACM/进制","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%BF%9B%E5%88%B6/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"基础练习 矩阵乘法","slug":"基础练习-矩阵乘法","date":"2020-03-14T08:27:26.000Z","updated":"2020-03-14T09:10:18.994Z","comments":true,"path":"2020/03/14/基础练习-矩阵乘法/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/","excerpt":"整数的乘法初始化为1，矩阵的乘法初始化为大小相同单位矩阵(只有对角线全是1)。必须由第三个变量保存结果。for循环不仅控制次数还控制积和被乘数每次的变换。","text":"整数的乘法初始化为1，矩阵的乘法初始化为大小相同单位矩阵(只有对角线全是1)。必须由第三个变量保存结果。for循环不仅控制次数还控制积和被乘数每次的变换。 问题试题 基础练习 矩阵乘法提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 给定一个N阶矩阵A，输出A的M次幂（M是非负整数） 例如： A = 1 2 3 4 A的2次幂 7 10 15 22 输入格式 第一行是一个正整数N、M（1&lt;=N&lt;=30, 0&lt;=M&lt;=5），表示矩阵A的阶数和要求的幂数 接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值 输出格式 输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开 样例输入2 21 23 4 样例输出7 1015 22 算法1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int juzhen[30][30],jieguo[2][30][30],nn&#x3D;0; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i&#x3D;0;i&lt;n;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; cin&gt;&gt;juzhen[i][j]; jieguo[0][i][j]&#x3D;i&#x3D;&#x3D;j?1:0; &#125; &#125; for(int i&#x3D;0;i&lt;m;i++) &#123; nn&#x3D;i&amp;1?0:1; for(int j&#x3D;0;j&lt;n;j++) &#123; for(int k&#x3D;0;k&lt;n;k++) &#123; int sum&#x3D;0; for(int l&#x3D;0;l&lt;n;l++) &#123; sum+&#x3D;jieguo[1-nn][j][l]*juzhen[l][k]; &#125; jieguo[nn][j][k]&#x3D;sum; &#125; &#125; &#125; for(int j&#x3D;0;j&lt;n;j++) &#123; for(int k&#x3D;0;k&lt;n;k++) cout&lt;&lt;jieguo[nn][j][k]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"矩阵乘法","slug":"ACM/矩阵乘法","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"}],"tags":[{"name":"妙用下标和","slug":"妙用下标和","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E4%B8%8B%E6%A0%87%E5%92%8C/"}]},{"title":"基础练习 矩形面积交","slug":"基础练习-矩形面积交","date":"2020-03-14T08:16:17.000Z","updated":"2020-03-14T08:26:58.826Z","comments":true,"path":"2020/03/14/基础练习-矩形面积交/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E4%BA%A4/","excerpt":"如果判断一个线段跟另一个线段相交的长度的话，起点就是两个线段起点的最大值，终点就是两个线段的终点的最小值。然后判断一下终点是不是比起点大，如果终点比起点小的话就不相交。但因为我们通常不知道线段的起点和终点，所以要进行比较。所以这个方法也可以推广到n维。","text":"如果判断一个线段跟另一个线段相交的长度的话，起点就是两个线段起点的最大值，终点就是两个线段的终点的最小值。然后判断一下终点是不是比起点大，如果终点比起点小的话就不相交。但因为我们通常不知道线段的起点和终点，所以要进行比较。所以这个方法也可以推广到n维。 问题试题 基础练习 矩形面积交提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。 输入格式 输入仅包含两行，每行描述一个矩形。 在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。 输出格式 输出仅包含一个实数，为交的面积，保留到小数后两位。 样例输入1 1 3 32 2 4 4 样例输出1.00 算法1234567891011121314151617#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; double a[8]; for(int i&#x3D;0;i&lt;8;i++) cin&gt;&gt;a[i]; double xmin&#x3D;max(min(a[0],a[2]),min(a[4],a[6])); double xmax&#x3D;min(max(a[0],a[2]),max(a[4],a[6])); double ymin&#x3D;max(min(a[1],a[3]),min(a[5],a[7])); double ymax&#x3D;min(max(a[1],a[3]),max(a[5],a[7])); if(xmin&lt;xmax&amp;&amp;ymin&lt;ymax) printf(&quot;%.2f&quot;,(xmax-xmin)*(ymax-ymin)); else cout&lt;&lt;&quot;0.00&quot;;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"线段交","slug":"ACM/线段交","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%BA%BF%E6%AE%B5%E4%BA%A4/"}],"tags":[{"name":"n维交","slug":"n维交","permalink":"https://donghuangzhong.github.io/tags/n%E7%BB%B4%E4%BA%A4/"}]},{"title":"基础练习 分解质因数","slug":"基础练习-分解质因数","date":"2020-03-14T08:11:19.000Z","updated":"2020-03-14T08:14:48.337Z","comments":true,"path":"2020/03/14/基础练习-分解质因数/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/","excerpt":"有好多种做法，最快的应该是从小到大打印素数表，然后挨个除。但是我觉得打印素数表太麻烦，于是就从2开始挨个除然后输出。","text":"有好多种做法，最快的应该是从小到大打印素数表，然后挨个除。但是我觉得打印素数表太麻烦，于是就从2开始挨个除然后输出。 题目试题 基础练习 分解质因数提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 求出区间[a,b]中所有整数的质因数分解。 输入格式 输入两个整数a，b。 输出格式 每行输出一个数的分解，形如k=a1a2a3…(a1&lt;=a2&lt;=a3…，k也是从小到大的)(具体可看样例) 样例输入3 10 样例输出3=34=225=56=237=78=2229=3310=25 提示 先筛出所有素数，然后再分解。 数据规模和约定 2&lt;=a&lt;=b&lt;=10000 算法1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;void zhiyinshu(int n)&#123; for(int i&#x3D;2;i&lt;&#x3D;n;i++) &#123; if(n%i&#x3D;&#x3D;0) &#123; n&#x2F;&#x3D;i; if(n&#x3D;&#x3D;1) cout&lt;&lt;i&lt;&lt;endl; else cout&lt;&lt;i&lt;&lt;&quot;*&quot;; i--; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int m,n; cin&gt;&gt;m&gt;&gt;n; for(int i&#x3D;m;i&lt;&#x3D;n;i++) &#123; cout&lt;&lt;i&lt;&lt;&quot;&#x3D;&quot;; zhiyinshu(i); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"质因数","slug":"ACM/质因数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%B4%A8%E5%9B%A0%E6%95%B0/"}],"tags":[{"name":"分解质因数","slug":"分解质因数","permalink":"https://donghuangzhong.github.io/tags/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/"}]},{"title":"基础练习 Sine之舞","slug":"基础练习-Sine之舞","date":"2020-03-14T08:08:27.000Z","updated":"2020-03-14T08:10:50.527Z","comments":true,"path":"2020/03/14/基础练习-Sine之舞/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-Sine%E4%B9%8B%E8%88%9E/","excerpt":"仔细观察，嵌套方式，然后写出来就行","text":"仔细观察，嵌套方式，然后写出来就行 问题试题 基础练习 Sine之舞提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 最近FJ为他的奶牛们开设了数学分析课，FJ知道若要学好这门课，必须有一个好的三角函数基本功。所以他准备和奶牛们做一个“Sine之舞”的游戏，寓教于乐，提高奶牛们的计算能力。 不妨设 An=sin(1–sin(2+sin(3–sin(4+…sin(n))…) Sn=(…(A1+n)A2+n-1)A3+…+2)An+1 FJ想让奶牛们计算Sn的值，请你帮助FJ打印出Sn的完整表达式，以方便奶牛们做题。 输入格式 仅有一个数：N&lt;201。 输出格式 请输出相应的表达式Sn，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。 样例输入3 样例输出((sin(1)+3)sin(1–sin(2))+2)sin(1–sin(2+sin(3)))+1 算法12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;void p(int s,int e)&#123; if(s&#x3D;&#x3D;e) &#123; printf(&quot;sin(%d)&quot;,e); return ; &#125; char c&#x3D;s&amp;1?&#39;-&#39;:&#39;+&#39;; printf(&quot;sin(%d%c&quot;,s,c); p(s+1,e); cout&lt;&lt;&quot;)&quot;;&#125;void pp(int an,int nn)&#123; if(an&#x3D;&#x3D;1) &#123; p(1,an); cout&lt;&lt;&quot;+&quot;&lt;&lt;nn; return ; &#125; cout&lt;&lt;&quot;(&quot;; pp(an-1,nn+1); cout&lt;&lt;&quot;)&quot;; p(1,an); cout&lt;&lt;&quot;+&quot;&lt;&lt;nn;&#125;int main()&#123; int n; cin&gt;&gt;n; pp(n,1);&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"递归","slug":"ACM/递归","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%92%E5%BD%92/"}],"tags":[{"name":"逻辑","slug":"逻辑","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91/"}]},{"title":"基础练习 FJ的字符串","slug":"基础练习-FJ的字符串","date":"2020-03-14T08:05:02.000Z","updated":"2020-03-14T08:07:29.021Z","comments":true,"path":"2020/03/14/基础练习-FJ的字符串/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-FJ%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"仔细观察就是二叉树的中序遍历","text":"仔细观察就是二叉树的中序遍历 题目试题 基础练习 FJ的字符串提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 FJ在沙盘上写了这样一些字符串： A1 = “A” A2 = “ABA” A3 = “ABACABA” A4 = “ABACABADABACABA” … … 你能找出其中的规律并写所有的数列AN吗？ 输入格式 仅有一个数：N ≤ 26。 输出格式 请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。 样例输入3 样例输出ABACABA 算法123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;void p(char c)&#123; if(c&#x3D;&#x3D;&#39;A&#39;) &#123; cout&lt;&lt;c; return ; &#125; p(c-1); cout&lt;&lt;c; p(c-1);&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; p(&#39;A&#39;-1+n); cout&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"递归","slug":"ACM/递归","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%92%E5%BD%92/"}],"tags":[{"name":"逻辑","slug":"逻辑","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"}]},{"title":"C++ to_string编写","slug":"C-to-string编写","date":"2020-03-13T01:38:31.000Z","updated":"2020-03-13T01:43:24.525Z","comments":true,"path":"2020/03/13/C-to-string编写/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/13/C-to-string%E7%BC%96%E5%86%99/","excerpt":"dev c++ 中不能用to_string函数，于是就自己用泛型写了一个。函数模板是函数的模板，需要经过编译两次，第一次检查错误，第二次生成具体的函数。","text":"dev c++ 中不能用to_string函数，于是就自己用泛型写了一个。函数模板是函数的模板，需要经过编译两次，第一次检查错误，第二次生成具体的函数。 1234567891011#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;template &lt;typename T &gt;string to_string(T i)&#123; stringstream s; s&lt;&lt;i; return s.str();&#125;","categories":[{"name":"tools","slug":"tools","permalink":"https://donghuangzhong.github.io/categories/tools/"},{"name":"C++","slug":"tools/C","permalink":"https://donghuangzhong.github.io/categories/tools/C/"}],"tags":[{"name":"泛型编程","slug":"泛型编程","permalink":"https://donghuangzhong.github.io/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"},{"name":"函数模板","slug":"函数模板","permalink":"https://donghuangzhong.github.io/tags/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"}]},{"title":"基础练习 芯片测试","slug":"基础练习-芯片测试","date":"2020-03-12T05:50:39.000Z","updated":"2020-03-12T05:50:39.301Z","comments":true,"path":"2020/03/12/基础练习-芯片测试/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E8%8A%AF%E7%89%87%E6%B5%8B%E8%AF%95/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"基础练习 龟兔赛跑预测","slug":"基础练习-龟兔赛跑预测","date":"2020-03-12T04:15:22.000Z","updated":"2020-03-12T04:27:38.052Z","comments":true,"path":"2020/03/12/基础练习-龟兔赛跑预测/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E9%A2%84%E6%B5%8B/","excerpt":"结果一定是一个整数，题中说是两个速度的公倍数。必须一秒一秒的走，当兔子领先t米时，后退v1*s米就行，这样再经过s秒之后回到后退前的位置","text":"结果一定是一个整数，题中说是两个速度的公倍数。必须一秒一秒的走，当兔子领先t米时，后退v1*s米就行，这样再经过s秒之后回到后退前的位置 题目试题 基础练习 龟兔赛跑预测提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 话说这个世界上有各种各样的兔子和乌龟，但是研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。 然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。 输入格式 输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt;=100;t&lt;=300;s&lt;=10;l&lt;=10000且为v1,v2的公倍数) 输出格式 输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。 第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。 样例输入10 5 5 2 20 样例输出D4 样例输入10 5 5 1 20 样例输出R3 样例输入10 5 5 3 20 样例输出T4 算法12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;void shuchu(int , int , int , int , int );int main(void)&#123; int v1,v2,t,s,l; scanf(&quot;%d%d%d%d%d&quot;, &amp;v1 , &amp;v2 , &amp;t , &amp;s , &amp;l ); shuchu( v1 , v2 , t , s , l ); return 0;&#125;void shuchu(int v1 , int v2 , int t , int s , int l )&#123; int s1&#x3D; 0 , s2 &#x3D; 0 ,i &#x3D; 0; while(s1 &lt; l &amp;&amp; s2 &lt; l) &#123; s1 +&#x3D;v1 ; s2 +&#x3D;v2 ; i ++ ; if( s1 &#x3D;&#x3D; l || s2 &#x3D;&#x3D; l) &#123; break; &#125; if(s1-s2 &gt;&#x3D; t) &#123; s1-&#x3D; v1 * s; &#125; &#x2F;&#x2F;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s1&lt;&lt;&quot; &quot;&lt;&lt;s2&lt;&lt;endl; &#125; if(s1 &gt; s2 ) &#123; printf(&quot;R\\n&quot;); &#125; if( s2 &gt; s1) &#123; printf(&quot;T\\n&quot;); &#125; if(s1 &#x3D;&#x3D; s2) &#123; printf(&quot;D\\n&quot;); &#125; printf(&quot;%d&quot;, i );&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"龟兔赛跑","slug":"龟兔赛跑","permalink":"https://donghuangzhong.github.io/tags/%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91/"}]},{"title":"基础练习 回形取数","slug":"基础练习-回形取数","date":"2020-03-12T02:17:09.000Z","updated":"2020-03-12T02:21:41.638Z","comments":true,"path":"2020/03/12/基础练习-回形取数/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/","excerpt":"将一个方向的点遍历并输出，直到碰壁，然后改变方向，然后再输出……。不能用dfs因为需要的是碰壁再换方向，而不是每次都改变方向。","text":"将一个方向的点遍历并输出，直到碰壁，然后改变方向，然后再输出……。不能用dfs因为需要的是碰壁再换方向，而不是每次都改变方向。 问题试题 基础练习 回形取数提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 回形取数就是沿矩阵的边取数，若当前方向上无数可取或已经取过，则左转90度。一开始位于矩阵左上角，方向向下。 输入格式 输入第一行是两个不超过200的正整数m, n，表示矩阵的行和列。接下来m行每行n个整数，表示这个矩阵。 输出格式 输出只有一行，共mn个数，为输入矩阵回形取数得到的结果。数之间用一个空格分隔，行末不要有多余的空格。 样例输入3 31 2 34 5 67 8 9 样例输出1 4 7 8 9 6 3 2 5 样例输入3 21 23 45 6 样例输出1 3 5 6 4 2 算法12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;&#x2F;&#x2F;#include&lt;map&gt;#define PI 3.14159265358979323#define MAX 0x3f3f3f3fusing namespace std;int map[210][210],m,n,sum&#x3D;1,x,y;int dir[4][2]&#x3D;&#123;1,0,0,1,-1,0,0,-1&#125;;int main()&#123; &#x2F;&#x2F;freopen(&quot;input2.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;m&gt;&gt;n; for(int i&#x3D;0;i&lt;m;i++) for(int j&#x3D;0;j&lt;n;j++) cin&gt;&gt;map[i][j]; x&#x3D;y&#x3D;0; cout&lt;&lt;map[0][0]; map[x][y]&#x3D;-1; while(sum!&#x3D;m*n) &#123; for(int i&#x3D;0;i&lt;4;i++) &#123; int xx&#x3D;x+dir[i][0]; int yy&#x3D;y+dir[i][1]; while(xx&gt;&#x3D;0&amp;&amp;xx&lt;m&amp;&amp;yy&gt;&#x3D;0&amp;&amp;yy&lt;n&amp;&amp;map[xx][yy]!&#x3D;-1) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;map[xx][yy]; map[xx][yy]&#x3D;-1; x&#x3D;xx; y&#x3D;yy; sum++; xx&#x3D;x+dir[i][0]; yy&#x3D;y+dir[i][1]; &#125; &#125; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"回形取数","slug":"回形取数","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/"}]},{"title":"基础练习 报时助手","slug":"基础练习-报时助手","date":"2020-03-12T02:12:49.000Z","updated":"2020-03-12T02:16:36.655Z","comments":true,"path":"2020/03/12/基础练习-报时助手/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E6%8A%A5%E6%97%B6%E5%8A%A9%E6%89%8B/","excerpt":"由于0~23都有完整的字符串，所以20,30,40,50要连续存储，求他们的十位数加上一个偏移量","text":"由于0~23都有完整的字符串，所以20,30,40,50要连续存储，求他们的十位数加上一个偏移量 问题试题 基础练习 报时助手提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 给定当前的时间，请用英文的读法将它读出来。 时间用时h和分m表示，在英文的读法中，读一个时间的方法是： 如果m为0，则将时读出来，然后加上“o’clock”，如3:00读作“three o’clock”。 如果m不为0，则将时读出来，然后将分读出来，如5:30读作“five thirty”。 时和分的读法使用的是英文数字的读法，其中0~20读作： 0:zero, 1: one, 2:two, 3:three, 4:four, 5:five, 6:six, 7:seven, 8:eight, 9:nine, 10:ten, 11:eleven, 12:twelve, 13:thirteen, 14:fourteen, 15:fifteen, 16:sixteen, 17:seventeen, 18:eighteen, 19:nineteen, 20:twenty。 30读作thirty，40读作forty，50读作fifty。 对于大于20小于60的数字，首先读整十的数，然后再加上个位数。如31首先读30再加1的读法，读作“thirty one”。 按上面的规则21:54读作“twenty one fifty four”，9:07读作“nine seven”，0:15读作“zero fifteen”。 输入格式 输入包含两个非负整数h和m，表示时间的时和分。非零的数字前没有前导0。h小于24，m小于60。 输出格式 输出时间时刻的英文。 样例输入0 15 样例输出zero fifteen 算法123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;map&gt;#define PI 3.14159265358979323#define MAX 0x3f3f3f3fusing namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); string yingshe[]&#x3D;&#123;&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;,&quot;ten&quot;,&quot;eleven&quot;,&quot;twelve&quot;,&quot;thirteen&quot;,&quot;fourteen&quot;,&quot;fifteen&quot;,&quot;sixteen&quot;,&quot;seventeen&quot;,&quot;eighteen&quot;,&quot;nineteen&quot;,&quot;twenty&quot;,&quot;twenty one&quot;,&quot;twenty two&quot;,&quot;twenty three&quot;,&quot;twenty&quot;,&quot;thirty&quot;,&quot;forty&quot;,&quot;fifty&quot;&#125;; int h,m; cin&gt;&gt;h&gt;&gt;m; cout&lt;&lt;yingshe[h]&lt;&lt;&quot; &quot;; if(m&#x3D;&#x3D;0) &#123; cout&lt;&lt;&quot;o&#39;clock&quot;; &#125; else if(m&gt;0&amp;&amp;m&lt;&#x3D;23) cout&lt;&lt;yingshe[m]; else &#123; int s&#x3D;m&#x2F;10+2; int g&#x3D;m%10; cout&lt;&lt;yingshe[20+s]&lt;&lt;&quot; &quot;&lt;&lt;yingshe[g]; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"字符串数组","slug":"字符串数组","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84/"}]},{"title":"基础练习 2n皇后问题","slug":"基础练习-2n皇后问题","date":"2020-03-12T02:01:47.000Z","updated":"2020-03-12T02:12:26.853Z","comments":true,"path":"2020/03/12/基础练习-2n皇后问题/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-2n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/","excerpt":"不能用dfs并行运算，会重复，可以举例2*2的棋盘，必须分开算","text":"不能用dfs并行运算，会重复，可以举例2*2的棋盘，必须分开算 问题试题 基础练习 Huffuman树提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。 给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下： 1. 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa + pb。 2. 重复步骤1，直到{pi}中只剩下一个数。 在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。 本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。 例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下： 1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。 2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。 3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。 4. 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。 5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。 输入格式 输入的第一行包含一个正整数n（n&lt;=100）。 接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。 输出格式 输出用这些数构造Huffman树的总费用。 样例输入55 3 8 2 9 样例输出59 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#define PI 3.14159265358979323#define MAX 0x3f3f3f3fusing namespace std;int lieh[9],lieb[9];int map[9][9],n,sum&#x3D;0;bool judgeh(int x,int y)&#123; if(map[x][y]&#x3D;&#x3D;0) return 0; if(lieh[y]!&#x3D;0) return 0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(lieh[i]!&#x3D;0) &#123; double t&#x3D;(i-y)&#x2F;double(lieh[i]-x); if(t&#x3D;&#x3D;1||t&#x3D;&#x3D;-1) &#123; return 0; &#125; &#125; &#125; return 1;&#125;bool judgeb(int x,int y)&#123; if(map[x][y]&#x3D;&#x3D;0) return 0; if(lieb[y]!&#x3D;0||lieh[y]&#x3D;&#x3D;x) return 0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(lieb[i]!&#x3D;0) &#123; double t&#x3D;(i-y)&#x2F;double(lieb[i]-x); if(t&#x3D;&#x3D;1||t&#x3D;&#x3D;-1) &#123; return 0; &#125; &#125; &#125; return 1; &#125;void dfsb(int h)&#123; if(h&#x3D;&#x3D;n+1) &#123; sum++; return ; &#125; for(int i&#x3D;0;i&lt;&#x3D;n;i++) &#123; if(judgeb(h,i)) &#123; lieb[i]&#x3D;h; dfsb(h+1); lieb[i]&#x3D;0; &#125; &#125;&#125;void dfsh(int h)&#123; if(h&#x3D;&#x3D;n+1) &#123; dfsb(1); return ; &#125; for(int i&#x3D;0;i&lt;&#x3D;n;i++) &#123; if(judgeh(h,i)) &#123; lieh[i]&#x3D;h; dfsh(h+1); lieh[i]&#x3D;0; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; cin&gt;&gt;map[i][j]; &#125; &#125; memset(lieh,0,sizeof(lieh)); memset(lieb,0,sizeof(lieb)); dfsh(1); cout&lt;&lt;sum&lt;&lt;endl; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dfs","slug":"ACM/dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/dfs/"}],"tags":[{"name":"八皇后问题","slug":"八皇后问题","permalink":"https://donghuangzhong.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"name":"黑白子","slug":"黑白子","permalink":"https://donghuangzhong.github.io/tags/%E9%BB%91%E7%99%BD%E5%AD%90/"}]},{"title":"基础练习 Huffuman树","slug":"基础练习-Huffuman树","date":"2020-03-12T01:55:32.000Z","updated":"2020-03-12T02:01:13.715Z","comments":true,"path":"2020/03/12/基础练习-Huffuman树/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-Huffuman%E6%A0%91/","excerpt":"用两个变量保存最小值，用两个变量保存两个最小值的下标，然后相加放入其中一个变量，另一个变量置无穷大，n个变量需要n-1步操作变成最后的一个变量，记录他们的和","text":"用两个变量保存最小值，用两个变量保存两个最小值的下标，然后相加放入其中一个变量，另一个变量置无穷大，n个变量需要n-1步操作变成最后的一个变量，记录他们的和 问题试题 基础练习 Huffuman树提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。 给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下： 1. 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa + pb。 2. 重复步骤1，直到{pi}中只剩下一个数。 在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。 本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。 例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下： 1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。 2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。 3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。 4. 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。 5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。 输入格式 输入的第一行包含一个正整数n（n&lt;=100）。 接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。 输出格式 输出用这些数构造Huffman树的总费用。 样例输入55 3 8 2 9 样例输出59 算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;#include&lt;queue&gt;#define PI 3.14159265358979323#define MAX 0x3f3f3f3fusing namespace std;int main()&#123; int hf[100]; int n,minn1,minn2,index1,index2,sum&#x3D;0; cin&gt;&gt;n; for(int i&#x3D;0;i&lt;n;i++) &#123; cin&gt;&gt;hf[i]; &#125; for(int i&#x3D;0;i&lt;n-1;i++) &#123; minn1&#x3D;MAX; minn2&#x3D;MAX; for(int j&#x3D;0;j&lt;n;j++) &#123; if(hf[j]&lt;minn2) &#123; if(hf[j]&lt;minn1) &#123; minn2&#x3D;minn1; index2&#x3D;index1; minn1&#x3D;hf[j]; index1&#x3D;j; &#125; else &#123;minn2&#x3D;hf[j]; index2&#x3D;j; &#125; &#125; &#125; hf[index1]&#x3D;minn1+minn2; sum+&#x3D;hf[index1]; hf[index2]&#x3D;MAX; &#125; cout&lt;&lt;sum; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Huffuman","slug":"ACM/Huffuman","permalink":"https://donghuangzhong.github.io/categories/ACM/Huffuman/"}],"tags":[{"name":"两个最小值","slug":"两个最小值","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%A4%E4%B8%AA%E6%9C%80%E5%B0%8F%E5%80%BC/"}]},{"title":"基础练习 阶乘计算","slug":"基础练习-阶乘计算","date":"2020-03-12T01:46:49.000Z","updated":"2020-03-12T01:54:44.453Z","comments":true,"path":"2020/03/12/基础练习-阶乘计算/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97/","excerpt":"m位数乘以n位数的最大位数是（m+1）*n（n&lt;m）","text":"m位数乘以n位数的最大位数是（m+1）*n（n&lt;m） 问题试题 基础练习 阶乘计算提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 输入一个正整数n，输出n!的值。 其中n!=123…*n*。 算法描述 n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。 将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。 首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。 输入格式 输入包含一个正整数n，n&lt;=1000。 输出格式 输出n!的准确值。 样例输入10 样例输出3628800 算法累乘，每次除10，求出i的位数，用len保存当前结果的位数，(len+1)*i的位数就是新结果的最大范围，依次更新并记录结果的实际位数 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;#include&lt;queue&gt;#define PI 3.14159265358979323using namespace std;int a[2600];int main()&#123; int n; cin&gt;&gt;n; memset(a,0,sizeof(a)); a[1]&#x3D;1; int jinwei&#x3D;0; int len&#x3D;1; for(int i&#x3D;2;i&lt;&#x3D;n;i++) &#123; int tlen&#x3D;len,t&#x3D;i; int wei&#x3D;0; while(t!&#x3D;0) &#123; t&#x2F;&#x3D;10; wei++; &#125; for(int j&#x3D;1;j&lt;&#x3D;(len+1)+wei;j++) &#123; a[j]&#x3D;i*a[j]+jinwei; if(a[j]&gt;&#x3D;10) &#123; jinwei&#x3D;a[j]&#x2F;10; a[j]&#x3D;a[j]%10; &#125; else jinwei&#x3D;0; if(j&gt;tlen&amp;&amp;a[j]) tlen&#x3D;j; &#125; len&#x3D;tlen; &#125; while(len) cout&lt;&lt;a[len--]; cout&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"大数","slug":"ACM/大数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0/"}],"tags":[{"name":"大数阶乘","slug":"大数阶乘","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/"}]},{"title":"POJ-1511-Invitation Cards","slug":"POJ-1511-Invitation-Cards","date":"2020-03-10T07:40:31.000Z","updated":"2020-03-10T07:52:08.464Z","comments":true,"path":"2020/03/10/POJ-1511-Invitation-Cards/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/10/POJ-1511-Invitation-Cards/","excerpt":"这个用Bellman一直超时，后来用了spfa，邻接表简直就是为spfa量身打造的，不过此题中的指针换成了变得索引，此题中由于要翻转边，所以需要把边的信息全部记下来，spfa开始的时候翻转，然后交换边的起点和终点，然后再调用一次spfa","text":"这个用Bellman一直超时，后来用了spfa，邻接表简直就是为spfa量身打造的，不过此题中的指针换成了变得索引，此题中由于要翻转边，所以需要把边的信息全部记下来，spfa开始的时候翻转，然后交换边的起点和终点，然后再调用一次spfa 题目邀请卡 时限： 8000MS 内存限制： 262144K 提交总数： 39132 接受的： 12664 描述在电视时代，很少有人参加戏剧表演。Malidinesia的古董喜剧演员知道这一事实。他们想传播戏剧，最重要的是传播古董喜剧。他们印有所有必要信息和计划的邀请卡。雇用了许多学生在人们中间分发这些邀请。每个学生志愿者都恰好分配了一个公交车站，他或她整天都呆在那里，并向乘公共汽车旅行的人发出邀请。开设了一门特殊的课程，让学生学习如何影响人以及影响力和抢劫之间的区别。 运输系统非常特殊：所有线路都是单向的，并且恰好连接两个站。公交车每半小时便有客流驶离始发站。到达目的地站后，他们返回到出发站为空，直到下一个完整的半小时，例如X：00或X：30，其中“ X”表示小时。两站之间的运输费用由特别表提供，应当场支付。线路的规划方式是，每次往返（即在同一站开始和结束的旅程）都要经过中央检查站（CCS），每位乘客都必须通过包括身体扫描在内的全面检查。 所有ACM学生成员每天早晨都离开CCS。每个志愿者将移动到一个预定的站点以邀请乘客。志愿人员的数量与站点的数量一样多。最终，所有学生都返回了CCS。您要编写一个计算机程序，以帮助ACM最大限度地减少每天支付给其员工的运输费用。 输入值输入包含N个案例。输入的第一行仅包含正整数N。然后遵循这些情况。每种情况均始于一条直线，该直线恰好包含两个整数P和Q，1 &lt;= P，Q &lt;=1000000。P是包含CCS的站点数，而Q是总线的数量。然后有Q条线，每条线描述一条总线。每行均包含三个数字-起始止损，目的地止损和价格。CCS由数字1表示。价格是正整数，其总和小于1000000000。您还可以假设始终可以从任何停靠点到达任何其他停靠点。 输出量对于每种情况，请打印一行，其中包含ACM每天为其志愿者支付的差旅费用的最低金额。 样本输入123456789101122 21 2 132 1 334 61 2 102 1 601 3 203 4 102 4 54 1 50 样本输出1246210 题目大意第一行输入测试用例，第二行分别输入顶点的个数和边的个数，剩下的行输入边的信息，起点终点费用 求来回的最小距离 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;#include&lt;queue&gt;#define N 1000005using namespace std;struct Point&#123; int start,end,price;&#125; route[N];int s,n,m,p[N],v[N],d[N],nextt[N];long long sum;void spfa()&#123; memset(p,0,(n+1)*sizeof(int)); memset(v,0,(n+1)*sizeof(int)); memset(d,0x3f,(n+1)*sizeof(int)); for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; nextt[i]&#x3D;p[route[i].start]; p[route[i].start]&#x3D;i; &#125; d[1]&#x3D;0; queue&lt;int&gt; q; q.push(1); v[1]&#x3D;1; while(!q.empty()) &#123; int a&#x3D;q.front(); q.pop(); v[a]&#x3D;0; int next&#x3D;p[a]; while(next!&#x3D;0) &#123; if(d[route[next].end]&gt;d[a]+route[next].price) &#123; d[route[next].end]&#x3D;d[a]+route[next].price; if(v[route[next].end]&#x3D;&#x3D;0) &#123; v[route[next].end]&#x3D;1; q.push(route[next].end); &#125; &#125; next&#x3D;nextt[next]; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; &#x2F;&#x2F;cout&lt;&lt;d[i]&lt;&lt;&quot; &quot;; sum+&#x3D;d[i]; &#125; &#x2F;&#x2F;cout&lt;&lt;endl;&#125;void turn()&#123; for (int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int temp&#x3D;route[i].start; route[i].start&#x3D;route[i].end; route[i].end&#x3D;temp; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int t; &#x2F;&#x2F;cin&gt;&gt;t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; sum&#x3D;0; &#x2F;&#x2F;cin&gt;&gt;n&gt;&gt;m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; &#x2F;&#x2F;cin&gt;&gt;route[i].start&gt;&gt;route[i].end&gt;&gt;route[i].price; scanf(&quot;%d%d%d&quot;,&amp;route[i].start,&amp;route[i].end,&amp;route[i].price); &#125; spfa(); turn(); spfa(); cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"SPFA","slug":"ACM/SPFA","permalink":"https://donghuangzhong.github.io/categories/ACM/SPFA/"}],"tags":[{"name":"翻转边","slug":"翻转边","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E8%BE%B9/"},{"name":"来回总和最短","slug":"来回总和最短","permalink":"https://donghuangzhong.github.io/tags/%E6%9D%A5%E5%9B%9E%E6%80%BB%E5%92%8C%E6%9C%80%E7%9F%AD/"}]},{"title":"HDU-1217-POJ-2240-Arbitrage","slug":"HDU-1217-POJ-2240-Arbitrage","date":"2020-03-09T01:58:42.000Z","updated":"2020-03-11T03:51:17.321Z","comments":true,"path":"2020/03/09/HDU-1217-POJ-2240-Arbitrage/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/09/HDU-1217-POJ-2240-Arbitrage/","excerpt":"HDU和POJ的数据都很水，这个题没说第一个货币一定在环中，但以第一种货币一定在环中的算法却都能AC，不信试试我给的测试数据，不得不说Bellman真的强，本文给出这个题的严谨证明和算法！！！不可转载谢谢！","text":"HDU和POJ的数据都很水，这个题没说第一个货币一定在环中，但以第一种货币一定在环中的算法却都能AC，不信试试我给的测试数据，不得不说Bellman真的强，本文给出这个题的严谨证明和算法！！！不可转载谢谢！ 题目套利\\时间限制：2000/1000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）提交总数：12754接受提交：5785** 问题描述套利是利用货币汇率差异将一种货币单位转换成一种以上相同货币单位。例如，假设1美元买入0.5英镑，1英镑买入10.0法国法郎，而1法国法郎买入0.21美元。然后，通过转换货币，一个聪明的交易者可以从1美元开始，买入0.5 * 10.0 * 0.21 = 1.05美元，获利5％。 您的工作是编写一个程序，该程序将货币汇率列表作为输入，然后确定是否可以进行套利。 输入值输入文件将包含一个或多个测试用例。在每个测试用例的第一行中，有一个整数n（1 &lt;= n &lt;= 30），代表不同货币的数量。接下来的n行分别包含一种货币的名称。名称中不会出现空格。下一行包含一个整数m，代表要跟随的表的长度。最后的m行分别包含源货币的名称ci，代表从ci到cj的汇率的实数rij和目标货币的名称cj。没有出现在表中的交换是不可能的。测试用例之间用空白行隔开。输入以n的零（0）值终止。 输出量对于每个测试用例，分别以“案例：是”和“案例：否”的格式打印一行，说明是否可以套利。 Sample Input123456789101112131415161718192021223USDollarBritishPoundFrenchFranc3USDollar 0.5 BritishPoundBritishPound 10.0 FrenchFrancFrenchFranc 0.21 USDollar3USDollarBritishPoundFrenchFranc6USDollar 0.5 BritishPoundUSDollar 4.9 FrenchFrancBritishPound 10.0 FrenchFrancBritishPound 1.99 USDollarFrenchFranc 0.09 BritishPoundFrenchFranc 0.19 USDollar0 Sample Output12Case 1: YesCase 2: No 算法先给出不严谨的算法(第一种货币一定在环中)，这个就不用证明了吧，这个在HDU、POJ都能AC！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;int n,m; map&lt;string,int&gt; y;struct &#123; int x,y; double h;&#125; bian[5000];double d[5000];int c&#x3D;1;bool Bellman()&#123; d[1]&#x3D;1; bool flag; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; flag&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(d[bian[j].y]&lt;d[bian[j].x]*bian[j].h) &#123; d[bian[j].y]&#x3D;d[bian[j].x]*bian[j].h; flag&#x3D;1; &#125; &#125; if(flag&#x3D;&#x3D;0) return 0; &#125; for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(d[bian[j].y]&lt;d[bian[j].x]*bian[j].h) &#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n) &#123; char a[100]; double hui; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; &#x2F;&#x2F;d[i]&#x3D;1; d[i]&#x3D;0; scanf(&quot;%s&quot;,a); y[a]&#x3D;i; &#125; cin&gt;&gt;m; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; scanf(&quot;%s%lf&quot;,a,&amp;hui); bian[i].x&#x3D;y[a]; bian[i].h&#x3D;hui; scanf(&quot;%s&quot;,a); bian[i].y&#x3D;y[a]; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;c++&lt;&lt;&quot;: &quot;; if(Bellman()) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125; 测试数据123456789104abcd3b 0.5 cc 1 dd 10 b0 这个数据将第一个点孤立了，b-&gt;c-&gt;d-&gt;b为正环，按照题目逻辑应该输出Yes,但是上述不严谨算法输出No，可见HDU、POJ数据太水了，上述不严谨算法都AC了 再给出严谨的算法，有人说遍历所有起点，多次调用Bellman，NoNoNo！还是太小看Bellman的算法，本题中如果指定第一种货币为起点则应该d[1]=1,其余全为0。严谨的做法应该是d全为1即可，但也不要生搬硬套，此题为乘法类，所以为1,如果是加法类就应该为0。如果d全为0，则起点在正负边(比如b-&gt;c为0.5倍，这是负边；d-&gt;b为10倍，为正边)交界的顶点，有人说正正边交界的顶点也是起点，那只能说你不明白Bellman算法。将正负交界的顶点放在一个集合S中，下面我来证明，一定有一个顶点q属于S,这个点到所有点都为正边(为什么要证明这个，因为碰到负边会走不下去)，现在的问题就变成了： 已知一个正环，S为正负边交界的顶点的集合，证明：一定存在点q属于S，q到此正环所有顶点的的边都为正边 将此正环相邻的相同符号的边看做一条边，即相邻的正边看做一条正边，相邻的负边看做一条负边，如下 这个是个有向图，顺时针，忘了画方向。相邻的正负(先正后负)边看做一个整体，比如上图有两部分，ad和da。这个图就有两组这样的正负边，一个正环可能有n组正负边，当n==2时，由于是一个正环，则这两组边有两种情况 1.都是正边，则结论得证 2.一正一负，那么从正的那组正负边的起点作为起点，结论得证 现在我要用数学归纳法，k==2时结论成立(k为正负边的组数，就是上面的n)，当k==k+1时,又有两种情况 1.都是正边，结论得证 2.存在负边，则将负边中任意一组去掉，变成k-1组正负边组合+一个负的正负边组合。因为整个环为正环，所以这k-1组也可以组成一个正环，k-1组正负边组成的正环符合结论，结论得证 所以可以证明，Bellman选择的起点集合中一定有一个点可以走遍整个环，附上代码，就改了d的初值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;int n,m; map&lt;string,int&gt; y;struct &#123; int x,y; double h;&#125; bian[5000];double d[5000];int c&#x3D;1;bool Bellman()&#123; &#x2F;&#x2F;d[1]&#x3D;1; bool flag; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; flag&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(d[bian[j].y]&lt;d[bian[j].x]*bian[j].h) &#123; d[bian[j].y]&#x3D;d[bian[j].x]*bian[j].h; flag&#x3D;1; &#125; &#125; if(flag&#x3D;&#x3D;0) return 0; &#125; for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(d[bian[j].y]&lt;d[bian[j].x]*bian[j].h) &#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n) &#123; char a[100]; double hui; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; d[i]&#x3D;1; &#x2F;&#x2F;d[i]&#x3D;0; scanf(&quot;%s&quot;,a); y[a]&#x3D;i; &#125; cin&gt;&gt;m; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; scanf(&quot;%s%lf&quot;,a,&amp;hui); bian[i].x&#x3D;y[a]; bian[i].h&#x3D;hui; scanf(&quot;%s&quot;,a); bian[i].y&#x3D;y[a]; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;c++&lt;&lt;&quot;: &quot;; if(Bellman()) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Bellman","slug":"ACM/Bellman","permalink":"https://donghuangzhong.github.io/categories/ACM/Bellman/"}],"tags":[{"name":"正环","slug":"正环","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E7%8E%AF/"}]},{"title":"POJ-3660-Cow Contest","slug":"POJ-3660-Cow-Contest","date":"2020-03-07T09:41:21.000Z","updated":"2020-03-07T09:59:15.242Z","comments":true,"path":"2020/03/07/POJ-3660-Cow-Contest/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/07/POJ-3660-Cow-Contest/","excerpt":"技巧：map[i][j]=map[i][j]||(map[i][k]&amp;&amp;map[k][j]);利用逻辑短路，如果map[i][i]==1说明i到j已经存在通路，直接返回1,否则判断map[i][k]&amp;&amp;map[k][j]==1，可达为1,不可达为0。","text":"技巧：map[i][j]=map[i][j]||(map[i][k]&amp;&amp;map[k][j]);利用逻辑短路，如果map[i][i]==1说明i到j已经存在通路，直接返回1,否则判断map[i][k]&amp;&amp;map[k][j]==1，可达为1,不可达为0。 题目牛比赛 时限： 1000MS 内存限制： 65536K 提交总数： 20550 接受的： 11394 描述Ñ（1≤ ñ ≤100）牛，方便地编号为1 .. Ñ，正在参与编程竞赛。众所周知，有些母牛的编码要好于其他母牛。每头母牛都有一定的恒定技能等级，这在竞争者中是独一无二的。 比赛分几个头对头进行，每回合在两头母牛之间进行。如果牛阿具有更大的技能水平比牛乙（1≤ 甲 ≤ Ñ ; 1≤ 乙 ≤ Ñ ; 甲 ≠ 乙），然后牛甲总是打牛乙。 农夫约翰试图按技能水平对母牛进行排名。给定一个列表的结果中号*（1≤ *中号 ≤4500）二牛回合，确定奶牛他们的职级从结果可以精确地确定的数量。可以保证回合的结果不会矛盾。 输入值第1行：两个以空格分隔的整数：N和*M第2行*。M +1：每行包含两个以空格分隔的整数，这些整数描述单个选手的竞争者和结果（第一个整数A是获胜者）一轮比赛：A和B 输出量*第1行：一个整数，代表可以确定其等级的母牛的数量 样本输入1234565 54 34 23 21 22 5 样本输出12 题目大意给出m个胜负关系对n个点进行排名，第一行输入n,m。剩下m行输入a,b。表示a胜过b。求通过胜负关系能确定几个点的名次。 算法用图(bool型，1表示可达，0表示不可达)的知识，Floyd算法，得到全图的可达关系，要判断第i个点能不能判断名次，去决议该点的入度和出度和是否为n-1。由于题目的输入必须有逻辑，即不能2胜1同时1胜2,所以map[i][j]与map[j][i]不能同时为1，并且不存在环(1-&gt;2-&gt;3-&gt;1)，所以map[i][i]必为0，所以可以用if(map[j][i]||map[i][j]) z++;统计次数 优化后bool图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;#define N 101int n,m;bool map[N][N];void floyd()&#123; for(int k&#x3D;1;k&lt;&#x3D;n;k++) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; map[i][j]&#x3D;map[i][j]||(map[i][k]&amp;&amp;map[k][j]); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n&gt;&gt;m; memset(map,0,sizeof(0)); for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; map[a][b]&#x3D;1; &#125; floyd(); int s&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int z&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(map[j][i]||map[i][j]) &#123; z++; &#125; &#125; if(z&#x3D;&#x3D;n-1) s++; &#125; cout&lt;&lt;s&lt;&lt;endl; return 0;&#125; 传统Floyd12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;#define N 101#define MAX 0x3f3f3f3fint map[N][N],n,m;void floyd()&#123; for(int k&#x3D;1;k&lt;&#x3D;n;k++) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(map[i][k]+map[k][j]&lt;map[i][j]) &#123; map[i][j]&#x3D;map[i][k]+map[k][j]; &#125; &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n&gt;&gt;m; for(int i&#x3D;0;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) map[i][j]&#x3D;MAX; &#125; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; map[a][b]&#x3D;1; &#125; floyd(); int z&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int l&#x3D;0; int q&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(map[j][i]!&#x3D;MAX) &#123; l++; &#125; if(map[i][j]!&#x3D;MAX) q++; &#125; if(l+q&#x3D;&#x3D;n-1) z++; &#125; cout&lt;&lt;z&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Floyd","slug":"ACM/Floyd","permalink":"https://donghuangzhong.github.io/categories/ACM/Floyd/"}],"tags":[{"name":"排名","slug":"排名","permalink":"https://donghuangzhong.github.io/tags/%E6%8E%92%E5%90%8D/"},{"name":"逻辑路径","slug":"逻辑路径","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E8%B7%AF%E5%BE%84/"}]},{"title":"POJ-1502-MPI Maelstrom","slug":"POJ-1502-MPI-Maelstrom","date":"2020-03-07T04:24:19.000Z","updated":"2020-03-07T04:36:35.248Z","comments":true,"path":"2020/03/07/POJ-1502-MPI-Maelstrom/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/07/POJ-1502-MPI-Maelstrom/","excerpt":"atoi(char *)把字符串转换成整形，还有一个string参数的方法是stoi但是在帮助文档里搜不到，但可以用s.c_str()将string转换成char *,当然也可用字符数组，但是我觉得字符数组有长度限制不大好。dij算法中邻接矩阵map[i][i]不用管，只需d[起点]=0，因为不可能访问到d[i][i]。","text":"atoi(char *)把字符串转换成整形，还有一个string参数的方法是stoi但是在帮助文档里搜不到，但可以用s.c_str()将string转换成char *,当然也可用字符数组，但是我觉得字符数组有长度限制不大好。dij算法中邻接矩阵map[i][i]不用管，只需d[起点]=0，因为不可能访问到d[i][i]。 题目MPI大漩涡 时限： 1000MS 内存限制： 10000K 提交总数： 15467 接受： 9422 描述BIT最近接受了他们的新超级计算机的交付，该超级计算机是具有分层通信子系统的32处理器Apollo Odyssey分布式共享内存计算机。Valentine McKee的研究顾问Jack Swigert要求她对新系统进行基准测试。瓦伦丁对斯维格特说：由于阿波罗是一台分布式共享存储机器，因此存储访问和通信时间并不统一。&#39;&#39;共享同一内存子系统的处理器之间的通信速度很快，但是不在同一子系统上的处理器之间的通信速度却较慢。阿波罗与我们实验室中的机器之间的通讯速度还慢一些。”“ 阿波罗的消息传递接口（MPI）的端口如何工作？”斯维格特问。 不太好，&#39;&#39;瓦伦丁回答。要将消息从一个处理器广播到所有其他n-1个处理器，它们只是执行一系列n-1发送。这确实使事情序列化并破坏了性能 .````有什么可以解决的吗？’’ 是的，&#39;&#39;情人微笑。有。一旦第一个处理器将消息发送到另一个，这两个处理器就可以同时将消息发送到另外两个主机。然后将有四个可以发送的主机，以此类推 .````啊，所以您可以像二叉树一样进行广播！’’ ``不是真正的二叉树-我们应该利用我们网络的某些特殊功能。我们拥有的接口卡允许每个处理器同时将消息发送到与其连接的任意数量的其他处理器。但是，消息不一定要同时到达目的地-涉及通信成本。总的来说，我们需要考虑网络拓扑中每个链接的通信成本，并做出相应的计划以最大程度地减少广播所需的总时间。’’ 输入值输入将描述连接n个处理器的网络的拓扑。输入的第一行将是n，即处理器的数量，因此1 &lt;= n &lt;=100 。其余的输入定义邻接矩阵A。邻接矩阵是正方形，大小为nx n。它的每个条目都是整数或字符x。A（i，j）的值表示直接从节点i向节点j发送消息的开销。A（i，j）的x值表示无法将消息直接从节点i发送到节点j。 请注意，对于节点向其自身发送消息的不需要网络通信，因此对于1 &lt;= i &lt;= n，A（i，i）= 0。另外，您可能会假定网络是无向的（消息可以以相同的开销在任一方向上传播），因此A（i，j）= A（j，i）。因此，将仅提供A的（严格）下部三角形部分上的条目。 程序的输入将是A的下部三角形部分。也就是说，输入的第二行将包含一个条目A（2,1）。下一行将包含两个条目A（3,1）和A（3,2），依此类推。 输出量您的程序应输出从第一个处理器向所有其他处理器广播消息所需的最短通信时间。 样本输入1234555030 5100 20 5010 xx 10 样本输出135 题目大意第一行输入点的数量，剩下输入邻接矩阵(双向边)的下三角，x表示不可达 算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAX 0x3f3f3f3fusing namespace std;int d[101],n;int map[101][101];bool v[101];void dij()&#123; int index; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; v[i]&#x3D;0; d[i]&#x3D;map[1][i]; &#125; v[1]&#x3D;1; d[1]&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; int minn&#x3D;MAX; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(v[j]&#x3D;&#x3D;0&amp;&amp;d[j]&lt;minn) &#123; minn&#x3D;d[j]; index&#x3D;j; &#125; &#125; v[index]&#x3D;1; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(v[j]&#x3D;&#x3D;0&amp;&amp;(d[j]&gt;d[index]+map[index][j])) &#123; d[j]&#x3D;d[index]+map[index][j]; &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; &#x2F;&#x2F;map[i][i]&#x3D;0; for(int j&#x3D;1;j&lt;i;j++) &#123; string s; cin&gt;&gt;s; if(s&#x3D;&#x3D;&quot;x&quot;) map[i][j]&#x3D;map[j][i]&#x3D;MAX; else map[i][j]&#x3D;map[j][i]&#x3D;atoi(s.c_str()); &#125; &#125; dij(); int maxx&#x3D;-1; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(d[i]&gt;maxx) &#123; maxx&#x3D;d[i]; &#125; &#125; cout&lt;&lt;maxx&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"最短路径","slug":"最短路径","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"POJ-3259-Wormholes","slug":"POJ-3259-Wormholes","date":"2020-03-07T01:17:58.264Z","updated":"2020-03-07T01:25:28.982Z","comments":true,"path":"2020/03/07/POJ-3259-Wormholes/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/07/POJ-3259-Wormholes/","excerpt":"负环，注意输入时输入的是正数，要变成负数存起来。这样可能两点之间存在三条边，但bellman对边没有要求，也可以只留两条边，但我觉得没有必要，还得搜索更改。","text":"负环，注意输入时输入的是正数，要变成负数存起来。这样可能两点之间存在三条边，但bellman对边没有要求，也可以只留两条边，但我觉得没有必要，还得搜索更改。 题目虫洞 时限： 2000MS 内存限制： 65536K 提交总数： 79083 接受： 29365 描述在探索他的许多农场时，农夫约翰发现了许多惊人的虫洞。虫洞非常特殊，因为它是一条单向路径，可在您进入虫洞之前将您送至目的地！每个FJ的农场包括Ñ（1≤ ñ ≤500）字段方便地编号为1 .. Ñ，中号*（1≤ *中号 ≤2500）的路径，和w ^*（1≤ *w ^ ≤200）虫洞。 由于FJ是一位狂热的时空旅行爱好者，因此他希望做到以下几点：从某个领域开始，经过一些路径和虫洞，并在他初次离开之前的某个时间返回开始领域。也许他将能够见到自己：）。 为了帮助FJ找出这是否可行与否，他将与完整的地图供你˚F*（1≤ *˚F ≤5）他的农场。路径行驶时间不会超过10,000秒，虫洞也不会使FJ的返回时间超过10,000秒。 输入值第1行：一个整数，˚F。F服务器场说明如下。每个服务器场的第1行：三个空格分隔的整数：N，M和W第2行。每个服务器场的M +1：三个以空格分隔的数字（S，E，T），分别描述：双向路径在S和E之间需要经过T秒。两个字段可能通过一条以上的路径连接。线中号 2 .. 中号 + w ^每个场的1：三个空间分隔的数字（S，E，T）分别描述：从S到E的单向路径，也将旅行者向后移动T秒。 输出量第1行。F：对于每个农场，如果FJ可以实现其目标，则输出“ YES”，否则输出“ NO”（不包括引号）。 样本输入1234567891023 3 11 2 21 3 42 3 13 1 33 2 11 2 32 3 43 1 8 样本输出12没有是 题目大意第一行输入三个正整数，代表点的个数，双向正边数，单向负边数。下面每行输入三个数，起点，终点，花费的时间(注意输入负边时也是正数，需要变成负数存起来)。 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;struct R&#123; int start,end,time;&#125; r[5201];int d[501];int n,m,w;bool bellman()&#123; memset(d,0x3f,sizeof(d)); d[1]&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;2*m+w;j++) &#123; if(d[r[j].end]&gt;d[r[j].start]+r[j].time) &#123; d[r[j].end]&#x3D;d[r[j].start]+r[j].time; &#125; &#125; &#125; for(int j&#x3D;1;j&lt;&#x3D;2*m+w;j++) &#123; if(d[r[j].end]&gt;d[r[j].start]+r[j].time) &#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;w; for(int i&#x3D;1;i&lt;&#x3D;2*m;i+&#x3D;2) &#123; cin&gt;&gt;r[i].start&gt;&gt;r[i].end&gt;&gt;r[i].time; r[i+1].start&#x3D;r[i].end; r[i+1].end&#x3D;r[i].start; r[i+1].time&#x3D;r[i].time; &#125; for(int i&#x3D;2*m+1;i&lt;&#x3D;2*m+w;i++) &#123; int tt; cin&gt;&gt;r[i].start&gt;&gt;r[i].end&gt;&gt;tt; r[i].time&#x3D;-tt; &#125; if(bellman()) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Bellman","slug":"ACM/Bellman","permalink":"https://donghuangzhong.github.io/categories/ACM/Bellman/"}],"tags":[{"name":"负环","slug":"负环","permalink":"https://donghuangzhong.github.io/tags/%E8%B4%9F%E7%8E%AF/"}]},{"title":"POJ-1860-Currency Exchange","slug":"POJ-1860-Currency-Exchange","date":"2020-03-07T00:24:06.000Z","updated":"2020-03-07T01:25:15.626Z","comments":true,"path":"2020/03/07/POJ-1860-Currency-Exchange/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/07/POJ-1860-Currency-Exchange/","excerpt":"dij算法不能处理负边，因为如果有负边就不能确定最小的那个是最优解了。Bellman-Ford可以处理负边，但在结束之前都不是最优解，并且可以处理闭环，因为i次循环可以算出走i步的最优解，所以必须循环n-1次，才能得到最优解，如果要判断是不是有环，需要再循环一次，如果最终的结果有被更改，则代表有环。正负环的初始化不同。","text":"dij算法不能处理负边，因为如果有负边就不能确定最小的那个是最优解了。Bellman-Ford可以处理负边，但在结束之前都不是最优解，并且可以处理闭环，因为i次循环可以算出走i步的最优解，所以必须循环n-1次，才能得到最优解，如果要判断是不是有环，需要再循环一次，如果最终的结果有被更改，则代表有环。正负环的初始化不同。 题目货币兑换 时限： 1000MS 内存限制： 30000K 提交总数： 44848 接受： 17312 描述我们城市有几个货币兑换点。让我们假设每个点专门研究两种特定货币，并且仅使用这些货币执行兑换操作。同一对货币可能有多个要点。每个点都有自己的汇率，A到B的汇率是您获得1A时B的数量。此外，每个兑换点都有一定的佣金，您必须为兑换操作支付的总金额。佣金始终以原始货币收取。例如，如果您想在兑换点将100美元兑换成俄罗斯卢布，汇率为29.75，佣金为0.39，您将获得（100-0.39）* 29.75 = 2963.3975RUR。您肯定知道我们城市可以处理N种不同的货币。让我们为每种货币分配从1到N的唯一整数。然后可以用6个数字描述每个兑换点：整数A和B-​​兑换的货币数量，以及实际R AB，C AB，R BA和C BA-分别将A兑换为B和B兑换为A时的汇率和佣金。尼克拥有货币S的钱，并且想知道在进行一些兑换操作后，他是否可以以某种方式增加其资本。当然，他希望最后用S货币来存钱。帮助他回答这个难题。尼克在进行操作时必须始终拥有非负数的资金。 输入值输入的第一行包含四个数字：N-货币数量，M-兑换点数量，S-Nick拥有的货币数量，V-他拥有的货币单位数量。接下来的M行每行包含6个数字-相应交换点的描述-按上面指定的顺序进行。数字用一个或多个空格分隔。1 &lt;= S &lt;= N &lt;= 100，1 &lt;= M &lt;= 100，V是实数，0 &lt;= V &lt;= 10 3。对于每个点的汇率和佣金是真实的，与小数点后至多两个数字，10给出-2 &lt;=速率&lt;= 10 2，0 &lt;=佣金&lt;= 10 2。如果在此序列中不使用任何交换点以上，则将交换操作的某些序列称为简单序列。您可以假定在任何简单的交换操作序列的末尾和开始处，总和的数值之比小于10 4。 输出量如果Nick可以增加他的财富，则输出YES，否则输出NO到输出文件。 样本输入1233 2 1 20.01 2 1.00 1.00 1.00 1.002 3 1.10 1.00 1.10 1.00 样本输出1是 题目描述第一行输入n,m,s,v分别表示货币的种数，货币转换的方式数，自己拥有的货币的种类，自己拥有货币的数量；接下来m行输入a,b,c,d,e,f表示a向b转换的汇率是c,手续费是d,b向a转换的汇率e,手续费是f.计算方式:（a-d）*c 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int n,m,t;double s,d[101];struct &#123; int a,b; double huilv,tax;&#125; bian[201];bool bellman_ford()&#123; memset(d,0,sizeof(d)); d[t]&#x3D;s; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;2*m;j++) &#123; if(d[bian[j].b]&lt;(d[bian[j].a]-bian[j].tax)*bian[j].huilv) &#123; d[bian[j].b]&#x3D;(d[bian[j].a]-bian[j].tax)*bian[j].huilv; &#125; &#125; &#125; for(int j&#x3D;1;j&lt;&#x3D;2*m;j++) &#123; if(d[bian[j].b]&lt;(d[bian[j].a]-bian[j].tax)*bian[j].huilv) &#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;s; for(int i&#x3D;1;i&lt;&#x3D;2*m;i+&#x3D;2) &#123; cin&gt;&gt;bian[i].a&gt;&gt;bian[i].b&gt;&gt;bian[i].huilv&gt;&gt;bian[i].tax&gt;&gt;bian[i+1].huilv&gt;&gt;bian[i+1].tax; bian[i+1].a&#x3D;bian[i].b; bian[i+1].b&#x3D;bian[i].a; &#125; if(bellman_ford()) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Bellman","slug":"ACM/Bellman","permalink":"https://donghuangzhong.github.io/categories/ACM/Bellman/"}],"tags":[{"name":"正环","slug":"正环","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E7%8E%AF/"}]},{"title":"POJ-3268-Silver Cow Party","slug":"POJ-3268-Silver-Cow-Party","date":"2020-03-06T03:44:08.000Z","updated":"2020-03-06T03:56:45.407Z","comments":true,"path":"2020/03/06/POJ-3268-Silver-Cow-Party/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/06/POJ-3268-Silver-Cow-Party/","excerpt":"上来一看觉得这个题很简单，写出来测试结果也对，一提交，超时。于是我又把cin改成scanf,cin比scanf慢太多了，结果还是超时。这就不是细节问题了，是算法本身的问题，后来把矩阵翻转了一下就可以解决，复杂度从n^3变成n^2，这样一想刚开始的算法太愚蠢了！","text":"上来一看觉得这个题很简单，写出来测试结果也对，一提交，超时。于是我又把cin改成scanf,cin比scanf慢太多了，结果还是超时。这就不是细节问题了，是算法本身的问题，后来把矩阵翻转了一下就可以解决，复杂度从n^3变成n^2，这样一想刚开始的算法太愚蠢了！ 题目银牛党 时限： 2000MS 内存限制： 65536K 提交总数： 38727 接受： 17305 描述从每一个牛ñ农场（1≤ ñ ≤1000）方便地编号为1 .. ñ是要参加大牛党在农场＃举行X（1≤ X ≤ ñ）。共中号*（1≤ *中号 ≤100,000）农场单向（单向道路所连接对;道路我需要Ť 我*（1≤ *Ť 我 ≤100）的时间到横动单元。 每头母牛都必须走到聚会上，聚会结束后，要回到自己的农场。每头母牛都是懒惰的，因此选择了最短时间的最佳路线。由于道路是单向的，所以母牛的回程路线可能与原先到达聚会的路线有所不同。 在所有奶牛中，奶牛步行去聚会和返回所花费的最长时间是多少？ 输入值分别三空格隔开的整数，：1线Ñ，中号，和X线2 .. 中号 1：线我 1描述了道路我有三个空格隔开的整数：甲我，乙我和Ť 我。所描述的道路从农场A i到农场B i延伸，需要经过T i个时间单位。 输出量第1行：一个整数：任何一头母牛必须行走的最长时间。 样本输入1234567894 8 21 2 41 3 21 4 72 1 12 3 53 1 23 4 44 2 3 样本输出110 题目大意输出三个数，n,m,x。n代表点的个数，m代表有向边的个数，x代表集会地点，下面m行:x,y,s。表示x点到y点的有向边的长度是s。要求输出某个点到x,再从x回家的最长距离 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 1001#define MAX 0x3f3f3f3fusing namespace std;int n,m,x,map[N][N],d[N],v[N],bd[N];void dij(int start)&#123; int index,minn; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; v[i]&#x3D;0; d[i]&#x3D;map[start][i]; &#125; v[start]&#x3D;1; for(int k&#x3D;2;k&lt;&#x3D;n;k++) &#123; minn&#x3D;MAX; for(int i&#x3D;1;i&lt;&#x3D;n;i++) if(v[i]&#x3D;&#x3D;0&amp;&amp;d[i]&lt;minn) &#123; minn&#x3D;d[i]; index&#x3D;i; &#125; v[index]&#x3D;1; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(v[i]&#x3D;&#x3D;0&amp;&amp;d[i]&gt;d[index]+map[index][i]) &#123; d[i]&#x3D;d[index]+map[index][i]; &#125; &#125; &#125; &#x2F;&#x2F;cout&lt;&lt;d[end]&lt;&lt;endl;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n&gt;&gt;m&gt;&gt;x; &#x2F;&#x2F;memset(map,0x3f,sizeof(map)); for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;n;j++) map[i][j]&#x3D;MAX; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; cin&gt;&gt;map[x][y]; &#125; dij(x); for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; bd[i]&#x3D;d[i]; for(int j&#x3D;i+1;j&lt;&#x3D;n;j++) &#123; int t&#x3D;map[i][j]; map[i][j]&#x3D;map[j][i]; map[j][i]&#x3D;t; &#125; &#125; dij(x); int jieguo&#x3D;-1; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(i!&#x3D;x&amp;&amp;d[i]!&#x3D;MAX&amp;&amp;bd[i]!&#x3D;MAX&amp;&amp;d[i]+bd[i]&gt;jieguo) jieguo&#x3D;d[i]+bd[i]; &#125; cout&lt;&lt;jieguo&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"有向图绕圈","slug":"有向图绕圈","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%89%E5%90%91%E5%9B%BE%E7%BB%95%E5%9C%88/"},{"name":"翻转矩阵","slug":"翻转矩阵","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5/"}]},{"title":"POJ-1797-Heavy Transportation","slug":"POJ-1797-Heavy-Transportation","date":"2020-03-06T00:57:10.000Z","updated":"2020-03-06T01:17:59.272Z","comments":true,"path":"2020/03/06/POJ-1797-Heavy-Transportation/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/06/POJ-1797-Heavy-Transportation/","excerpt":"dij用途还是很广的，稍微分析一下可行性就可以。可行性主要表现在两部分，第一部分筛选最优解，第二部分更新当前状态。只要这两点可行就可以。注意不能图省事两个循环同时计算和求最优解。","text":"dij用途还是很广的，稍微分析一下可行性就可以。可行性主要表现在两部分，第一部分筛选最优解，第二部分更新当前状态。只要这两点可行就可以。注意不能图省事两个循环同时计算和求最优解。 题目重型运输 时限： 3000MS 内存限制： 30000K 提交总数： 66100 接受： 16246 描述背景雨果重工很高兴。Cargolifter项目崩溃后，他现在可以扩展业务。但是他需要一个聪明的人，告诉他从客户建造巨型钢起重机的地方到所有街道都可以承载重量的地方是否真的有办法。幸运的是，他已经制定了一个计划，包括所有街道，桥梁和所有允许的重量。不幸的是，他不知道如何找到最大重量来告诉客户起重机的重量。但是你当然知道。 问题系统会为您提供城市规划，由交叉口之间的街道（权重限制）描述，该街道编号为1到n。您的任务是找到从1号交叉口（Hugo的位置）到n号交叉口（客户的位置）可以运输的最大重量。您可以假设至少有一条路径。所有街道均可双向行驶。 输入值第一行包含方案（城市计划）的数量。对于每个城市，第一行给出的是路口交叉口数量n（1 &lt;= n &lt;= 1000）和街道数量m。接下来的m行包含整数的三元组，这些整数指定了道路的起点和终点交叉点以及允许的最大权重，该权重为正且不大于1000000。每对交叉点之间最多有一条街道。 输出量每个方案的输出都以包含“方案#i：”的行开头，其中i是从1开始的方案编号。然后打印一行，其中包含Hugo可以运输给客户的最大允许重量。用空白行终止方案的输出。 样本输入123451个3 31 2 31 3 42 3 5 样本输出12方案1：4 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int map[1001][1001];int d[1001];bool v[1001];int q&#x3D;1;int n,index,m,maxx;void dij()&#123; int i,j; for(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; v[i]&#x3D;0; d[i]&#x3D;map[1][i]; &#125; v[1]&#x3D;1; while(v[n]!&#x3D;1) &#123; maxx&#x3D;-1; for(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(v[i]&#x3D;&#x3D;0&amp;&amp;d[i]&gt;maxx) &#123; maxx&#x3D;d[i]; index&#x3D;i; &#125; &#125; v[index]&#x3D;1; for(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int tt&#x3D;map[index][i]&lt;d[index]?map[index][i]:d[index]; if(v[i]&#x3D;&#x3D;0&amp;&amp;(d[i]&lt;tt)) &#123; d[i]&#x3D;tt; &#125; &#125; &#125; printf(&quot;Scenario #%d:\\n%d\\n\\n&quot;,q++,d[n]);&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; map[i][j]&#x3D;0; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int a,b,w; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w); map[a][b]&#x3D;map[b][a]&#x3D;w; &#125; dij(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"最大最小距离","slug":"最大最小距离","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"}]},{"title":"POJ-2253-Frogger","slug":"POJ-2253-Frogger","date":"2020-03-05T07:16:38.000Z","updated":"2020-03-05T07:49:10.697Z","comments":true,"path":"2020/03/05/POJ-2253-Frogger/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/05/POJ-2253-Frogger/","excerpt":"跟dij算法的可行性一样，分为两个集合，一个是处理完的集合a(a中存在起点s),一个是待处理的集合b，取b中所求量(一般为最短型，可以是总路径，也可以是组内路径)最小的那个点c，那么s到c的最优解就能够确定下来，c的上一个点p，要么在a中，要么在b中，在b中不可能，因为b中除了c点别的点都要比c大(我们之前的取得C是最小的)，所以p点只能在a中。如果a中只有起点s，那么s到c的最小值就是s到c的距离，把c加入a集合，同时更新b集合中的点到s的距离，这样就能保证每次保留的都是b集合中每一个点到a集合的距离，再取最小值……","text":"跟dij算法的可行性一样，分为两个集合，一个是处理完的集合a(a中存在起点s),一个是待处理的集合b，取b中所求量(一般为最短型，可以是总路径，也可以是组内路径)最小的那个点c，那么s到c的最优解就能够确定下来，c的上一个点p，要么在a中，要么在b中，在b中不可能，因为b中除了c点别的点都要比c大(我们之前的取得C是最小的)，所以p点只能在a中。如果a中只有起点s，那么s到c的最小值就是s到c的距离，把c加入a集合，同时更新b集合中的点到s的距离，这样就能保证每次保留的都是b集合中每一个点到a集合的距离，再取最小值…… 题目蛙人 时限： 1000MS 内存限制： 65536K 提交总数： 77942 接受： 23692 描述弗雷迪·青蛙坐在湖中间的一块石头上。突然，他注意到坐在另一块石头上的菲奥娜·青蛙。他计划去探望她，但由于水很脏，到处都是游客的防晒霜，他想避免游泳，而是跳跳来到达她。不幸的是，菲奥娜的石头不在他的跳跃范围内。因此，弗雷迪（Freddy）考虑使用其他石头作为中间停靠点，并通过几次小跳的顺序到达她。为了执行给定的跳跃序列，青蛙的跳跃范围显然必须至少与序列中发生的最长跳跃一样长。因此，将两块石头之间的青蛙距离（人类也称为最小最大距离）定义为两块石头之间所有可能路径上的最小必要跳跃范围。 您将获得弗雷迪石头，菲奥娜石头和湖中所有其他石头的坐标。您的工作是计算Freddy和Fiona的石头之间的青蛙距离。 输入值输入将包含一个或多个测试用例。每个测试用例的第一行将包含结石数量n（2 &lt;= n &lt;= 200）。接下来的n条线分别包含两个整数xi，yi（0 &lt;= xi，yi &lt;= 1000），它们表示石头#i的坐标。第1块石头是弗雷迪的石头，第2块石头是菲奥娜的石头，其他n-2块石头未被占用。每个测试用例后面都有一个空白行。输入以n的零（0）值终止。 输出量对于每个测试用例，打印一行“ Scenario #x”和一行“ Frog Distance = y”，其中x替换为测试用例编号（从1开始编号），y替换为适当的实数，打印到三位小数。在每个测试用例之后，甚至在最后一个测试用例之后，都应留一个空白行。 样本输入123456789102 0 0 3 4 3 17 4 19 4 18 5 0 样本输出12345方案＃1 青蛙距离&#x3D; 5.000 方案＃2 青蛙距离&#x3D; 1.414 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int n,MAX&#x3D;0x3f3f3f3f;int x[201];int y[201];double d[201];bool v[201];double map[201][201];int index;int q&#x3D;1;double minn;void dij()&#123; memset(v,0,sizeof(v)); d[1]&#x3D;0; v[1]&#x3D;1; int mubiao&#x3D;1; while(v[2]!&#x3D;1) &#123; minn&#x3D;MAX; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(v[i]&#x3D;&#x3D;0) &#123; if(max(d[mubiao],map[mubiao][i])&lt;d[i]) &#123; d[i]&#x3D;max(d[mubiao],map[mubiao][i]); &#125; if(d[i]&lt;minn) &#123; minn&#x3D;d[i]; index&#x3D;i; &#125; &#125; &#125; v[index]&#x3D;1; mubiao&#x3D;index; &#125; printf(&quot;Scenario #%d\\nFrog Distance &#x3D; %.3f\\n\\n&quot;,q++,d[2]); &#x2F;&#x2F;printf(&quot;%.3f\\n&quot;,d[2]);&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;n&amp;&amp;n) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; cin&gt;&gt;x[i]&gt;&gt;y[i]; &#125; &#x2F;&#x2F;memset(map,0,sizeof(map)); for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; map[i][i]&#x3D;0; d[i]&#x3D;MAX; for(int j&#x3D;1;j&lt;&#x3D;i-1;j++) &#123; map[i][j]&#x3D;map[j][i]&#x3D;sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])); &#125; &#125; dij(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"组内最短路径","slug":"组内最短路径","permalink":"https://donghuangzhong.github.io/tags/%E7%BB%84%E5%86%85%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"POJ-2387-Til the Cows Come Home","slug":"POJ-2387-Til-the-Cows-Come-Home","date":"2020-03-05T00:46:24.000Z","updated":"2020-03-05T08:51:12.523Z","comments":true,"path":"2020/03/05/POJ-2387-Til-the-Cows-Come-Home/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/05/POJ-2387-Til-the-Cows-Come-Home/","excerpt":"dijkstra算法，非简单可达路径不要用DFS；如果要输出路径保存在标志数组中，递归输出；变与不变的情况最好不用三目运算符","text":"dijkstra算法，非简单可达路径不要用DFS；如果要输出路径保存在标志数组中，递归输出；变与不变的情况最好不用三目运算符 题目http://poj.org/problem?id=2387 直到母牛回家 时限： 1000MS 内存限制： 65536K 提交总数： 100676 接受的： 32539 描述贝西（Bessie）在野外，想回到谷仓，以便在农夫约翰（Johner John）叫醒她早晨挤奶之前尽可能多地入睡。贝西需要美睡，所以她想尽快回来。 农夫约翰的田地中有N（2 &lt;= N &lt;= 1000）个地标，唯一编号为1..N。地标1是谷仓；Bessie整日站立的苹果树丛是地标N。奶牛使用地标之间长度各不相同的T（1 &lt;= T &lt;= 2000）双向奶牛场在田间旅行。贝西对自己的导航能力不抱有信心，因此，从开始到结束，她始终处在步道上。 给定地标之间的路径，确定Bessie返回谷仓必须行走的最小距离。可以保证存在这样的路由。 输入值*第1行：两个整数：T和N *第2..T + 1行：每行将一个轨迹描述为三个以空格分隔的整数。前两个整数是小径在其间行进的地标。第三个整数是路径的长度，范围为1..100。 输出量*第1行：一个整数，Bessie从地标N到地标1所必须经过的最小距离。 样本输入1234565 51 2 202 3 303 4 204 5 201 5 100 样本输出190 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int N[1001];bool v[1001];int map[1001][1001];int n,x,index,mubiao; int MAX&#x3D;0x3f3f3f3f;void dij()&#123; N[x]&#x3D;0; v[x]&#x3D;1; int mubiao&#x3D;x; while(v[1]!&#x3D;1) &#123; int min&#x3D;MAX; for(int i&#x3D;1;i&lt;&#x3D;x;i++) &#123; if(v[i]&#x3D;&#x3D;0) &#123; int t&#x3D;N[mubiao]+map[mubiao][i]; if(N[i]&gt;t) N[i]&#x3D;t; if(N[i]&lt;min)&#123; min&#x3D;N[i]; index&#x3D;i; &#125; &#125; &#125; v[index]&#x3D;1; mubiao&#x3D;index; &#125; cout&lt;&lt;N[1]&lt;&lt;endl;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;n&gt;&gt;x) &#123; &#x2F;&#x2F;memset(map,0x3f,sizeof(map)); &#x2F;&#x2F;memset(v,0,sizeof(v)); &#x2F;&#x2F;memset(N,0x3f,sizeof(N)); for(int i&#x3D;1;i&lt;&#x3D;x;i++) &#123; N[i]&#x3D;MAX; v[i]&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;x;j++) &#123; map[i][j]&#x3D;MAX; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int j,k,dd; cin&gt;&gt;j&gt;&gt;k; cin&gt;&gt;dd; if(dd&lt;map[j][k]) &#123; map[j][k]&#x3D;dd; map[k][j]&#x3D;dd; &#125; &#125; dij(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"最短路径","slug":"最短路径","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"HDU-2102-A计划","slug":"HDU-2102-A计划","date":"2020-03-03T02:39:56.000Z","updated":"2020-03-03T02:49:20.495Z","comments":true,"path":"2020/03/03/HDU-2102-A计划/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/03/HDU-2102-A%E8%AE%A1%E5%88%92/","excerpt":"两层迷宫，‘#’代表瞬时传送装置，如果传送后是墙则撞死，如果传送后是‘#’，则一直在传送，必须考虑这两种情况。","text":"两层迷宫，‘#’代表瞬时传送装置，如果传送后是墙则撞死，如果传送后是‘#’，则一直在传送，必须考虑这两种情况。 题目A计划\\Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 38233 Accepted Submission(s): 9470** Problem Description 可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用*表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。 Input 输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小NM（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前NM表示迷宫的第一层的布置情况，后N*M表示迷宫第二层的布置情况。 Output 如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。 Sample Input 1234567891011121315 5 14S*#*..#........****....#...*.P#.*..***.....*.*.#.. Sample Output 1YES 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;struct Point&#123; int x,y,z;&#125; a,b;int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;int m,n,t,zx,zy,zz;char map[2][10][10];int v[2][10][10];void bfs()&#123; memset(v,0,sizeof(v)); v[0][0][0]&#x3D;1; a.x&#x3D;0;a.y&#x3D;0;a.z&#x3D;0; queue&lt;Point&gt; q; q.push(a); while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x; b.y&#x3D;a.y+dir[i][0]; b.z&#x3D;a.z+dir[i][1]; if(b.y&gt;&#x3D;0&amp;&amp;b.y&lt;m&amp;&amp;b.z&gt;&#x3D;0&amp;&amp;b.z&lt;n&amp;&amp;map[b.x][b.y][b.z]!&#x3D;&#39;*&#39;&amp;&amp;v[b.x][b.y][b.z]&#x3D;&#x3D;0) &#123; v[b.x][b.y][b.z]&#x3D;v[a.x][a.y][a.z]+1; if(map[b.x][b.y][b.z]&#x3D;&#x3D;&#39;#&#39;) &#123; int tt&#x3D;v[b.x][b.y][b.z]; b.x&#x3D;(b.x&#x3D;&#x3D;1?0:1); if(map[b.x][b.y][b.z]&#x3D;&#x3D;&#39;*&#39;||map[b.x][b.y][b.z]&#x3D;&#x3D;&#39;#&#39;) continue; v[b.x][b.y][b.z]&#x3D;tt; &#125; if(v[b.x][b.y][b.z]-1&gt;t)&#123;cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;return;&#125; if(map[b.x][b.y][b.z]&#x3D;&#x3D;&#39;P&#39;) &#123;cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; return;&#125; q.push(b); &#125; &#125; &#125; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int c; cin&gt;&gt;c; while(c--)&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;t; for(int k&#x3D;0;k&lt;2;k++) for(int i&#x3D;0;i&lt;m;i++) for(int j&#x3D;0;j&lt;n;j++) cin&gt;&gt;map[k][i][j]; bfs(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"易错题","slug":"易错题","permalink":"https://donghuangzhong.github.io/tags/%E6%98%93%E9%94%99%E9%A2%98/"},{"name":"标志数组做记录","slug":"标志数组做记录","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%81%9A%E8%AE%B0%E5%BD%95/"}]},{"title":"HDU-2181-哈密顿绕行问题","slug":"HDU-2181-哈密顿绕行问题","date":"2020-03-03T00:35:19.000Z","updated":"2020-03-03T00:42:31.992Z","comments":true,"path":"2020/03/03/HDU-2181-哈密顿绕行问题/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/03/HDU-2181-%E5%93%88%E5%AF%86%E9%A1%BF%E7%BB%95%E8%A1%8C%E9%97%AE%E9%A2%98/","excerpt":"DFS遍历所有可能性","text":"DFS遍历所有可能性 题目哈密顿绕行世界问题\\Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 10731 Accepted Submission(s): 6191** Problem Description 一个规则的实心十二面体，它的 20个顶点标出世界著名的20个城市，你从一个城市出发经过每个城市刚好一次后回到出发的城市。 Input 前20行的第i行有3个数,表示与第i个城市相邻的3个城市.第20行以后每行有1个数m,m&lt;=20,m&gt;=1.m=0退出. Output 输出从第m个城市出发经过每个城市1次又回到m的所有路线,如有多条路线,按字典序输出,每行1条路线.每行首先输出是第几条路线.然后个一个: 后列出经过的城市.参看Sample output Sample Input 123456789101112131415161718192021222 5 201 3 122 4 103 5 81 4 65 7 196 8 174 7 98 10 163 9 1110 12 152 11 1312 14 2013 15 1811 14 169 15 177 16 1814 17 196 18 201 13 1950 Sample Output 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601: 5 1 2 3 4 8 7 17 18 14 15 16 9 10 11 12 13 20 19 6 52: 5 1 2 3 4 8 9 10 11 12 13 20 19 18 14 15 16 17 7 6 53: 5 1 2 3 10 9 16 17 18 14 15 11 12 13 20 19 6 7 8 4 54: 5 1 2 3 10 11 12 13 20 19 6 7 17 18 14 15 16 9 8 4 55: 5 1 2 12 11 10 3 4 8 9 16 15 14 13 20 19 18 17 7 6 56: 5 1 2 12 11 15 14 13 20 19 18 17 16 9 10 3 4 8 7 6 57: 5 1 2 12 11 15 16 9 10 3 4 8 7 17 18 14 13 20 19 6 58: 5 1 2 12 11 15 16 17 18 14 13 20 19 6 7 8 9 10 3 4 59: 5 1 2 12 13 20 19 6 7 8 9 16 17 18 14 15 11 10 3 4 510: 5 1 2 12 13 20 19 18 14 15 11 10 3 4 8 9 16 17 7 6 511: 5 1 20 13 12 2 3 4 8 7 17 16 9 10 11 15 14 18 19 6 512: 5 1 20 13 12 2 3 10 11 15 14 18 19 6 7 17 16 9 8 4 513: 5 1 20 13 14 15 11 12 2 3 10 9 16 17 18 19 6 7 8 4 514: 5 1 20 13 14 15 16 9 10 11 12 2 3 4 8 7 17 18 19 6 515: 5 1 20 13 14 15 16 17 18 19 6 7 8 9 10 11 12 2 3 4 516: 5 1 20 13 14 18 19 6 7 17 16 15 11 12 2 3 10 9 8 4 517: 5 1 20 19 6 7 8 9 10 11 15 16 17 18 14 13 12 2 3 4 518: 5 1 20 19 6 7 17 18 14 13 12 2 3 10 11 15 16 9 8 4 519: 5 1 20 19 18 14 13 12 2 3 4 8 9 10 11 15 16 17 7 6 520: 5 1 20 19 18 17 16 9 10 11 15 14 13 12 2 3 4 8 7 6 521: 5 4 3 2 1 20 13 12 11 10 9 8 7 17 16 15 14 18 19 6 522: 5 4 3 2 1 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 523: 5 4 3 2 12 11 10 9 8 7 6 19 18 17 16 15 14 13 20 1 524: 5 4 3 2 12 13 14 18 17 16 15 11 10 9 8 7 6 19 20 1 525: 5 4 3 10 9 8 7 6 19 20 13 14 18 17 16 15 11 12 2 1 526: 5 4 3 10 9 8 7 17 16 15 11 12 2 1 20 13 14 18 19 6 527: 5 4 3 10 11 12 2 1 20 13 14 15 16 9 8 7 17 18 19 6 528: 5 4 3 10 11 15 14 13 12 2 1 20 19 18 17 16 9 8 7 6 529: 5 4 3 10 11 15 14 18 17 16 9 8 7 6 19 20 13 12 2 1 530: 5 4 3 10 11 15 16 9 8 7 17 18 14 13 12 2 1 20 19 6 531: 5 4 8 7 6 19 18 17 16 9 10 3 2 12 11 15 14 13 20 1 532: 5 4 8 7 6 19 20 13 12 11 15 14 18 17 16 9 10 3 2 1 533: 5 4 8 7 17 16 9 10 3 2 1 20 13 12 11 15 14 18 19 6 534: 5 4 8 7 17 18 14 13 12 11 15 16 9 10 3 2 1 20 19 6 535: 5 4 8 9 10 3 2 1 20 19 18 14 13 12 11 15 16 17 7 6 536: 5 4 8 9 10 3 2 12 11 15 16 17 7 6 19 18 14 13 20 1 537: 5 4 8 9 16 15 11 10 3 2 12 13 14 18 17 7 6 19 20 1 538: 5 4 8 9 16 15 14 13 12 11 10 3 2 1 20 19 18 17 7 6 539: 5 4 8 9 16 15 14 18 17 7 6 19 20 13 12 11 10 3 2 1 540: 5 4 8 9 16 17 7 6 19 18 14 15 11 10 3 2 12 13 20 1 541: 5 6 7 8 4 3 2 12 13 14 15 11 10 9 16 17 18 19 20 1 542: 5 6 7 8 4 3 10 9 16 17 18 19 20 13 14 15 11 12 2 1 543: 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 544: 5 6 7 8 9 16 17 18 19 20 1 2 12 13 14 15 11 10 3 4 545: 5 6 7 17 16 9 8 4 3 10 11 15 14 18 19 20 13 12 2 1 546: 5 6 7 17 16 15 11 10 9 8 4 3 2 12 13 14 18 19 20 1 547: 5 6 7 17 16 15 11 12 13 14 18 19 20 1 2 3 10 9 8 4 548: 5 6 7 17 16 15 14 18 19 20 13 12 11 10 9 8 4 3 2 1 549: 5 6 7 17 18 19 20 1 2 3 10 11 12 13 14 15 16 9 8 4 550: 5 6 7 17 18 19 20 13 14 15 16 9 8 4 3 10 11 12 2 1 551: 5 6 19 18 14 13 20 1 2 12 11 15 16 17 7 8 9 10 3 4 552: 5 6 19 18 14 15 11 10 9 16 17 7 8 4 3 2 12 13 20 1 553: 5 6 19 18 14 15 11 12 13 20 1 2 3 10 9 16 17 7 8 4 554: 5 6 19 18 14 15 16 17 7 8 9 10 11 12 13 20 1 2 3 4 555: 5 6 19 18 17 7 8 4 3 2 12 11 10 9 16 15 14 13 20 1 556: 5 6 19 18 17 7 8 9 16 15 14 13 20 1 2 12 11 10 3 4 557: 5 6 19 20 1 2 3 10 9 16 15 11 12 13 14 18 17 7 8 4 558: 5 6 19 20 1 2 12 13 14 18 17 7 8 9 16 15 11 10 3 4 559: 5 6 19 20 13 12 11 10 9 16 15 14 18 17 7 8 4 3 2 1 560: 5 6 19 20 13 14 18 17 7 8 4 3 10 9 16 15 11 12 2 1 5 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int nn,Case;bool v[21];int l[21];struct Point&#123; int xianglin[3];&#125; map[21];void dfs(int n)&#123; if(n&#x3D;&#x3D;21)&#123; for(int i&#x3D;0;i&lt;3;i++) &#123; if(map[l[n-1]].xianglin[i]&#x3D;&#x3D;nn) &#123; cout&lt;&lt;Case++&lt;&lt;&quot;: &quot;; for(int j&#x3D;1;j&lt;21;j++) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;l[j]; &#125; cout&lt;&lt;&quot; &quot;&lt;&lt;l[1]; cout&lt;&lt;endl; &#125; &#125; return; &#125; for(int i&#x3D;0;i&lt;3;i++) &#123; if(v[map[l[n-1]].xianglin[i]]&#x3D;&#x3D;0) &#123; v[map[l[n-1]].xianglin[i]]&#x3D;1; l[n]&#x3D;map[l[n-1]].xianglin[i]; dfs(n+1); v[map[l[n-1]].xianglin[i]]&#x3D;0; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); for(int i &#x3D; 1; i &lt; 21; i++) &#123; cin&gt;&gt;map[i].xianglin[0]&gt;&gt;map[i].xianglin[1]&gt;&gt;map[i].xianglin[2]; &#125; while(cin&gt;&gt;nn&amp;&amp;nn)&#123; Case&#x3D;1; memset(v,0,sizeof(v)); v[nn]&#x3D;1; l[1]&#x3D;nn; dfs(2); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DFS","slug":"ACM/DFS","permalink":"https://donghuangzhong.github.io/categories/ACM/DFS/"}],"tags":[{"name":"遍历所有可能性","slug":"遍历所有可能性","permalink":"https://donghuangzhong.github.io/tags/%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E6%80%A7/"}]},{"title":"HDU-2612","slug":"HDU-2612","date":"2020-03-02T01:47:16.000Z","updated":"2020-03-02T01:58:36.944Z","comments":true,"path":"2020/03/02/HDU-2612/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/02/HDU-2612/","excerpt":"两个标志数组，两次BFS，不是双BFS，双BFS应该是双入口BFS，是一次BFS，两个入口而已，UVA-11624这才是双入口BFS。二维数组对应的函数形参必须声明第二维，并且不能对传进函数的形参用memset,因为sizeof(数组)不对，这样只能自行指定memset的大小了。","text":"两个标志数组，两次BFS，不是双BFS，双BFS应该是双入口BFS，是一次BFS，两个入口而已，UVA-11624这才是双入口BFS。二维数组对应的函数形参必须声明第二维，并且不能对传进函数的形参用memset,因为sizeof(数组)不对，这样只能自行指定memset的大小了。 问题想办法\\时间限制：3000/1000 MS（Java /其他）内存限制：32768/32768 K（Java /其他）总提交数量：35622接受提交数量：11329** 问题描述 终于在杭州经过一年的学习，一分飞终于到了宁波。离开宁波一年后，一分飞有很多人见面。特别是好朋友Merceki。Yifenfei的家在乡下，而Merceki的家在城市中心。因此，易芬菲与Merceki安排了在肯德基会面。宁波有很多肯德基，他们想选择一种让总时间最短的肯德基。现在给您一张宁波地图，yifenfei和Merceki都可以通过成本11分钟左右上下移动到相邻的道路。 输入值 输入包含多个测试用例。每个测试用例包括前两个整数n，m。（2 &lt;= n，m &lt;= 200）。接下来的n行，每行包含m个字符。“ Y”表示一分钱的初始职位。“ M”表示Merceki的初始位置。‘＃’禁止道路；‘。’ 路。‘@’KCF 输出量 对于每个测试用例输出，yifenfei和Merceki到达肯德基之一的最短总时间。您可以肯定总是有一个肯德基可以让他们见面。 样本输入 123456789101112131415164 4Y。＃@....。＃..@ .. M4 4Y。＃@....。＃..@＃。M5 5Y .. @。。＃...。＃...@ .. M。＃...＃ 样本输出 123668866 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;char map[201][201];int v1[201][201];int v2[201][201];int m,n,minn;int dir[4][2]&#x3D;&#123;0,1,1,0,0,-1,-1,0&#125;;struct Point&#123; int x,y;&#125; a,b,y,M;void bfs(int x,int y,int v[201][201])&#123; memset(v,0,4*201*201); a.x&#x3D;x;a.y&#x3D;y; queue&lt;Point&gt; q; q.push(a); v[x][y]&#x3D;1; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(b.x&gt;&#x3D;0&amp;&amp;b.x&lt;m&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;n&amp;&amp;map[b.x][b.y]!&#x3D;&#39;#&#39;&amp;&amp;v[b.x][b.y]&#x3D;&#x3D;0) &#123; v[b.x][b.y]&#x3D;v[a.x][a.y]+1; q.push(b); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;m&gt;&gt;n) &#123; for(int i&#x3D;0;i&lt;m;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]&#x3D;&#x3D;&#39;Y&#39;) &#123; y.x&#x3D;i;y.y&#x3D;j; &#125; if(map[i][j]&#x3D;&#x3D;&#39;M&#39;) &#123; M.x&#x3D;i;M.y&#x3D;j; &#125; &#125; &#125; bfs(y.x,y.y,v1); bfs(M.x,M.y,v2); minn&#x3D;1000000; for(int i&#x3D;0;i&lt;m;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; if(map[i][j]&#x3D;&#x3D;&#39;@&#39;&amp;&amp;v1[i][j]&amp;&amp;v2[i][j]) &#123; v2[i][j]+&#x3D;v1[i][j]-2; if(v2[i][j]&lt;minn) &#123; minn&#x3D;v2[i][j]; &#125; &#125; &#125;&#125; cout&lt;&lt;minn*11&lt;&lt;endl; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"两次BFS","slug":"两次BFS","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%A4%E6%AC%A1BFS/"},{"name":"函数数组形参","slug":"函数数组形参","permalink":"https://donghuangzhong.github.io/tags/%E5%87%BD%E6%95%B0%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82/"}]},{"title":"HDU-1495","slug":"HDU-1495","date":"2020-02-29T09:43:05.000Z","updated":"2020-03-02T01:41:23.273Z","comments":true,"path":"2020/02/29/HDU-1495/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/29/HDU-1495/","excerpt":"搜索所有的状态，标志数组同时用于记录次数，最后减一，用i!=j的方式遍历倒法，用3-i-j得到剩余的被子杯子的可乐。网上有一份数论的做法，极为精简，以后再研究吧。路漫漫其修远兮！","text":"搜索所有的状态，标志数组同时用于记录次数，最后减一，用i!=j的方式遍历倒法，用3-i-j得到剩余的被子杯子的可乐。网上有一份数论的做法，极为精简，以后再研究吧。路漫漫其修远兮！ 题目非常可乐\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 36161 Accepted Submission(s): 14072** Problem Description 大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 Input 三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。 Output 如果能平分的话请输出最少要倒的次数，否则输出”NO”。 Sample Input 1237 4 34 1 30 0 0 Sample Output 12NO3 算法刚开始状态为0,0,s。之后模拟所有倒法共有6种，能倒的前提是本瓶子有水，被倒的瓶子有空闲容量。根据这两个的大小倒之后可能有两个状态，本瓶子空，被倒瓶子水增加；本瓶子非空，被盗瓶子满。得到倒之后的状态，判断是否到达过这个状态，没有则步数加一…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int m,n,s;int v[101][101][101];int r[3];struct S&#123; int c[3];&#125; a,b;void bfs()&#123; a.c[0]&#x3D;0; a.c[1]&#x3D;0; a.c[2]&#x3D;s; v[0][0][s]&#x3D;1; queue&lt;S&gt; q; q.push(a); while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;3;i++) &#123; for(int j&#x3D;0;j&lt;3;j++) &#123; if(i!&#x3D;j) &#123; if(a.c[i]&gt;0&amp;&amp;r[j]-a.c[j]&gt;0) &#123; if(a.c[i]&gt;&#x3D;r[j]-a.c[j]) &#123;b.c[j]&#x3D;r[j]; b.c[i]&#x3D;a.c[i]-r[j]+a.c[j]; b.c[3-i-j]&#x3D;a.c[3-i-j]; &#125; else &#123; b.c[i]&#x3D;0; b.c[j]&#x3D;a.c[j]+a.c[i]; b.c[3-i-j]&#x3D;a.c[3-i-j]; &#125; if(v[b.c[0]][b.c[1]][b.c[2]]&#x3D;&#x3D;0) &#123; v[b.c[0]][b.c[1]][b.c[2]]&#x3D;v[a.c[0]][a.c[1]][a.c[2]]+1; if((b.c[0]&#x3D;&#x3D;s&#x2F;2&amp;&amp;b.c[1]&#x3D;&#x3D;s&#x2F;2)||(b.c[1]&#x3D;&#x3D;s&#x2F;2&amp;&amp;b.c[2]&#x3D;&#x3D;s&#x2F;2)||(b.c[0]&#x3D;&#x3D;s&#x2F;2&amp;&amp;b.c[2]&#x3D;&#x3D;s&#x2F;2)) &#123;cout&lt;&lt;v[b.c[0]][b.c[1]][b.c[2]]-1&lt;&lt;endl; return; &#125; q.push(b); &#125; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;s&gt;&gt;n&gt;&gt;m&amp;&amp;m&amp;&amp;n&amp;&amp;s) &#123; if(s%2 &#x3D;&#x3D; 1)&#123; printf(&quot;NO\\n&quot;); continue; &#125; memset(v,0,sizeof(v)); r[0]&#x3D;m; r[1]&#x3D;n; r[2]&#x3D;s; bfs(); &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"倒水","slug":"倒水","permalink":"https://donghuangzhong.github.io/tags/%E5%80%92%E6%B0%B4/"},{"name":"数论","slug":"数论","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"HDU-1241","slug":"HDU-1241","date":"2020-02-23T11:57:05.000Z","updated":"2020-02-23T11:59:40.268Z","comments":true,"path":"2020/02/23/HDU-1241/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/23/HDU-1241/","excerpt":"简单BFS，找到一个入队点将所有可达的区域置为不可达","text":"简单BFS，找到一个入队点将所有可达的区域置为不可达 题目油藏\\时间限制：2000/1000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）提交总数：58896接受提交：33745** 问题描述 GeoSurvComp地质勘测公司负责检测地下油藏。GeoSurvComp一次处理一个大矩形区域的土地，并创建一个将土地划分为多个正方形图的网格。然后，它使用传感设备分别分析每个地块，以确定该地块是否包含油。包含油的地块称为矿穴。如果两个凹坑相邻，则它们是同一油藏的一部分。积油可能很大，可能包含许多凹穴。您的工作是确定网格中包含多少种不同的油藏。 输入值 输入文件包含一个或多个网格。每个网格均以包含m和n的行开始，网格中的行和列数为m和n，并用单个空格分隔。如果m = 0，则表示输入结束；否则，输入0。否则为1 &lt;= m &lt;= 100和1 &lt;= n &lt;=100。紧随其后的是m行，每行n个字符（不计算行尾字符）。每个字符对应一个地块，要么是代表无油的“ *”，要么是代表油囊的“ @”。 输出量 对于每个网格，输出不同的油藏数量。如果两个不同的油藏在水平，垂直或对角线上相邻，则它们是同一油藏的一部分。积油最多可容纳100个口袋。 样本输入 1234567891011121314151 1 * 3 5 * @ * @ * ** @ ** * @ * @ * 1 8 @@ **** @ * 5 5 **** @ * @@ * @ * @ ** @ @@@ * @ @@ ** @ 0 0 样本输出 12340 1 2 2 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int dir[8][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1,1,1,-1,-1,1,-1,-1,1&#125;;char map[101][101]; struct Point&#123; int x,y;&#125; a,b;int h,l;void bfs(int x,int y)&#123; queue&lt;Point&gt; q; a.x&#x3D;x; a.y&#x3D;y; q.push(a); map[x][y]&#x3D;&#39;*&#39;; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;8;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(b.x&gt;&#x3D;0&amp;&amp;b.x&lt;h&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;l&amp;&amp;map[b.x][b.y]&#x3D;&#x3D;&#39;@&#39;) &#123; map[b.x][b.y]&#x3D;&#39;*&#39;; q.push(b); &#125; &#125; &#125; &#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;h&gt;&gt;l&amp;&amp;h&amp;&amp;l) &#123; int sum&#x3D;0; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; cin&gt;&gt;map[i][j]; &#125; &#125; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; if(map[i][j]&#x3D;&#x3D;&#39;@&#39;) &#123; bfs(i,j); sum++; &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"},{"name":"图的连通区域","slug":"图的连通区域","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%8C%BA%E5%9F%9F/"}]},{"title":"迷宫问题","slug":"迷宫问题","date":"2020-02-23T10:16:02.000Z","updated":"2020-02-23T10:20:59.846Z","comments":true,"path":"2020/02/23/迷宫问题/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/23/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/","excerpt":"每个节点的去向有很多，不变保存，每个点的来源只有一个，方便保存，但是是逆序的，最后要递归输出","text":"每个节点的去向有很多，不变保存，每个点的来源只有一个，方便保存，但是是逆序的，最后要递归输出 题目迷宫问题定义一个二维数组： 1234567int maze[5][5] &#x3D; &#123; 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,&#125;; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 Input 一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。 Output 左上角到右下角的最短路径，格式如样例所示。 Sample Input123450 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0 Sample Output123456789(0, 0)(1, 0)(2, 0)(2, 1)(2, 2)(2, 3)(2, 4)(3, 4)(4, 4) 算法用另外一个和map一样大小的数组保存该点的上一个点的坐标，然后递归输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std; int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;struct Point&#123; int x; int y;&#125; a,b,point[5][5];int map[5][5];void printxy(int x,int y)&#123; if(x&#x3D;&#x3D;-1&amp;&amp;y&#x3D;&#x3D;-1) return ; printxy(point[x][y].x,point[x][y].y); cout&lt;&lt;&quot;(&quot;&lt;&lt;x&lt;&lt;&quot;, &quot;&lt;&lt;y&lt;&lt;&quot;)&quot;&lt;&lt;endl;&#125;void bfs()&#123; queue&lt;Point&gt; q; a.x&#x3D;0; a.y&#x3D;0; q.push(a); map[0][0]&#x3D;1; point[0][0].x&#x3D;-1; point[0][0].y&#x3D;-1; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(b.x&gt;&#x3D;0&amp;&amp;b.x&lt;5&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;5&amp;&amp;map[b.x][b.y]&#x3D;&#x3D;0) &#123; map[b.x][b.y]&#x3D;1; point[b.x][b.y].x&#x3D;a.x; point[b.x][b.y].y&#x3D;a.y; if(b.x&#x3D;&#x3D;4&amp;&amp;b.y&#x3D;&#x3D;4) &#123; printxy(4,4); &#125; q.push(b); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); for(int i&#x3D;0;i&lt;5;i++) &#123; for(int j&#x3D;0;j&lt;5;j++) &#123; cin&gt;&gt;map[i][j]; &#125; &#125; bfs(); return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"输出路径","slug":"输出路径","permalink":"https://donghuangzhong.github.io/tags/%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84/"}]},{"title":"UVA-11624","slug":"UVA-11624","date":"2020-02-23T04:24:43.000Z","updated":"2020-02-23T06:09:58.176Z","comments":true,"path":"2020/02/23/UVA-11624/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/23/UVA-11624/","excerpt":"一个BFS，多个入口，char的表示范围[0,127]，本来可以不用标志数组的，节省空间，但奈何char表示不了比较大的数","text":"一个BFS，多个入口，char的表示范围[0,127]，本来可以不用标志数组的，节省空间，但奈何char表示不了比较大的数 题目火场逃生一个矩阵中有一个人，用J表示，可以向上下左右走。有多个起火点，用F表示。#表示墙，.表示人可以行走的地方。要求是逃出这个矩阵即可，输出逃出这个矩阵的最短时间，如果不能逃出这个矩阵输出IMPOSSIBEL Sample Input1234567891024 4#### #JF# #..# #..# 3 3 ### #J. #.F Sample Output123 IMPOSSIBLE 算法单个BFS火场逃生是一个连续的过程，同时有火的蔓延和人的移动。但可以将这个连续的过程分割，比如人先走一步，火再蔓延一步，人再走一步，火再蔓延一步······。可是既然是同时发生的，谁先谁后呢？肯定是人先火后了，因为这样不会改变的火场逃生的结果。不然火先的话，假设火和人差一步，火先的话人就死了，火场逃生的结果就不符合事实。人先火后的话问题就变得简单起来了，因为人要先行，所以人必须先入队(同时将该点的J，改变为K)，然后才是各个火种的入队。进入循环，取队首，队首出队，判断这个队首是火(火的话就是’F‘)还是人(&gt;=’K’)，如果是人，判断走完下一步是否走出矩阵，如果走出，则直接保存一下时间(这个时间的基数为’K‘，最后要减去’K‘)然后return，否则将这个点可达的’.’置为队首加一(没错，这是一个字符数组，但char和int在[0,127]互通,这也是为什么失败的原因)，可达点入队；如果是火，则将火的可达点(不是火并且不是墙)置为F，可达点入队……循环往复 失败原因：char能表示的int为[0,127]，再加上基数为’K‘，能表示的时间就更短了，无奈溢出。。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;int h,l,startx,starty,firex,firey,mintime;int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;char map[1001][1001];using namespace std;struct Point&#123; int x; int y;&#125; a,b;queue&lt;Point&gt; q;void bfs()&#123; mintime&#x3D;0; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(map[a.x][a.y]&gt;&#x3D;&#39;K&#39;) &#123; if(b.x&lt;0||b.x&gt;&#x3D;h||b.y&lt;0||b.y&gt;&#x3D;l) &#123; mintime&#x3D;map[a.x][a.y]+1-&#39;K&#39;; return ; &#125; else if(map[b.x][b.y]&#x3D;&#x3D;&#39;.&#39;) &#123; map[b.x][b.y]&#x3D;map[a.x][a.y]+1; q.push(b); &#125; &#125; if(map[a.x][a.y]&#x3D;&#x3D;&#39;F&#39;&amp;&amp;b.x&gt;&#x3D;0&amp;&amp;b.x&lt;h&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;l&amp;&amp;map[b.x][b.y]!&#x3D;&#39;F&#39;&amp;&amp;map[b.x][b.y]!&#x3D;&#39;#&#39;) &#123; map[b.x][b.y]&#x3D;&#39;F&#39;; q.push(b); &#125; &#125; &#125; &#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; while(n--) &#123; while(!q.empty()) q.pop(); cin&gt;&gt;h&gt;&gt;l; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]&#x3D;&#x3D;&#39;J&#39;) &#123; startx&#x3D;i; starty&#x3D;j; a.x&#x3D;startx; a.y&#x3D;starty; map[a.x][a.y]&#x3D;&#39;K&#39;; q.push(a); &#125; &#125; &#125; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; if(map[i][j]&#x3D;&#x3D;&#39;F&#39;) &#123; firex&#x3D;i; firey&#x3D;j; a.x&#x3D;firex; a.y&#x3D;firey; q.push(a); &#125; &#125; &#125; bfs(); if(mintime&#x3D;&#x3D;0) cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl; else cout&lt;&lt;mintime&lt;&lt;endl; &#125; return 0; &#125; 这个在UVA上有debug功能，这个算法通过了所有的测试，但还是WA了，追求完美是每个人的向往，我看到这个题发现地图，标志数组，记录时间的数组可以共用一个，所以写出了上面的代码。知道失败的原因就好改了，记录时间的数组少不了。同时我也将标志数组和记录时间的数组共用一个(这是我的习惯，可以去看看我其他的BFS，其实大部分都是可以共用的)，于是有了下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;int h,l,mintime;int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;char map[1001][1001];int v[1001][1001];using namespace std;struct Point&#123; int x; int y;&#125; a,b;queue&lt;Point&gt; q;void bfs()&#123; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(map[a.x][a.y]&#x3D;&#x3D;&#39;.&#39;) &#123; if(b.x&lt;0||b.x&gt;&#x3D;h||b.y&lt;0||b.y&gt;&#x3D;l) &#123; mintime&#x3D;v[a.x][a.y]+1-1; return ; &#125; else if(map[b.x][b.y]&#x3D;&#x3D;&#39;.&#39;&amp;&amp;v[b.x][b.y]&#x3D;&#x3D;0) &#123; v[b.x][b.y]&#x3D;v[a.x][a.y]+1; q.push(b); &#125; &#125; if(map[a.x][a.y]&#x3D;&#x3D;&#39;F&#39;&amp;&amp;b.x&gt;&#x3D;0&amp;&amp;b.x&lt;h&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;l&amp;&amp;map[b.x][b.y]!&#x3D;&#39;F&#39;&amp;&amp;map[b.x][b.y]!&#x3D;&#39;#&#39;) &#123; map[b.x][b.y]&#x3D;&#39;F&#39;; q.push(b); &#125; &#125; &#125; &#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; while(n--) &#123; mintime&#x3D;0; memset(v,0,sizeof(v)); while(!q.empty()) q.pop(); cin&gt;&gt;h&gt;&gt;l; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]&#x3D;&#x3D;&#39;J&#39;) &#123; a.x&#x3D;i; a.y&#x3D;j; v[a.x][a.y]&#x3D;1; map[a.x][a.y]&#x3D;&#39;.&#39;; q.push(a); &#125; &#125; &#125; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; if(map[i][j]&#x3D;&#x3D;&#39;F&#39;) &#123; a.x&#x3D;i; a.y&#x3D;j; q.push(a); &#125; &#125; &#125; bfs(); if(mintime&#x3D;&#x3D;0) cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl; else cout&lt;&lt;mintime&lt;&lt;endl; &#125; return 0; &#125; 双BFS这也是一个方法，分为火的BFS和人的BFS，先算火的BFS，记录火到达每一个点的时间，然后再算人的BFS，加一个条件，人必须要比火先到才能走下一步，不过我没写代码","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"妙用标志数组","slug":"妙用标志数组","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"},{"name":"多入口BFS","slug":"多入口BFS","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%9A%E5%85%A5%E5%8F%A3BFS/"},{"name":"火场逃生","slug":"火场逃生","permalink":"https://donghuangzhong.github.io/tags/%E7%81%AB%E5%9C%BA%E9%80%83%E7%94%9F/"}]},{"title":"POJ-3126","slug":"POJ-3126","date":"2020-02-22T08:07:26.000Z","updated":"2020-02-22T08:30:17.283Z","comments":true,"path":"2020/02/22/POJ-3126/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/22/POJ-3126/","excerpt":"4位数素数共1061个，如果m个条件，其中固定a个条件成立，b个条件不成立，a+b=m，则可以列出这些条件，令它们的和为a","text":"4位数素数共1061个，如果m个条件，其中固定a个条件成立，b个条件不成立，a+b=m，则可以列出这些条件，令它们的和为a 题目主要路径 时限： 1000MS 内存限制： 65536K 提交总数： 37988 接受： 20286 就是给两个四位数素数a,b，每次只能变化a中个位十位百位千位其中的一位，问经过多少次变化可以a可以变成b 1033173337333739377987798179 该解决方案的成本为6磅。请注意，在步骤2中粘贴的数字1不能在最后一步中重复使用-必须购买新的1。 输入值 一行带有正数：测试用例的数量（最多100个）。然后，对于每个测试用例，用两个数字用空格分隔的一行。这两个数字都是四位数的质数（无前导零）。 输出量 每种情况下一行，或者用数字表示最低费用，或者包含“不可能”一词。 样本输入 123431033 81791373 80171033 1033 样本输出 123670 算法对素数进行打表，利用标志数组记录步数(基数为1，最终结果-1)，利用逻辑相加保证只有一位变化，比如找相比于a只有一位变化的数字，遍历素数数组p，(p[i]%10==g)+(p[i]/10%10==s)+(p[i]/100%10==ba)+(p[i]/1000==qi))==3就能保证只有一位发生变化，其中g,s,ba,qi分别为a的个，十，百，千位。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int a,b,minn&#x3D;1000000;int p[1062];int pp[1062];void bfs(int k)&#123; pp[k]&#x3D;1; queue&lt;int&gt; q; q.push(k); while(!q.empty()) &#123; int w&#x3D;q.front(); q.pop(); int g,s,ba,qi; g&#x3D;p[w]%10; s&#x3D;p[w]&#x2F;10%10; ba&#x3D;p[w]&#x2F;100%10; qi&#x3D;p[w]&#x2F;1000; for(int i&#x3D;1;i&lt;1062;i++) &#123; if(((p[i]%10&#x3D;&#x3D;g)+(p[i]&#x2F;10%10&#x3D;&#x3D;s)+(p[i]&#x2F;100%10&#x3D;&#x3D;ba)+(p[i]&#x2F;1000&#x3D;&#x3D;qi))&#x3D;&#x3D;3&amp;&amp;pp[i]&#x3D;&#x3D;0) &#123; pp[i]&#x3D;pp[w]+1; if(p[i]&#x3D;&#x3D;b) &#123; cout&lt;&lt;pp[i]-1&lt;&lt;endl; return; &#125; q.push(i); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int qq&#x3D;0,j; for(int i&#x3D;1000;i&lt;&#x3D;9999;i++) &#123; int sq&#x3D;sqrt(i); for(j&#x3D;2;j&lt;&#x3D;sq;j++) &#123; if(i%j&#x3D;&#x3D;0) break; &#125; if(j&lt;&#x3D;sq) continue; qq++; &#x2F;&#x2F;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl; p[qq]&#x3D;i; &#125; int n; cin&gt;&gt;n; while(n--) &#123; int r; cin&gt;&gt;a&gt;&gt;b; if(a&#x3D;&#x3D;b) &#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; memset(pp,0,sizeof(pp)); for(r&#x3D;1;r&lt;1062;r++) if(p[r]&#x3D;&#x3D;a) &#123; break; &#125; pp[r]&#x3D;1; bfs(r); &#x2F;&#x2F; cout&lt;&lt;minn-1&lt;&lt;endl; &#x2F;&#x2F;cout&lt;&lt;1&#x3D;&#x3D;1+ &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"标志数组妙用","slug":"标志数组妙用","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/"},{"name":"素数打表","slug":"素数打表","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A0%E6%95%B0%E6%89%93%E8%A1%A8/"},{"name":"逻辑相加妙用","slug":"逻辑相加妙用","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E7%9B%B8%E5%8A%A0%E5%A6%99%E7%94%A8/"}]},{"title":"POJ-1426","slug":"POJ-1426","date":"2020-02-21T10:20:08.000Z","updated":"2020-02-21T11:38:04.800Z","comments":true,"path":"2020/02/21/POJ-1426/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/21/POJ-1426/","excerpt":"代码是从网上抄下来的，我之前想过这个思路，但是被我否决了，否决的原因有两点，1.无法判断从小到大的每一种01组合对n取余是不是0？2.题目中说解的长度不超过100位，我无法判断解的最短长度的最大值。虽然AC了，但是网上的答案还是没有解决第二个问题，不知道他们是怎么确定答案在32位数以内","text":"代码是从网上抄下来的，我之前想过这个思路，但是被我否决了，否决的原因有两点，1.无法判断从小到大的每一种01组合对n取余是不是0？2.题目中说解的长度不超过100位，我无法判断解的最短长度的最大值。虽然AC了，但是网上的答案还是没有解决第二个问题，不知道他们是怎么确定答案在32位数以内 题目寻找多重 时限： 1000MS 内存限制： 10000K 提交总数： 56332 接受： 23292 特别法官 描述 给定正整数n，编写一个程序以找出n的非零倍数m，其十进制表示形式仅包含数字0和1。您可以假定n不大于200，并且对应的m包含不超过100十进制数字。 输入值 输入文件可能包含多个测试用例。每行包含一个值n（1 &lt;= n &lt;= 200）。包含零的行将终止输入。 输出量 对于输入中n的每个值，打印一行包含m的对应值。m的十进制表示形式不能超过100个数字。如果给定值n有多个解，则其中任何一个都是可接受的。 样本输入 123426190 样本输出 12310100100100100100100111111111111111111 算法具体步骤就是二进制枚举，将一个整形的二进制表示十进制,注意是表示不是转换，例如11(二进制)=3(十进制)，这是转换，3(十进制)=11(二进制)表示为11(十进制)，这是表示。一个整形表示的范围为0(2^31-1)，也就是二进制000,001,010,011,100111(这只是3位，应该是31位)，这些01串正是从小到大的遍历。","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"二进制","slug":"ACM/二进制","permalink":"https://donghuangzhong.github.io/categories/ACM/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}],"tags":[{"name":"同余定理","slug":"同余定理","permalink":"https://donghuangzhong.github.io/tags/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/"},{"name":"二进制表示十进制","slug":"二进制表示十进制","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%8D%81%E8%BF%9B%E5%88%B6/"}]},{"title":"POJ-3279","slug":"POJ-3279","date":"2020-02-20T10:30:53.000Z","updated":"2020-02-20T11:00:47.764Z","comments":true,"path":"2020/02/20/POJ-3279/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/20/POJ-3279/","excerpt":"本来想DFS的，但是复杂度太高了。第一次遇到这种开关类问题，关键就是要找唯一点，比如本题，要翻转一个色块有5种选择，砍掉四个，只留下最下面的一个选择。这样如果此色块为黑色，则下面的色块必须翻转；为白则必须不翻转","text":"本来想DFS的，但是复杂度太高了。第一次遇到这种开关类问题，关键就是要找唯一点，比如本题，要翻转一个色块有5种选择，砍掉四个，只留下最下面的一个选择。这样如果此色块为黑色，则下面的色块必须翻转；为白则必须不翻转 题目翻板 时限： 2000MS 内存限制： 65536K 提交总数： 25631 接受的： 9075 描述 农夫约翰知道，一头知识上满意的母牛是一头快乐的母牛，它将提供更多的牛奶。他已安排一个聪明的活动中，他们操纵奶牛中号 × Ñ栅格（1≤ 中号 ≤15; 1≤ ñ ≤15）正方形瓷砖，其中的每一个着色为黑色的一侧和白色的另一侧。 就像人们猜测的那样，当翻转单个白色图块时，它会变为黑色。翻转单个黑色图块时，它将变为白色。母牛在翻转砖块时会得到奖励，因此每块砖块的白色侧面都朝上。但是，母牛的蹄子相当大，当他们尝试翻转特定的瓷砖时，它们也会翻转所有相邻的瓷砖（与翻转的瓷砖共享完整边缘的瓷砖）。由于翻转很累，奶牛希望尽量减少翻转次数。 帮助奶牛确定所需的最小翻转次数，以及达到该最小翻转的位置。如果有多种方法可以以最小的翻转次数来完成任务，则当将其视为字符串时，以输出中词典顺序最少的方式返回。如果无法完成任务，请用“ IMPOSSIBLE”一词打印一行。 输入值 第1行：两个以空格分隔的整数：M和N第2行。M +1：第i +1行描述了网格第i行的颜色（从左到右），其中N个以空格分隔的整数，黑色和1为黑色。 0代表白色 输出量 第1 .. M行：每行包含N个以空格分隔的整数，每个整数指定翻转该特定位置的次数。 样本输入 123454 41 0 0 10 1 1 00 1 1 01 0 0 1 样本输出 12340 0 0 01 0 0 11 0 0 10 0 0 0 算法该游戏不受步骤的影响，没有翻转的先后顺序，因为某一个色块被翻转的总和跟翻转的顺序没有关系，总和不变，颜色就不变，所以对于一个色块翻转两次没有意义。假设现在已经知道最优解的第一行要翻转哪几个色块(指的是中心色块，不是周围被翻转的四个)，那么将这几个色块根据规则翻转后，对于第一行的黑色块，它下面的色块(第二行)必须被翻转，因为对于这个黑色块而言，能够改变它颜色的邻居四个中只有下面的能翻转(上面没有色块，左右色块不能翻转，因为你已经将最优解中第一行的的翻转色块翻转完了)；同理第一行白色块下面必须不能翻转，这样就能确定第二行色块的翻转情况，将第二行翻转后，又回到第一行最优解翻转后的情况….。重复这个过程。所以如果知道第一行的翻转情况，就能知道整体的翻转情况。现在的问题是我们不知道最优解第一行的翻转情况，那么就需要枚举了，枚举第一行的翻转情况(最多2^n)，取最优即可，需要注意的是如果最后一行翻转后还有黑色，则此种第一行的分布不能得出解，因为最后一行没有能改变的选择了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;using namespace std;int c,k,sum,minn;bool qipan[16][16],zturn[16][16],turn[16][16]; int lujing[5][2]&#x3D;&#123;0,0,0,1,0,-1,1,0,-1,0&#125;;bool getcolor(int a,int b)&#123; int turn_sum&#x3D;qipan[a][b]; for(int i&#x3D;0;i&lt;5;i++) &#123; int x&#x3D;a+lujing[i][0]; int y&#x3D;b+lujing[i][1]; if(x&gt;&#x3D;0&amp;&amp;x&lt;c&amp;&amp;y&gt;&#x3D;0&amp;&amp;y&lt;k) turn_sum+&#x3D;turn[x][y]; &#125; return turn_sum%2;&#125;void cal()&#123; for(int q&#x3D;1;q&lt;c;q++) for(int w&#x3D;0;w&lt;k;w++) &#123; if(getcolor(q-1,w)) &#123; turn[q][w]&#x3D;1; sum++; if(sum&gt;&#x3D;minn) return; &#125; &#125; for(int e&#x3D;0;e&lt;k;e++) if(getcolor(c-1,e)) return ; if(sum&lt;minn) &#123; minn&#x3D;sum; memcpy(zturn,turn,sizeof(turn)); &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;c&gt;&gt;k) &#123; for(int i&#x3D;0;i&lt;c;i++) for(int j&#x3D;0;j&lt;k;j++) cin&gt;&gt;qipan[i][j]; minn&#x3D;0x3f3f3f3f; for(int i&#x3D;0;i&lt;1&lt;&lt;k;i++) &#123; sum&#x3D;0; memset(turn,0,sizeof(turn)); for(int j&#x3D;0;j&lt;k;j++) &#123; turn[0][k-1-j]&#x3D;(i&gt;&gt;j)&amp;1; if(turn[0][k-1-j]&#x3D;&#x3D;1) sum++; &#125; cal(); &#125; if(minn&#x3D;&#x3D;0x3f3f3f3f) cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl; else &#123; for(int i&#x3D;0;i&lt;c;i++) &#123; for(int j&#x3D;0;j&lt;k;j++) cout&lt;&lt;zturn[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; &#125; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"开关","slug":"ACM/开关","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%BC%80%E5%85%B3/"}],"tags":[{"name":"翻转游戏","slug":"翻转游戏","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E6%B8%B8%E6%88%8F/"}]},{"title":"HDU-2717 POJ-3278","slug":"HDU-2717-POJ-3278","date":"2020-02-19T10:36:00.000Z","updated":"2020-02-20T01:23:37.830Z","comments":true,"path":"2020/02/19/HDU-2717-POJ-3278/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/19/HDU-2717-POJ-3278/","excerpt":"太坑了，题中没有标明有多个测试用例，如果只输入一次，POJ可以通过，HDU必需用while(cin&gt;&gt;n&gt;&gt;k),并且POJ有一个测试用例是起点和终点一起，所以bfs的开始就要判断起点和终点是否相同，每一次入队前都要判断起点和终点是否相同，如果为了省代码出队判断是否为终点，牺牲了太多时间(多处理了太多点)，我非常不推荐","text":"太坑了，题中没有标明有多个测试用例，如果只输入一次，POJ可以通过，HDU必需用while(cin&gt;&gt;n&gt;&gt;k),并且POJ有一个测试用例是起点和终点一起，所以bfs的开始就要判断起点和终点是否相同，每一次入队前都要判断起点和终点是否相同，如果为了省代码出队判断是否为终点，牺牲了太多时间(多处理了太多点)，我非常不推荐 题目赶上那头牛\\时间限制：5000/2000 MS（Java /其他）内存限制：32768/32768 K（Java /其他）总计提交：28511已接受提交：7809** 问题描述 农夫约翰已被告知一头逃犯的位置，并希望立即抓住她。他从数字线上的点N（0≤N≤100,000）开始，而母牛在同一数字线上的点K（0≤K≤100,000）。农夫约翰有两种运输方式：步行和传送。 *行走：FJ可以在一分钟内从任意点X移至点X-1或X + 1。*传送：FJ可以在一分钟内从任意点X移至点2×X。 如果没有意识到它的追捕能力的母牛完全没有动弹，那么农夫约翰要花多长时间？ 输入值 第1行：两个以空格分隔的整数：N和K 输出量 第1行：最短的时间（以分钟为单位），农夫John赶上了逃亡的母牛。 样本输入 15 17 样本输出 1234暗示农夫约翰到达逃亡者牛的最快方法是沿着以下路径移动：5-10-9-18-17，这需要4分钟。 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;using namespace std;int n,k;int zhou[100001];int a,b;bool judge(int w)&#123; if(w&gt;&#x3D;0&amp;&amp;w&lt;&#x3D;100000&amp;&amp;zhou[w]&#x3D;&#x3D;0) return 1; return 0;&#125;void bfs()&#123; if(n&#x3D;&#x3D;k)&#123; cout&lt;&lt;0&lt;&lt;endl; return ; &#125; memset(zhou,0,sizeof(zhou)); zhou[n]&#x3D;1; queue&lt;int&gt; q; q.push(n); while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;3;i++) &#123; if(i&#x3D;&#x3D;0) b&#x3D;a-1; else if(i&#x3D;&#x3D;1) b&#x3D;a+1; else b&#x3D;2*a; &#x2F;&#x2F;if(b&lt;0||b&gt;100000) continue; &#x2F;&#x2F; if(zhou[b]&#x3D;&#x3D;0) if(judge(b)) &#123; zhou[b]&#x3D;zhou[a]+1; if(b&#x3D;&#x3D;k) &#123; cout&lt;&lt;zhou[b]-1&lt;&lt;endl; return ; &#125; q.push(b); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;n&gt;&gt;k) &#123; if(k&lt;&#x3D;n) cout&lt;&lt;n-k&lt;&lt;endl; else bfs(); &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"标志数组妙用","slug":"标志数组妙用","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/"}]},{"title":"POJ-2251","slug":"POJ-2251","date":"2020-02-19T04:08:39.000Z","updated":"2020-02-19T04:24:48.079Z","comments":true,"path":"2020/02/19/POJ-2251/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/19/POJ-2251/","excerpt":"无论是BFS还是DFS都需要一个标志数组来防止无意义的重复路径访问，并不是只能访问一次，有些迷宫会有加血或者加时间的设定。但有些仅仅是简单的只能访问一次，这样只能用到数组的01两个状态，如果有别的属性值(例如时间等)也可以放到标志数组中(前提是不能有乘除运算)，但是如果这样设定，起点初始化为被访问过，置1，这样有些时间就整体提升了1，所以在最后要减去1。","text":"无论是BFS还是DFS都需要一个标志数组来防止无意义的重复路径访问，并不是只能访问一次，有些迷宫会有加血或者加时间的设定。但有些仅仅是简单的只能访问一次，这样只能用到数组的01两个状态，如果有别的属性值(例如时间等)也可以放到标志数组中(前提是不能有乘除运算)，但是如果这样设定，起点初始化为被访问过，置1，这样有些时间就整体提升了1，所以在最后要减去1。 题目Dungeon Master Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 68475 Accepted: 24773 Description You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. Is an escape possible? If yes, how long will it take? Input The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).L is the number of levels making up the dungeon.R and C are the number of rows and columns making up the plan of each level.Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C. Output Each maze generates one line of output. If it is possible to reach the exit, print a line of the form Escaped in x minute(s). where x is replaced by the shortest time it takes to escape.If it is not possible to escape, print the line Trapped! Sample Input 123456789101112131415161718192021223 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0 Sample Output 12Escaped in 11 minute(s).Trapped! 算法这个题也可以不将起点置1，这样起点就可以访问两次(访问第二次后就不能再次访问)，对本题没有什么影响，因为本题的起点终点一定不会重合，但我实在不提倡这种做法 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;using namespace std;char migong[31][31][31];int visit[31][31][31];int l,r,c;struct Point&#123; int x,y,z;&#125; qi,zhong,a,b;int lujing[6][3]&#x3D;&#123;1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1&#125;;void bfs()&#123; queue&lt;Point&gt; q; a&#x3D;qi; if(a.x&#x3D;&#x3D;zhong.x&amp;&amp;a.y&#x3D;&#x3D;zhong.y&amp;&amp;a.z&#x3D;&#x3D;zhong.z) &#123;cout&lt;&lt;&quot;Escaped in 0 minute(s).&quot;&lt;&lt;endl;return ; &#125; memset(visit,0,sizeof(visit)); visit[a.x][a.y][a.z]&#x3D;1; q.push(a); while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;6;i++) &#123; b.x&#x3D;a.x+lujing[i][0]; b.y&#x3D;a.y+lujing[i][1]; b.z&#x3D;a.z+lujing[i][2]; if(b.x&gt;&#x3D;1&amp;&amp;b.x&lt;&#x3D;l&amp;&amp;b.y&gt;&#x3D;1&amp;&amp;b.y&lt;&#x3D;r&amp;&amp;b.z&gt;&#x3D;1&amp;&amp;b.z&lt;&#x3D;c&amp;&amp;migong[b.x][b.y][b.z]!&#x3D;&#39;#&#39;&amp;&amp;visit[b.x][b.y][b.z]&#x3D;&#x3D;0) &#123; visit[b.x][b.y][b.z]&#x3D;visit[a.x][a.y][a.z]+1; if(b.x&#x3D;&#x3D;zhong.x&amp;&amp;b.y&#x3D;&#x3D;zhong.y&amp;&amp;b.z&#x3D;&#x3D;zhong.z)&#123; cout&lt;&lt;&quot;Escaped in &quot;&lt;&lt;visit[b.x][b.y][b.z]-1&lt;&lt;&quot; minute(s).&quot;&lt;&lt;endl;return ; &#125; q.push(b); &#125; &#125;​ &#125; cout&lt;&lt;&quot;Trapped!&quot;&lt;&lt;endl;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;l&gt;&gt;r&gt;&gt;c&amp;&amp;l&amp;&amp;r&amp;&amp;c) &#123; for(int i&#x3D;1;i&lt;&#x3D;l;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;r;j++) &#123; for(int k&#x3D;1;k&lt;&#x3D;c;k++) &#123; cin&gt;&gt;migong[i][j][k]; if(migong[i][j][k]&#x3D;&#x3D;&#39;E&#39;)&#123; zhong.x&#x3D;i;zhong.y&#x3D;j;zhong.z&#x3D;k; &#125; if(migong[i][j][k]&#x3D;&#x3D;&#39;S&#39;)&#123; qi.x&#x3D;i;qi.y&#x3D;j;qi.z&#x3D;k; &#125;​ &#125; &#125; &#125; bfs(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"妙用标志数组","slug":"妙用标志数组","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"}]},{"title":"POJ-1312","slug":"POJ-1312","date":"2020-02-18T08:19:28.000Z","updated":"2020-02-18T08:37:19.056Z","comments":true,"path":"2020/02/18/POJ-1312/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/18/POJ-1312/","excerpt":"此问题只要求不在同一行和同一列，新奇的标志数组，难点：每次递归范围的确定","text":"此问题只要求不在同一行和同一列，新奇的标志数组，难点：每次递归范围的确定 题目棋盘问题 Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 94015 Accepted: 42955 Description 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 Input 输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 Output 对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 Sample Input 1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output 1221 算法棋盘上不一定放多少棋子，不一定每一行都有棋子(相对于全排列)，所以每次递归的范围为上一个棋子的下一行开始一直到棋盘的最后，因此行一定不重复，所以标志数组只需表示某列有没有棋子，即lie[i]=0。同时需要用到上一个棋子的行数，可以选择保留整个点(这样可以输出所有可能的情况)，也可以选择只保留上一个点的x坐标(这样不方便输出每一种情况) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;char qipan[9][9];bool lie[9];int n,sum,k;struct Point&#123; int x; int y;&#125; point[9];bool judge(int x,int y,int n)&#123; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; if(point[i].x&#x3D;&#x3D;x||point[i].y&#x3D;&#x3D;y) return 0; &#125; return 1;&#125;void dfs(int nn)&#123; if(nn&#x3D;&#x3D;k+1) &#123; sum++; return ; &#125; for(int i&#x3D;point[nn-1].x+1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(qipan[i][j]&#x3D;&#x3D;&#39;#&#39;&amp;&amp;lie[j]&#x3D;&#x3D;0&amp;&amp;judge(i,j,nn-1)) &#123; lie[j]&#x3D;1; point[nn].x&#x3D;i; point[nn].y&#x3D;j; dfs(nn+1); lie[j]&#x3D;0; &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;n&gt;&gt;k&amp;&amp;n!&#x3D;-1&amp;&amp;k!&#x3D;-1) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;n;j++) cin&gt;&gt;qipan[i][j]; memset(lie,0,sizeof(lie)); memset(point,0,sizeof(point)); sum&#x3D;0; dfs(1); cout&lt;&lt;sum&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DFS","slug":"ACM/DFS","permalink":"https://donghuangzhong.github.io/categories/ACM/DFS/"}],"tags":[{"name":"八皇后简化版","slug":"八皇后简化版","permalink":"https://donghuangzhong.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%80%E5%8C%96%E7%89%88/"},{"name":"特殊标志数组","slug":"特殊标志数组","permalink":"https://donghuangzhong.github.io/tags/%E7%89%B9%E6%AE%8A%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"},{"name":"递归范围","slug":"递归范围","permalink":"https://donghuangzhong.github.io/tags/%E9%80%92%E5%BD%92%E8%8C%83%E5%9B%B4/"}]},{"title":"HDU-1016","slug":"HDU-1016","date":"2020-02-17T10:12:58.000Z","updated":"2020-02-17T10:54:37.869Z","comments":true,"path":"2020/02/17/HDU-1016/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/HDU-1016/","excerpt":"典型的DFS数据类问题，介绍一个快速打表素数的方法","text":"典型的DFS数据类问题，介绍一个快速打表素数的方法 题目素环问题\\时间限制：4000/2000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）提交总数：82346接受提交：33935** 问题描述 圆环由n个圆组成，如图所示。将自然数1、2，…，n分别放入每个圆，并且两个相邻圆中的数字总和应为质数。 注意：第一个圆的数目应始终为1。 输入值 n（0 &lt;n &lt;20）。 输出量 输出格式如下所示。每一行代表环中从顺时针和逆时针1开始的一系列圆圈编号。数字顺序必须满足上述要求。按字典顺序打印解决方案。 您将编写一个完成上述过程的程序。 在每种情况下都打印空白行。 样本输入 1268 样本输出 123456789情况1：1 4 3 2 5 61 6 5 2 3 4情况2：1 2 3 8 5 6 7 41 2 5 8 3 4 7 61 4 7 6 5 8 3 21 6 7 4 3 8 5 2 算法快速打表素数(0~n)利用memset置0(对字节操作，不能置1的)，0代表是素数，如果i是素数，则2i~ni都不是素数，只要将素数的倍数们都标记为非素数即可,需要注意的是它们的表示与我们通常的认知相反，用法:!sushu[i] 12345bool sushu[45]&#x3D;&#123;0&#125;;for(int i&#x3D;2;i&lt;8;i++)&#x2F;&#x2F;此处的8&#x3D;sqrt(45)+1 if(!sushu[i]) for(int j&#x3D;i*i;j&lt;45;j+&#x3D;i) sushu[j]&#x3D;1; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;int n;int flag[21];int b[21];int sum;bool sushu[45]&#x3D;&#123;0&#125;;bool judge(int a)&#123; return !sushu[a];&#125;void dfs2(int q)&#123; if(q&#x3D;&#x3D;1) &#123; flag[1]&#x3D;1; b[1]&#x3D;1; dfs2(2); return ; &#125; if(q&#x3D;&#x3D;n+1) &#123; if(judge(b[q-1]+1)) &#123; sum++; for(int k&#x3D;1;k&lt;&#x3D;n;k++) &#123; cout&lt;&lt;b[k]; if(k!&#x3D;n) cout&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(flag[i]&#x3D;&#x3D;0&amp;&amp;judge(b[q-1]+i)) &#123; flag[i]&#x3D;1; b[q]&#x3D;i; dfs2(q+1); flag[i]&#x3D;0; &#125; &#125; &#125; int main()&#123; for(int i&#x3D;2;i&lt;8;i++) if(!sushu[i]) for(int j&#x3D;i*i;j&lt;45;j+&#x3D;i) sushu[j]&#x3D;1; int ca&#x3D;1; while(cin&gt;&gt;n) &#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;ca++&lt;&lt;&quot;:&quot;&lt;&lt;endl; sum&#x3D;0; memset(flag,0,sizeof(flag)); dfs2(1); &#x2F;&#x2F;cout&lt;&lt;&quot;种数&quot;&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;endl; &#125;&#125; &#x2F;*void dfs(int nn,int ln)&#123; if(nn&#x3D;&#x3D;1) &#123; b[nn]&#x3D;1; flag[1]&#x3D;1; dfs(2,1); return ; &#125; if(nn&#x3D;&#x3D;n+1) &#123; if(judge(1+ln)) &#123; sum++; for(int k&#x3D;1;k&lt;&#x3D;n;k++) &#123; cout&lt;&lt;b[k]; if(k!&#x3D;n) cout&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return ; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(flag[i]&#x3D;&#x3D;0&amp;&amp;judge(ln+i)) &#123; flag[i]&#x3D;1; b[nn]&#x3D;i; dfs(nn+1,i); flag[i]&#x3D;0; &#125; &#125;&#125;*&#x2F; presentation error输出的最后一个数字后面不应该有空格","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DFS","slug":"ACM/DFS","permalink":"https://donghuangzhong.github.io/categories/ACM/DFS/"}],"tags":[{"name":"素数环","slug":"素数环","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A0%E6%95%B0%E7%8E%AF/"},{"name":"回溯","slug":"回溯","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"PTA-L1-006","slug":"PTA-L1-006","date":"2020-02-17T07:00:35.000Z","updated":"2020-02-17T10:12:40.142Z","comments":true,"path":"2020/02/17/PTA-L1-006/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/PTA-L1-006/","excerpt":"给一个数，求这个数的最长连续因数","text":"给一个数，求这个数的最长连续因数 题目L1-006 连续因子 (20分) 一个正整数 N 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数 N，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。 输入格式：输入在一行中给出一个正整数 N（1&lt;N&lt;231）。 输出格式：首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按 因子1*因子2*……*因子k 的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。 输入样例：1630 输出样例：1235*6*7 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main() &#123; int N, temp; int count &#x3D; 0, maxcount &#x3D; 0, start &#x3D; 0; cin &gt;&gt; N; for (int i &#x3D; 2; i &lt;&#x3D; sqrt(N) ; i++) &#123; temp &#x3D; N; count &#x3D; 0; int j &#x3D; i; while (temp%j&#x3D;&#x3D;0) &#123; temp &#x2F;&#x3D; j++; count++; &#125; if (count &gt; maxcount) &#123; maxcount &#x3D; count; start &#x3D; i; &#125; &#125; if (maxcount) &#123; cout &lt;&lt; maxcount &lt;&lt; endl; for (int i &#x3D; start; i &lt; start+maxcount; i++) &#123; if(i!&#x3D;start)cout&lt;&lt;&quot;*&quot;; cout&lt;&lt;i; &#125; &#125; else cout &lt;&lt;&quot;1&quot;&lt;&lt;endl&lt;&lt; N; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"因数","slug":"ACM/因数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%9B%A0%E6%95%B0/"}],"tags":[{"name":"最长连续因数","slug":"最长连续因数","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%9B%A0%E6%95%B0/"},{"name":"按序列累除","slug":"按序列累除","permalink":"https://donghuangzhong.github.io/tags/%E6%8C%89%E5%BA%8F%E5%88%97%E7%B4%AF%E9%99%A4/"}]},{"title":"pintia-L1-005","slug":"pintia-L1-005","date":"2020-02-17T02:03:38.000Z","updated":"2020-02-17T02:07:56.034Z","comments":true,"path":"2020/02/17/pintia-L1-005/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/pintia-L1-005/","excerpt":"简单字典问题","text":"简单字典问题 题目L1-005 考试座位号 (15分) 每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。 输入格式：输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 16 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。 考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。 输出格式：对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。 输入样例：123456743310120150912233 2 43310120150912119 4 13310120150912126 1 33310120150912002 3 223 4 输出样例：123310120150912002 23310120150912119 1 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;struct student&#123; string xuehao; int shiji; int kszwh;&#125; st[1001];int num[1001];int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; for(int i&#x3D;0;i&lt;n;i++) cin&gt;&gt;st[i].xuehao&gt;&gt;st[i].shiji&gt;&gt;st[i].kszwh; int nn; cin&gt;&gt;nn; for(int i&#x3D;0;i&lt;n;i++) &#123; int nnn; cin&gt;&gt;nnn; for(int j&#x3D;0;j&lt;n;j++) &#123; if(st[j].shiji&#x3D;&#x3D;nnn) &#123; num[i]&#x3D;j; break; &#125; &#125; &#125; for(int i&#x3D;0;i&lt;nn;i++) cout&lt;&lt;st[num[i]].xuehao&lt;&lt;&quot; &quot;&lt;&lt;st[num[i]].kszwh&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"map","slug":"map","permalink":"https://donghuangzhong.github.io/tags/map/"},{"name":"字典","slug":"字典","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E5%85%B8/"}]},{"title":"pintia-L1-004","slug":"pintia-L1-004","date":"2020-02-17T01:47:27.000Z","updated":"2020-02-17T02:06:09.565Z","comments":true,"path":"2020/02/17/pintia-L1-004/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/pintia-L1-004/","excerpt":"给华氏温度求摄氏温度","text":"给华氏温度求摄氏温度 题目L1-004 计算摄氏温度 (5分) 给定一个华氏温度F，本题要求编写程序，计算对应的摄氏温度C。计算公式：C=5×(F−32)/9。题目保证输入与输出均在整型范围内。 输入格式:输入在一行中给出一个华氏温度。 输出格式:在一行中按照格式“Celsius = C”输出对应的摄氏温度C的整数值。 输入样例:1150 输出样例:1Celsius &#x3D; 65 代码1234567891011#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;&quot;Celsius &#x3D; &quot;&lt;&lt;(int)(5*(n-32)&#x2F;9)&lt;&lt;endl; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"摄氏华氏温度转换","slug":"摄氏华氏温度转换","permalink":"https://donghuangzhong.github.io/tags/%E6%91%84%E6%B0%8F%E5%8D%8E%E6%B0%8F%E6%B8%A9%E5%BA%A6%E8%BD%AC%E6%8D%A2/"}]},{"title":"pintia-L1-003","slug":"pintia-L1-003","date":"2020-02-17T00:28:10.000Z","updated":"2020-02-17T02:06:01.928Z","comments":true,"path":"2020/02/17/pintia-L1-003/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/pintia-L1-003/","excerpt":"统计字数的个数","text":"统计字数的个数 题目L1-003 个位数统计 (15分) 给定一个 k 位整数 N=dk−110k−1+⋯+d1101+d0 (0≤di*≤9, *i=0,⋯,k−1, d*k−1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 *N=100311，则有 2 个 0，3 个 1，和 1 个 3。 输入格式：每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。 输出格式：对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。 输入样例：1100311 输出样例：1230:21:33:1 代码1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; char ch[1001];int a[10]&#x3D;&#123;0&#125;;cin&gt;&gt;ch;int lenth&#x3D;strlen(ch);while(lenth--)&#123; for(int i&#x3D;0;i&lt;&#x3D;9;i++) if((ch[lenth]-&#39;0&#39;)&#x3D;&#x3D;i) a[i]++;&#125;for(int i&#x3D;0;i&lt;&#x3D;9;i++)&#123; if(a[i]) cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;a[i]&lt;&lt;endl;&#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"统计数字的个数","slug":"统计数字的个数","permalink":"https://donghuangzhong.github.io/tags/%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%AA%E6%95%B0/"}]},{"title":"pintia-L1-002","slug":"pintia-L1-002","date":"2020-02-17T00:27:46.000Z","updated":"2020-02-17T02:04:26.454Z","comments":true,"path":"2020/02/17/pintia-L1-002/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/pintia-L1-002/","excerpt":"公式求n,两个循环打印","text":"公式求n,两个循环打印 题目L1-002 打印沙漏 (20分) 本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 12345***** *** * ******** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式:输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。 输出格式:首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。 输入样例:119 * 输出样例:123456***** *** * ********2 代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n; char ch; cin&gt;&gt;n&gt;&gt;ch; int nn&#x3D;(int)sqrt((n+1)&#x2F;2); for(int i&#x3D;nn;i&gt;&#x3D;1;i--) &#123; int k&#x3D;nn-i; while(k--) cout&lt;&lt;&quot; &quot;; k&#x3D;2*i-1; while(k--) cout&lt;&lt;ch; cout&lt;&lt;endl; &#125; for(int i&#x3D;2;i&lt;&#x3D;nn;i++) &#123; int k&#x3D;nn-i; while(k--) cout&lt;&lt;&quot; &quot;; k&#x3D;2*i-1; while(k--) cout&lt;&lt;ch; cout&lt;&lt;endl; &#125; int c&#x3D;n-2*nn*nn+1; &#x2F;&#x2F;if(c) cout&lt;&lt;c;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"沙漏","slug":"沙漏","permalink":"https://donghuangzhong.github.io/tags/%E6%B2%99%E6%BC%8F/"},{"name":"等差数列","slug":"等差数列","permalink":"https://donghuangzhong.github.io/tags/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/"}]},{"title":"HDU-1008","slug":"HDU-1008","date":"2020-02-16T09:46:41.000Z","updated":"2020-02-16T10:00:36.521Z","comments":true,"path":"2020/02/16/HDU-1008/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/16/HDU-1008/","excerpt":"给出楼层，计算电梯的运行时间","text":"给出楼层，计算电梯的运行时间 题目电梯\\时间限制：2000/1000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）总提交数量：100638接受提交数量：54525** 问题描述 我们城市最高的建筑物只有一部电梯。请求列表由N个正数组成。数字按指定顺序表示电梯将停在的楼层。将电梯上移一层需要6秒钟，而将一层下移则需要4秒钟。电梯将在每个站点停留5秒钟。 对于给定的请求列表，您将计算完成列表上的请求所花费的总时间。电梯在开始时位于0楼，并且在满足请求后不必返回一楼。 输入值 有多个测试用例。每个案例包含一个正整数N，后跟N个正数。输入中的所有数字均小于100。N = 0的测试用例表示输入结束。该测试用例将不被处理。 输出量 将每个测试用例的总时间打印在一行上。 样本输入 1231 23 2 3 10 样本输出 121741 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n,floor,lfloor; while(cin&gt;&gt;n&amp;&amp;n) &#123; int time&#x3D;0; lfloor&#x3D;0; while(n--) &#123; cin&gt;&gt;floor; if(floor&gt;lfloor) time+&#x3D;6*(floor-lfloor); else time+&#x3D;4*(lfloor-floor); lfloor&#x3D;floor; time+&#x3D;5; &#125; cout&lt;&lt;time&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"电梯","slug":"电梯","permalink":"https://donghuangzhong.github.io/tags/%E7%94%B5%E6%A2%AF/"}]},{"title":"dotcpp-1004","slug":"dotcpp-1004","date":"2020-02-16T07:59:20.000Z","updated":"2020-02-16T08:03:02.178Z","comments":true,"path":"2020/02/16/dotcpp-1004/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/16/dotcpp-1004/","excerpt":"第一年一头成年母牛，每年生一小牛，小牛四年后才成年，求第N年的牛的个数","text":"第一年一头成年母牛，每年生一小牛，小牛四年后才成年，求第N年的牛的个数 题目题目描述 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ 输入 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 输出 对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。 样例输入 12342450 样例输出 123246 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n; int a[56]; a[1]&#x3D;1; a[2]&#x3D;2; a[3]&#x3D;3; a[4]&#x3D;4; for(int i&#x3D;5;i&lt;56;i++) &#123; a[i]&#x3D;a[i-1]+a[i-3]; &#125; while(cin&gt;&gt;n&amp;&amp;n) &#123; cout&lt;&lt;a[n]&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://donghuangzhong.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"},{"name":"兔子问题","slug":"兔子问题","permalink":"https://donghuangzhong.github.io/tags/%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98/"}]},{"title":"HDU-1006","slug":"HDU-1006","date":"2020-02-14T03:10:09.000Z","updated":"2020-02-14T04:00:58.166Z","comments":true,"path":"2020/02/14/HDU-1006/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/14/HDU-1006/","excerpt":"一般我们的思维都是先找第一段符合题目的解，然后找第二段第三段，从而理解题目和找出规律。但对于有些题目，规律甚至第一段的解都非常难找，但如果我们知道解位于一个临界集合中，我们就可以不用去找这个解，转而寻找这个临界集合(因为寻找解非常复杂，寻找临界集合却比较容易)，前提是可以把解从临界集合中分离出来(一般是临界集合的最值)。这样我们就可以避开寻找解这个非常复杂的过程，简化题目。","text":"一般我们的思维都是先找第一段符合题目的解，然后找第二段第三段，从而理解题目和找出规律。但对于有些题目，规律甚至第一段的解都非常难找，但如果我们知道解位于一个临界集合中，我们就可以不用去找这个解，转而寻找这个临界集合(因为寻找解非常复杂，寻找临界集合却比较容易)，前提是可以把解从临界集合中分离出来(一般是临界集合的最值)。这样我们就可以避开寻找解这个非常复杂的过程，简化题目。 题目滴答和滴答\\时间限制：2000/1000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）提交总计：26354接受提交：7208** 问题描述 时钟的三只指针每秒旋转一次，并且每天相遇很多次。最后，他们对此感到无聊，并且每个人都希望远离其他两个人。如果一只手与其余任何一只手至少有D度，那它就是快乐的。您要计算一天中所有双手都开心的时间。 输入值 输入包含许多测试用例。他们每个人都有一条单行，其实数D在0和120之间（含0和120）。输入以-1的D终止。 输出量 对于每个D，用一行打印一天中所有手牌都高兴的时间百分比，精确到小数点后3位。 样本输入 1234012090-1 样本输出 123100.0000.0006.251 算法为什么暴力遍历每一秒不行因为本题对精度有非常高的要求，这个表应该是静音表(扫秒表)，不会发出滴答滴答的声音，并且要用到角速度，因为只有这样才能满足精度要求 分析本题如果仔细思考求解的话，整个过程是非常复杂的，因为你不知道每一小段开始时究竟是那两个针到达临界值。既然这样那就求临界集合，将分针和时针从重合到再次重合看做一个大周期，将分针和表针从重合到再次重合看做一个周期，将时针和秒针从重合到再次重合看做一个小周期。一共有三个针，C32共有三种可能，也就是说每一小段的开始时刻必然在临界开始集合(分-时=n,秒-时=n,秒-分=n)中，并且是临界开始集合的最大值，而每一小段的结束必然存在于临界结束集合(分-时=360-n,秒-时=360-n,秒-分=360-n)中，并且是临界结束集合的最小值。这样只求两个临界集合就行了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;double max(double a,double b,double c)&#123; double max=a&gt;b?a:b; return max&gt;c?max:c;&#125;double min(double a,double b,double c)&#123; double min=a&lt;b?a:b; return min&lt;c?min:c;&#125;int main()&#123; freopen(\"input.txt\", \"r\", stdin);double n;while(cin&gt;&gt;n&amp;&amp;n!=-1)&#123; double maxx=12*60*60; double shij=30.0/60/60; double fenj=6/60.0; double miaoj=6/1.0; double sfx=fenj-shij; double smx=miaoj-shij; double fmx=miaoj-fenj; double sfz=360/sfx; double sfn=n/sfx; double sf_n=(360-n)/sfx; double fmz=360/fmx; double fmn=n/fmx; double fm_n=(360-n)/fmx; double smz=360/smx; double smn=n/smx; double sm_n=(360-n)/smx; double shichang=0; for(double i=0;i&lt;=maxx;i+=sfz) &#123; for(double j=0;j&lt;=maxx;j+=fmz) &#123; if(j+fm_n&lt;i+sfn) continue; if(i+sf_n&lt;j+fmn) break; for(double k=0;k&lt;=maxx;k+=smz) &#123; if(k+sm_n&lt;i+sfn||k+sm_n&lt;j+fmn) continue; if(j+fm_n&lt;k+smn||i+sf_n&lt;k+smn) break; double kaishi=max(i+sfn,j+fmn,k+smn); double jieshu=min(i+sf_n,j+fm_n,k+sm_n); if(jieshu&gt;kaishi) shichang+=jieshu-kaishi; &#125; &#125; &#125; printf(\"%.3f\\n\",100.0*shichang/maxx); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"盲集合求交","slug":"ACM/盲集合求交","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%9B%B2%E9%9B%86%E5%90%88%E6%B1%82%E4%BA%A4/"}],"tags":[{"name":"临界最优","slug":"临界最优","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%B4%E7%95%8C%E6%9C%80%E4%BC%98/"},{"name":"屏蔽细节","slug":"屏蔽细节","permalink":"https://donghuangzhong.github.io/tags/%E5%B1%8F%E8%94%BD%E7%BB%86%E8%8A%82/"}]},{"title":"HDU-1005","slug":"HDU-1005","date":"2020-02-09T04:33:27.000Z","updated":"2020-02-09T05:45:39.499Z","comments":true,"path":"2020/02/09/HDU-1005/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/09/HDU-1005/","excerpt":"这个题大家第一次应该都是超时吧，这个题网上流传的%49或者%48都是错误的，大家反而觉得他们解释的逻辑很对，我也是服了，这么一份错答案竟然能够横扫CSDN！能够在网络上横行！HDUOJ也真是水！后台数据太水了！！！","text":"这个题大家第一次应该都是超时吧，这个题网上流传的%49或者%48都是错误的，大家反而觉得他们解释的逻辑很对，我也是服了，这么一份错答案竟然能够横扫CSDN！能够在网络上横行！HDUOJ也真是水！后台数据太水了！！！ 题目Number Sequence\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 234505 Accepted Submission(s): 59544** Problem Description A number sequence is defined as follows: f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7. Given A, B, and n, you are to calculate the value of f(n). Input The input consists of multiple test cases. Each test case contains 3 integers A, B and n on a single line (1 &lt;= A, B &lt;= 1000, 1 &lt;= n &lt;= 100,000,000). Three zeros signal the end of input and this test case is not to be processed. Output For each test case, print the value of f(n) on a single line. Sample Input 1231 1 31 2 100 0 0 Sample Output 1225 代码算法这个确实要用到循环节，公式为f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7由前两项推出第三项，所以如果出现连续两项相同，后面的也完全相同，对7取余，结果为0~6，一项有7种可能，将连续两项(2n+1,2n+2)看做一个循环节，则循环节共有7*7=49种可能，所以根据抽屉原理，前50个循环节内，必然存在两个一样的循环节，第一个循环节后的序列为周期序列，整个序列不一定是周期序列。例如序列:3、4项分别和13、14项相同，则从第3项开始，这个序列才是周期序列，整个序列不一定是周期序列。所以算出前100项，找出两个相同循环节(位置分别为a,b)，周期t=b-a，则从a开始，这个序列为周期序列，n&lt;=a，则直接输出，n&gt;a，则输出第(n-a)%t+a项 测试数据如果取余49是正确的，那么就是说第50项一定为1。写代码的不觉得荒谬吗！测试数据1 5 50，自己去测试吧，可以用你们超时代码(超时代码的结果一定是正确的，只是时间太长)的测试结果和网上所谓取余49的代码的结果对比 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); int a,b,n,y,t,kaishi; int jieguo[101]; jieguo[1]=jieguo[2]=1; while((cin&gt;&gt;a&amp;&amp;cin&gt;&gt;b&amp;&amp;cin&gt;&gt;n)&amp;&amp;!(a==0&amp;&amp;b==0&amp;&amp;n==0)) &#123; for(int i=3;i&lt;=100;i++) jieguo[i]=(a*jieguo[i-1]+b*jieguo[i-2])%7; t=-1; for(int i=1;i&lt;=99;i+=2) &#123; if(t!=-1) break; for(int j=i+2;j&lt;=99;j+=2) &#123; if(jieguo[i]==jieguo[j]&amp;&amp;jieguo[i+1]==jieguo[j+1]) &#123; t=j-i; kaishi=i; break; &#125; &#125; &#125; if(n&lt;=kaishi) cout&lt;&lt;jieguo[n]&lt;&lt;endl; else cout&lt;&lt;jieguo[(n-kaishi)%t+kaishi]&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"大数动态周期","slug":"ACM/大数动态周期","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0%E5%8A%A8%E6%80%81%E5%91%A8%E6%9C%9F/"}],"tags":[{"name":"斐波那契取余版","slug":"斐波那契取余版","permalink":"https://donghuangzhong.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%8F%96%E4%BD%99%E7%89%88/"},{"name":"动态周期","slug":"动态周期","permalink":"https://donghuangzhong.github.io/tags/%E5%8A%A8%E6%80%81%E5%91%A8%E6%9C%9F/"}]},{"title":"HUD-1004","slug":"HUD-1004","date":"2020-02-07T09:38:59.000Z","updated":"2020-02-07T09:48:03.437Z","comments":true,"path":"2020/02/07/HUD-1004/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/07/HUD-1004/","excerpt":"我在本题没有用map,因为一开始没有过map,用的话还得去查怎么使用，我的算法是统计每一个颜色出现的次数，取最大值的下标，存在的问题是可能超时。但令我不解的是C++显示编译错误，G++ AC。while(cin&gt;&gt;n&amp;&amp;n)","text":"我在本题没有用map,因为一开始没有过map,用的话还得去查怎么使用，我的算法是统计每一个颜色出现的次数，取最大值的下标，存在的问题是可能超时。但令我不解的是C++显示编译错误，G++ AC。while(cin&gt;&gt;n&amp;&amp;n) 问题Let the Balloon Rise\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 175113 Accepted Submission(s): 69765** Problem Description Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges’ favorite time is guessing the most popular problem. When the contest is over, they will count the balloons of each color and find the result. This year, they decide to leave this lovely job to you. Input Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 1000) – the total number of balloons distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case letters. A test case with N = 0 terminates the input and this test case is not to be processed. Output For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a unique solution for each test case. Sample Input 12345678910115greenredblueredred3pinkorangepink0 Sample Output 12redpink 代码(G++下AC，C++下编译错误)1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; freopen(\"input.txt\", \"r\", stdin); string color[1000]; int n,max; int xiabiao; while(cin&gt;&gt;n&amp;&amp;n) &#123; max=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;color[i]; &#125; for(int j=0;j&lt;n;j++) &#123; int num=0; for(int k=0;k&lt;n;k++) &#123; if(color[j]==color[k]) num++; &#125; if(num&gt;max)&#123; xiabiao=j; max=num; &#125; &#125; cout&lt;&lt;color[xiabiao]&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"字典","slug":"ACM/字典","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E5%85%B8/"}],"tags":[{"name":"map","slug":"map","permalink":"https://donghuangzhong.github.io/tags/map/"},{"name":"字典","slug":"字典","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E5%85%B8/"}]},{"title":"HDU-1003","slug":"HDU-1003","date":"2020-02-07T08:06:14.000Z","updated":"2020-04-01T04:17:51.696Z","comments":true,"path":"2020/02/07/HDU-1003/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/07/HDU-1003/","excerpt":"这个问题作者都描述错了，应该是如果有多个结果，输出end最靠后，start最靠前的那个结果。这个和1002质量都不行，原来和1002是同一个作者","text":"这个问题作者都描述错了，应该是如果有多个结果，输出end最靠后，start最靠前的那个结果。这个和1002质量都不行，原来和1002是同一个作者 题目Max Sum\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 344830 Accepted Submission(s): 82002** Problem Description Given a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000). Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases. Sample Input 12325 6 -1 5 4 -77 0 6 -1 1 -6 7 -5 Sample Output 12345Case 1:14 1 4Case 2:7 1 6 代码:验证作者描述错误的序列:-100 5 5 -100 1 -1 10 -100 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); int t; cin&gt;&gt;t; for(int i=1;i&lt;=t;i++)&#123; int n,max,kaishi,jieshu,shuzi; max=0; int maxmax=-1; int maxkaishi,maxjieshu; cin&gt;&gt;n; kaishi=1; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;shuzi; if(max&gt;=0)&#123; max+=shuzi; jieshu=j; &#125; else &#123; max=shuzi; kaishi=j; jieshu=j; &#125; if(max&gt;=maxmax)&#123; maxmax=max; maxkaishi=kaishi; maxjieshu=jieshu; &#125; &#125; cout&lt;&lt;\"Case \"&lt;&lt;i&lt;&lt;\":\"&lt;&lt;endl&lt;&lt;maxmax&lt;&lt;\" \"&lt;&lt;maxkaishi&lt;&lt;\" \"&lt;&lt;maxjieshu&lt;&lt;endl; if(i!=t)cout&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"最大连续子序列","slug":"最大连续子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"}]},{"title":"HDU-1002","slug":"HDU-1002","date":"2020-02-06T10:50:21.000Z","updated":"2020-02-07T04:48:36.242Z","comments":true,"path":"2020/02/06/HDU-1002/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/06/HDU-1002/","excerpt":"此题在杭电oj上有问题，AC了也不一定代表可以正确，还有dev-cpp5.4.0这个环境，结束时自动输出一行换行","text":"此题在杭电oj上有问题，AC了也不一定代表可以正确，还有dev-cpp5.4.0这个环境，结束时自动输出一行换行 题目A + B Problem II\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 514958 Accepted Submission(s): 98584** Problem Description I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000. Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line is the an equation “A + B = Sum”, Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases. Sample Input 12321 2112233445566778899 998877665544332211 Sample Output 1234Case 1:1 + 2 &#x3D; 3Case 2: 步骤代码1：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); int n,ai,ci,j,sum,jinwei; char a[1000]; char c[1000]; char he[1000]; cin&gt;&gt;n; for(int k=1;k&lt;=n;k++) &#123; cout&lt;&lt;\"Case \"&lt;&lt;k&lt;&lt;\":\"&lt;&lt;endl; cin&gt;&gt;a&gt;&gt;c; cout&lt;&lt;a&lt;&lt;\" + \"&lt;&lt;c&lt;&lt;\" = \"; ai=strlen(a)-1; ci=strlen(c)-1; jinwei=0; int hei=0; while(ai&gt;=0&amp;&amp;ci&gt;=0) &#123; sum=a[ai]-'0'+c[ci]-'0'+jinwei; he[hei++]=sum%10+'0'; jinwei=sum&gt;=10?1:0; ai--; ci--; &#125; while(ai&gt;=0) &#123; sum=a[ai]-'0'+jinwei; he[hei++]=sum%10+'0'; jinwei=sum&gt;=10?1:0; ai--; &#125; while(ci&gt;=0)&#123; sum=c[ci]-'0'+jinwei; he[hei++]=sum%10+'0'; jinwei=sum&gt;=10?1:0; ci--; &#125; hei--; if(jinwei!=0) cout&lt;&lt;jinwei; while(hei&gt;=0) cout&lt;&lt;he[hei--]; cout&lt;&lt;endl; if(k!=n) cout&lt;&lt;endl;&#125;&#125; 错误的AC代码(未考虑进位，结果错误，但还是AC了，输出1+9=0)：由此可见，杭电oj部分题目的后台测试还是不太准确 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); int n,b,d; cin&gt;&gt;n; char a[1000]; char c[1000]; //cin&gt;&gt;n; for(int k=1;k&lt;=n;k++) &#123; cout&lt;&lt;\"Case \"&lt;&lt;k&lt;&lt;\":\"&lt;&lt;endl; cin&gt;&gt;a&gt;&gt;c; cout&lt;&lt;a&lt;&lt;\" + \"&lt;&lt;c&lt;&lt;\" = \"; int j; for(j=0;j&lt;1000;j++) if(a[j]=='\\0') break; b=j; for(j=0;j&lt;1000;j++) if(c[j]=='\\0') break; d=j; //cout&lt;&lt;b&lt;&lt;d; int min=b; if(min&gt;d) min=d; int jinwei=0; int sum; for(int i=1;i&lt;=min;i++)&#123; sum=a[b-i]-'0'+c[d-i]-'0'+jinwei; c[d-i]=sum%10+'0'; //cout&lt;&lt;c[d-i]&lt;&lt;\"\"; jinwei=sum/10; &#125; //cout&lt;&lt;endl; if(min==b) &#123; c[d-min-1]+=jinwei; cout&lt;&lt;c; cout&lt;&lt;endl; &#125; else&#123; a[b-min-1]+=jinwei; for(int i=0;i&lt;=b-min-1;i++) cout&lt;&lt;a[i]; for(int i=d-min;i&lt;=d-1;i++) cout&lt;&lt;c[i]; cout&lt;&lt;endl; &#125;if(k!=n) cout&lt;&lt;endl;&#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"大数","slug":"ACM/大数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0/"}],"tags":[{"name":"大数","slug":"大数","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0/"},{"name":"大数加法","slug":"大数加法","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95/"}]},{"title":"HDU-1001","slug":"HDU-1001","date":"2020-02-06T01:59:33.000Z","updated":"2020-02-06T02:57:26.129Z","comments":true,"path":"2020/02/06/HDU-1001/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/06/HDU-1001/","excerpt":"这个题的平均通过比率大约为0.25(20200206)，平均提交四次才能通过。确实有一个大陷阱，这道题需要我们了解C语言的基本知识和计算机中的运算过程。","text":"这个题的平均通过比率大约为0.25(20200206)，平均提交四次才能通过。确实有一个大陷阱，这道题需要我们了解C语言的基本知识和计算机中的运算过程。 题目Sum Problem \\Time Limit: 1000/500 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 677426 Accepted Submission(s): 170938** Problem Description Hey, welcome to HDOJ(Hangzhou Dianzi University Online Judge). In this problem, your task is to calculate SUM(n) = 1 + 2 + 3 + … + n. Input The input will consist of a series of integers n, one integer per line. Output For each case, output SUM(n) in one line, followed by a blank line. You may assume the result will be in the range of 32-bit signed integer. Sample Input 121100 Sample Output 12315050 C语言中IO和运算过程例如cin&gt;&gt;a;在屏幕上输入5然后点回车，存储过程为将5的补码存到a对应的地址，然后对这个补码进行运算。 例如2*a+1先计算2*a存到一个地方b，然后运算b+1。运算过程为一步一步的，每一步都保存结果，这样就导致了在运算过程中可能导致临时的结果溢出，例如本题中计算1+2+3+···+N有好多种算法(循环累加和公式法)，我们都会下意识的用比较简单的n*(n+1)/2，题目中告诉我们n*(n+1)/2在有符号整形的范围之内，但是计算n*(n+1)的时候要保存一个临时结果，这个结果是有可能比有符号整形大的，所以最终结果不准确。 解决方法调整运算顺序将增大运算和减小运算交错排布将n*(n+1)/2调整为n/2*(n+1)(n为偶数)或(n+1)/2*n(n+1为偶数) 12345678910111213#include &lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std; int main()&#123; int a; while(cin&gt;&gt;a)&#123; if(a%2==0) cout&lt;&lt;a/2*(a+1)&lt;&lt;endl&lt;&lt;endl; else cout&lt;&lt;(a+1)/2*a&lt;&lt;endl&lt;&lt;endl; &#125; return 0;&#125; 消除运算过程中的减小运算(将公式法改为累加法)1234567891011121314#include &lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std; int main()&#123; int a; while(cin&gt;&gt;a) &#123; int sum=0; for(int i=1;i&lt;=a;i++) sum+=i; cout&lt;&lt;sum&lt;&lt;endl&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"易错题","slug":"ACM/易错题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%98%93%E9%94%99%E9%A2%98/"}],"tags":[{"name":"大数陷阱","slug":"大数陷阱","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%99%B7%E9%98%B1/"},{"name":"代数式最大化部分溢出","slug":"代数式最大化部分溢出","permalink":"https://donghuangzhong.github.io/tags/%E4%BB%A3%E6%95%B0%E5%BC%8F%E6%9C%80%E5%A4%A7%E5%8C%96%E9%83%A8%E5%88%86%E6%BA%A2%E5%87%BA/"},{"name":"补码","slug":"补码","permalink":"https://donghuangzhong.github.io/tags/%E8%A1%A5%E7%A0%81/"},{"name":"计算机中运算过程","slug":"计算机中运算过程","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B/"}]},{"title":"HDU-1000","slug":"HDU-1000","date":"2020-02-05T01:17:01.000Z","updated":"2020-02-05T03:18:13.166Z","comments":true,"path":"2020/02/05/HDU-1000/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/05/HDU-1000/","excerpt":"C语言中EOF，C++中EOF，用input.txt代替手工输入，提高解题的测试速度","text":"C语言中EOF，C++中EOF，用input.txt代替手工输入，提高解题的测试速度 题目 A + B Problem Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 944642 Accepted Submission(s): 281848 Problem Description Calculate A + B. Input Each line will contain two integers A and B. Process to end of file. Output For each case, output A + B in one line. Sample Input 11 1 Sample Output 12 C语言EOF 1while(scanf(\"%d%d\",&amp;a,&amp;b)!=EOF) C++EOF 1while(cin&gt;&gt;a&gt;&gt;b)&#123; 用input.txt代替手工输入 在源程序文件(.c、.cpp)的同级目录新建intut.txt文件，里面模拟手工输入的数据 在源程序中main()函数开始处添加代码(要添加#include&lt;stdio.h&gt;头文件)，！！！提交代码前一定要注释掉这行代码 12345#include&lt;stdio.h&gt;int main()&#123; freopen(\"input.txt\", \"r\", stdin);&#125; 本题AC代码： 1234567891011#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; freopen(\"input.txt\", \"r\", stdin); int a,b; while(cin&gt;&gt;a&gt;&gt;b)&#123; cout&lt;&lt;a+b&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"EOF","slug":"EOF","permalink":"https://donghuangzhong.github.io/tags/EOF/"},{"name":"C++文件代替手工输入","slug":"C-文件代替手工输入","permalink":"https://donghuangzhong.github.io/tags/C-%E6%96%87%E4%BB%B6%E4%BB%A3%E6%9B%BF%E6%89%8B%E5%B7%A5%E8%BE%93%E5%85%A5/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-03T04:41:43.819Z","updated":"2020-02-03T04:58:24.929Z","comments":true,"path":"2020/02/03/hello-world/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/03/hello-world/","excerpt":"使用方法","text":"使用方法 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/categories/hexo/"}],"tags":[]},{"title":"ACM-BFS","slug":"ACM-BFS","date":"2019-08-31T06:45:05.000Z","updated":"2020-02-03T04:02:29.707Z","comments":true,"path":"2019/08/31/ACM-BFS/","link":"","permalink":"https://donghuangzhong.github.io/2019/08/31/ACM-BFS/","excerpt":"摘要","text":"摘要 1.BFS的作用：遍历图找到与步长强相关的属性的最优解（也可以附带路径）2.原理起点入队，起点出队，从出队点开始下一步可以到达（符合条件）的所有点入队，队首再出队，从出队点开始下一步可以到达（符合条件）的所有点入队……。总之，步长为n的所有符合条件的点依次批量入队（n=0,1,2……），所以最先访问即步长最短，与步长相关的例如路径长度，消耗的时间最短，即最先访问即最优！ 3.判断是否可以回头(不可随意重复访问标志的设立) 传统01：不可重复访问 如果图中存在能量补充点、时间重置点等等是可以回头的，可以回头的条件是剩余的能量或时间要大于上一次来到这个点时的剩余能量或时间 4.初始化 三个数组 地图数组（一般二维，可三维）：存放墙，可走点，能量补充点、时间充值点 路径变换数组（s[走法种类数][维度]）：通常加法变换，也可以写成乘法矩阵变换 随意访问的数组（跟地图数组一个格式的结构体）：存标志量(传统01，上次到此点剩余能量时间)、路径量(这个点的上一个点的坐标）、其他想随时访问的属性 队列节点结构体 含x,y和仅终点访问的属性 3.实现方式（按常用程度排序） C自带队列 缺点：无法随意访问队列中任意节点，所以如果想要随时访问一个属性，此属性可以存在随意访问数组中 优点：书写简介方便 头文件：#include &lt;queue&gt; 定义代码：queue&lt;node&gt; q; node:可以是结构体，一般含有x,y和仅终点访问的属性 通用代码： 12345678910111213141516171819202122232425262728293031323334353637void dfs()&#123; queue&lt;node&gt; q; node a,b;//a:起点、当前节点、出队点;b:下一节点 …………//初始化a …………/*初始化其他的不可计算量（不可通过上一节点计算的，比如上一次到达这个节点的剩余的时间或者能量） 用lasttime[][],memset(lastime,0,sizeof(lasttime))*/ …………//设置a点不可计算量 if(…………)&#123;…………;return;&#125;//判断起点是不是最优解 q.push(a); while(!q.empty()) &#123; a=q.front(); q.pop(); if(…………)//当前节点必须可以走下一步，比如能量没用完，时间还有 //有些时候规定到达终点时间为0不算，要&gt;1 &#123; for(i=0;i&lt;4;++i)//向题目中规定的方向走 &#123; b.x=a.x+s[i][0];//s数组存储变换矩阵,s[变幻种类][维度] b.y=a.y+s[i][1];//当然也可以写成乘法那种矩阵 if()//判断是不是越界、和走到墙壁位置（如果是传统01标志现在就可以判断） &#123; …………//计算b if(…………)&#123;&#125;//判断是不是能量补充点、时间重置点等等 else&#123;&#125;//如果不是要消耗能量和时间 if(能量和剩余时间&lt;=上一次到达此点的能量和时间)&#123;…………;continue;&#125; //非01标志判断可不可以重复访问 if()&#123;return;&#125;//判断是不是终点，如果自定义队列求路径可以放在入队之后 …………//更新不可计算量（包括01标志） q.push(b); &#125; &#125; &#125; &#125; …………//输出不能到达终点&#125; 自定义队列（需要知道程序需要的最大队列节点数） 自己写队列，不释放入队节点，只移动队首下标。所以可以随意访问队列中任意元素，在求解路径中只需要在队列的结构体中添加一个上一个节点的下标的属性就可以 优点：方便求解路径 队列元素结构：struct point{int x,y,s;};s代表来源点的下标 队列结构：struct p{point pp[1000];int t,w;};其中t表示队列的头，w表示队列的尾 push():d.pp[d.w++]=a; !empty():d.w!=d.t front()&amp;pop():a=d.pp[d.t++]; 递归（没什么意义，还是用的队列） 就是原函数初始化在外面，while()循环体单独写成BFS函数，用!q.empty()判断是否运行此函数 dfs()1234567891011121314151617181920212223242526272829303132333435363738394041424344void dfs()&#123; a&#x3D;q.front(); q.pop(); if(…………)&#x2F;&#x2F;当前节点必须可以走下一步，比如能量没用完，时间还有 &#x2F;&#x2F;有些时候规定到达终点时间为0不算，要&gt;1 &#123; for(i&#x3D;0;i&lt;4;++i)&#x2F;&#x2F;向题目中规定的方向走 &#123; b.x&#x3D;a.x+s[i][0];&#x2F;&#x2F;s数组存储变换矩阵,s[变幻种类][维度] b.y&#x3D;a.y+s[i][1];&#x2F;&#x2F;当然也可以写成乘法那种矩阵 if()&#x2F;&#x2F;判断是不是越界、和走到墙壁位置（如果是传统01标志现在就可以判断） &#123; …………&#x2F;&#x2F;计算b if(…………)&#123;&#125;&#x2F;&#x2F;判断是不是能量补充点、时间重置点等等 else&#123;&#125;&#x2F;&#x2F;如果不是要消耗能量和时间 if(能量和剩余时间&lt;&#x3D;上一次到达此点的能量和时间)&#123;…………;continue;&#125; &#x2F;&#x2F;非01标志判断可不可以重复访问 if()&#123;return;&#125;&#x2F;&#x2F;判断是不是终点，如果自定义队列求路径可以放在入队之后 …………&#x2F;&#x2F;更新不可计算量（包括01标志） q.push(b); &#125; &#125; &#125; if(!q.empty()) dfs(); else …………;&#x2F;&#x2F;输出不能到达终点&#125;queue&lt;node&gt; q;node a,b;&#x2F;&#x2F;a:起点、当前节点、出队点;b:下一节点int main()&#123; …………&#x2F;&#x2F;初始化a …………&#x2F;*初始化其他的不可计算量（不可通过上一节点计算的，比如上一次到达这个节点的剩余的时间或者能量） 用lasttime[][],memset(lastime,0,sizeof(lasttime))*&#x2F; …………&#x2F;&#x2F;设置a点不可计算量 if(…………)&#123;…………;return;&#125;&#x2F;&#x2F;判断起点是不是最优解 q.push(a); if(!q.empty()) dfs(); &#125; 4. 路径打印因为一个点的来源只有一个，但一个点的去处可能有好多点，所以在存储路径的时候一般存储这个点的上一个点，但这样就出现了一个问题，打印路径的时候是倒着的，一般有两种方法解决这个问题，其实是一种 初始化 起点的前一个点的参数设置为-1，自带队列：a[0][0].x=a[0][0].y=-1;自定义：a.s=-1; 递归（隐式调用栈） c自带队列 12345678void print(int x,int y或者int n)&#x2F;&#x2F;注意参数是-，null-0-0-0-&#123;if(x&#x3D;&#x3D;-1&amp;&amp;y&#x3D;&#x3D;-1或者s&#x3D;&#x3D;-1) return ; print(a[x][y].x,a[x][y].y或者p.a[n].s); cout&lt;&lt;x&lt;&lt;y或者cout&lt;&lt;p.a[n].x&lt;&lt;p.a[n].y; &#125; 显式用栈:没什么意义，写起来不方便","categories":[{"name":"工具","slug":"工具","permalink":"https://donghuangzhong.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://donghuangzhong.github.io/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"https://donghuangzhong.github.io/tags/DFS/"}]}],"categories":[{"name":"目标检测","slug":"目标检测","permalink":"https://donghuangzhong.github.io/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"Linux","slug":"Linux","permalink":"https://donghuangzhong.github.io/categories/Linux/"},{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"},{"name":"深度学习","slug":"深度学习","permalink":"https://donghuangzhong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"TersorFlow","slug":"TersorFlow","permalink":"https://donghuangzhong.github.io/categories/TersorFlow/"},{"name":"Hexo","slug":"Hexo","permalink":"https://donghuangzhong.github.io/categories/Hexo/"},{"name":"VM","slug":"VM","permalink":"https://donghuangzhong.github.io/categories/VM/"},{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"},{"name":"个人博客","slug":"个人博客","permalink":"https://donghuangzhong.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"博客搭建","slug":"个人博客/博客搭建","permalink":"https://donghuangzhong.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://donghuangzhong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"多边形填充","slug":"计算机图形学/多边形填充","permalink":"https://donghuangzhong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%A1%AB%E5%85%85/"},{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"category2","slug":"ACM/category2","permalink":"https://donghuangzhong.github.io/categories/ACM/category2/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"},{"name":"字符串","slug":"ACM/字符串","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"双向链表","slug":"ACM/双向链表","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"贪心","slug":"ACM/贪心","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%B4%AA%E5%BF%83/"},{"name":"快速幂","slug":"ACM/快速幂","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"爬虫","slug":"python/爬虫","permalink":"https://donghuangzhong.github.io/categories/python/%E7%88%AC%E8%99%AB/"},{"name":"RMQ","slug":"ACM/RMQ","permalink":"https://donghuangzhong.github.io/categories/ACM/RMQ/"},{"name":"tools","slug":"tools","permalink":"https://donghuangzhong.github.io/categories/tools/"},{"name":"C++","slug":"tools/C","permalink":"https://donghuangzhong.github.io/categories/tools/C/"},{"name":"解题报告","slug":"ACM/解题报告","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"高级dfs","slug":"ACM/高级dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%AB%98%E7%BA%A7dfs/"},{"name":"dfs","slug":"ACM/dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/dfs/"},{"name":"回文","slug":"ACM/回文","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%9B%9E%E6%96%87/"},{"name":"进制","slug":"ACM/进制","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%BF%9B%E5%88%B6/"},{"name":"矩阵乘法","slug":"ACM/矩阵乘法","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"},{"name":"线段交","slug":"ACM/线段交","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%BA%BF%E6%AE%B5%E4%BA%A4/"},{"name":"质因数","slug":"ACM/质因数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%B4%A8%E5%9B%A0%E6%95%B0/"},{"name":"递归","slug":"ACM/递归","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%92%E5%BD%92/"},{"name":"Huffuman","slug":"ACM/Huffuman","permalink":"https://donghuangzhong.github.io/categories/ACM/Huffuman/"},{"name":"大数","slug":"ACM/大数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0/"},{"name":"SPFA","slug":"ACM/SPFA","permalink":"https://donghuangzhong.github.io/categories/ACM/SPFA/"},{"name":"Bellman","slug":"ACM/Bellman","permalink":"https://donghuangzhong.github.io/categories/ACM/Bellman/"},{"name":"Floyd","slug":"ACM/Floyd","permalink":"https://donghuangzhong.github.io/categories/ACM/Floyd/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"},{"name":"DFS","slug":"ACM/DFS","permalink":"https://donghuangzhong.github.io/categories/ACM/DFS/"},{"name":"二进制","slug":"ACM/二进制","permalink":"https://donghuangzhong.github.io/categories/ACM/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"开关","slug":"ACM/开关","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%BC%80%E5%85%B3/"},{"name":"因数","slug":"ACM/因数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%9B%A0%E6%95%B0/"},{"name":"盲集合求交","slug":"ACM/盲集合求交","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%9B%B2%E9%9B%86%E5%90%88%E6%B1%82%E4%BA%A4/"},{"name":"大数动态周期","slug":"ACM/大数动态周期","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0%E5%8A%A8%E6%80%81%E5%91%A8%E6%9C%9F/"},{"name":"字典","slug":"ACM/字典","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E5%85%B8/"},{"name":"易错题","slug":"ACM/易错题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%98%93%E9%94%99%E9%A2%98/"},{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/categories/hexo/"},{"name":"工具","slug":"工具","permalink":"https://donghuangzhong.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"目标检测","slug":"目标检测","permalink":"https://donghuangzhong.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"WSL","slug":"WSL","permalink":"https://donghuangzhong.github.io/tags/WSL/"},{"name":"pandas","slug":"pandas","permalink":"https://donghuangzhong.github.io/tags/pandas/"},{"name":"numpy","slug":"numpy","permalink":"https://donghuangzhong.github.io/tags/numpy/"},{"name":"pyplot","slug":"pyplot","permalink":"https://donghuangzhong.github.io/tags/pyplot/"},{"name":"_keras","slug":"keras","permalink":"https://donghuangzhong.github.io/tags/keras/"},{"name":"AlexNet","slug":"AlexNet","permalink":"https://donghuangzhong.github.io/tags/AlexNet/"},{"name":"jupyter","slug":"jupyter","permalink":"https://donghuangzhong.github.io/tags/jupyter/"},{"name":"GeForce940MX","slug":"GeForce940MX","permalink":"https://donghuangzhong.github.io/tags/GeForce940MX/"},{"name":"图片","slug":"图片","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%BE%E7%89%87/"},{"name":"VM","slug":"VM","permalink":"https://donghuangzhong.github.io/tags/VM/"},{"name":"共享文件","slug":"共享文件","permalink":"https://donghuangzhong.github.io/tags/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/"},{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"},{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/tags/hexo/"},{"name":"github_pages","slug":"github-pages","permalink":"https://donghuangzhong.github.io/tags/github-pages/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"MFC","slug":"MFC","permalink":"https://donghuangzhong.github.io/tags/MFC/"},{"name":"W","slug":"W","permalink":"https://donghuangzhong.github.io/tags/W/"},{"name":"设状态","slug":"设状态","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%BE%E7%8A%B6%E6%80%81/"},{"name":"记忆化dfs","slug":"记忆化dfs","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96dfs/"},{"name":"滚动数组","slug":"滚动数组","permalink":"https://donghuangzhong.github.io/tags/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"},{"name":"二分查找(大小于)","slug":"二分查找-大小于","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%A4%A7%E5%B0%8F%E4%BA%8E/"},{"name":"最长公共子序列","slug":"最长公共子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"最长上升子序列","slug":"最长上升子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"最长(非)单调子序列","slug":"最长-非-单调子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF-%E9%9D%9E-%E5%8D%95%E8%B0%83%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"Dilworth定理","slug":"Dilworth定理","permalink":"https://donghuangzhong.github.io/tags/Dilworth%E5%AE%9A%E7%90%86/"},{"name":"简单DP","slug":"简单DP","permalink":"https://donghuangzhong.github.io/tags/%E7%AE%80%E5%8D%95DP/"},{"name":"高阶01背包","slug":"高阶01背包","permalink":"https://donghuangzhong.github.io/tags/%E9%AB%98%E9%98%B601%E8%83%8C%E5%8C%85/"},{"name":"无限背包","slug":"无限背包","permalink":"https://donghuangzhong.github.io/tags/%E6%97%A0%E9%99%90%E8%83%8C%E5%8C%85/"},{"name":"01可不满背包","slug":"01可不满背包","permalink":"https://donghuangzhong.github.io/tags/01%E5%8F%AF%E4%B8%8D%E6%BB%A1%E8%83%8C%E5%8C%85/"},{"name":"食物链","slug":"食物链","permalink":"https://donghuangzhong.github.io/tags/%E9%A3%9F%E7%89%A9%E9%93%BE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://donghuangzhong.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"记忆化递归","slug":"记忆化递归","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92/"},{"name":"邻接表","slug":"邻接表","permalink":"https://donghuangzhong.github.io/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"},{"name":"优先队列","slug":"优先队列","permalink":"https://donghuangzhong.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"vector","slug":"vector","permalink":"https://donghuangzhong.github.io/tags/vector/"},{"name":"正向DP","slug":"正向DP","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E5%90%91DP/"},{"name":"数塔","slug":"数塔","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E5%A1%94/"},{"name":"正反向思考","slug":"正反向思考","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E5%8F%8D%E5%90%91%E6%80%9D%E8%80%83/"},{"name":"转移方程的构造","slug":"转移方程的构造","permalink":"https://donghuangzhong.github.io/tags/%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E7%9A%84%E6%9E%84%E9%80%A0/"},{"name":"极度优化","slug":"极度优化","permalink":"https://donghuangzhong.github.io/tags/%E6%9E%81%E5%BA%A6%E4%BC%98%E5%8C%96/"},{"name":"多数组DP","slug":"多数组DP","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%9A%E6%95%B0%E7%BB%84DP/"},{"name":"背包","slug":"背包","permalink":"https://donghuangzhong.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"},{"name":"字母","slug":"字母","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E6%AF%8D/"},{"name":"双向链表","slug":"双向链表","permalink":"https://donghuangzhong.github.io/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"索引表","slug":"索引表","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A2%E5%BC%95%E8%A1%A8/"},{"name":"整除2","slug":"整除2","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B4%E9%99%A42/"},{"name":"字符串比较","slug":"字符串比较","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"},{"name":"大数陷阱","slug":"大数陷阱","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%99%B7%E9%98%B1/"},{"name":"溢出陷阱","slug":"溢出陷阱","permalink":"https://donghuangzhong.github.io/tags/%E6%BA%A2%E5%87%BA%E9%99%B7%E9%98%B1/"},{"name":"贪心","slug":"贪心","permalink":"https://donghuangzhong.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数据规模","slug":"数据规模","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1/"},{"name":"二进制优化","slug":"二进制优化","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"},{"name":"wallpapers","slug":"wallpapers","permalink":"https://donghuangzhong.github.io/tags/wallpapers/"},{"name":"壁纸","slug":"壁纸","permalink":"https://donghuangzhong.github.io/tags/%E5%A3%81%E7%BA%B8/"},{"name":"ST","slug":"ST","permalink":"https://donghuangzhong.github.io/tags/ST/"},{"name":"STL","slug":"STL","permalink":"https://donghuangzhong.github.io/tags/STL/"},{"name":"蓝桥杯2020模拟赛","slug":"蓝桥杯2020模拟赛","permalink":"https://donghuangzhong.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"编码","slug":"编码","permalink":"https://donghuangzhong.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"动态二进制","slug":"动态二进制","permalink":"https://donghuangzhong.github.io/tags/%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"高级dfs","slug":"高级dfs","permalink":"https://donghuangzhong.github.io/tags/%E9%AB%98%E7%BA%A7dfs/"},{"name":"判断条件的先后","slug":"判断条件的先后","permalink":"https://donghuangzhong.github.io/tags/%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%88%E5%90%8E/"},{"name":"移动成回文最短","slug":"移动成回文最短","permalink":"https://donghuangzhong.github.io/tags/%E7%A7%BB%E5%8A%A8%E6%88%90%E5%9B%9E%E6%96%87%E6%9C%80%E7%9F%AD/"},{"name":"读数字","slug":"读数字","permalink":"https://donghuangzhong.github.io/tags/%E8%AF%BB%E6%95%B0%E5%AD%97/"},{"name":"妙用下标和","slug":"妙用下标和","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E4%B8%8B%E6%A0%87%E5%92%8C/"},{"name":"n维交","slug":"n维交","permalink":"https://donghuangzhong.github.io/tags/n%E7%BB%B4%E4%BA%A4/"},{"name":"分解质因数","slug":"分解质因数","permalink":"https://donghuangzhong.github.io/tags/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/"},{"name":"逻辑","slug":"逻辑","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"泛型编程","slug":"泛型编程","permalink":"https://donghuangzhong.github.io/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"},{"name":"函数模板","slug":"函数模板","permalink":"https://donghuangzhong.github.io/tags/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"},{"name":"龟兔赛跑","slug":"龟兔赛跑","permalink":"https://donghuangzhong.github.io/tags/%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91/"},{"name":"回形取数","slug":"回形取数","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/"},{"name":"字符串数组","slug":"字符串数组","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84/"},{"name":"八皇后问题","slug":"八皇后问题","permalink":"https://donghuangzhong.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"name":"黑白子","slug":"黑白子","permalink":"https://donghuangzhong.github.io/tags/%E9%BB%91%E7%99%BD%E5%AD%90/"},{"name":"两个最小值","slug":"两个最小值","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%A4%E4%B8%AA%E6%9C%80%E5%B0%8F%E5%80%BC/"},{"name":"大数阶乘","slug":"大数阶乘","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/"},{"name":"翻转边","slug":"翻转边","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E8%BE%B9/"},{"name":"来回总和最短","slug":"来回总和最短","permalink":"https://donghuangzhong.github.io/tags/%E6%9D%A5%E5%9B%9E%E6%80%BB%E5%92%8C%E6%9C%80%E7%9F%AD/"},{"name":"正环","slug":"正环","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E7%8E%AF/"},{"name":"排名","slug":"排名","permalink":"https://donghuangzhong.github.io/tags/%E6%8E%92%E5%90%8D/"},{"name":"逻辑路径","slug":"逻辑路径","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E8%B7%AF%E5%BE%84/"},{"name":"最短路径","slug":"最短路径","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"负环","slug":"负环","permalink":"https://donghuangzhong.github.io/tags/%E8%B4%9F%E7%8E%AF/"},{"name":"有向图绕圈","slug":"有向图绕圈","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%89%E5%90%91%E5%9B%BE%E7%BB%95%E5%9C%88/"},{"name":"翻转矩阵","slug":"翻转矩阵","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5/"},{"name":"最大最小距离","slug":"最大最小距离","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"},{"name":"组内最短路径","slug":"组内最短路径","permalink":"https://donghuangzhong.github.io/tags/%E7%BB%84%E5%86%85%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"易错题","slug":"易错题","permalink":"https://donghuangzhong.github.io/tags/%E6%98%93%E9%94%99%E9%A2%98/"},{"name":"标志数组做记录","slug":"标志数组做记录","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%81%9A%E8%AE%B0%E5%BD%95/"},{"name":"遍历所有可能性","slug":"遍历所有可能性","permalink":"https://donghuangzhong.github.io/tags/%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E6%80%A7/"},{"name":"两次BFS","slug":"两次BFS","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%A4%E6%AC%A1BFS/"},{"name":"函数数组形参","slug":"函数数组形参","permalink":"https://donghuangzhong.github.io/tags/%E5%87%BD%E6%95%B0%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82/"},{"name":"倒水","slug":"倒水","permalink":"https://donghuangzhong.github.io/tags/%E5%80%92%E6%B0%B4/"},{"name":"数论","slug":"数论","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"图的连通区域","slug":"图的连通区域","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%8C%BA%E5%9F%9F/"},{"name":"输出路径","slug":"输出路径","permalink":"https://donghuangzhong.github.io/tags/%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84/"},{"name":"妙用标志数组","slug":"妙用标志数组","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"},{"name":"多入口BFS","slug":"多入口BFS","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%9A%E5%85%A5%E5%8F%A3BFS/"},{"name":"火场逃生","slug":"火场逃生","permalink":"https://donghuangzhong.github.io/tags/%E7%81%AB%E5%9C%BA%E9%80%83%E7%94%9F/"},{"name":"标志数组妙用","slug":"标志数组妙用","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/"},{"name":"素数打表","slug":"素数打表","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A0%E6%95%B0%E6%89%93%E8%A1%A8/"},{"name":"逻辑相加妙用","slug":"逻辑相加妙用","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E7%9B%B8%E5%8A%A0%E5%A6%99%E7%94%A8/"},{"name":"同余定理","slug":"同余定理","permalink":"https://donghuangzhong.github.io/tags/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/"},{"name":"二进制表示十进制","slug":"二进制表示十进制","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%8D%81%E8%BF%9B%E5%88%B6/"},{"name":"翻转游戏","slug":"翻转游戏","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E6%B8%B8%E6%88%8F/"},{"name":"八皇后简化版","slug":"八皇后简化版","permalink":"https://donghuangzhong.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%80%E5%8C%96%E7%89%88/"},{"name":"特殊标志数组","slug":"特殊标志数组","permalink":"https://donghuangzhong.github.io/tags/%E7%89%B9%E6%AE%8A%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"},{"name":"递归范围","slug":"递归范围","permalink":"https://donghuangzhong.github.io/tags/%E9%80%92%E5%BD%92%E8%8C%83%E5%9B%B4/"},{"name":"素数环","slug":"素数环","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A0%E6%95%B0%E7%8E%AF/"},{"name":"回溯","slug":"回溯","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"最长连续因数","slug":"最长连续因数","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%9B%A0%E6%95%B0/"},{"name":"按序列累除","slug":"按序列累除","permalink":"https://donghuangzhong.github.io/tags/%E6%8C%89%E5%BA%8F%E5%88%97%E7%B4%AF%E9%99%A4/"},{"name":"map","slug":"map","permalink":"https://donghuangzhong.github.io/tags/map/"},{"name":"字典","slug":"字典","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E5%85%B8/"},{"name":"摄氏华氏温度转换","slug":"摄氏华氏温度转换","permalink":"https://donghuangzhong.github.io/tags/%E6%91%84%E6%B0%8F%E5%8D%8E%E6%B0%8F%E6%B8%A9%E5%BA%A6%E8%BD%AC%E6%8D%A2/"},{"name":"统计数字的个数","slug":"统计数字的个数","permalink":"https://donghuangzhong.github.io/tags/%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"name":"沙漏","slug":"沙漏","permalink":"https://donghuangzhong.github.io/tags/%E6%B2%99%E6%BC%8F/"},{"name":"等差数列","slug":"等差数列","permalink":"https://donghuangzhong.github.io/tags/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/"},{"name":"电梯","slug":"电梯","permalink":"https://donghuangzhong.github.io/tags/%E7%94%B5%E6%A2%AF/"},{"name":"斐波那契","slug":"斐波那契","permalink":"https://donghuangzhong.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"},{"name":"兔子问题","slug":"兔子问题","permalink":"https://donghuangzhong.github.io/tags/%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98/"},{"name":"临界最优","slug":"临界最优","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%B4%E7%95%8C%E6%9C%80%E4%BC%98/"},{"name":"屏蔽细节","slug":"屏蔽细节","permalink":"https://donghuangzhong.github.io/tags/%E5%B1%8F%E8%94%BD%E7%BB%86%E8%8A%82/"},{"name":"斐波那契取余版","slug":"斐波那契取余版","permalink":"https://donghuangzhong.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%8F%96%E4%BD%99%E7%89%88/"},{"name":"动态周期","slug":"动态周期","permalink":"https://donghuangzhong.github.io/tags/%E5%8A%A8%E6%80%81%E5%91%A8%E6%9C%9F/"},{"name":"最大连续子序列","slug":"最大连续子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"大数","slug":"大数","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0/"},{"name":"大数加法","slug":"大数加法","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95/"},{"name":"代数式最大化部分溢出","slug":"代数式最大化部分溢出","permalink":"https://donghuangzhong.github.io/tags/%E4%BB%A3%E6%95%B0%E5%BC%8F%E6%9C%80%E5%A4%A7%E5%8C%96%E9%83%A8%E5%88%86%E6%BA%A2%E5%87%BA/"},{"name":"补码","slug":"补码","permalink":"https://donghuangzhong.github.io/tags/%E8%A1%A5%E7%A0%81/"},{"name":"计算机中运算过程","slug":"计算机中运算过程","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B/"},{"name":"EOF","slug":"EOF","permalink":"https://donghuangzhong.github.io/tags/EOF/"},{"name":"C++文件代替手工输入","slug":"C-文件代替手工输入","permalink":"https://donghuangzhong.github.io/tags/C-%E6%96%87%E4%BB%B6%E4%BB%A3%E6%9B%BF%E6%89%8B%E5%B7%A5%E8%BE%93%E5%85%A5/"},{"name":"BFS","slug":"BFS","permalink":"https://donghuangzhong.github.io/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"https://donghuangzhong.github.io/tags/DFS/"}]}