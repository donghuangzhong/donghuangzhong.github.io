{"meta":{"title":"DHZ'S BLOG","subtitle":"","description":"","author":"东皇钟","url":"https://donghuangzhong.github.io","root":"/"},"pages":[{"title":"所有标签","date":"2020-02-03T05:26:25.965Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"tags/index.html","permalink":"https://donghuangzhong.github.io/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-02-03T05:26:25.962Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"categories/index.html","permalink":"https://donghuangzhong.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-04T08:15:42.817Z","updated":"2020-02-04T08:15:42.817Z","comments":true,"path":"about/index.html","permalink":"https://donghuangzhong.github.io/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 菜鸟程序员一名，涉及ACM算法、python传统机器学习等，2021考研党 关于主题本站主题是：Material X"}],"posts":[{"title":"dao层","slug":"dao层","date":"2021-08-01T01:48:16.000Z","updated":"2021-08-01T11:36:13.030Z","comments":true,"path":"2021/08/01/dao层/","link":"","permalink":"https://donghuangzhong.github.io/2021/08/01/dao%E5%B1%82/","excerpt":"记录java dao层的技术 https://gitee.com/Jagger_Zhong/java-simple-code","text":"记录java dao层的技术 https://gitee.com/Jagger_Zhong/java-simple-code JDBC原始jdbcmybatis原生mybatis 创建maven工程引入依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建mybatis的核心配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 1.properties属性 --&gt; &lt;!--resource目录下--&gt; &lt;properties resource=\"jdbc.properties\"/&gt; &lt;!--&lt;properties&gt;--&gt; &lt;!-- &lt;property name=\"jdbc.driver\" value=\"com.mysql.jdbc.Driver\"/&gt;--&gt; &lt;!-- &lt;property name=\"jdbc.url\" value=\"jdbc:mysql:///test\"/&gt;--&gt; &lt;!-- &lt;property name=\"jdbc.username\" value=\"root\"/&gt;--&gt; &lt;!-- &lt;property name=\"jdbc.password\" value=\"root\"/&gt;--&gt; &lt;!--&lt;/properties&gt;--&gt; &lt;!--2.settings属性。一般不设置--&gt; &lt;settings&gt; &lt;!--全局映射器启用禁用缓存、默认启用--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;!--启用禁用延时加载、默认启用--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载,默认值false--&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"true\"/&gt; &lt;!--是否允许单一语句返回多结果集,默认值为true --&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;!--使用列标签代替列名,默认值为true --&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;!--允许 JDBC 支持自动生成主键，需要驱动兼容,默认值为false --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;!--指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集 （无论是否嵌套）,默认值为PARTIAL--&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;!--设置超时时间，它决定驱动等待数据库响应的秒数。参数为任意正整数，未设置默认值--&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25000\"/&gt; &lt;/settings&gt; &lt;!--3.类别名typeAliases--&gt; &lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias=\"user\" type=\"com.dhz.entity.User\"/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大小写都可以） --&gt; &lt;package name=\"com.dhz.entity\"/&gt; &lt;/typeAliases&gt; &lt;!--4.typeHandlers（类型句柄）。设置参数、结果集取出数据时，java类型和数据库类型的互相转换--&gt; &lt;!--注册类型自定义转换器--&gt; &lt;typeHandlers&gt; &lt;typeHandler handler=\"com.dhz.typeHandlers.MyDateTypeHandler\"&gt;&lt;/typeHandler&gt; &lt;/typeHandlers&gt; &lt;!--5、ObjectFactory（对象工厂） 不常用--&gt; &lt;!--&lt;ObjectFactory type=\"com.yan.objectFactory.TestObjectFactory\"&gt;--&gt; &lt;!-- &lt;property name=\"\" value=\"\"/&gt;--&gt; &lt;!--&lt;/ObjectFactory&gt;--&gt; &lt;!--6.Plugins （插件）--&gt; &lt;plugins&gt; &lt;!-- PageHelper5版本配置 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"/&gt; &lt;/plugins&gt; &lt;!--7、environments。数据源环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 8、加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;package name=\"cn.kang.mapper\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 创建映射文件 1 常用操作自定义类型转换器需求：进数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。 创建类MyDateTypeHandler继承BaseTypeHandler、指定Date泛型、覆盖未实现的方法 123456789101112131415161718192021222324package com.dhz.typeHandlers;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import java.sql.*;public class MyDateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; public void setNonNullParameter(PreparedStatement ps, int i, Date parameter, JdbcType jdbcType) throws SQLException &#123; ps.setLong(i,parameter.getTime()); &#125; public Date getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return new Date(rs.getLong(columnName)); &#125; public Date getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return new Date(rs.getLong(columnIndex)); &#125; public Date getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return new Date(cs.getLong(columnIndex)); &#125;&#125; 在MyBatis核心配置文件中进行注册 1234&lt;!--注册类型自定义转换器--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=\"com.dhz.typeHandlers.MyDateTypeHandler\"&gt;&lt;/typeHandler&gt;&lt;/typeHandlers&gt; 用pageHelper分页 导入坐标 1234567891011&lt;!-- 分页助手 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt; &lt;artifactId&gt;pagehelper&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsqlparser&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 在mybatis核心配置文件中配置PageHelper插件 1234&lt;plugins&gt; &lt;!-- PageHelper5版本配置 --&gt; &lt;plugin interceptor&#x3D;&quot;com.github.pagehelper.PageInterceptor&quot;&#x2F;&gt;&lt;&#x2F;plugins&gt; 测试 12345678910@Testpublic void testPageHelper()&#123; &#x2F;&#x2F;设置分页参数 PageHelper.startPage(1,2); List&lt;User&gt; select &#x3D; userMapper2.select(null); for(User user : select)&#123; System.out.println(user); &#125;&#125; 获得分页相关的其他参数 12345678&#x2F;&#x2F;其他分页的数据PageInfo&lt;User&gt; pageInfo &#x3D; new PageInfo&lt;User&gt;(select);System.out.println(&quot;总条数：&quot;+pageInfo.getTotal());System.out.println(&quot;总页数：&quot;+pageInfo.getPages());System.out.println(&quot;当前页：&quot;+pageInfo.getPageNum());System.out.println(&quot;每页显示长度：&quot;+pageInfo.getPageSize());System.out.println(&quot;是否第一页：&quot;+pageInfo.isIsFirstPage());System.out.println(&quot;是否最后一页：&quot;+pageInfo.isIsLastPage()); 常见问题 为什么占位符可以防止sql注入？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103String sql &#x3D; &quot;select * from administrator where adminname&#x3D;?&quot;;psm &#x3D; con.prepareStatement(sql);String s_name &#x3D;&quot;zhangsan&#39; or &#39;1&#39;&#x3D;&#39;1&quot;;psm.setString(1, s_name);JDBC是一套接口(规范)，不同的数据库厂商自己实现JDBC的接口，封装成数据库驱动，供我们使用。在mysql的源码中会对特殊字符进行处理，例如“ &#39; ”变为“ \\&#39; ”,原来的sql注入问题：&quot; select * from administrator where adminname&#x3D;&#39; &quot;+&quot; zhangsan&#39; or &#39;1&#39;&#x3D;&#39;1 &quot;&#x3D;&quot; select * from administrator where adminname&#x3D;&#39; zhangsan&#39; or &#39;1&#39;&#x3D;&#39;1 &quot;现在的方式得到的sql为：&quot; select * from administrator where adminname&#x3D;&#39; zhangsan\\&#39; or \\&#39;1\\&#39;&#x3D;\\&#39;1 &quot;查询就会失败！！！public void setString(int parameterIndex, String x) throws SQLException &#123; &#x2F;&#x2F; if the passed string is null, then set this column to null if (x &#x3D;&#x3D; null) &#123; setNull(parameterIndex, Types.CHAR); &#125; else &#123; StringBuffer buf &#x3D; new StringBuffer((int) (x.length() * 1.1)); buf.append(&#39;\\&#39;&#39;); int stringLength &#x3D; x.length(); &#x2F;&#x2F; &#x2F;&#x2F; Note: buf.append(char) is _faster_ than &#x2F;&#x2F; appending in blocks, because the block &#x2F;&#x2F; append requires a System.arraycopy().... &#x2F;&#x2F; go figure... &#x2F;&#x2F; for (int i &#x3D; 0; i &lt; stringLength; ++i) &#123; char c &#x3D; x.charAt(i); switch (c) &#123; case 0: &#x2F;* Must be escaped for &#39;mysql&#39; *&#x2F; buf.append(&#39;\\\\&#39;); buf.append(&#39;0&#39;); break; case &#39;\\n&#39;: &#x2F;* Must be escaped for logs *&#x2F; buf.append(&#39;\\\\&#39;); buf.append(&#39;n&#39;); break; case &#39;\\r&#39;: buf.append(&#39;\\\\&#39;); buf.append(&#39;r&#39;); break; case &#39;\\\\&#39;:&#x2F;&#x2F; 此处会将一&#39;变为&#x2F;&#39;所以 buf.append(&#39;\\\\&#39;); buf.append(&#39;\\\\&#39;); break; case &#39;\\&#39;&#39;: buf.append(&#39;\\\\&#39;); buf.append(&#39;\\&#39;&#39;); break; case &#39;&quot;&#39;: &#x2F;* Better safe than sorry *&#x2F; if (this.usingAnsiMode) &#123; buf.append(&#39;\\\\&#39;); &#125; buf.append(&#39;&quot;&#39;); break; case &#39;\\032&#39;: &#x2F;* This gives problems on Win32 *&#x2F; buf.append(&#39;\\\\&#39;); buf.append(&#39;Z&#39;); break; default: buf.append(c); &#125; &#125; buf.append(&#39;\\&#39;&#39;); String parameterAsString &#x3D; buf.toString(); byte[] parameterAsBytes &#x3D; null; if (!this.isLoadDataQuery) &#123; parameterAsBytes &#x3D; StringUtils.getBytes(parameterAsString, this.charConverter, this.charEncoding, this.connection .getServerCharacterEncoding(), this.connection .parserKnowsUnicode()); &#125; else &#123; &#x2F;&#x2F; Send with platform character encoding parameterAsBytes &#x3D; parameterAsString.getBytes(); &#125; setInternal(parameterIndex, parameterAsBytes); &#125; &#125;","categories":[{"name":"dao","slug":"dao","permalink":"https://donghuangzhong.github.io/categories/dao/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"}]},{"title":"centos","slug":"centos","date":"2021-07-31T00:11:52.000Z","updated":"2021-07-31T00:30:03.214Z","comments":true,"path":"2021/07/31/centos/","link":"","permalink":"https://donghuangzhong.github.io/2021/07/31/centos/","excerpt":"记录linux常用的命令操作","text":"记录linux常用的命令操作 文件相关写文件 创建文件 1touch a.txt 向文件写数据 1&gt;是重定向的意思 12echo hello docker &gt;b.txt # 覆盖写echo hello docker &gt;&gt;b.txt # 追加写 查看文件(结果可作为其他命令的参数) cat 1cat [参数] fileName -n -b -s 输出行号(1开始) 等于-n,空白行不显示 连续两行以上的空白行，代换为一行的空白行 -v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。 -E 或 –show-ends : 在每行结束处显示 $。 -T 或 –show-tabs: 将 TAB 字符显示为 ^I。 -A, –show-all：等价于 -vET。 -e：等价于”-vE”选项； -t：等价于”-vT”选项； 常见问题 Another app is currently holding the yum lock; waiting for it to exit… 1pkill yum","categories":[{"name":"linux","slug":"linux","permalink":"https://donghuangzhong.github.io/categories/linux/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://donghuangzhong.github.io/tags/centos/"}]},{"title":"igix","slug":"igix","date":"2021-07-15T11:52:21.000Z","updated":"2021-07-15T12:22:30.576Z","comments":true,"path":"2021/07/15/igix/","link":"","permalink":"https://donghuangzhong.github.io/2021/07/15/igix/","excerpt":"摘要","text":"摘要 新建用户以及用户赋权 创建系统组织、用户分组、用户 创建功能组和岗位并绑定，岗位赋给用户，功能组和岗位绑定，只要设置功能组中的功能即可","categories":[{"name":"igix","slug":"igix","permalink":"https://donghuangzhong.github.io/categories/igix/"}],"tags":[]},{"title":"typora","slug":"typora","date":"2021-07-15T11:49:05.000Z","updated":"2021-07-15T11:51:30.490Z","comments":true,"path":"2021/07/15/typora/","link":"","permalink":"https://donghuangzhong.github.io/2021/07/15/typora/","excerpt":"记录Markdown的相关操作","text":"记录Markdown的相关操作 typora自动添加编号 打开typora设置 -&gt; 偏好设置 -&gt; 打开主题文件夹 新建ase.user.css文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/* 正文标题区: #write *//* [TOC]目录树区: .md-toc-content *//* 侧边栏的目录大纲区: .sidebar-content *//** initialize css counter */#write, .sidebar-content,.md-toc-content&#123; counter-reset: h2&#125;#write h1, .outline-h1, .md-toc-item.md-toc-h1 &#123; counter-reset: h2&#125;#write h2, .outline-h2, .md-toc-item.md-toc-h2 &#123; counter-reset: h3&#125;#write h3, .outline-h3, .md-toc-item.md-toc-h3 &#123; counter-reset: h4&#125;#write h4, .outline-h4, .md-toc-item.md-toc-h4 &#123; counter-reset: h5&#125;#write h5, .outline-h5, .md-toc-item.md-toc-h5 &#123; counter-reset: h6&#125;/** put counter result into headings *//* 一级标题不展示 */#write h1:before,.outline-h1&gt;.outline-item&gt;.outline-label:before,.md-toc-item.md-toc-h1&gt;.md-toc-inner:before &#123; /* counter-increment: h1; content: counter(h1) \". \" */&#125;/* 二级标题 */#write h2:before,.outline-h2&gt;.outline-item&gt;.outline-label:before,.md-toc-item.md-toc-h2&gt;.md-toc-inner:before &#123; counter-increment: h2; content: counter(h2) \". \"; /* content: counter(h2) \". \" */&#125;/* 三级标题 */#write h3:before,h3.md-focus.md-heading:before, /** override the default style for focused headings */.outline-h3&gt;.outline-item&gt;.outline-label:before,.md-toc-item.md-toc-h3&gt;.md-toc-inner:before &#123; text-decoration: none; counter-increment: h3; /* content: counter(h1) \".\" counter(h2) \".\" counter(h3) \". \" */ /* content: counter(h2) \".\" counter(h3) \". \" */ content: counter(h2) \".\" counter(h3) \" \"&#125;/* 四级标题 */#write h4:before,h4.md-focus.md-heading:before,.outline-h4&gt;.outline-item&gt;.outline-label:before,.md-toc-item.md-toc-h4&gt;.md-toc-inner:before &#123; text-decoration: none; counter-increment: h4; /* content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \". \" */ /* content: counter(h2) \".\" counter(h3) \".\" counter(h4) \". \" */ content: counter(h2) \".\" counter(h3) \".\" counter(h4) \" \"&#125;/* 五级标题 */#write h5:before,h5.md-focus.md-heading:before,.outline-h5&gt;.outline-item&gt;.outline-label:before,.md-toc-item.md-toc-h5&gt;.md-toc-inner:before &#123; text-decoration: none; counter-increment: h5; /* content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \". \" */ /* content: counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \". \" */ content: counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \" \"&#125;/* 六级标题 */#write h6:before,h6.md-focus.md-heading:before,.outline-h6&gt;.outline-item&gt;.outline-label:before,.md-toc-item.md-toc-h6&gt;.md-toc-inner:before &#123; text-decoration: none; counter-increment: h6; /* content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \".\" counter(h6) \". \" */ /* content: counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \".\" counter(h6) \". \" */ content: counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \".\" counter(h6) \" \"&#125;/** override the default style for focused headings */#write&gt;h3.md-focus:before,#write&gt;h4.md-focus:before,#write&gt;h5.md-focus:before,#write&gt;h6.md-focus:before,h3.md-focus:before,h4.md-focus:before,h5.md-focus:before,h6.md-focus:before &#123; color: inherit; border: inherit; border-radius: inherit; position: inherit; left:initial; float: none; top:initial; font-size: inherit; padding-left: inherit; padding-right: inherit; vertical-align: inherit; font-weight: inherit; line-height: inherit;&#125;/* 设置行距 *//* 设置一级标题行距 */#write h1 &#123; margin-bottom:50px; margin-top:50px;&#125;#write h2 &#123; margin-bottom:30px; margin-top:50px;&#125;#write h3 &#123; margin-bottom:30px; margin-top:30px;&#125;#write h4 &#123; margin-bottom:30px; margin-top:30px;&#125;#write h5 &#123; margin-bottom:30px; margin-top:30px;&#125;","categories":[{"name":"md","slug":"md","permalink":"https://donghuangzhong.github.io/categories/md/"}],"tags":[]},{"title":"pgsql","slug":"pgsql","date":"2021-07-10T02:19:38.000Z","updated":"2021-07-10T02:36:52.465Z","comments":true,"path":"2021/07/10/pgsql/","link":"","permalink":"https://donghuangzhong.github.io/2021/07/10/pgsql/","excerpt":"摘要","text":"摘要 下载安装地址：https://www.enterprisedb.com/downloads/postgresql 以管理员运行，会先下载c++运行库 选择全部安装项","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"docker","slug":"docker","date":"2021-07-04T00:09:38.000Z","updated":"2021-07-31T11:29:42.478Z","comments":true,"path":"2021/07/04/docker/","link":"","permalink":"https://donghuangzhong.github.io/2021/07/04/docker/","excerpt":"摘要","text":"摘要 docker概述 Docker 是一个开源的应用容器引擎 诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后改名为Docker Inc） Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。 容器是完全使用沙箱机制，相互隔离 容器性能开销极低。 docker架构 镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。 安装Docker123456789101112# 1、yum 包更新到最新 yum update# 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm2# 3、 设置yum源yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 失败的话安装阿里的yum源yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 4、 安装docker，出现输入的界面都按 y yum install -y docker-ce# 5、 查看docker版本，验证是否验证成功docker -v Docker 进程(daemon)相关命令 启动docker服务 1systemctl start docker 停止docker服务 1systemctl stop docker 查看docker服务状态 1systemctl status docker 重启docker服务 1systemctl restart docker 设置开机启动docker服务 1systemctl enable docker 镜像相关命令 查看镜像: 查看本地所有的镜像 12docker imagesdocker images –q # 查看所有镜像的id(仅有id) 搜索镜像:从网络中查找需要的镜像 1docker search 镜像名称 拉取镜像:从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。 12docker pull 镜像名称docker pull 镜像名称：版本号 删除镜像: 删除本地镜像 12docker rmi 镜像id # 删除指定本地镜像docker rmi `docker images -q` # 删除所有本地镜像 容器相关命令 查看容器 123docker ps # 查看正在运行的容器docker ps –a # 查看所有容器docker ps -aq #查看所有容器的id(仅有id、可作为删除的参数) 创建并启动容器 1docker run 参数 参数说明： •-i：保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。 •-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。 •-d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。 •-it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器 -it会立刻进入容器、-id运行容器但是不进入（需要使用exec进入） •–name：为创建的容器命名。 1docker run -it --name=centos1 centos:7 进入运行的容器 12docker exec 参数 # 退出容器，容器不会关闭docker exec -it centosid /bin/bash 停止容器 1docker stop 容器名称 启动容器 1docker start 容器名称 删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除 1docker rm 容器名称 查看容器信息 1docker inspect 容器名称 数据卷概述数据卷是宿主机中的被容器使用的一个目录或文件 特性 当容器目录和数据卷目录绑定后，对方的修改会立即同步 一个数据卷可以被多个容器同时挂载 一个容器也可以被挂载多个数据卷 作用 容器数据持久化 外部机器和容器间接通信 容器之间数据交换（两个容器挂在同一个数据卷） 操作 创建启动容器时，使用 –v 参数 设置数据卷 12docker run ... –v 宿主机目录(文件):容器内目录(文件) ... docker run -it --name=c1 -v /root/data:/root/data_container centos:7 目录必须是绝对路径 如果目录不存在，会自动创建 可以挂载多个数据卷 数据卷容器 作用：方便快捷实现共享的数据卷配置 创建启动c3数据卷容器，使用 –v 参数 设置数据卷 1docker run –it --name=c3 –v /volume centos:7 /bin/bash 如果不指定宿主机的目录(没有冒号)，会在宿主机的docker目录下分配一个UUID名字类型的目录 创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷 123docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bashdocker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash Docker 应用部署部署MySQL 搜索mysql镜像 1docker search mysql 拉取mysql镜像 1docker pull mysql:5.6 创建容器，设置端口映射、目录映射 123# 在/root目录下创建mysql目录用于存储mysql数据信息mkdir ~/mysqlcd ~/mysql 12345678docker run -id \\-p 3307:3306 \\--name=c_mysql \\-v $PWD/conf:/etc/mysql/conf.d \\-v $PWD/logs:/logs \\-v $PWD/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\mysql:5.6 参数说明： -p 3307:3306：将容器的 3306 端口映射到宿主机的 3307 端口。映射的端口可以相同 -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。配置目录 -v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。日志目录 -v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。数据目录 -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。 进入容器，操作mysql 1docker exec -it c_mysql /bin/bash 使用外部机器连接容器中的mysql 部署Tomcat 搜索tomcat镜像 1docker search tomcat 拉取tomcat镜像 1docker pull tomcat 创建容器，设置端口映射、目录映射 123# 在/root目录下创建tomcat目录用于存储tomcat数据信息mkdir ~/tomcatcd ~/tomcat 1234docker run -id --name=c_tomcat \\-p 8080:8080 \\-v $PWD:/usr/local/tomcat/webapps \\tomcat 参数说明： -p 8080:8080：将容器的8080端口映射到主机的8080端口 -v $PWD:/usr/local/tomcat/webapps：将主机中当前目录挂载到容器的webapps 使用外部机器访问tomcat 部署Nginx 搜索nginx镜像 1docker search nginx 拉取nginx镜像 1docker pull nginx 创建容器，设置端口映射、目录映射 1234567# 在/root目录下创建nginx目录用于存储nginx数据信息mkdir ~/nginxcd ~/nginxmkdir confcd conf# 在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容vim nginx.conf 12345678910111213141516171819202122232425262728293031user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;&#125; 123456docker run -id --name=c_nginx \\-p 80:80 \\-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\-v $PWD/logs:/var/log/nginx \\-v $PWD/html:/usr/share/nginx/html \\nginx 参数说明： -p 80:80：将容器的 80端口映射到宿主机的 80 端口。 -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机当前目录下的 /conf/nginx.conf 挂载到容器的 :/etc/nginx/nginx.conf。配置目录 -v $PWD/logs:/var/log/nginx：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx。日志目录 使用外部机器访问nginx 部署Redis 搜索redis镜像 1docker search redis 拉取redis镜像 1docker pull redis:5.0 创建容器，设置端口映射 1docker run -id --name=c_redis -p 6379:6379 redis:5.0 使用外部机器连接redis 1./redis-cli.exe -h 192.168.149.135 -p 6379 docker镜像原理Linux文件系统由bootfs和rootfs两部分组成 bootfs：包含bootloader（引导加载程序）和 kernel（内核） rootfs： root文件系统，包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件 不同的linux发行版，bootfs基本一样，而rootfs不同，如ubuntu 123456Docker镜像是由特殊的文件系统叠加而成最底端是 bootfs，并使用宿主机的bootfs 第二层是 root文件系统rootfs,称为base image然后再往上可以叠加其他的镜像文件docker镜像本质就是一个分层文件系统 镜像制作 容器转为镜像 1docker commit 容器id 镜像名称:版本号 镜像转为压缩包 1docker save -o 压缩文件名称 镜像名称:版本号 压缩包还原为镜像 1docker load –i 压缩文件名称 dockerfileDockerfile 是一个文本文件,包含了一条条的指令,每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像。 关键字 构建镜像的命令 1docker bulid –f dockerfile文件路径 –t 镜像名称:版本 关键字 作用 备注 FROM 指定父镜像 指定dockerfile基于那个image构建 MAINTAINER 作者信息 用来标明这个dockerfile谁写的 LABEL 标签 用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看 RUN 执行命令 执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”] CMD 容器启动命令 提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”] ENTRYPOINT 入口 一般在制作一些执行就关闭的容器中会使用 COPY 复制文件 build的时候复制文件到image中 ADD 添加文件 build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务 ENV 环境变量 指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value ARG 构建参数 构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数 VOLUME 定义外部可以挂载的数据卷 指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”] EXPOSE 暴露端口 定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp WORKDIR 工作目录 指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径 USER 指定执行用户 指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户 HEALTHCHECK 健康检查 指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制 ONBUILD 触发器 当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大 STOPSIGNAL 发送信号量到宿主机 该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。 SHELL 指定执行脚本的shell 指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell 构建自己的centos7需求123自定义centos7镜像。要求：1. 默认登录路径为 &#x2F;usr2. 可以使用vim 步骤123456定义父镜像：FROM centos:7定义作者信息：MAINTAINER itheima &lt;itheima@itcast.cn&gt;执行安装vim命令： RUN yum install -y vim定义默认的工作目录：WORKDIR &#x2F;usr定义容器启动执行的命令：CMD &#x2F;bin&#x2F;bash通过dockerfile构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本 构建自己的额springboot项目镜像12345定义父镜像：FROM java:8定义作者信息：MAINTAINER itheima &lt;itheima@itcast.cn&gt;将jar包添加到容器： ADD springboot.jar app.jar定义容器启动执行的命令：CMD java–jar app.jar通过dockerfile构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本 Docker Compose安装Docker Compose123456# Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以编译好的二进制包方式安装在Linux系统中。 curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose# 设置文件可执行权限 chmod +x /usr/local/bin/docker-compose# 查看版本信息 docker-compose -version 卸载Docker Compose12# 二进制包方式安装的，删除二进制文件即可rm /usr/local/bin/docker-compose 使用docker compose编排nginx+springboot项目 创建docker-compose目录 12mkdir ~/docker-composecd ~/docker-compose 编写 docker-compose.yml 文件 1234567891011121314version: '3'services: nginx: image: nginx ports: - 80:80 links: - app volumes: - ./nginx/conf.d:/etc/nginx/conf.d app: image: app expose: - \"8080\" 创建./nginx/conf.d目录 1mkdir -p ./nginx/conf.d 在./nginx/conf.d目录下 编写itheima.conf文件 123456789server &#123; listen 80; access_log off; location / &#123; proxy_pass http://app:8080; &#125; &#125; 在~/docker-compose 目录下 使用docker-compose 启动容器 1docker-compose up 测试访问 1http://192.168.149.135/hello Docker 私有仓库私有仓库搭建123456789101112# 1、拉取私有仓库镜像 docker pull registry# 2、启动私有仓库容器 docker run -id --name=registry -p 5000:5000 registry# 3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;\"repositories\":[]&#125; 表示私有仓库 搭建成功# 4、修改daemon.json vim /etc/docker/daemon.json # 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip &#123;\"insecure-registries\":[\"私有仓库服务器ip:5000\"]&#125; # 5、重启docker 服务 systemctl restart dockerdocker start registry 将镜像上传至私有仓库12345# 1、标记镜像为私有仓库的镜像 docker tag centos:7 私有仓库服务器IP:5000/centos:7 # 2、上传标记的镜像 docker push 私有仓库服务器IP:5000/centos:7 从私有仓库拉取镜像12#拉取镜像 docker pull 私有仓库服务器ip:5000/centos:7","categories":[{"name":"docker","slug":"docker","permalink":"https://donghuangzhong.github.io/categories/docker/"}],"tags":[]},{"title":"ES6","slug":"ES6","date":"2021-07-03T09:05:13.000Z","updated":"2021-07-03T23:52:04.744Z","comments":true,"path":"2021/07/03/ES6/","link":"","permalink":"https://donghuangzhong.github.io/2021/07/03/ES6/","excerpt":"摘要","text":"摘要 ES6概述ECMAScript是前端js的语法规范；可以应用在各种js环境中。如：浏览器或者node.js环境。 它有很多版本：es1/2/3/5/6，很多新特性，可以在js环境中使用这些新特性。 let、模板字符串、简写初始化对象 let所声明的变量只能在let命令所在的代码块中使用 const声明的变量是常量，也就是值不可以改变 模板字符串：用飘号(esc键下面的键)，来声明字符串，原样显示字符串 使用${变量名}取变量的值 1234var name=\"张三\";console.log(`\"'@#$%^&amp;-$&#123;name&#125;-*()_+'\"`); 对象初始化简化：可以在返回的对象时，不用指定属性名。 12345678910function getPerson(name,age) &#123; return &#123;name:name,age:age&#125;;&#125;console.log(\"传统构造对象的方式:\"+JSON.stringify(getPerson(\"张三\",15))); function getES6Person(name,age) &#123; //属性和变量名同名的情况下可以这样书写 return &#123;name,age&#125;;&#125;console.log(\"传统构造对象的方式:\"+JSON.stringify(getES6Person(\"李四\",26))); 解构表达式 数组 console.log(x,y,z);可以连续输出数字 123var nums=[1,2,3];var [x,y,z]=nums;console.log(x,y,z); 对象解构 12345const person = &#123; name:\"jack\", age:21, language: ['java','js','css']&#125;; 解构到同属性名的变量中 12var &#123;name,age,language&#125;=person;console.log(\"name:\"+name+\"\\nage:\"+age+\"\\nlanguage:\"+language); 变量名与属性名不同 12var &#123;name:mingzi,age:nianling,language:yuyan&#125;=person;console.log(\"mingzi:\"+mingzi+\"\\nnianling:\"+nianling+\"\\nyuyan:\"+yuyan); 拷贝对象属性 :想获取person的 name 和 age 属性并封装到新的对象 12var &#123;language:yuyan,...newObj&#125;=person;console.log(\"yuyan:\"+yuyan+\"\\nnewObj\"+JSON.stringify(newObj)); 函数优化(箭头函数)普通函数优化12345678910111213//普通函数function print1(str) &#123; console.log(str);&#125;console.log(`$&#123;print1(\"print1正在输出\")&#125;`);//变量函数var print2=function (str) &#123; console.log(str);&#125;console.log(`$&#123;print2(\"print2正在输出\")&#125;`);//箭头函数var print3=str=&gt;console.log(str);console.log(`$&#123;print3(\"print3正在输出\")&#125;`); 对象的函数属性简写1234567891011121314151617//对象的函数属性简写var p = &#123; \"name\":\"jack\", //以前，也可以给food默认值 eat1: function (food=\"肉\") &#123; console.log(this.name + \"在吃\" + food); &#125;, //箭头函数版,不能使用this eat2: (food) =&gt; console.log(person.name + \"在吃\" + food), //简版 eat3(food)&#123; console.log(this.name + \"在吃\" + food) &#125;&#125;;p.eat1(\"111\");p.eat2(\"222\");p.eat3(\"333\"); 箭头函数结合解构表达式1234567891011//箭头函数结合解构表达式 var pp=&#123; name:\"张三\"&#125;;//普通函数var hello=person=&gt;console.log(\"hello,\"+name);hello(pp);//用结构做参数需要加 ‘（）’var helloES6=(&#123;name&#125;)=&gt;console.log(\"hello,\"+name);helloES6(person) map方法使用map方法可以将原数组中的所有元素通过一个函数进行处理并放入到一个新数组中并返回该新数组。 1234//map函数的使用var tt=[\"1\",\"2\",\"3\"];var ttt=tt.map(a=&gt;parseInt(a));console.log(ttt); reduce方法使用12345//reduce函数的使用 var arr=[1,2,3]; var t1=arr.reduce((a,b)=&gt;a+b); var t2=arr.reduce((a,b)=&gt;a+b,4); console.log(t1,t2); reduce函数有两个参数： 参数1：是一个两个参数的函数，必须有返回值，必填 参数二：选填 let arr = [1, 2, 3] arr.reduce((a,b)=&gt;a+b) 第1次：(1,2) =&gt; 1+2 第2次：(3, 3) =&gt; 3+3 ——–》 6 promise应用示例promise是一个对象，保存着预期事件执行的结果；可以应用在异步操作时候，指定异步操作的成功与失败的结果。 1234567891011var promise=new Promise(function (resolve, reject) &#123; setTimeout(()=&gt;&#123; var num=Math.random(); if (num&lt;0.5) resolve(\"操作成功！num=\"+num); else reject(\"操作失败！num=\"+num); &#125;,1000);&#125;);promise.then(msg=&gt;console.log(msg)).catch(msg=&gt;console.log(msg)); 对象的扩展方法使用Object的方法： keys：获取对象的属性名 values：获取对象的属性值 entries：获取对象的属性和属性值 assign：可以将对象进行拷贝 数组的扩展方法使用数组的扩展方法： find：根据函数条件查找数组中符合条件的元素 findIndex：与find类似，返回的不是元素而是元素对应的索引号 includes：判断指定的元素是否存在 安装babel、导入导出 安装babel babel是一个javaScript语法编译器，可以将es6的语法进行转换并执行。 需要在nodejs工程的目录下执行 12cnpm install babel-preset-es2015 --save-dev cnpm install babel-cli -g 编写.babelrc文件，指定es的版本 123&#123;\"presets\" : [\"es2015\"]&#125; 使用 1babel-node js文件名 导入导出 export1.js 12345678910111213141516//方式一export let name = \"张三\";export let age = 13;export let gender = \"男\";export let say = function(str)&#123; console.log(str); &#125;;// //方式二；更推荐// let name = \"itcast\";// let age = 13;// let gender = \"男\";// let say = function(str)&#123;// console.log(str);// &#125;;// export &#123;name, age, gender, say&#125; import1.js 12345678910//import命令输入的变量都是只读的，因为它的本质是只读的输入接口。import &#123;name, age, gender, say&#125; from \"./export1\";console.log(name);say(\"hello xxx\");//如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。import &#123;name as abc, say as hello&#125; from \"./export1\"console.log(abc)hello(\"hello xxx\") 默认导出 默认输出不需要name，但是一个js文件中只能有一个export default。 export2.js 1234567891011121314// //方式一// export default function(str)&#123;// console.log(str)// &#125;;//方式二；一个文件只能一个export default，不能1个以上同时存在export default &#123; eat(sth) &#123; console.log(\"eat \" + sth); &#125;, drink(sth) &#123; console.log(\"drink \" + sth); &#125;&#125; import2.js 12345678&#x2F;&#x2F; &#x2F;&#x2F;导入default的模块文件不需要使用&#123;&#125;&#x2F;&#x2F; import ep2 from &quot;.&#x2F;export2&quot;&#x2F;&#x2F; ep2(&quot;hello ep2&quot;);import abc from &quot;.&#x2F;export2&quot;abc.eat(&quot;meat&quot;)abc.drink(&quot;water&quot;) 20. export和import联合应用目标：export和import的联合应用场景；使用export导出模板文件，import引入模板文件 小结： 可以通过export导出模块，通过import导入模块并使用其内容。 导出有两种方式：命名导出和默认导出。 因为浏览器默认不支持export和import命令，所以需要安装babel对export和import进行解析和执行。","categories":[{"name":"js","slug":"js","permalink":"https://donghuangzhong.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://donghuangzhong.github.io/tags/ES6/"}]},{"title":"nodejs","slug":"nodejs","date":"2021-07-03T00:54:44.000Z","updated":"2021-07-03T09:13:03.757Z","comments":true,"path":"2021/07/03/nodejs/","link":"","permalink":"https://donghuangzhong.github.io/2021/07/03/nodejs/","excerpt":"nodejs学习记录","text":"nodejs学习记录 Nodejs概述简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 搭建工程 创建module 编写start-demo.js 123var a=1;var b=2;console.log(a+b); 运行 直接ctrl+shift+F10 打开idea的terminal 1F:\\Java\\nodejs&gt;node start-demo.js Nodejs模块化编程 编写“模块”module1.js 123exports.add=function (a,b) &#123; console.log(a+b);&#125; 引入模块测试 12var module1=require(\"./module1\");module1.add(1,2); 创建Nodejs Web服务器可以利用node.js创建web服务器： 123456789101112//引入http模块var http=require(\"http\");http.createServer(function (request,response) &#123; //发送http头部 //参数1：响应状态码，200表示成功 //参数2：响应头部信息，Content-Type内容类型：纯文本 response.writeHead(200,&#123;\"Content-Type\": \"text/plain\"&#125;); //发送响应数据 response.end(\"Hello World \\n\");&#125;).listen(8888);console.log(\"Server running in http://127.0.0.1:8888\") 处理Nodejs Web请求参数目标：引入http和url模块创建web容器并使用url解析请求路径中参数且输出 分析： 需求：http://127.0.0.1:8888?id=123&amp;name=heima 获取到请求路径中参数及值并输出 实现步骤： 创建web服务器； 引入url模块； 利用url解析请求地址中的参数和值并输出 启动测试； 小结： 在node.js中可以引入url内置模块对请求地址进行处理： 12345678910111213141516171819var http=require(\"http\"); //引入node.js内置http模块var url=require(\"url\");http.createServer(function (request,response) &#123; //发送http头部 //参数1：响应状态码，200表示成功 //参数2：响应头部信息，Content-Type内容类型：纯文本 response.writeHead(200,&#123;\"Content-Type\": \"text/plain\"&#125;); //解析请求地址 //参数1：请求地址 //参数2：true的话使用query解析参数到一个对象，默认false var params = url.parse(request.url,true).query; for (var paramsKey in params) &#123; response.write(paramsKey+\":\"+params[paramsKey]); &#125; response.end(\"\"); //end是结束的意思、必须加&#125;).listen(8888);console.log(\"Server running in http://127.0.0.1:8888\"); 包资源管理器NPMnpm是一个node.js的管理和分发工具，可以根据配置package.json下载js库。 初始化 12345npm initinit命令是工程初始化命令。建立一个空文件夹或者在上述的示例工程中，在命令提示符进入该文件夹 执行命令初始化按照提示输入相关信息，最后会生成 package.json 文件，这个是包的配置文件，相当于maven的pom.xml之后也可以根据需要进行修改 本地安装：将下载的模块安装到当前目录（项目）； 123npm insatll expressinstall命令用于安装某个模块，可以通过require引入到项目中使用。 全局安装：将下载的模块安装到全局的目录（ npm root -g ） 1npm insatll express -g 批量下载 1234npm install从网上下载某些代码，发现只有package.json，没有node_modules文件夹，这时需要通过命令重新下载这些js库执行此命令npm会自动下载package.json中依赖的js库。 切换NPM镜像 使用nrm 切换镜像源 123npm install nrm -gnrm use taobao 使用cnpm下载 123npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install ** webpack打包js 安装webpack 12npm install webpack -gnpm install webpack-cli -g 新建src文件夹，创建两个模块化的js，并在主文件main.js 中引用 log.js 123exports.print=function (str) &#123; document.write(str);&#125; math.js 123exports.add=function (a,b) &#123; return a+b;&#125; main.js 123var log=require(\"./log\");var math=require(\"./math\");log.print(\"100+200=\"+math.add(100,200)); 创建配置文件webpack.config.js ，该文件与src处于同级目录 12345678910111213var path=require(\"path\");//exports 就是 module.exports，// 但是这里直接是赋值，所以不能直接使用exports，否则exports就不是module.exports了module.exports=&#123; //入口文件 entry: \"./src/main.js\", output:&#123; //__dirname 是node的一个全局变量，获得当前文件所在目录的完整目录名 path:path.resolve(__dirname,\"./dist\"), filename:\"bundle.js\" &#125;&#125; 以上代码的意思是：读取当前目录下src文件夹中的main.js（入口文件）内容，把对应的js文件打包，打包后的文件放入当前目录的dist文件夹下，打包后的js文件名为bundle.js 执行编译命令 1webpack 创建index.html ,引用bundle.js ,访问测试 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;dist&#x2F;bundle.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; webpack打包css 安装style-loader和 css-loader 12cnpm install style-loader css-loader --save-devcnpm install less less-loader --save-dev 修改webpack.config.js 123456789101112131415161718192021var path=require(\"path\");//exports 就是 module.exports，// 但是这里直接是赋值，所以不能直接使用exports，否则exports就不是module.exports了module.exports=&#123; //入口文件 entry: \"./src/main.js\", output:&#123; //__dirname 是node的一个全局变量，获得当前文件所在目录的完整目录名 path:path.resolve(__dirname,\"./dist\"), filename:\"bundle.js\" &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125; ] &#125;&#125; 在src文件夹创建css文件夹,css文件夹下创建css1.css 123body&#123; background: blue;&#125; 修改main.js ，引入css1.css 1234var log=require(\"./log\");var math=require(\"./math\");require(\"./css/css1.css\")log.print(\"100+200=\"+math.add(100,200)); 重新运行webpack ，刷新页面测试","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://donghuangzhong.github.io/categories/nodejs/"}],"tags":[]},{"title":"ElasticSearch","slug":"ElasticSearch","date":"2021-06-29T01:08:09.000Z","updated":"2021-07-03T00:32:32.085Z","comments":true,"path":"2021/06/29/ElasticSearch/","link":"","permalink":"https://donghuangzhong.github.io/2021/06/29/ElasticSearch/","excerpt":"摘要","text":"摘要 ElasticSearch简介什么是ElasticSearchElaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 ElasticSearch的使用案例 2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码” 维基百科：启动以elasticsearch为基础的核心搜索架构 SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务” 百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据 新浪使用ES 分析处理32亿条实时日志 阿里使用ES 构建挖财自己的日志采集和分析体系 ElasticSearch对比Solr Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能; Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式； Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供； Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch ElasticSearch安装与启动注意：ElasticSearch是使用java开发的，且本版本的es需要的jdk版本要是1.8以上，所以安装ElasticSearch之前保证JDK1.8+安装完毕，并正确的配置好JDK环境变量，否则启动ElasticSearch失败。 下载ES压缩包 ElasticSearch分为Linux和Window版本，基于我们主要学习的是ElasticSearch的Java客户端的使用，所以我们课程中使用的是安装较为简便的Window版本，项目上线后，公司的运维人员会安装Linux版的ES供我们连接使用。 ElasticSearch的官方地址： https://www.elastic.co/products/elasticsearch 加压完即可用 目录结构 修改一下跨域访问的配置 修改elasticsearch配置文件：config/elasticsearch.yml，增加以下两句命令： 123http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;# 特殊字符需要删除重新输入&#123;冒号，-，引号&#125; 此步为允许elasticsearch跨越访问，如果不安装后面的elasticsearch-head是可以不修改，直接启动。 启动 注意：9300是tcp通讯端口，集群间和TCPClient都执行该端口，9200是http协议的RESTful接口 。通过浏览器访问ElasticSearch服务器，看到如下返回的json信息，代表服务启动成功： http://localhost:9200/ 安装ES的图形化界面插件ElasticSearch不同于Solr自带图形化界面，我们可以通过安装ElasticSearch的head插件，完成图形化界面的效果，完成索引数据的查看。安装插件的方式有两种，在线安装和本地安装。本文档采用本地安装方式进行head插件的安装。elasticsearch-5-*以上版本安装head需要安装node和grunt 下载head插件：https://github.com/mobz/elasticsearch-head 将elasticsearch-head-master压缩包解压到任意目录，但是要和elasticsearch的安装目录区别开 安装nodejs，在nodejs中安装grunt 1npm install -g grunt-cli 进入elasticsearch-head-master目录启动head，在命令提示符下输入命令： 12npm installgrunt server &#x2F;&#x2F;启动命令 打开浏览器，输入 http://localhost:9100，看到如下页面： 第三章 ElasticSearch相关概念(术语)概述Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。Elasticsearch比传统关系型数据库如下： 12Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; ColumnsElasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; Fields Elasticsearch核心概念索引 index一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。 类型 type在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。 字段Field相当于是数据表的字段，对文档数据根据不同属性进行的分类标识 映射 mappingmapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。 文档 document一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。 在一个index/type里面，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须被索引/赋予一个索引的type。 接近实时 NRTElasticsearch是一个接近实时的搜索平台。这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒以内） 集群 cluster一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群 节点 node一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。 一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。 在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。 分片和复制 shards&amp;replicas一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因：1）允许你水平分割/扩展你的内容容量。2）允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量。 至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。 在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。 复制之所以重要，有两个主要原因： 在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行。总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。 默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。 ElasticSearch的客户端操作实际开发中，主要有三种方式可以作为elasticsearch服务的客户端： 第一种，elasticsearch-head插件 第二种，使用elasticsearch提供的Restful接口直接访问，配合postman 第三种，使用elasticsearch提供的API进行访问 安装Postman工具Postman官网：https://www.getpostman.com Postman中文版是postman这款强大网页调试工具的windows客户端，提供功能强大的Web API &amp; HTTP 请求调试。软件功能非常强大，界面简洁明晰、操作方便快捷，设计得很人性化。Postman中文版能够发送任何类型的HTTP 请求 (GET, HEAD, POST, PUT..)，且可以附带任何数量的参数。 双击即可以使用 创建索引index和映射mapping创建一个索引blog1，其中有一个名为article的types，article下又有各种属性的字段 请求url： 1PUT localhost:9200/blog1 请求体： 12345678910111213141516171819202122232425&#123; \"mappings\": &#123; \"article\": &#123; \"properties\": &#123; \"id\": &#123; \"type\": \"long\", \"store\": true, \"index\":\"not_analyzed\" &#125;, \"title\": &#123; \"type\": \"text\", \"store\": true, \"index\":\"analyzed\", \"analyzer\":\"standard\" &#125;, \"content\": &#123; \"type\": \"text\", \"store\": true, \"index\":\"analyzed\", \"analyzer\":\"standard\" &#125; &#125; &#125; &#125;&#125; postman elasticsearch-head查看： 创建索引后设置Mapping创建索引时没有设置mapping信息(在postman中不设置PUT的请求body)，也可用postman设置，例如向已经存在的blog2索引中，添加名为hello的types，并设置其中字段的各种属性 请求的url：(修改一般用post) 1POST http:&#x2F;&#x2F;127.0.0.1:9200&#x2F;blog2&#x2F;hello&#x2F;_mapping 请求体：（已经没有mapping关键字，hello表示的是同有一个名为hello的types） 12345678910111213141516171819202122&#123; \"hello\": &#123; \"properties\": &#123; \"id\":&#123; \"type\":\"long\", \"store\":true &#125;, \"title\":&#123; \"type\":\"text\", \"store\":true, \"index\":true, \"analyzer\":\"standard\" &#125;, \"content\":&#123; \"type\":\"text\", \"store\":true, \"index\":true, \"analyzer\":\"standard\" &#125; &#125; &#125; &#125; 删除索引index请求url： 1DELETE localhost:9200/blog1 创建文档document请求url：localhost:9200/索引名/type/真的id 真ID如果不加的话，会自动生成一个UUID 1POST localhost:9200/blog1/article/1 请求体： 12345&#123; \"id\":1, \"title\":\"ElasticSearch是一个基于Lucene的搜索服务器\", \"content\":\"它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。\"&#125; 修改文档document请求url： 1POST localhost:9200/blog1/article/1 请求体： 12345&#123; \"id\":1, \"title\":\"【修改】ElasticSearch是一个基于Lucene的搜索服务器\", \"content\":\"【修改】它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。\"&#125; 删除文档document请求url： 1DELETE localhost:9200/blog1/article/1 查询文档-根据id查询请求url： 1GET localhost:9200/blog1/article/1 查询文档-querystring查询请求url： 1POST localhost:9200/blog1/article/_search 请求体：query_string是查询方式；default_field是查询的字段名；query是查询的“句子”(多个关键词的集合)。 查询的时候会先对query进行分词，然后再进行匹配。注意和关键词查询的区别。 12345678&#123; \"query\": &#123; \"query_string\": &#123; \"default_field\": \"title\", \"query\": \"搜NM\" &#125; &#125;&#125; 查询文档-term查询请求url： 1POST localhost:9200/blog1/article/_search 请求体：其中query和term都是固定的，title：要查询的字段名；搜：是查询的关键字 关键字和分词器有关，其中标准分词器是一个汉字作为一个词，所以查询两个字的词语是查不出来的 1234567&#123; \"query\": &#123; \"term\": &#123; \"title\": \"搜\" &#125; &#125;&#125; IK 分词器和ElasticSearch集成使用默认的standard分词器对汉语不友好，一个汉字一个词。因此我们可以使用IK分词器 standard对中文分词的测试 1GET http:&#x2F;&#x2F;127.0.0.1:9200&#x2F;_analyze?analyzer&#x3D;standard&amp;pretty&#x3D;true&amp;text&#x3D;我是程序员 结果：一个汉字一个词。{“我”，“是”，“程”，“序”，“员”} ElasticSearch集成IK分词器 下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases 将此文件解压至elasticsearch-5.6.8\\plugins 目录下 重启ElasticSearch 测试 最小切分ik_smart 1GET http:&#x2F;&#x2F;127.0.0.1:9200&#x2F;_analyze?analyzer&#x3D;ik_smart&amp;pretty&#x3D;true&amp;text&#x3D;我是程序员 分词效果：{“我”，“是”，“程序员”} 最大切分ik_max_word 1GET http:&#x2F;&#x2F;127.0.0.1:9200&#x2F;_analyze?analyzer&#x3D;ik_max_word&amp;pretty&#x3D;true&amp;text&#x3D;我是程序员 分词效果：{“我”，“是”，“程序员”，“程序”，“员”} 创建索引时可以直接指定IK分词方式 12345678910111213141516171819202122232425&#123; &quot;mappings&quot;: &#123; &quot;article&quot;: &#123; &quot;properties&quot;: &#123; &quot;id&quot;: &#123; &quot;type&quot;: &quot;long&quot;, &quot;store&quot;: true, &quot;index&quot;:&quot;not_analyzed&quot; &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: true, &quot;index&quot;:&quot;analyzed&quot;, &quot;analyzer&quot;:&quot;ik_max_word&quot; &#125;, &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: true, &quot;index&quot;:&quot;analyzed&quot;, &quot;analyzer&quot;:&quot;ik_smart&quot; &#125; &#125; &#125; &#125;&#125; ElasticSearch集群 ES集群是一个 P2P类型(使用 gossip 协议)的分布式系统 节点Node：一个节点就是集群中一个单独的服务器 分片：一个ES可以被分为若干个片，默认5个片。这5个片分散分布在不同的节点上 复制：就是备份的意思，默认有一个备份，每个分片都有一个复制的片，并且复制的片和原本的片不在一个服务器上 集群的搭建(单机多实例)多个实例的文件夹下的data目录必须为空(也可以直接删除data目录)，不然数据会不一致 删除data目录后复制3份文件夹 修改每个节点文件夹下config\\elasticsearch.yml配置文件 123456789101112#集群名称，保证唯一cluster.name: es-cluster#节点名称，必须不一样node.name: node-1 # 1、2、3节点对应1、2、3#必须为本机的ip地址network.host: 127.0.0.1#服务端口号，在同一机器下必须不一样http.port: 9201 # 1、2、3节点对应1、2、3#集群间通信端口号，在同一机器下必须不一样transport.tcp.port: 9301 # 1、2、3节点对应1、2、3#设置集群自动发现机器ip集合discovery.zen.ping.unicast.hosts: [\"127.0.0.1:9301\",\"127.0.0.1:9302\",\"127.0.0.1:9303\"] 启动三个节点，用三个节点中的任意节点都可访问集群 使用和使用单个节点的操作一样 在ES磁盘分配分片控制策略中，为了保护数据节点的安全，ES对磁盘进行了限额，并会定时检查各节点数据目录的使用情况：磁盘占用超过85%，新索引分片就不会分配到这个节点上了。 ElasticSearch原始java客户端创建工程引入坐标12345678910111213141516171819202122232425262728293031323334353637&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;5.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;5.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建索引(不指定mapping) 这里可以创建的时候指定mapping 1client.admin().indices().prepareCreate(&quot;java-elasticsearch&quot;).addMapping().get(); 1234567891011121314@Testpublic void createIndice() throws UnknownHostException &#123; // 1、创建一个Settings对象，相当于是一个配置信息。主要配置集群的名称。 Settings settings = Settings.builder().put(\"cluster.name\", \"elasticsearch\").build(); // 2、创建一个客户端Client对象 TransportClient client = new PreBuiltTransportClient(settings) //可以添加多个addTransportAddress，保证集群的高可用 .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(\"127.0.0.1\"), 9300)); // 3、使用client对象创建一个索引库 //get表示执行的意思 client.admin().indices().prepareCreate(\"java-elasticsearch\").get(); // 4、关闭client对象 client.close();&#125; 对已经创建索引添加mapping123456789101112131415161718192021222324252627282930313233343536373839404142@Test public void addMapping() throws IOException &#123; // 1、创建一个Settings对象，相当于是一个配置信息。主要配置集群的名称。 Settings settings = Settings.builder().put(\"cluster.name\", \"elasticsearch\").build(); // 2、创建一个客户端Client对象 TransportClient client = new PreBuiltTransportClient(settings) //可以添加多个addTransportAddress，保证集群的高可用 .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(\"127.0.0.1\"), 9300)); // 3、创建一个json格式的字符串，或者使用XContentBuilder XContentBuilder builder = XContentFactory.jsonBuilder() .startObject() .startObject(\"article\") .startObject(\"properties\") .startObject(\"id\") .field(\"type\", \"integer\") .field(\"store\", \"yes\") .endObject() .startObject(\"title\") .field(\"type\", \"string\") .field(\"store\", \"yes\") .field(\"analyzer\", \"ik_smart\") .endObject() .startObject(\"content\") .field(\"type\", \"string\") .field(\"store\", \"yes\") .field(\"analyzer\", \"ik_smart\") .endObject() .endObject() .endObject() .endObject(); //4、使用Client对象把mapping添加到索引库中 client.admin().indices() //设置要添加到哪个索引的名称 .preparePutMapping(\"java-elasticsearch\") //设置type的名称 .setType(\"article\") //mapping信息可以是String也可以是XContentBuilder .setSource(builder) .get(); // 5、关闭client对象 client.close(); &#125; 创建文档document通过XContentBuilder1234567891011121314151617181920212223@Testpublic void addDocument() throws IOException &#123; // 1、创建一个Settings对象，相当于是一个配置信息。主要配置集群的名称。 Settings settings = Settings.builder().put(\"cluster.name\", \"elasticsearch\").build(); // 2、创建一个客户端Client对象 TransportClient client = new PreBuiltTransportClient(settings) //可以添加多个addTransportAddress，保证集群的高可用 .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(\"127.0.0.1\"), 9300)); // 3、创建一个文档 XContentBuilder builder = XContentFactory.jsonBuilder() .startObject() .field(\"id\", 1) .field(\"title\", \"ElasticSearch是一个基于Lucene的搜索服务器\") .field(\"content\", \"它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。\") .endObject(); //4、添加文档到索引库 //参数：index,type,id client.prepareIndex(\"java-elasticsearch\",\"article\",\"1\") .setSource(builder).get(); // 5、关闭client对象 client.close();&#125; 也可以通过空参的prepareIndex一阵set 1client.prepareIndex().setId().setType().setId().setSource() 通过jackson ObjectMapper().writeValueAsString(article)要求实体类必须有get方法 导入jackson坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.11.4&lt;/version&gt; &lt;/dependency&gt; 以json格式添加 12345678&#x2F;&#x2F; 3、创建json的String Article article &#x3D; new Article(&quot;2&quot;, &quot;title2&quot;, &quot;content2&quot;); String arcticleStr &#x3D; new ObjectMapper().writeValueAsString(article); &#x2F;&#x2F;4、添加文档到索引库 &#x2F;&#x2F;参数：index,type,id client.prepareIndex(&quot;java-elasticsearch&quot;,&quot;article&quot;,&quot;1&quot;) .setSource(arcticleStr, XContentType.JSON).get(); 根据ID查询1234567891011121314151617181920212223242526272829303132@Test public void searchById() throws UnknownHostException &#123; //1、创建一个Settings对象，相当于是一个配置信息。主要配置集群的名称。 Settings settings = Settings.builder().put(\"cluster.name\", \"elasticsearch\").build(); //2、创建一个客户端Client对象 TransportClient client = new PreBuiltTransportClient(settings) //可以添加多个addTransportAddress，保证集群的高可用 .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(\"127.0.0.1\"), 9300)); //3、创建一个查询对象 QueryBuilder queryBuilder = QueryBuilders.idsQuery().addIds(\"1\", \"2\"); //4、执行查询。表明在哪个indice和type SearchResponse searchResponse = client.prepareSearch(\"java-elasticsearch\").setTypes(\"article\") .setQuery(queryBuilder).get(); //5、遍历结果 //获取命中的结果 SearchHits hits = searchResponse.getHits(); System.out.println(\"查询结果的总记录数:\"+hits.getTotalHits()); //获取查询结果数组 SearchHit[] hitsArray = hits.getHits(); for (SearchHit hitItem : hitsArray) &#123; //以json格式打印命中的一条数据 System.out.println(\"命中数据的json格式：\"+hitItem.getSourceAsString()); //以map形式获取命中的一条数据 Map&lt;String, Object&gt; hitMap = hitItem.getSource(); System.out.println(hitMap.get(\"id\")); System.out.println(hitMap.get(\"title\")); System.out.println(hitMap.get(\"content\")); &#125; //6、关闭client对象 client.close(); &#125; 根据term查询12//参数：【查询的字段，查询的关键词】 QueryBuilder queryBuilder = QueryBuilders.termQuery(\"content\",\"编程\"); queryString查询先分词后匹配，是或者的关系 12&#x2F;&#x2F;参数：【搜索的字符串，默认的搜索字段】不指定默认的搜索字段的话会在所有字段中查询QueryBuilder queryBuilder &#x3D; QueryBuilders.queryStringQuery(&quot;让编程改变世界&quot;).defaultField(&quot;content&quot;); 分页查询在cilent查询时指定，默认的查询数量是10条 1234&#x2F;&#x2F;4、执行查询。from:起始行号。size：一次查多少数据SearchResponse searchResponse &#x3D; client.prepareSearch(&quot;java-elasticsearch&quot;).setTypes(&quot;article&quot;) .setQuery(queryBuilder) .setFrom(0).setSize(5).get(); 高亮显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Testpublic void searchByQueryStringWithHighLight() throws UnknownHostException &#123; //1、创建一个Settings对象，相当于是一个配置信息。主要配置集群的名称。 Settings settings = Settings.builder().put(\"cluster.name\", \"elasticsearch\").build(); //2、创建一个客户端Client对象 TransportClient client = new PreBuiltTransportClient(settings) //可以添加多个addTransportAddress，保证集群的高可用 .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(\"127.0.0.1\"), 9300)); //3、创建一个查询对象 //参数：【搜索的字符串，默认的搜索字段】不指定默认的搜索字段的话会在所有字段中查询 QueryBuilder queryBuilder = QueryBuilders.queryStringQuery(\"让编程改变世界\").defaultField(\"content\"); //4、设置高亮 HighlightBuilder hiBuilder=new HighlightBuilder(); hiBuilder.field(\"content\"); hiBuilder.preTags(\"&lt;em&gt;\"); hiBuilder.postTags(\"&lt;/em&gt;\"); //5、执行查询。设置高亮 SearchResponse searchResponse = client.prepareSearch(\"java-elasticsearch\").setTypes(\"article\") .setQuery(queryBuilder).highlighter(hiBuilder) .get(); //6、遍历结果 //获取命中的结果 SearchHits hits = searchResponse.getHits(); System.out.println(\"查询结果的总记录数:\"+hits.getTotalHits()); //获取查询结果数组 SearchHit[] hitsArray = hits.getHits(); for (SearchHit hitItem : hitsArray) &#123; //以json格式打印命中的一条数据 System.out.println(\"命中数据的json格式：\"+hitItem.getSourceAsString()); //以map形式获取命中的一条数据 Map&lt;String, Object&gt; hitMap = hitItem.getSource(); System.out.println(hitMap.get(\"id\")); System.out.println(hitMap.get(\"title\")); System.out.println(hitMap.get(\"content\")); //获取高亮的结果 System.out.println(\"-------------------高亮显示-------------\"); System.out.println(hitItem.getHighlightFields()); System.out.println(\"name:\"+hitItem.getHighlightFields().get(\"content\").getName()); Text[] texts = hitItem.getHighlightFields().get(\"content\").getFragments(); for (Text text : texts) &#123; System.out.println(text); &#125; &#125; //7、关闭client对象 client.close();&#125; spring整合elasticsearch 创建maven工程 1234567891011121314151617181920212223242526272829303132333435363738&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;5.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;5.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt; &lt;version&gt;3.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.18&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写配置文件applicationContext.xml Autowired的bean也需要id 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:elasticsearch=\"http://www.springframework.org/schema/data/elasticsearch\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/data/elasticsearch http://www.springframework.org/schema/data/elasticsearch/spring-elasticsearch.xsd\"&gt; &lt;!--配置包扫描继承关系、接口自动代理、加入spring--&gt; &lt;elasticsearch:repositories base-package=\"com.dhz.es.repositories\"/&gt; &lt;!--配置es集群的连接--&gt; &lt;elasticsearch:transport-client id=\"cilent\" cluster-nodes=\"127.0.0.1:9301,127.0.0.1:9302\" cluster-name=\"es-cluster\"/&gt; &lt;!--配置ElasticsearchTemplate--&gt; &lt;bean id=\"elasticsearchTemplate\" class=\"org.springframework.data.elasticsearch.core.ElasticsearchTemplate\"&gt; &lt;constructor-arg name=\"client\" ref=\"cilent\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建与document对应的实体类 1234567@Document(indexName &#x3D; &quot;spring_es&quot;,type &#x3D; &quot;article&quot;)表明此类和document一一对应，indexName：索引名，type：类型名@Id 文档主键 唯一标识@Field(type &#x3D; FieldType.String,store &#x3D; true,analyzer &#x3D; &quot;ik_smart&quot;)每个文档的字段配置（类型、是否存储、分词器 ） 1234567891011@Document(indexName = \"spring_es\",type = \"article\")@Datapublic class Article &#123; @Id @Field(type = FieldType.Long,store = true) private Long id; @Field(type = FieldType.String,store = true,analyzer = \"ik_smart\") private String title; @Field(type = FieldType.String,store = true,analyzer = \"ik_smart\") private String content;&#125; 编写ArticleRepository接口、继承ElasticsearchRepository 泛型：1：实体类。2：实体主键的类型 123@Repositorypublic interface ArticleRepository extends ElasticsearchRepository&lt;Article, Long&gt; &#123;&#125; 测试 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\")public class ESTest &#123; @Autowired ElasticsearchTemplate elasticsearchTemplate; @Test public void createIndiceWithMapping()&#123; elasticsearchTemplate.createIndex(Article.class); &#125;&#125; 创建索引1elasticsearchTemplate.createIndex(Article.class); 创建document1234567891011@AutowiredArticleRepository articleRepository;@Testpublic void addDocument()&#123; Article article = new Article(); article.setId(1L); article.setTitle(\"article_title\"); article.setContent(\"article_content\"); articleRepository.save(article);&#125; 删除document1234567@AutowiredArticleRepository articleRepository;@Testpublic void deleteDocument()&#123; articleRepository.deleteById(1L);&#125; 修改document修改也是用save，save方法如果没有数据则添加。如果有数据则先删除后添加 查询document articleRepository.findById(1L); &lt;!--￼46--&gt; 根据自带的查询规则 需要在ArticleRepository中声明(不需要实现) 自带分词效果，默认的是分词后全匹配的and关系 123articleRepository.findByContent(&quot;填写内容和题目&quot;).forEach(a-&gt; System.out.println(a));&#x2F;&#x2F;先分词：【“填写”、“内容”、“和”，“题目”】&#x2F;&#x2F;必须全部含有分析结果才算匹配成功 函数名中有几个字段，函数的参数中就有几个字段，并且一一对应，通过逻辑词实现逻辑 1234 &#x2F;&#x2F;查询Content中含有测试，并且Title含有测试的记录articleRepository.findByContentAndTitle(&quot;测试&quot;, &quot;测试&quot;); &#x2F;&#x2F;查询Content中含有测试，或者Title含有测试的记录articleRepository.findByContentOrTitle(&quot;测试&quot;, &quot;测试&quot;); 关键字 命名规则 解释 示例 and findByField1AndField2 根据Field1和Field2获得数据 findByTitleAndContent or findByField1OrField2 根据Field1或Field2获得数据 findByTitleOrContent is findByField 根据Field获得数据 findByTitle not findByFieldNot 根据Field获得补集数据 findByTitleNot between findByFieldBetween 获得指定范围的数据 findByPriceBetween lessThanEqual findByFieldLessThan 获得小于等于指定值的数据 findByPriceLessThan 设置分页(默认从第0页开始) 1234@Repositorypublic interface ArticleRepository extends ElasticsearchRepository&lt;Article,Long&gt; &#123; List&lt;Article&gt; findByContentOrTitle(String content, String title, Pageable p);&#125; 123456@Testpublic void page()&#123; Pageable pageable= PageRequest.of(0,15); List&lt;Article&gt; articles = articleRepository.findByContentOrTitle(\"内容\", \"题目\", pageable); articles.forEach(a-&gt; System.out.println(a));&#125; 使用Elasticsearch的原生查询对象进行查询elasticsearchTemplate.queryForList(query, Article.class); 参数：【SearchQuery对象，查询结果的类】 123456789@Testpublic void yaunsheng()&#123; NativeSearchQuery query &#x3D; new NativeSearchQueryBuilder() .withQuery(QueryBuilders.queryStringQuery(&quot;填写内容和题目&quot;).defaultField(&quot;content&quot;)) .withPageable(PageRequest.of(0, 15)) .build(); List&lt;Article&gt; articles &#x3D; elasticsearchTemplate.queryForList(query, Article.class); System.out.println(articles);&#125; spring boot整合elasticsearch 创建maven项目 1234567891011121314151617181920&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;&lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 生成启动类和application.yml 12345spring: data: elasticsearch: cluster-name: es-cluster cluster-nodes: 127.0.0.1:9301,127.0.0.1:9302 创建entity，repository，运行测试即可 12345678910111213141516171819202122232425262728293031@RunWith(SpringRunner.class)@SpringBootTestpublic class ESTest &#123; @Autowired ElasticsearchTemplate elasticsearchTemplate; @Autowired ArticleRepository articleRepository; @Test public void findAll()&#123; Iterable&lt;Article&gt; articles &#x3D; articleRepository.findAll(); articles.forEach(a-&gt; System.out.println(a)); &#125; @Test public void addDocuemnt()&#123; Article article &#x3D; new Article(); article.setId(1L); article.setTitle(&quot;title1&quot;); article.setContent(&quot;content1&quot;); articleRepository.save(article); &#125; @Test public void addIndice()&#123; elasticsearchTemplate.createIndex(Article.class); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"search","slug":"java/search","permalink":"https://donghuangzhong.github.io/categories/java/search/"}],"tags":[]},{"title":"springCloud","slug":"springCloud","date":"2021-06-24T10:23:00.000Z","updated":"2021-06-29T01:03:14.458Z","comments":true,"path":"2021/06/24/springCloud/","link":"","permalink":"https://donghuangzhong.github.io/2021/06/24/springCloud/","excerpt":"摘要","text":"摘要 系统架构演变概述12345graph LR;1[集中式架构] --&gt; 2[垂直拆分]2 --&gt; 3[分布式服务]3 --&gt; 4[SOA面向服务架构]4 --&gt; 5[微服务架构] 微服务架构说明 微服务架构：是一套使用小服务或者单一业务来开发单个应用的方式或途径。 微服务架构特点： 单一职责 服务粒度小 面向服务（对外暴露REST api） 服务之间相互独立 与使用ESB的SOA架构的区别：微服务架构没有使用ESB，有服务治理注册中心；业务粒度小。 服务调用方式说明 RPC：基于socket，速度快，效率高；webservice、dubbo HTTP：基于TCP，封装比较臃肿；对服务和调用方没有任何技术、语言的限定，自由灵活；RESTful，Spring Cloud Spring RestTemplate示例工程导入 一般情况下有如下三种http客户端工具类包都可以方便的进行http服务调用： httpClient okHttp JDK原生URLConnection spring 提供了RestTemplate的工具类对上述的3种http客户端工具类进行了封装，可在spring项目中使用RestTemplate进行服务调用。 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTestpublic class RestTemplateTest &#123; @Autowired private RestTemplate restTemplate; @Test public void test()&#123; String url &#x3D; &quot;http:&#x2F;&#x2F;localhost&#x2F;user&#x2F;8&quot;; &#x2F;&#x2F;restTemplate可以对json格式字符串进行反序列化 User user &#x3D; restTemplate.getForObject(url, User.class); System.out.println(user); &#125;&#125; Spring Cloud 整合的组件可以有很多组件；常见的组件有：eureka注册中心，Gateway网关，Ribbon负载均衡，Feign服务调用，Hystrix熔断器。在有需要的时候项目添加对于的启动器依赖即可。 版本特征：以英文单词命名（伦敦地铁站名） 示例demo 父工程springcloud：添加spring boot父坐标和管理其它组件的依赖 用户服务工程user-service：整合mybatis查询数据库中用户数据；提供查询用户服务 服务消费工程consumer-demo：利用查询用户服务获取用户数据并输出到浏览器 创建父工程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 &lt;parent&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;version&gt;2.3.9.RELEASE&lt;/version&gt;&lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt; &lt;mapper.starter.version&gt;2.1.5&lt;/mapper.starter.version&gt; &lt;mysql.version&gt;5.1.46&lt;/mysql.version&gt;&lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 通过 scope 的import可以继承 spring-cloud-dependencies 工程中的依赖 创建user-service(勾选1中的父工程) 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; application.yml 12345678server: port: 8081spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test username: root password: root com.dhz.pojo.User 123456789101112@Datapublic class User &#123; @Id @Column(name &#x3D; &quot;id&quot;) private int id; private String username; private String password; private String birthday;&#125; com.dhz.mapper.UserMapper 12public interface UserMapper extends Mapper&lt;User&gt; &#123;&#125; com.dhz.service.UserService 1234567891011@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User findById(int id)&#123; return userMapper.selectByPrimaryKey(id); &#125;&#125; com.dhz.controller.UserController 12345678910111213@Controller@RequestMapping(&quot;user&quot;)public class UserController &#123; @Autowired private UserService userService; @RequestMapping(&quot;&#x2F;&#123;id&#125;&quot;) @ResponseBody User findById(@PathVariable(&quot;id&quot;)int id)&#123; return userService.findById(id); &#125;&#125; 创建consumer-demo（勾选父工程） 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; com.dhz.pojo.User 1234567@Datapublic class User &#123; private int id; private String username; private String password; private String birthday;&#125; com.dhz.controller.UserController 12345678910@Controller@RequestMapping(&quot;userApi&quot;)public class UserController &#123; @RequestMapping(&quot;&#x2F;&#123;id&#125;&quot;) @ResponseBody User findById(@PathVariable(&quot;id&quot;)int id)&#123; return new RestTemplate().getForObject(&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;user&#x2F;&quot;+id,User.class); &#125;&#125; 访问http://localhost:8080/userApi/3 即可 demo中存在的问题存在的问题 在consumer中，我们把url地址硬编码到了代码中，不方便后期维护 consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效 consumer不清楚user-service的状态，服务宕机也不知道 user-service只有1台服务，不具备高可用性 即便user-service形成集群，consumer还需自己实现负载均衡 其实上面说的问题，概括一下就是分布式服务必然要面临的问题： 服务管理 如何自动注册和发现 如何实现状态监管 如何实现动态路由 服务如何实现负载均衡 服务如何解决容灾问题 以上问题都可以在springCloud中解决 Eureka注册中心Eureka的主要功能是进行服务管理，定期检查服务状态，返回服务地址列表。 搭建eureka-server工程Eureka是服务注册中心，只做服务注册；自身并不提供服务也不消费服务。可以搭建web工程使用Eureka，可以使用Spring Boot方式搭建。 创建maven工程、添加启动器依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 编写启动引导类(添加eureka的服务注解)，修改application.yml文件 1234567@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 1234567891011121314server: port: 10086spring: application: name: eureka-servereureka: client: service-url: # eureka 服务地址，如果是集群的话；需要指定其它集群eureka地址 defaultZone: http:&#x2F;&#x2F;127.0.0.1:10086&#x2F;eureka # 不注册自己 register-with-eureka: false # 不拉取服务 fetch-registry: false 启动测试 访问http://127.0.0.1:10086/ 服务注册与发现目标：将user-service的服务注册到eureka并在consumer-demo中可以根据服务名称调用 分析： 服务注册：在服务提供工程user-service上添加Eureka客户端依赖；自动将服务注册到EurekaServer服务地址列表。 添加依赖； 改造启动引导类；添加开启Eureka客户端发现的注解； 修改配置文件；设置Eureka 服务地址 服务发现：在服务消费工程consumer-demo上添加Eureka客户端依赖；可以使用工具类根据服务名称获取对应的服务地址列表。 添加依赖； 改造启动引导类；添加开启Eureka客户端发现的注解； 修改配置文件；设置Eureka 服务地址； 改造处理器类ConsumerController，可以使用工具类DiscoveryClient根据服务名称获取对应服务地址列表。 服务注册 添加Eureka客户端依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 改造启动引导类；添加开启Eureka客户端发现的注解； 12345678@SpringBootApplication@MapperScan(\"com.dhz.mapper\")@EnableEurekaClientpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 修改配置文件；设置Eureka 服务地址、和应用名称 1234567spring: application: name: user-serviceeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 启动springboot即可注册服务(网页管理界面中可见) 注：eureka服务需要一直启动 发现服务 添加Eureka客户端依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 改造启动引导类；添加开启Eureka客户端发现的注解； 1234567@SpringBootApplication@EnableEurekaClientpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 修改配置文件；设置Eureka 服务地址、和应用名称 1234567spring: application: name: consumer-demoeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 改造处理器类ConsumerController，可以使用工具类DiscoveryClient根据服务名称获取对应服务地址列表。 import org.springframework.cloud.client.discovery.DiscoveryClient 123456789101112131415161718@Controller@RequestMapping(&quot;userApi&quot;)public class UserController &#123; @Autowired private DiscoveryClient discoveryClient; @RequestMapping(&quot;&#x2F;&#123;id&#125;&quot;) @ResponseBody User findById(@PathVariable(&quot;id&quot;)int id)&#123; &#x2F;&#x2F;获取eureka中注册的user-service实例列表 List&lt;ServiceInstance&gt; serviceInstanceList &#x3D; discoveryClient.getInstances(&quot;user-service&quot;); ServiceInstance serviceInstance &#x3D; serviceInstanceList.get(0); String url &#x3D; &quot;http:&#x2F;&#x2F;&quot; + serviceInstance.getHost() + &quot;:&quot; + serviceInstance.getPort() + &quot;&#x2F;user&#x2F;&quot; + id; &#x2F;&#x2F; return new RestTemplate().getForObject(&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;user&#x2F;&quot;+id,User.class); return new RestTemplate().getForObject(url,User.class); &#125;&#125; Eureka Server高可用配置多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。 如果有三个Eureka，则每一个EurekaServer都需要注册到其它几个Eureka服务中，例如：有三个分别为10086、10087、10088，则：10086要注册到10087和10088上10087要注册到10086和10088上10088要注册到10086和10087上 修改application.yml如下 123456789101112131415server: port: $&#123;port:10086&#125;# port是一个变量，如果没有此变量则使用冒号后边的10086spring: application: name: eureka-servereureka: client: service-url: # eureka 服务地址，如果是集群的话；需要指定其它集群eureka地址 defaultZone: $&#123;defaultZone:http:&#x2F;&#x2F;127.0.0.1:10086&#x2F;eureka&#125; # 不注册自己，集群需要注释掉# register-with-eureka: false # 不拉取服务，集群需要注释掉# fetch-registry: false 设置启动VM参数 1-Dport&#x3D;10086 -DdefaultZone&#x3D;http:&#x2F;&#x2F;127.0.0.1:10087&#x2F;eureka 1-Dport&#x3D;10087 -DdefaultZone&#x3D;http:&#x2F;&#x2F;127.0.0.1:10086&#x2F;eureka 启动测试 Eureka客户端与服务端配置目标：配置eureka客户端user-service的注册、续约等配置项，配置eureka客户端consumer-demo的获取服务间隔时间；了解失效剔除和自我保护 分析： Eureka客户端工程 user-service 服务提供 服务地址使用ip方式 续约 consumer-demo 服务消费 获取服务地址的频率 Eureka服务端工程 eureka-server 失效剔除 自我保护 小结： user-service 12345678910111213eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: # 更倾向使用ip地址，而不是host名 prefer-ip-address: true # ip地址 ip-address: 127.0.0.1 # 续约间隔，默认30秒 lease-renewal-interval-in-seconds: 5 # 服务失效时间，默认90秒 lease-expiration-duration-in-seconds: 5 consumer-demo 123456eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka # 获取服务地址列表间隔时间，默认30秒 registry-fetch-interval-seconds: 10 eureka-server 123456eureka: server: # 服务失效剔除时间间隔，默认60秒 eviction-interval-timer-in-ms: 60000 # 关闭自我保护模式（默认是打开的） enable-self-preservation: false 负载均衡Ribbon负载均衡是一个算法，可以通过该算法实现从地址列表中获取一个地址进行服务调用。 在Spring Cloud中提供了负载均衡器：Ribbon Ribbon提供了轮询、随机两种负载均衡算法（默认是轮询）可以实现从地址列表中使用负载均衡算法获取地址进行服务调用。 Ribbon负载均衡应用目标：配置启动两个用户服务，在consumer-demo中使用服务名实现根据用户id获取用户 分析： 需求：可以使用RestTemplate访问http://user-service/user/8获取服务数据。 可以使用Ribbon负载均衡：在执行RestTemplate发送服务地址请求的时候，使用负载均衡拦截器拦截，根据服务名获取服务地址列表，使用Ribbon负载均衡算法从服务地址列表中选择一个服务地址，访问该地址获取服务数据。 实现步骤： 启动多个user-service实例（9091,9092）； 12server: port: $&#123;port:8081&#125; 1-Dport&#x3D;9091 修改RestTemplate实例化方法(消费端)，添加负载均衡注解 在实例化RestTemplate的时候使用@LoadBalanced 12345@Bean@LoadBalancedpublic RestTemplate restTemplate()&#123; return new RestTemplate();&#125; 修改ConsumerController 服务地址直接可以使用服务名 1234567891011121314151617181920212223242526@Controller@RequestMapping(&quot;userApi&quot;)public class UserController &#123; @Autowired private DiscoveryClient discoveryClient; @Autowired private RestTemplate restTemplate; @RequestMapping(&quot;&#x2F;&#123;id&#125;&quot;) @ResponseBody User findById(@PathVariable(&quot;id&quot;)int id)&#123; &#x2F;&#x2F; return new RestTemplate().getForObject(&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;user&#x2F;&quot;+id,User.class); &#x2F;&#x2F; &#x2F;&#x2F;获取eureka中注册的user-service实例列表 &#x2F;&#x2F; List&lt;ServiceInstance&gt; serviceInstanceList &#x3D; discoveryClient.getInstances(&quot;user-service&quot;); &#x2F;&#x2F; ServiceInstance serviceInstance &#x3D; serviceInstanceList.get(0); &#x2F;&#x2F; String url &#x3D; &quot;http:&#x2F;&#x2F;&quot; + serviceInstance.getHost() + &quot;:&quot; + serviceInstance.getPort() + &quot;&#x2F;user&#x2F;&quot; + id; &#x2F;&#x2F; return new RestTemplate().getForObject(url,User.class); String url &#x3D; &quot;http:&#x2F;&#x2F;user-service&#x2F;user&#x2F;&quot; + id; return restTemplate.getForObject(url,User.class); &#125;&#125; 测试 http://localhost:8080/userApi/3 熔断器HystrixHystrix是一个延迟和容错库，用于隔离访问远程服务，防止出现级联失败。服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。 Hystrix解决雪崩问题的手段主要是服务降级，包括： 线程隔离 服务熔断 线程隔离&amp;服务降级(消费端系统)Hystrix解决雪崩效应： 线程隔离：用户请求不直接访问服务，而是使用线程池中空闲的线程访问服务，加速失败判断时间。 服务降级：及时返回服务调用失败的结果，让线程不因为等待服务而阻塞。 以下操作全部在消费端系统 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 开启熔断。在启动类上加注解@EnableCircuitBreaker 1234@SpringBootApplication@EnableEurekaClient@EnableCircuitBreakerpublic class Application &#123; 编写声明降级逻辑 1234567891011121314151617181920@Controller@RequestMapping(&quot;userApi&quot;)public class UserController &#123; @Autowired private RestTemplate restTemplate; @RequestMapping(&quot;&#x2F;hystrix&#x2F;&#123;id&#125;&quot;) @ResponseBody @HystrixCommand(fallbackMethod &#x3D; &quot;findUserStrByIdFallback&quot;) String findUserStrById(@PathVariable(&quot;id&quot;)int id)&#123; String url &#x3D; &quot;http:&#x2F;&#x2F;user-service&#x2F;user&#x2F;&quot; + id; return restTemplate.getForObject(url,String.class); &#125; String findUserStrByIdFallback(int id)&#123; return &quot;对不起，网络太拥挤了，本次查询(id&#x3D;&quot;+id+&quot;)失败！&quot;; &#125;&#125; 熔断的降级逻辑方法必须跟正常逻辑方法保证：相同的参数列表和返回值声明 当 user-service 正常提供服务时，访问与以前一致。但是当将 user-service 停机时，会发现页面返回了降级处理信息 也可以在类上加注解@DefaultProperties(defaultFallback = “aaa”)，适用于全部方法 仍然需要加 @HystrixCommand注解，不指定具体的回调函数 1234@RequestMapping(&quot;&#x2F;hystrix&#x2F;&#123;id&#125;&quot;) @ResponseBody @HystrixCommand String findUserStrById(@PathVariable(&quot;id&quot;)int id)&#123; 所有函数的返回值必须跟回调方法的返回值一样 修改超时时间(连接不到服务端不算超时) 在之前的案例中，请求在超过1秒后都会返回错误信息，这是因为Hystrix的默认超时时长为1，我们可以通过配置修改这个值；修改 consumer-demo\\src\\main\\resources\\application.yml 添加如下配置： 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 可以在服务端用Thread.sleep测试 服务熔断演示Hystrix的服务熔断机制，可以实现弹性容错；当服务请求情况好转之后，可以自动重连。通过断路的方式，将后续请求直接拒绝，一段时间（默认5秒）之后允许部分请求通过，如果调用成功则回到断路器关闭状态，否则继续打开，拒绝请求的服务。 状态机有3个状态： Closed：关闭状态（断路器关闭），所有请求都正常访问。 Open：打开状态（断路器打开），所有请求都会被降级。Hystrix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次 Half Open：半开状态，不是永久的，断路器打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求都是健康的，则会关闭断路器，否则继续保持打开，再次进行休眠计时 可以通过配置(消费端application.yml)服务熔断参数修改默认： 1234567891011hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 circuitBreaker: errorThresholdPercentage: 50 # 触发熔断错误比例阈值，默认值50% sleepWindowInMilliseconds: 10000 # 熔断后休眠时长，默认值5秒 requestVolumeThreshold: 10 # 熔断触发最小请求次数，默认值是20 在消费端通过抛出异常来模拟失败 12345678910111213141516171819202122232425@Controller@RequestMapping(\"userApi\")@DefaultProperties(defaultFallback = \"aaa\")public class UserController &#123; @Autowired private DiscoveryClient discoveryClient; @Autowired private RestTemplate restTemplate; @RequestMapping(\"/hystrix/&#123;id&#125;\") @ResponseBody @HystrixCommand String findUserStrById(@PathVariable(\"id\")int id)&#123; if (id==1) throw new RuntimeException(\"太忙了\"); String url = \"http://user-service/user/\" + id; return restTemplate.getForObject(url,String.class); &#125; public String aaa()&#123; return \"这是默认的defaultFallBack\"; &#125;&#125; Feign(消费端)Feign也叫伪装：Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做 应用 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类上添加注解@EnableFeignClients 12345@SpringBootApplication@EnableEurekaClient@EnableCircuitBreaker@EnableFeignClientspublic class Application &#123; 编写如下Feign客户端接口类 12345@FeignClient(\"user-service\")public interface UserCilent &#123; @RequestMapping(\"/user/&#123;id&#125;\") User findById(@PathVariable int id);&#125; 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像 @FeignClient ，声明这是一个Feign客户端，同时通过 value 属性指定服务名称 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果 @GetMapping中的/user，请不要忘记；因为Feign需要拼接可访问的地址 在controller中进行注入使用 1234567891011121314@Controller@RequestMapping(\"userApi\")public class UserController &#123; @Autowired private UserCilent userCilent; @RequestMapping(\"/feign/&#123;id&#125;\") @ResponseBody String feign(@PathVariable int id)&#123; return userCilent.findById(id).toString(); &#125;&#125; 测试http://localhost:8080/userApi/feign/1 Feign集成负载均衡RibbonFeign中本身已经集成了Ribbon依赖和自动配置 在application.yml文件中进行如下配置 123456ribbon: ConnectTimeout: 1000 # 连接超时时长 ReadTimeout: 3000 # 数据通信超时时长 MaxAutoRetries: 0 # 当前服务器的重试次数 MaxAutoRetriesNextServer: 0 # 重试多少次服务 OkToRetryOnAllOperations: false # 是否对所有的请求方式都重试 Feign集成HystrixFeign默认也有对Hystrix的集成，只不过，默认情况下是关闭的。需要通过更改application.yml进行开启。同时对hystrix的配置也需要通过在application.yml里面进行配置 123456789101112131415feign: hystrix: enabled: true # 开启Feign的熔断功能 hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 circuitBreaker: errorThresholdPercentage: 50 # 触发熔断错误比例阈值，默认值50% sleepWindowInMilliseconds: 10000 # 熔断后休眠时长，默认值5秒 requestVolumeThreshold: 10 # 熔断触发最小请求次数，默认值是20 但是，Feign中的Fallback配置不像Ribbon中那样简单了。 编写一个类，实现刚才编写的UserClient，作为fallback的处理类 12345678910@Componentpublic class UserClientFallback implements UserCilent &#123; @Override public User findById(int id) &#123; User user = new User(); user.setId(id); user.setUsername(\"获取失败\"); return user; &#125;&#125; 在UserClient中指定1中的UserClientFallback 12345@FeignClient(value = \"user-service\",fallback = UserClientFallback.class)public interface UserCilent &#123; @RequestMapping(\"/user/&#123;id&#125;\") User findById(@PathVariable int id);&#125; 重启制造超时测试 Feign集成请求压缩在application.yml中配置 12345678910feign: hystrix: enabled: true # 开启Feign的熔断功能 compression: #压缩请求 request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 response: enabled: true Feign集成日志级别通过 logging.level.xx=debug 来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为@FeignClient 注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。 在 consumer-demo 的配置文件中设置com.dhz包下的日志级别都为 debug 123logging: level: com.dhz: debug 在 consumer-demo 编写FeignConfig配置类，定义日志级别 12345678package com.dhz.config;@Configurationpublic class FeignConfig &#123; @Bean Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; 这里指定的Level级别是FULL，Feign支持4种级别： NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据 。 在 consumer-demo 的 UserClient 接口类上的@FeignClient注解中指定配置类 123456@FeignClient(value = \"user-service\",fallback = UserClientFallback.class, configuration = FeignConfig.class)public interface UserCilent &#123; @RequestMapping(\"/user/&#123;id&#125;\") User findById(@PathVariable int id);&#125; 测试即可 Spring Cloud Gateway Spring Cloud Gateway是Spring官网基于Spring 5.0、 Spring Boot 2.0、Project Reactor等技术开发的网关服务。 Spring Cloud Gateway基于Filter链提供网关基本功能：安全、监控／埋点、限流等。 Spring Cloud Gateway为微服务架构提供简单、有效且统一的API路由管理方式。 Spring Cloud Gateway是替代Netflix Zuul的一套解决方案。 Spring Cloud Gateway组件的核心是一系列的过滤器，通过这些过滤器可以将客户端发送的请求转发（路由）到对应的微服务。 Spring Cloud Gateway是加在整个微服务最前沿的防火墙和代理器，隐藏微服务结点IP端口信息，从而加强安全保护。Spring Cloud Gateway本身也是一个微服务，需要注册到Eureka服务注册中心。 网关的核心功能是：过滤和路由 核心概念 路由（route） 路由信息的组成：由一个ID、一个目的URL、一组断言工厂、一组Filter组成。如果路由断言为真，说明请求URL和配置路由匹配。 断言（Predicate） Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中ServerWebExchange。Spring Cloud Gateway的断言函数允许开发者去定义匹配来自于Http Request中的任何信息比如请求头和参数。 过滤器（Filter） 一个标准的Spring WebFilter。 Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter。过滤器Filter将会对请求和响应进行修改处理。 入门搭建目标：搭建网关服务工程测试网关服务作用 分析： 需求：通过网关系统heima-gateway将包含有 /user 的请求 路由到 http://127.0.0.1:9091/user/用户id 实现步骤： 创建工程、添加启动器依赖 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 生成启动类和yml配置文件 启动类添加@EnableEurekaClient注解，注册到配置中心 1234567@SpringBootApplication@EnableEurekaClientpublic class GateWayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GateWayApplication.class, args); &#125;&#125; 修改yml配置文件 12345678910111213141516171819202122server: port: 10010spring: application: name: api-gateway cloud: gateway: routes: # 路由id，可以任意 - id: user-service-route # 代理的服务地址 uri: http://127.0.0.1:9091 # 路由断言： 可以匹配映射路径 predicates: - Path=/user/**eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true 测试http://localhost:10010/user/2 面向服务的路由在刚才的路由规则中，把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然不合理。应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由！ 只需要修改uri即可 1234567891011121314151617181920212223server: port: 10010spring: application: name: api-gateway cloud: gateway: routes: # 路由id，可以任意 - id: user-service-route # 代理的服务地址# uri: http://127.0.0.1:9091 uri: lb://user-service #通过服务名调用 # 路由断言： 可以匹配映射路径 predicates: - Path=/user/**eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true 路由配置中uri所用的协议为lb时（以uri: lb://user-service为例），gateway将使用 LoadBalancerClient把user-service通过eureka解析为实际的主机和端口，并进行ribbon负载均衡。 路由前缀添加前缀在gateway中可以通过配置路由的过滤器PrefixPath，实现映射路径中地址的添加；修改gateway\\src\\main\\resources\\application.yml 文件： 1234567891011121314151617181920212223242526server: port: 10010spring: application: name: api-gateway cloud: gateway: routes: # 路由id，可以任意 - id: user-service-route # uri为代理的服务地址 lb表示从eureka中获取具体服务# uri: http://127.0.0.1:9091 uri: lb://user-service #通过服务名调用 # 路由断言： 可以匹配映射路径 predicates:# - Path=/user/** - Path=/** filters: - PrefixPath=/usereureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true 测试http://localhost:10010/2 通过 PrefixPath=/xxx 来指定了路由要添加的前缀。也就是：PrefixPath=/user http://localhost:10010/8 –》http://localhost:9091/user/8PrefixPath=/user/abc http://localhost:10010/8 –》http://localhost:9091/user/abc/8 去除前缀在gateway中可以通过配置路由的过滤器StripPrefix，实现映射路径中地址的去除；修改 heima-gateway\\src\\main\\resources\\application.yml 文件 ： 1234567891011121314151617181920212223242526272829server: port: 10010spring: application: name: api-gateway cloud: gateway: routes: # 路由id，可以任意 - id: user-service-route # uri为代理的服务地址 lb表示从eureka中获取具体服务# uri: http://127.0.0.1:9091 uri: lb://user-service #通过服务名调用 # 路由断言： 可以匹配映射路径 predicates:# - Path=/user/**# - Path=/** - Path=/api/user/** filters:# - PrefixPath=/user # 表示删除前1个路径，2表示删除前两个路径，以此类推 - StripPrefix=1eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true 测试http://localhost:10010/api/user/2 通过 StripPrefix=1 来指定了路由要去掉的前缀个数。如：路径 /api/user/1 将会被代理到 /user/1 。也就是：StripPrefix=1 http://localhost:10010/api/user/8 –》http://localhost:9091/user/8StripPrefix=2 http://localhost:10010/api/user/8 –》http://localhost:9091/8以此类推。 过滤器Gateway作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作往往是通过网关提供的过滤器来实现的。前面的 路由前缀 章节中的功能也是使用过滤器实现的 。 Gateway自带过滤器有几十个，常见自带过滤器有： 过滤器名称 说明 AddRequestHeader 对匹配上的请求加上Header AddRequestParameters 对匹配上的请求路由添加参数 AddResponseHeader 对从网关返回的响应添加Header StripPrefix 对匹配上的请求路径去除前缀 配置自带全局过滤器demo修改application.yml文件 12345678910111213141516171819202122232425262728293031server: port: 10010spring: application: name: api-gateway cloud: gateway: default-filters: - AddResponseHeader=name,zhangsan routes: # 路由id，可以任意 - id: user-service-route # uri为代理的服务地址 lb表示从eureka中获取具体服务# uri: http://127.0.0.1:9091 uri: lb://user-service #通过服务名调用 # 路由断言： 可以匹配映射路径 predicates: - Path=/user/**# - Path=/**# - Path=/api/user/**# filters:# - PrefixPath=/user # 表示删除前1个路径，2表示删除前两个路径，以此类推# - StripPrefix=1eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true 测试http://localhost:10010/user/2 过滤器类型：Gateway实现方式上，有两种过滤器； 局部过滤器：通过 spring.cloud.gateway.routes.filters 配置在具体路由下，只作用在当前路由上；自带的过滤器都可以配置或者自定义按照自带过滤器的方式。如果配spring.cloud.gateway.default-filters 上会对所有路由生效也算是全局的过滤器；但是这些过滤器的实现上都是要实现GatewayFilterFactory接口。 全局过滤器：不需要在配置文件中配置，作用在所有的路由上；实现 GlobalFilter 接口即可。 常见的应用场景如下： 请求鉴权：一般 GatewayFilterChain 执行filter方法前，如果发现没有访问权限，直接就返回空。 异常处理：一般 GatewayFilterChain 执行filter方法后，记录异常并返回。 服务调用时长统计： GatewayFilterChain 执行filter方法前后根据时间统计。 自定义局部过滤器(消费端)目标：按照默认过滤器编写并配置一个自定义局部过滤器，该过滤器可以通过配置文件中的参数名称获取请求的参数值 分析： 需求：在过滤器（MyParamGatewayFilterFactory）中将http://localhost:10010/api/user/8?name=itcast中的参数name的值获取到并输出到控制台；并且参数名是可变的，也就是不一定每次都是name；需要可以通过配置过滤器的时候做到配置参数名。 实现步骤： 配置过滤器(application.yml中配置) 123456789101112131415161718192021222324server: port: 10010spring: application: name: api-gateway cloud: gateway: default-filters: - AddResponseHeader=name,zhangsan routes: # 路由id，可以任意 - id: user-service-route uri: lb://user-service #通过服务名调用 predicates: - Path=/user/** filters: - MyParam=nameeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true 编写过滤器 名字必须是1中的MyParam+GatewayFilterFactory 实现抽象类AbstractGatewayFilterFactory 编写一个内部配置类，接收配置文件中传进来的参数 指定抽象类AbstractGatewayFilterFactory 的泛型为配置类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.dhz.filter;import org.springframework.cloud.gateway.filter.GatewayFilter;import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.stereotype.Component;import java.util.Arrays;import java.util.List;@Componentpublic class MyParamGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;MyParamGatewayFilterFactory.Config&gt; &#123; public static final String PARAM_NAME = \"param\";//和Config中的变量名一样 public MyParamGatewayFilterFactory() &#123; super(Config.class); &#125; @Override public List&lt;String&gt; shortcutFieldOrder() &#123; return Arrays.asList(PARAM_NAME); &#125; @Override public GatewayFilter apply(Config config) &#123; return ((exchange, chain) -&gt; &#123; ServerHttpRequest request = exchange.getRequest(); if (request.getQueryParams().containsKey(config.param))&#123; request.getQueryParams().get(config.param).forEach(value-&gt; System.out.printf(\"----------局部过滤器-----%s = %s-----\",config.param,value)); &#125; return chain.filter(exchange);//放行 &#125;); &#125; public static class Config&#123; private String param; public String getParam() &#123; return param; &#125; public void setParam(String param) &#123; this.param = param; &#125; &#125;&#125; 测试http://localhost:10010/user/2?name=123&amp;name=789 自定义全局过滤器需求：模拟一个登录的校验。基本逻辑：如果请求中有token参数，则认为请求有效，放行 。 不用配置自动生效 gateway工程编写全局过滤器类MyGlobalFilter 。实现GlobalFilter, Ordered接口。重写方法 12345678910111213141516171819@Componentpublic class MyGlobalFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; String token = exchange.getRequest().getQueryParams().getFirst(\"token\"); if (StringUtils.isBlank(token))&#123; ServerHttpResponse response = exchange.getResponse(); response.setStatusCode(HttpStatus.UNAUTHORIZED); response.setComplete(); &#125; return chain.filter(exchange); &#125; //值越小越先执行 @Override public int getOrder() &#123; return 1; &#125;&#125; 测试 负载均衡和熔断Gateway中默认就已经集成了Ribbon负载均衡和Hystrix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议手动进行配置： 123456789101112hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 6000ribbon: ConnectTimeout: 1000 ReadTimeout: 2000 MaxAutoRetries: 0 MaxAutoRetriesNextServer: 0 Gateway跨域配置一般网关都是所有微服务的统一入口，必然在被调用的时候会出现跨域问题。 跨域：在js请求访问中，如果访问的地址与当前服务器的域名、ip或者端口号不一致则称为跨域请求。若不解决则不能获取到对应地址的返回结果。 如：从在http://localhost:9090中的js访问 http://localhost:9000的数据，因为端口不同，所以也是跨域请求。 在访问Spring Cloud Gateway网关服务器的时候，出现跨域问题的话；可以在网关服务器中通过配置解决，允许哪些服务是可以跨域请求的；具体配置如下： 12345678910spring: cloud: globalcors: corsConfigurations: '[/**]': #allowedOrigins: * # 这种写法或者下面的都可以，*表示全部 allowedOrigins: - \"http://docs.spring.io\" allowedMethods: - GET 上述配置表示：可以允许来自 http://docs.spring.io 的get请求方式获取服务数据。allowedOrigins 指定允许访问的服务器地址，如：http://localhost:10000 也是可以的。‘[/**]’ 表示对所有访问到网关服务器的请求地址官网具体说明：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.1.RELEASE/multi/multi__cors_configuration.html Gateway与Feign的区别 Gateway 作为整个应用的流量入口，接收所有的请求，如PC、移动端等，并且将不同的请求转发至不同的处理微服务模块，其作用可视为nginx；大部分情况下用作权限鉴定、服务端流量控制 Feign 则是将当前微服务的部分服务接口暴露出来，并且主要用于各个微服务之间的服务调用 Spring Cloud Config分布式配置中心 spring cloud config作用：可以通过修改在git仓库中的配置文件实现其它所有微服务的配置文件的修改。 搭建配置中心微服务 在gitee上创建仓库 创建配置文件 在新建的仓库中创建需要被统一配置管理的配置文件。 配置文件的命名方式：{application}-{profile}.yml 或 {application}-{profile}.propertiesapplication为应用名称profile用于区分开发环境，测试环境、生产环境等 如user-dev.yml，表示用户微服务开发环境下使用的配置文件。这里将user-service工程的配置文件application.yml文件的内容复制作为user-dev.yml文件的内容，具体配置如下： 123456789101112131415server: port: $&#123;port:8081&#125;spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/test username: root password: root application: name: user-serviceeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 创建配置中心微服务工程 (选spring cloud为父工程)，添加依赖 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 生成启动引导类和application.yml并进行配置 在启动引导类上添加启用配置中心的注解 123@SpringBootApplication@EnableConfigServerpublic class Application &#123; 修改application.yml 123456789101112131415server: port: 12000spring: application: name: config-server cloud: config: server: git: # gitee上仓库的地址 uri: https://gitee.com/Jagger_Zhong/dhz_config.giteureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 启动测试http://localhost:12000/user-dev.yml 在gitee中对此文件进行修改可以实时更新 修改普通工程使用配置中心的配置文件以修改user-service为例 添加启动器依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 修改xml配置文件 删除 user-service 工程的 user-service\\src\\main\\resources\\application.yml 文件（因为该文件从配置中心获取） 创建 user-service 工程 user-service\\src\\main\\resources\\bootstrap.yml 配置文件 123456789101112131415161718spring: cloud: config: # 与远程仓库中的配置文件的application保持一致 name: user # 远程仓库中的配置文件的profile保持一致 profile: dev # 远程仓库中的版本保持一致 label: master discovery: # 使用配置中心 enabled: true # 配置中心服务id service-id: config-servereureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka bootstrap.yml文件也是Spring Boot的默认配置文件，而且其加载的时间相比于application.yml更早。application.yml和bootstrap.yml虽然都是Spring Boot的默认配置文件，但是定位却不相同。 bootstrap.yml可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。application.yml 可以用来定义应用级别的参数，如果搭配 spring cloud config 使用，application.yml 里面定义的文件可以实现动态替换。 总结就是，bootstrap.yml文件相当于项目启动时的引导文件，内容相对固定。application.yml文件是微服务的一些常规配置参数，变化比较频繁。 测试user-service是否还能正常工作 Spring Cloud Bus服务总线配置中心的yml文件的配置是以键值对的方式存在的，如果只修改value，则不会立即更新，只有重启服务后才会立即更新。 Spring Cloud Bus是用轻量的消息代理将分布式的节点连接起来，可以用于广播配置文件的更改或者服务的监控管理。也就是消息总线可以为微服务做监控，也可以实现应用程序之间相互通信。 Spring Cloud Bus可选的消息代理有RabbitMQ和Kafka。 启动RabbitMQ； 在 config-server 项目的pom.xml文件中加入Spring Cloud Bus相关依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-bus&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;&lt;/dependency&gt; 在 config-server 项目修改application.yml文件如下： 加上rabbitmq和暴露触发消息总线的地址 123456789101112131415161718192021222324252627server: port: 12000spring: application: name: config-server cloud: config: server: git: # gitee上仓库的地址 uri: https://gitee.com/Jagger_Zhong/dhz_config.git rabbitmq: host: 192.168.1.10 port: 5672 username: guest password: guestmanagement: endpoints: web: exposure: # 暴露触发消息总线的地址 include: bus-refresheureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 在用户微服务 user-service 项目的pom.xml中加入Spring Cloud Bus相关依赖 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-bus&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 修改 user-service 项目的bootstrap.yml如下 加入rabbitmq 1234567891011121314151617181920212223spring: cloud: config: # 与远程仓库中的配置文件的application保持一致 name: user # 远程仓库中的配置文件的profile保持一致 profile: dev # 远程仓库中的版本保持一致 label: master discovery: # 使用配置中心 enabled: true # 配置中心服务id service-id: config-server rabbitmq: host: 192.168.1.10 port: 5672 username: guest password: guesteureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 在 user-service 项目的UserController 上加上刷新的注解@RefreshScope 123456789101112131415161718@Controller@RequestMapping(\"user\")@RefreshScopepublic class UserController &#123; @Autowired private UserService userService; @Value(\"$&#123;test.name&#125;\") private String name; @RequestMapping(\"/&#123;id&#125;\") @ResponseBody User findById(@PathVariable(\"id\")int id)&#123; System.out.println(\"配置文件中的name=\"+name); return userService.findById(id); &#125;&#125; 测试 随便找一个jquery在线环境运行以下代码，就会更新参数 1$.post(&quot;http:&#x2F;&#x2F;127.0.0.1:12000&#x2F;actuator&#x2F;bus-refresh&quot;);","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"springCloud","slug":"java/springCloud","permalink":"https://donghuangzhong.github.io/categories/java/springCloud/"}],"tags":[]},{"title":"vm_linux","slug":"vm-linux","date":"2021-06-12T01:18:31.000Z","updated":"2021-06-13T04:50:24.873Z","comments":true,"path":"2021/06/12/vm-linux/","link":"","permalink":"https://donghuangzhong.github.io/2021/06/12/vm-linux/","excerpt":"在vm中安装配置linux","text":"在vm中安装配置linux 下载安装vm 进入中国vm官网https://www.vmware.com/cn.html 在应用和云中点击查看所有产品 在工作空间-》桌面Hypervisor-》Workstation Pro 点击试用中的下载，下载完安装即可，激活码如下 123ZF3R0-FHED2-M80TY-8QYGC-NPKYFYF390-0HF8P-M81RQ-2DXQE-M2UT6ZF71R-DMX85-08DQY-8YMNC-PPHV8 安装centos7准备工作： 安装好vm 网上下载好centos7的镜像 创建新的虚拟机，选择典型 选择稍后安装操作系统 一直点下一步，直到自定义硬件 选择使用iso镜像，修改网络适配器为桥接模式 点击完成，创建完毕开启centos安装即可 语言默认英文即可 点击software selection,选server with gui 点击开始安装 设置root密码，密码一般为root，短密码需要点击两次done 跑完进度条重启，设置时区语言用户名密码 用secureCRT连接 查看centos的ip 1ifconfig 打开secureCRT选择quick connection，填入ip、用户名、密码 更新阿里源 备份原先的源 1mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup 下载新的阿里源，注意后边的centos是几就填几 1wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo 运行 yum makecache 生成缓存 1yum makecache 更新 1yum -y update 用secureCRT进行文件上传下载快捷键alt+p进入sftp命令窗口 通过cd、mkdir进入linux中接收的路径 注：不用单独创建rabbitmq文件夹，会自动创建 1sftp&gt; cd &#x2F; 通过-r上传此文件夹中的全部文件 1sftp&gt; put -r F:&#x2F;share&#x2F;rabbitmq&#x2F;","categories":[{"name":"linux","slug":"linux","permalink":"https://donghuangzhong.github.io/categories/linux/"}],"tags":[]},{"title":"linux-problem","slug":"linux-problem","date":"2021-06-10T02:32:26.000Z","updated":"2021-06-10T02:35:06.321Z","comments":true,"path":"2021/06/10/linux-problem/","link":"","permalink":"https://donghuangzhong.github.io/2021/06/10/linux-problem/","excerpt":"摘要","text":"摘要 cannot open Packages database in /var/lib/rpm 解决方法 1rm -rf &#x2F;var&#x2F;lib&#x2F;rpm&#x2F;__db*","categories":[{"name":"linux","slug":"linux","permalink":"https://donghuangzhong.github.io/categories/linux/"}],"tags":[]},{"title":"RabbitMQ","slug":"RabbitMQ","date":"2021-06-10T01:51:32.000Z","updated":"2021-06-18T03:33:15.739Z","comments":true,"path":"2021/06/10/RabbitMQ/","link":"","permalink":"https://donghuangzhong.github.io/2021/06/10/RabbitMQ/","excerpt":"摘要","text":"摘要 能够说出什么是消息中间件 能够安装RabbitMQ 能够编写RabbitMQ的入门程序 能够说出RabbitMQ的5种模式特征 能够使用Spring整合RabbitMQ 消息中间件概述什么是消息中间件MQ全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法。 为什么使用MQ 在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。 开发中消息队列通常有如下应用场景： 1、任务异步处理 将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。 2、应用程序解耦合 MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。 3、削峰填谷 如订单系统，在下单的时候就会往数据库写数据。但是数据库只能支撑每秒1000左右的并发写入，并发量再高就容易宕机。低峰期的时候并发也就100多个，但是在高峰期时候，并发量会突然激增到5000以上，这个时候数据库肯定卡死了。 消息被MQ保存起来了，然后系统就可以按照自己的消费能力来消费，比如每秒1000个数据，这样慢慢写入数据库，这样就不会卡死数据库了。 但是使用了MQ之后，限制消费消息的速度为1000，但是这样一来，高峰期产生的数据势必会被积压在MQ中，高峰就被“削”掉了。但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000QPS，直到消费完积压的消息,这就叫做“填谷” AMQP 和 JMSMQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。 AMQPAMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。 JMSJMS即Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 AMQP 与 JMS 区别 JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式 JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。 JMS规定了两种消息模式；而AMQP的消息模式更加丰富 消息队列产品市场上常见的消息队列有如下： ActiveMQ：基于JMS ZeroMQ：基于C语言开发 RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好 RocketMQ：基于JMS，阿里巴巴产品 Kafka：类似MQ的产品；分布式消息系统，高吞吐量 RabbitMQRabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。 RabbitMQ官方地址：http://www.rabbitmq.com/ RabbitMQ提供了6种模式：简单模式，work模式，Publish/Subscribe发布与订阅模式，Routing路由模式，Topics主题模式，RPC远程调用模式（远程调用，不太算MQ；暂不作介绍）； 官网对应模式介绍：https://www.rabbitmq.com/getstarted.html 安装及配置RabbitMQ 用到的文件： 在线安装依赖环境 1yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz 安装Erlang 1yum install yum install erlang 安装RabbitMQ 12345# 安装所需的环境yum install socat# 安装rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm 安装完成重启一下才生效 123service rabbitmq-server start # 启动服务service rabbitmq-server stop # 停止服务service rabbitmq-server restart # 重启服务 开启管理界面及配置 123456789# 开启管理界面rabbitmq-plugins enable rabbitmq_management# 修改默认配置信息vim &#x2F;usr&#x2F;lib&#x2F;rabbitmq&#x2F;lib&#x2F;rabbitmq_server-3.6.5&#x2F;ebin&#x2F;rabbit.app # 比如修改密码、配置等等，例如：loopback_users 中的 &lt;&lt;&quot;guest&quot;&gt;&gt;,只保留guest#关闭防火墙systemctl stop firewalld 开启后浏览器访问ip:15672 设置配置文件 123cd &#x2F;usr&#x2F;share&#x2F;doc&#x2F;rabbitmq-server-3.6.5&#x2F;cp rabbitmq.config.example &#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.config 弄完重启服务 配置虚拟主机及用户 用户角色 RabbitMQ在安装好后，可以访问http://ip地址:15672 ；其自带了guest/guest的用户名和密码；如果需要创建自定义用户；那么也可以登录管理界面后，如下操作： 角色说明： 1、 超级管理员(administrator) 可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。 2、 监控者(monitoring) 可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等) 3、 策略制定者(policymaker) 可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。 4、 普通管理者(management) 仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。 5、 其他 无法登陆管理控制台，通常就是普通的生产者和消费者。 Virtual Hosts配置 像mysql拥有数据库的概念并且可以指定用户对库和表等操作的权限。RabbitMQ也有类似的权限管理；在RabbitMQ中可以虚拟消息服务器Virtual Host，每个Virtual Hosts相当于一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的。exchange、queue、message不能互通。 相当于mysql的db。Virtual Name一般以/开头。 创建Virtual Hosts 设置Virtual Hosts权限 RabbitMQ入门编写生产者 添加依赖 1234567891011121314151617181920212223&lt;!--rabbitmq的依赖--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt; &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt; &lt;version&gt;5.6.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.8.0&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;&#x2F;source&gt; &lt;target&gt;1.8&lt;&#x2F;target&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt; 创建生产者类Producer_Helloworld 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Producer_Helloworld &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.142.25&quot;);&#x2F;&#x2F;ip 默认值localhost connectionFactory.setPort(5672);&#x2F;&#x2F;端口 默认5672 connectionFactory.setVirtualHost(&quot;&#x2F;dhzVm&quot;);&#x2F;&#x2F;虚拟机 默认值&#39;&#x2F;&#39; connectionFactory.setUsername(&quot;dhz&quot;);&#x2F;&#x2F;用户名 默认guest connectionFactory.setPassword(&quot;dhz&quot;);&#x2F;&#x2F;密码 默认guest &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.创建队列Queue &#x2F;* queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数： 1.queue:队列名称 2.durable：是否持久化，当mq重启后还在 3.exclusive： * 是否独占。只有一个消费者监听这个队列 * Connection关闭时，是否删除队列 4.autoDelete：是否自动删除。当没有consumer时，自动删除 5.arguments：参数 *&#x2F; &#x2F;&#x2F;如果没有&#39;hello_worlld&#39;队列，则会自动创建；有则不会创建 channel.queueDeclare(&quot;hello_worlld&quot;,true,false,false,null); &#x2F;&#x2F;6.发送消息 &#x2F;* basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) 参数： 1.exchange：交换机名称。简单模式下交换机会使用默认的&quot;&quot; 2.routingKey：路由名称。简单模式下要和队列的名称一样 3.props：配置信息 4.body：发送的消息数据 *&#x2F; channel.basicPublish(&quot;&quot;,&quot;hello_worlld&quot;,null,&quot;hello rabbitmq....&quot;.getBytes()); &#x2F;&#x2F;7.释放资源 channel.close(); connection.close(); &#125;&#125; 在执行上述的消息发送之后；可以登录rabbitMQ的管理控制台，可以发现队列和其消息： 编写消费者编写消息的消费者Consumer_Helloworld 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Consumer_Helloworld &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.120.25&quot;);&#x2F;&#x2F;ip 默认值localhost connectionFactory.setPort(5672);&#x2F;&#x2F;端口 默认5672 connectionFactory.setVirtualHost(&quot;&#x2F;dhzVm&quot;);&#x2F;&#x2F;虚拟机 默认值&#39;&#x2F;&#39; connectionFactory.setUsername(&quot;dhz&quot;);&#x2F;&#x2F;用户名 默认guest connectionFactory.setPassword(&quot;dhz&quot;);&#x2F;&#x2F;密码 默认guest &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.声明队列。非必须，不声明的话队列必须存在 channel.queueDeclare(&quot;hello_worlld&quot;,true,false,false,null); &#x2F;&#x2F;6.接受消息 &#x2F;&#x2F;创建回调对象 Consumer consumer&#x3D;new DefaultConsumer(channel)&#123; &#x2F;* 回调方法，收到消息后会自动执行该方法 参数： 1.consumerTag：标识 2.envelope：包含一些信息，交换机，路由器key... 3.properties:配置信息 4.body：数据 *&#x2F; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;consumerTag：&quot;+consumerTag); System.out.println(&quot;Exchange：&quot;+envelope.getExchange()); System.out.println(&quot;RoutingKey：&quot;+envelope.getRoutingKey()); System.out.println(&quot;properties：&quot;+properties); System.out.println(&quot;body：&quot;+new String(body)); System.out.println(&quot;--------------EOF--------------&quot;); &#125; &#125;; &#x2F;* basicConsume(String queue, boolean autoAck, Consumer callback) 参数： 1.queue:队列名称。和生产者的一致 2.autoAck：是否自动确认 3.callback：回调对象 *&#x2F; channel.basicConsume(&quot;hello_worlld&quot;,true,consumer); &#x2F;&#x2F;7.消费者作为监听者，不要关闭资源，一直监听。。。。 &#125;&#125; 小结上述的入门案例中中其实使用的是如下的简单模式： 在上图的模型中，有以下概念： P：生产者，也就是要发送消息的程序 C：消费者：消息的接受者，会一直等待消息到来。 queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。 AMQP相关概念介绍AMQP 一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。 AMQP是一个二进制协议，拥有一些现代化特点：多信道、协商式，异步，安全，扩平台，中立，高效。 RabbitMQ是AMQP协议的Erlang的实现。 概念 说明 连接Connection 一个网络连接，比如TCP/IP套接字连接。 会话Session 端点之间的命名对话。在一个会话上下文中，保证“恰好传递一次”。 信道Channel 多路复用连接中的一条独立的双向数据流通道。为会话提供物理传输介质。 客户端Client AMQP连接或者会话的发起者。AMQP是非对称的，客户端生产和消费消息，服务器存储和路由这些消息。 服务节点Broker 消息中间件的服务节点；一般情况下可以将一个RabbitMQ Broker看作一台RabbitMQ 服务器。 端点 AMQP对话的任意一方。一个AMQP连接包括两个端点（一个是客户端，一个是服务器）。 消费者Consumer 一个从消息队列里请求消息的客户端程序。 生产者Producer 一个向交换机发布消息的客户端应用程序。 RabbitMQ运转流程在入门案例中： 生产者发送消息 生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker； 声明队列并设置属性；如是否排它，是否持久化，是否自动删除； 将路由键（空字符串）与队列绑定起来； 发送消息至RabbitMQ Broker； 关闭信道； 关闭连接； 消费者接收消息 消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker 向Broker 请求消费相应队列中的消息，设置相应的回调函数； 等待Broker回应闭关投递响应队列中的消息，消费者接收消息； 确认（ack，自动确认）接收到的消息； RabbitMQ从队列中删除相应已经被确认的消息； 关闭信道； 关闭连接； 生产者流转过程说明 客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。 客户端调用connection.createChannel方法。此方法开启信道，其包装的channel.open命令发送给Broker,等待channel.basicPublish方法，对应的AMQP命令为Basic.Publish,这个命令包含了content Header 和content Body()。content Header 包含了消息体的属性，例如:投递模式，优先级等，content Body 包含了消息体本身。 客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。 消费者流转过程说明 消费者客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。 消费者客户端调用connection.createChannel方法。和生产者客户端一样，协议涉及Channel . Open/Open-Ok命令。 在真正消费之前，消费者客户端需要向Broker 发送Basic.Consume 命令(即调用channel.basicConsume 方法〉将Channel 置为接收模式，之后Broker 回执Basic . Consume - Ok 以告诉消费者客户端准备好消费消息。 Broker 向消费者客户端推送(Push) 消息，即Basic.Deliver 命令，这个命令和Basic.Publish 命令一样会携带Content Header 和Content Body。 消费者接收到消息并正确消费之后，向Broker 发送确认，即Basic.Ack 命令。 客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。 RabbitMQ工作模式Work queues工作队列模式 模式说明 Work Queues与入门程序的简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。多个消费者对于同一个消息的关系是竞争的关系。 应用场景：对于 任务过重或任务较多情况使用工作队列可以提高任务处理的速度。 代码 Work Queues与入门程序的简单模式的代码是几乎一样的；可以完全复制，并复制多一个消费者进行多个消费者同时消费消息的测试。 生产者(一个)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Producer_WorkQueues &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.120.25&quot;);&#x2F;&#x2F;ip 默认值localhost connectionFactory.setPort(5672);&#x2F;&#x2F;端口 默认5672 connectionFactory.setVirtualHost(&quot;&#x2F;dhzVm&quot;);&#x2F;&#x2F;虚拟机 默认值&#39;&#x2F;&#39; connectionFactory.setUsername(&quot;dhz&quot;);&#x2F;&#x2F;用户名 默认guest connectionFactory.setPassword(&quot;dhz&quot;);&#x2F;&#x2F;密码 默认guest &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.创建队列Queue &#x2F;* queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数： 1.queue:队列名称 2.durable：是否持久化，当mq重启后还在 3.exclusive： * 是否独占。只有一个消费者监听这个队列 * Connection关闭时，是否删除队列 4.autoDelete：是否自动删除。当没有consumer时，自动删除 5.arguments：参数 *&#x2F; &#x2F;&#x2F;如果没有&#39;hello_worlld&#39;队列，则会自动创建；有则不会创建 channel.queueDeclare(&quot;work_queues&quot;,true,false,false,null); &#x2F;&#x2F;6.发送消息。work_queues和简单模式的配置类似 &#x2F;* basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) 参数： 1.exchange：交换机名称。简单模式下交换机会使用默认的&quot;&quot; 2.routingKey：路由名称。简单模式下要和队列的名称一样 3.props：配置信息 4.body：发送的消息数据 *&#x2F; for (int i &#x3D; 0; i &lt; 10; i++) &#123; channel.basicPublish(&quot;&quot;,&quot;work_queues&quot;,null,(i+&quot;work_queues....&quot;).getBytes()); &#125; &#x2F;&#x2F;7.释放资源 channel.close(); connection.close(); &#125;&#125; 消费者两个(Consumer_WorkQueues1、2。代码完全一样): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Consumer_WorkQueues1 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.120.25&quot;);&#x2F;&#x2F;ip 默认值localhost connectionFactory.setPort(5672);&#x2F;&#x2F;端口 默认5672 connectionFactory.setVirtualHost(&quot;&#x2F;dhzVm&quot;);&#x2F;&#x2F;虚拟机 默认值&#39;&#x2F;&#39; connectionFactory.setUsername(&quot;dhz&quot;);&#x2F;&#x2F;用户名 默认guest connectionFactory.setPassword(&quot;dhz&quot;);&#x2F;&#x2F;密码 默认guest &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.声明队列。非必须，不声明的话队列必须存在 channel.queueDeclare(&quot;work_queues&quot;,true,false,false,null); &#x2F;&#x2F;6.接受消息 &#x2F;&#x2F;创建回调对象 Consumer consumer&#x3D;new DefaultConsumer(channel)&#123; &#x2F;* 回调方法，收到消息后会自动执行该方法 参数： 1.consumerTag：标识 2.envelope：包含一些信息，交换机，路由器key... 3.properties:配置信息 4.body：数据 *&#x2F; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;body：&quot;+new String(body)); &#125; &#125;; &#x2F;* basicConsume(String queue, boolean autoAck, Consumer callback) 参数： 1.queue:队列名称。和生产者的一致 2.autoAck：是否自动确认 3.callback：回调对象 *&#x2F; channel.basicConsume(&quot;work_queues&quot;,true,consumer); &#x2F;&#x2F;7.消费者作为监听者，不要关闭资源，一直监听。。。。 &#125;&#125; 结果 订阅模式类型订阅模式示例图： 前面2个案例中，只有3个角色： P：生产者，也就是要发送消息的程序 C：消费者：消息的接受者，会一直等待消息到来。 queue：消息队列，图中红色部分 而在订阅模型中，多了一个exchange角色，而且过程略有变化： P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机） C：消费者，消息的接受者，会一直等待消息到来。 Queue：消息队列，接收消息、缓存消息。 Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型： Fanout：广播，将消息交给所有绑定到交换机的队列 Direct：定向，把消息交给符合指定routing key 的队列 Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列 Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！ 发布订阅模式与工作队列模式的区别 1、工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机。 2、发布/订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)。 3、发布/订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑 定到默认的交换机 。 Fanout(广播)模式 模式说明 每个消费者监听自己的队列。 生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息 代码 生产者(一个)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Producer_FanOut &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.120.25&quot;);&#x2F;&#x2F;ip 默认值localhost connectionFactory.setPort(5672);&#x2F;&#x2F;端口 默认5672 connectionFactory.setVirtualHost(&quot;&#x2F;dhzVm&quot;);&#x2F;&#x2F;虚拟机 默认值&#39;&#x2F;&#39; connectionFactory.setUsername(&quot;dhz&quot;);&#x2F;&#x2F;用户名 默认guest connectionFactory.setPassword(&quot;dhz&quot;);&#x2F;&#x2F;密码 默认guest &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.创建交换机。 &#x2F;* exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments) 参数： 1.exchange：交换机名称 2.type：交换机类型 DIRECT(&quot;direct&quot;),:定向 FANOUT(&quot;fanout&quot;),：扇形(广播)。发送消息到每一个绑定的队列 TOPIC(&quot;topic&quot;),：通配符方式 HEADERS(&quot;headers&quot;);：参数匹配 3.durable：是否持久化 4.autoDelete：是否自动删除 5.internal：内部使用一般false 6.arguments：参数 *&#x2F; channel.exchangeDeclare(&quot;fanout_exchange&quot;, BuiltinExchangeType.FANOUT,true,false,false,null); &#x2F;&#x2F;6.创建两个队列Queue &#x2F;* queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数： 1.queue:队列名称 2.durable：是否持久化，当mq重启后还在 3.exclusive： * 是否独占。只有一个消费者监听这个队列 * Connection关闭时，是否删除队列 4.autoDelete：是否自动删除。当没有consumer时，自动删除 5.arguments：参数 *&#x2F; &#x2F;&#x2F;如果没有&#39;hello_worlld&#39;队列，则会自动创建；有则不会创建 channel.queueDeclare(&quot;fanout_queue1&quot;,true,false,false,null); channel.queueDeclare(&quot;fanout_queue2&quot;,true,false,false,null); &#x2F;&#x2F;7.绑定队列和交换机 &#x2F;* queueBind(String queue, String exchange, String routingKey) 参数： 1.queue：队列名称 2.exchange：交换机名称 3.routingKey：路由键。绑定规则 如果交换机类型为fanout，routingKey设为&quot;&quot; *&#x2F; channel.queueBind(&quot;fanout_queue1&quot;,&quot;fanout_exchange&quot;,&quot;&quot;); channel.queueBind(&quot;fanout_queue2&quot;,&quot;fanout_exchange&quot;,&quot;&quot;); &#x2F;&#x2F;8.发送消息 &#x2F;* basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) 参数： 1.exchange：交换机名称。 2.routingKey：路由名称。fanout模式下为&quot;&quot; 3.props：配置信息 4.body：发送的消息数据 *&#x2F; channel.basicPublish(&quot;fanout_exchange&quot;,&quot;&quot;,null,&quot;fanout message...&quot;.getBytes()); &#x2F;&#x2F;9.释放资源 channel.close(); connection.close(); &#125;&#125; 消费者1： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Consumer_FanOut1 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.120.25&quot;);&#x2F;&#x2F;ip 默认值localhost connectionFactory.setPort(5672);&#x2F;&#x2F;端口 默认5672 connectionFactory.setVirtualHost(&quot;&#x2F;dhzVm&quot;);&#x2F;&#x2F;虚拟机 默认值&#39;&#x2F;&#39; connectionFactory.setUsername(&quot;dhz&quot;);&#x2F;&#x2F;用户名 默认guest connectionFactory.setPassword(&quot;dhz&quot;);&#x2F;&#x2F;密码 默认guest &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.声明队列。非必须，不声明的话队列必须存在 channel.queueDeclare(&quot;fanout_queue1&quot;,true,false,false,null); &#x2F;&#x2F;6.接受消息 &#x2F;&#x2F;创建回调对象 Consumer consumer&#x3D;new DefaultConsumer(channel)&#123; &#x2F;* 回调方法，收到消息后会自动执行该方法 参数： 1.consumerTag：标识 2.envelope：包含一些信息，交换机，路由器key... 3.properties:配置信息 4.body：数据 *&#x2F; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;1号消费者的body：&quot;+new String(body)); &#125; &#125;; &#x2F;* basicConsume(String queue, boolean autoAck, Consumer callback) 参数： 1.queue:队列名称。 2.autoAck：是否自动确认 3.callback：回调对象 *&#x2F; channel.basicConsume(&quot;fanout_queue1&quot;,true,consumer); &#x2F;&#x2F;7.消费者作为监听者，不要关闭资源，一直监听。。。。 &#125;&#125; 消费者2：改改消费者1，监听2号队列 结果 在执行完测试代码后，其实到RabbitMQ的管理后台找到Exchanges选项卡，点击 fanout_exchange 的交换机，可以查看到如下的绑定： Routing路由模式 模式说明 路由模式特点： 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。 Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息 图解： P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。 X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列 C1：消费者，其所在队列指定了需要routing key 为 error 的消息 C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息 代码 在编码上与 Publish/Subscribe发布与订阅模式 的区别是交换机的类型为：Direct，还有队列绑定交换机的时候需要指定routing key。 生产者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class Producer_Routing &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.163.25&quot;);&#x2F;&#x2F;ip 默认值localhost connectionFactory.setPort(5672);&#x2F;&#x2F;端口 默认5672 connectionFactory.setVirtualHost(&quot;&#x2F;dhzVm&quot;);&#x2F;&#x2F;虚拟机 默认值&#39;&#x2F;&#39; connectionFactory.setUsername(&quot;dhz&quot;);&#x2F;&#x2F;用户名 默认guest connectionFactory.setPassword(&quot;dhz&quot;);&#x2F;&#x2F;密码 默认guest &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.创建交换机。 &#x2F;* exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments) 参数： 1.exchange：交换机名称 2.type：交换机类型 DIRECT(&quot;direct&quot;),:定向 FANOUT(&quot;fanout&quot;),：扇形(广播)。发送消息到每一个绑定的队列 TOPIC(&quot;topic&quot;),：通配符方式 HEADERS(&quot;headers&quot;);：参数匹配 3.durable：是否持久化 4.autoDelete：是否自动删除 5.internal：内部使用一般false 6.arguments：参数 *&#x2F; channel.exchangeDeclare(&quot;direct_exchange&quot;, BuiltinExchangeType.DIRECT,true,false,false,null); &#x2F;&#x2F;6.创建两个队列Queue &#x2F;* queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数： 1.queue:队列名称 2.durable：是否持久化，当mq重启后还在 3.exclusive： * 是否独占。只有一个消费者监听这个队列 * Connection关闭时，是否删除队列 4.autoDelete：是否自动删除。当没有consumer时，自动删除 5.arguments：参数 *&#x2F; &#x2F;&#x2F;如果没有&#39;hello_worlld&#39;队列，则会自动创建；有则不会创建 channel.queueDeclare(&quot;direct_queue1&quot;,true,false,false,null); channel.queueDeclare(&quot;direct_queue2&quot;,true,false,false,null); &#x2F;&#x2F;7.绑定队列和交换机 &#x2F;* queueBind(String queue, String exchange, String routingKey) 参数： 1.queue：队列名称 2.exchange：交换机名称 3.routingKey：路由键。绑定规则 如果交换机类型为fanout，routingKey设为&quot;&quot; *&#x2F; &#x2F;&#x2F;队列1的绑定。队列1负责存储错误信息到数据库 channel.queueBind(&quot;direct_queue1&quot;,&quot;direct_exchange&quot;,&quot;error&quot;); &#x2F;&#x2F;队列2的绑定。队列2负责打印所有信息到控制台 channel.queueBind(&quot;direct_queue2&quot;,&quot;direct_exchange&quot;,&quot;info&quot;); channel.queueBind(&quot;direct_queue2&quot;,&quot;direct_exchange&quot;,&quot;error&quot;); channel.queueBind(&quot;direct_queue2&quot;,&quot;direct_exchange&quot;,&quot;warning&quot;); &#x2F;&#x2F;8.发送消息 &#x2F;* basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) 参数： 1.exchange：交换机名称。 2.routingKey：路由名称。fanout模式下为&quot;&quot; 3.props：配置信息 4.body：发送的消息数据 *&#x2F; channel.basicPublish(&quot;direct_exchange&quot;,&quot;error&quot;,null,&quot; 这是一条错误...&quot;.getBytes()); channel.basicPublish(&quot;direct_exchange&quot;,&quot;warning&quot;,null,&quot; 这是一条警告...&quot;.getBytes()); &#x2F;&#x2F;9.释放资源 channel.close(); connection.close(); &#125;&#125; 消费者1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Consumer_direct1 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.163.25&quot;);&#x2F;&#x2F;ip 默认值localhost connectionFactory.setPort(5672);&#x2F;&#x2F;端口 默认5672 connectionFactory.setVirtualHost(&quot;&#x2F;dhzVm&quot;);&#x2F;&#x2F;虚拟机 默认值&#39;&#x2F;&#39; connectionFactory.setUsername(&quot;dhz&quot;);&#x2F;&#x2F;用户名 默认guest connectionFactory.setPassword(&quot;dhz&quot;);&#x2F;&#x2F;密码 默认guest &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.声明队列。非必须，不声明的话队列必须存在 channel.queueDeclare(&quot;direct_queue1&quot;,true,false,false,null); &#x2F;&#x2F;6.接受消息 &#x2F;&#x2F;创建回调对象 Consumer consumer&#x3D;new DefaultConsumer(channel)&#123; &#x2F;* 回调方法，收到消息后会自动执行该方法 参数： 1.consumerTag：标识 2.envelope：包含一些信息，交换机，路由器key... 3.properties:配置信息 4.body：数据 *&#x2F; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;1号消费者的body：&quot;+new String(body)+&quot; 正在将错误信息存储到数据库。。。&quot;); &#125; &#125;; &#x2F;* basicConsume(String queue, boolean autoAck, Consumer callback) 参数： 1.queue:队列名称。 2.autoAck：是否自动确认 3.callback：回调对象 *&#x2F; channel.basicConsume(&quot;direct_queue1&quot;,true,consumer); &#x2F;&#x2F;7.消费者作为监听者，不要关闭资源，一直监听。。。。 &#125;&#125; 消费者2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Consumer_direct2 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.163.25&quot;);&#x2F;&#x2F;ip 默认值localhost connectionFactory.setPort(5672);&#x2F;&#x2F;端口 默认5672 connectionFactory.setVirtualHost(&quot;&#x2F;dhzVm&quot;);&#x2F;&#x2F;虚拟机 默认值&#39;&#x2F;&#39; connectionFactory.setUsername(&quot;dhz&quot;);&#x2F;&#x2F;用户名 默认guest connectionFactory.setPassword(&quot;dhz&quot;);&#x2F;&#x2F;密码 默认guest &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.声明队列。非必须，不声明的话队列必须存在 channel.queueDeclare(&quot;direct_queue2&quot;,true,false,false,null); &#x2F;&#x2F;6.接受消息 &#x2F;&#x2F;创建回调对象 Consumer consumer&#x3D;new DefaultConsumer(channel)&#123; &#x2F;* 回调方法，收到消息后会自动执行该方法 参数： 1.consumerTag：标识 2.envelope：包含一些信息，交换机，路由器key... 3.properties:配置信息 4.body：数据 *&#x2F; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;2号消费者的body：&quot;+new String(body)+&quot; 正在将日志信息存储到打印到控制台。。。&quot;); &#125; &#125;; &#x2F;* basicConsume(String queue, boolean autoAck, Consumer callback) 参数： 1.queue:队列名称。 2.autoAck：是否自动确认 3.callback：回调对象 *&#x2F; channel.basicConsume(&quot;direct_queue2&quot;,true,consumer); &#x2F;&#x2F;7.消费者作为监听者，不要关闭资源，一直监听。。。。 &#125;&#125; 结果 在执行完测试代码后，其实到RabbitMQ的管理后台找到Exchanges选项卡，点击 direct_exchange 的交换机，可以查看到如下的绑定： Topics通配符模式 模式说明 Topic类型与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！ Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert 通配符规则： #：匹配一个或多个词 *：匹配不多不少恰好1个词 举例： item.#：能够匹配item.insert.abc 或者 item.insert item.*：只能匹配item.insert 图解： 红色Queue：绑定的是usa.# ，因此凡是以 usa.开头的routing key 都会被匹配到 黄色Queue：绑定的是#.news ，因此凡是以 .news结尾的 routing key 都会被匹配 代码 生产者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class Producer_Topics &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.37.25&quot;);&#x2F;&#x2F;ip 默认值localhost connectionFactory.setPort(5672);&#x2F;&#x2F;端口 默认5672 connectionFactory.setVirtualHost(&quot;&#x2F;dhzVm&quot;);&#x2F;&#x2F;虚拟机 默认值&#39;&#x2F;&#39; connectionFactory.setUsername(&quot;dhz&quot;);&#x2F;&#x2F;用户名 默认guest connectionFactory.setPassword(&quot;dhz&quot;);&#x2F;&#x2F;密码 默认guest &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.创建交换机。 &#x2F;* exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments) 参数： 1.exchange：交换机名称 2.type：交换机类型 DIRECT(&quot;direct&quot;),:定向 FANOUT(&quot;fanout&quot;),：扇形(广播)。发送消息到每一个绑定的队列 TOPIC(&quot;topic&quot;),：通配符方式 HEADERS(&quot;headers&quot;);：参数匹配 3.durable：是否持久化 4.autoDelete：是否自动删除 5.internal：内部使用一般false 6.arguments：参数 *&#x2F; channel.exchangeDeclare(&quot;topic_exchange&quot;, BuiltinExchangeType.TOPIC,true,false,false,null); &#x2F;&#x2F;6.创建两个队列Queue &#x2F;* queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数： 1.queue:队列名称 2.durable：是否持久化，当mq重启后还在 3.exclusive： * 是否独占。只有一个消费者监听这个队列 * Connection关闭时，是否删除队列 4.autoDelete：是否自动删除。当没有consumer时，自动删除 5.arguments：参数 *&#x2F; &#x2F;&#x2F;如果没有&#39;hello_worlld&#39;队列，则会自动创建；有则不会创建 channel.queueDeclare(&quot;topic_queue1&quot;,true,false,false,null); channel.queueDeclare(&quot;topic_queue2&quot;,true,false,false,null); &#x2F;&#x2F;7.绑定队列和交换机 &#x2F;* queueBind(String queue, String exchange, String routingKey) 参数： 1.queue：队列名称 2.exchange：交换机名称 3.routingKey：路由键。绑定规则 如果交换机类型为fanout，routingKey设为&quot;&quot; *&#x2F; &#x2F;&#x2F;队列1的绑定。队列1负责存储错误信息到数据库 channel.queueBind(&quot;topic_queue1&quot;,&quot;topic_exchange&quot;,&quot;#.error&quot;); &#x2F;&#x2F;队列2的绑定。队列2负责打印所有信息到控制台 channel.queueBind(&quot;topic_queue2&quot;,&quot;topic_exchange&quot;,&quot;*.*&quot;); &#x2F;&#x2F;8.发送消息 &#x2F;* basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) 参数： 1.exchange：交换机名称。 2.routingKey：路由名称。fanout模式下为&quot;&quot; 3.props：配置信息 4.body：发送的消息数据 *&#x2F; channel.basicPublish(&quot;topic_exchange&quot;,&quot;system.runtime.error&quot;,null,&quot; 这是一条system.runtime.error类型的消息...&quot;.getBytes()); channel.basicPublish(&quot;topic_exchange&quot;,&quot;rabbit.warning&quot;,null,&quot; 这是一条rabbit.warning类型的消息...&quot;.getBytes()); &#x2F;&#x2F;9.释放资源 channel.close(); connection.close(); &#125;&#125; 消费者1： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Consumer_topic1 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.37.25&quot;);&#x2F;&#x2F;ip 默认值localhost connectionFactory.setPort(5672);&#x2F;&#x2F;端口 默认5672 connectionFactory.setVirtualHost(&quot;&#x2F;dhzVm&quot;);&#x2F;&#x2F;虚拟机 默认值&#39;&#x2F;&#39; connectionFactory.setUsername(&quot;dhz&quot;);&#x2F;&#x2F;用户名 默认guest connectionFactory.setPassword(&quot;dhz&quot;);&#x2F;&#x2F;密码 默认guest &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.声明队列。非必须，不声明的话队列必须存在 channel.queueDeclare(&quot;topic_queue1&quot;,true,false,false,null); &#x2F;&#x2F;6.接受消息 &#x2F;&#x2F;创建回调对象 Consumer consumer&#x3D;new DefaultConsumer(channel)&#123; &#x2F;* 回调方法，收到消息后会自动执行该方法 参数： 1.consumerTag：标识 2.envelope：包含一些信息，交换机，路由器key... 3.properties:配置信息 4.body：数据 *&#x2F; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;1号消费者的body：&quot;+new String(body)+&quot; 正在将错误信息存储到数据库。。。&quot;); &#125; &#125;; &#x2F;* basicConsume(String queue, boolean autoAck, Consumer callback) 参数： 1.queue:队列名称。 2.autoAck：是否自动确认 3.callback：回调对象 *&#x2F; channel.basicConsume(&quot;topic_queue1&quot;,true,consumer); &#x2F;&#x2F;7.消费者作为监听者，不要关闭资源，一直监听。。。。 &#125;&#125; 生产者2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Consumer_topic2 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.37.25&quot;);&#x2F;&#x2F;ip 默认值localhost connectionFactory.setPort(5672);&#x2F;&#x2F;端口 默认5672 connectionFactory.setVirtualHost(&quot;&#x2F;dhzVm&quot;);&#x2F;&#x2F;虚拟机 默认值&#39;&#x2F;&#39; connectionFactory.setUsername(&quot;dhz&quot;);&#x2F;&#x2F;用户名 默认guest connectionFactory.setPassword(&quot;dhz&quot;);&#x2F;&#x2F;密码 默认guest &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.声明队列。非必须，不声明的话队列必须存在 channel.queueDeclare(&quot;topic_queue2&quot;,true,false,false,null); &#x2F;&#x2F;6.接受消息 &#x2F;&#x2F;创建回调对象 Consumer consumer&#x3D;new DefaultConsumer(channel)&#123; &#x2F;* 回调方法，收到消息后会自动执行该方法 参数： 1.consumerTag：标识 2.envelope：包含一些信息，交换机，路由器key... 3.properties:配置信息 4.body：数据 *&#x2F; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;1号消费者的body：&quot;+new String(body)+&quot; 正在将日志信息打印到控制台。。。&quot;); &#125; &#125;; &#x2F;* basicConsume(String queue, boolean autoAck, Consumer callback) 参数： 1.queue:队列名称。 2.autoAck：是否自动确认 3.callback：回调对象 *&#x2F; channel.basicConsume(&quot;topic_queue2&quot;,true,consumer); &#x2F;&#x2F;7.消费者作为监听者，不要关闭资源，一直监听。。。。 &#125;&#125; 结果 在执行完测试代码后，其实到RabbitMQ的管理后台找到Exchanges选项卡，点击 topic_exchange 的交换机，可以查看到如下的绑定： 模式总结RabbitMQ工作模式：1、简单模式 HelloWorld一个生产者、一个消费者，不需要设置交换机（使用默认的交换机） 2、工作队列模式 Work Queue一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机） 3、发布订阅模式 Publish/subscribe需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列 4、路由模式 Routing需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列 5、通配符模式 Topic需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列 Spring 整合RabbitMQ整合生产者 常见maven工程，添加依赖 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 创建rabbitmq.properties配置文件 spring-rabbitmq-producer\\src\\main\\resources\\properties\\rabbitmq.properties 12345rabbitmq.host&#x3D;192.168.37.25rabbitmq.port&#x3D;5672rabbitmq.username&#x3D;dhzrabbitmq.password&#x3D;dhzrabbitmq.virtual-host&#x3D;&#x2F;dhzVm 创建spring-rabbitmq.xml(queue和exchange的id可以不要) spring-rabbitmq-producer\\src\\main\\resources\\spring\\spring-rabbitmq.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\"&gt; &lt;!--加载rabbitmq.properties配置文件--&gt; &lt;context:property-placeholder location=\"classpath:rabbitmq.properties\"/&gt; &lt;!--定义rabbitmq connectionFactory--&gt; &lt;rabbit:connection-factory id=\"connectionFactory\" host=\"$&#123;rabbitmq.host&#125;\" port=\"$&#123;rabbitmq.port&#125;\" username=\"$&#123;rabbitmq.username&#125;\" password=\"$&#123;rabbitmq.password&#125;\" virtual-host=\"$&#123;rabbitmq.virtual-host&#125;\"/&gt; &lt;!--注册。定义管理交换机、队列--&gt; &lt;rabbit:admin connection-factory=\"connectionFactory\"/&gt; &lt;!--定义简单队列--&gt; &lt;rabbit:queue id=\"simple_queue\" name=\"simple_queue\"/&gt; &lt;!--定义work_queue--&gt; &lt;rabbit:queue id=\"work_queue\" name=\"work_queue\"/&gt; &lt;!--和fanout绑定的队列1、2--&gt; &lt;rabbit:queue id=\"fanout_queue1\" name=\"fanout_queue1\"/&gt; &lt;rabbit:queue id=\"fanout_queue2\" name=\"fanout_queue2\"/&gt; &lt;!--定义fanout交换机、绑定队列--&gt; &lt;rabbit:fanout-exchange name=\"spring_fanout_exchange\" id=\"spring_fanout_exchange\"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue=\"fanout_queue1\"/&gt; &lt;rabbit:binding queue=\"fanout_queue2\"/&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:fanout-exchange&gt; &lt;!--和routing绑定的队列1、2--&gt; &lt;rabbit:queue id=\"direct_queue1\" name=\"direct_queue1\"/&gt; &lt;rabbit:queue id=\"direct_queue2\" name=\"direct_queue2\"/&gt; &lt;!--定义routing交换机、绑定队列--&gt; &lt;rabbit:direct-exchange name=\"spring_direct_exchange\" id=\"spring_direct_exchange\"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding key=\"error\" queue=\"direct_queue1\"&gt;&lt;/rabbit:binding&gt; &lt;rabbit:binding key=\"info\" queue=\"direct_queue2\"&gt;&lt;/rabbit:binding&gt; &lt;rabbit:binding key=\"error\" queue=\"direct_queue2\"&gt;&lt;/rabbit:binding&gt; &lt;rabbit:binding key=\"warning\" queue=\"direct_queue2\"&gt;&lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:direct-exchange&gt; &lt;!--和topic绑定的队列1、2--&gt; &lt;rabbit:queue id=\"topic_queue1\" name=\"topic_queue1\"/&gt; &lt;rabbit:queue id=\"topic_queue2\" name=\"topic_queue2\"/&gt; &lt;!--定义topic交换机、绑定队列--&gt; &lt;rabbit:topic-exchange name=\"spring_topic_exchange\" id=\"spring_topic_exchange\"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding pattern=\"#.error\" queue=\"topic_queue1\"&gt;&lt;/rabbit:binding&gt; &lt;rabbit:binding pattern=\"*.*\" queue=\"topic_queue2\"/&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:topic-exchange&gt; &lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt; &lt;rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/&gt;&lt;/beans&gt; 创建测试包进行spring测试 spring-rabbitmq-producer\\src\\test\\java\\com\\dhz\\rabbitmq\\ProducerTest.java 123456789101112131415161718192021222324252627282930313233343536@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:spring-rabbitmq.xml\")public class ProducerTest &#123; @Autowired private RabbitTemplate rabbitTemplate; @Test public void simple_queue_test()&#123; rabbitTemplate.convertAndSend(\"\",\"simple_queue\",\"simple_queue_message\"); &#125; @Test public void work_queue_test()&#123; for (int i = 0; i &lt; 10; i++) &#123; rabbitTemplate.convertAndSend(\"\",\"work_queue\",\"work_queue_message\"+i); &#125; &#125; @Test public void fanout_test()&#123; rabbitTemplate.convertAndSend(\"spring_fanout_exchange\",\"\",\"fanout_message\"); &#125; @Test public void routing_test()&#123; rabbitTemplate.convertAndSend(\"spring_direct_exchange\",\"error\",\"routing_message_error\"); rabbitTemplate.convertAndSend(\"spring_direct_exchange\",\"info\",\"routing_message_info\"); &#125; @Test public void topic_test()&#123; rabbitTemplate.convertAndSend(\"spring_topic_exchange\",\"system.runtime.error\",\"topic_message_system.runtime.error\"); rabbitTemplate.convertAndSend(\"spring_topic_exchange\",\"rabbit.waring\",\"topic_message_rabbit.waring\"); &#125;&#125; 结果 整合消费者 创建maven，添加依赖 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 创建rabbitmq.properties配置文件 spring-rabbitmq-consumer\\src\\main\\resources\\properties\\rabbitmq.properties 12345rabbitmq.host&#x3D;192.168.37.25rabbitmq.port&#x3D;5672rabbitmq.username&#x3D;dhzrabbitmq.password&#x3D;dhzrabbitmq.virtual-host&#x3D;&#x2F;dhzVm 创建QueueListener实现MessageListener接口，实现onMessage方法 com.dhz.rabbitmq.listener.SpringQueueListene 12345678910public class SpringQueueListener implements MessageListener &#123; public void onMessage(Message message) &#123; String msg &#x3D; new String(message.getBody()); System.out.printf(&quot;接收路由名称为：%s，路由键为：%s，队列名为：%s的消息：%s \\n&quot;, message.getMessageProperties().getReceivedExchange(), message.getMessageProperties().getReceivedRoutingKey(), message.getMessageProperties().getConsumerQueue(), msg); &#125;&#125; 创建spring-rabbitmq.xml。配置队列与Bean的对应关系 spring-rabbitmq-consumer\\src\\main\\resources\\spring\\spring-rabbitmq.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:rabbit&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit&#x2F;spring-rabbit.xsd&quot;&gt; &lt;!--加载rabbitmq.properties配置文件--&gt; &lt;context:property-placeholder location&#x3D;&quot;classpath:rabbitmq.properties&quot;&#x2F;&gt; &lt;!--定义rabbitmq connectionFactory--&gt; &lt;rabbit:connection-factory id&#x3D;&quot;connectionFactory&quot; host&#x3D;&quot;$&#123;rabbitmq.host&#125;&quot; port&#x3D;&quot;$&#123;rabbitmq.port&#125;&quot; username&#x3D;&quot;$&#123;rabbitmq.username&#125;&quot; password&#x3D;&quot;$&#123;rabbitmq.password&#125;&quot; virtual-host&#x3D;&quot;$&#123;rabbitmq.virtual-host&#125;&quot;&#x2F;&gt; &lt;bean id&#x3D;&quot;springQueueListener&quot; class&#x3D;&quot;com.dhz.rabbitmq.listener.SpringQueueListener&quot;&#x2F;&gt; &lt;!--配置队列和Bean的映射--&gt; &lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;simple_queue&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;work_queue&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;fanout_queue1&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;fanout_queue2&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;direct_queue1&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;direct_queue2&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;topic_queue1&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;topic_queue2&quot;&#x2F;&gt; &lt;&#x2F;rabbit:listener-container&gt;&lt;&#x2F;beans&gt; 创建测试类，执行空的测试方法 spring-rabbitmq-consumer\\src\\test\\java\\com\\dhz\\rabbitmq\\ConsumerTest.java 1234567@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbitmq.xml&quot;)public class ConsumerTest &#123; @Test public void test()&#123; &#125;&#125; 结果 Spring Boot整合RabbitMQ在Spring项目中，可以使用Spring-Rabbit去操作RabbitMQhttps://github.com/spring-projects/spring-amqp 尤其是在spring boot项目中只需要引入对应的amqp启动器依赖即可，方便的使用RabbitTemplate发送消息，使用注解接收消息。 整合生产者 创建maven工程，引入依赖 12345678910111213141516&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 创建启动类 1234567891011package com.dhz;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class AppRun &#123; public static void main(String[] args) &#123; SpringApplication.run(AppRun.class); &#125;&#125; 创建application.yml 1234567spring: rabbitmq: host: 192.168.37.25 port: 5672 username: dhz password: dhz virtual-host: &#x2F;dhzVm 创建配置类，其中定义交换机和队列以及它们的绑定 com.dhz.configuration.RabbitmqConfig 123456789101112131415161718192021222324@Configurationpublic class RabbitmqConfig &#123; &#x2F;&#x2F;1.创建交换机 &#x2F;&#x2F;通过ExchangeBuilder.选择不同的交换机类型，一系列点配置持久化、自动删除等 @Bean(&quot;bootExchange&quot;) public Exchange bootExchange()&#123; return ExchangeBuilder.topicExchange(&quot;boot_topic_exchange&quot;).durable(true).build(); &#125; &#x2F;&#x2F;2.创建队列 &#x2F;&#x2F;*durable(&quot;队列名称&quot;) @Bean(&quot;bootQueue&quot;) public Queue bootQueue()&#123; return QueueBuilder.durable(&quot;boot_queue&quot;).build(); &#125; &#x2F;&#x2F;3.绑定交换机和队列 @Bean public Binding bingQueueExchange(@Qualifier(&quot;bootQueue&quot;) Queue queue,@Qualifier(&quot;bootExchange&quot;) Exchange exchange)&#123; return BindingBuilder.bind(queue).to(exchange).with(&quot;boot.#&quot;).noargs(); &#125; &#125; 创建测试类测试 12345678910111213@SpringBootTest@RunWith(SpringRunner.class)public class ProducerTest &#123; @Autowired private RabbitTemplate rabbitTemplate; @Test public void test()&#123; rabbitTemplate.convertAndSend(&quot;boot_topic_exchange&quot;,&quot;boot.test&quot;,&quot;spring_boot_producer_message&quot;); &#125;&#125; 整合消费者 创建maven工程，引入依赖 12345678910111213141516&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 创建启动类 1234567891011package com.dhz;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class AppRun &#123; public static void main(String[] args) &#123; SpringApplication.run(AppRun.class); &#125;&#125; 创建application.yml 1234567spring: rabbitmq: host: 192.168.37.25 port: 5672 username: dhz password: dhz virtual-host: &#x2F;dhzVm 编写RabbitmqListener类，其中的方法和队列做映射 1234567@Componentpublic class RabbitmqListener &#123; @RabbitListener(queues &#x3D; &quot;boot_queue&quot;) public void listenerQueue(Message message)&#123; System.out.println(message); &#125;&#125; 启动启动类 rabbitmq高级特性基于用springboot集成rabbitmq，参见上文的搭建 消息可靠性投递(生产者)rabbitmq 整个消息投递的路径为：producer—&gt;rabbitmq broker—&gt;exchange—&gt;queue—&gt;consumer 消息从 producer 到 exchange 则会返回一个 confirmCallback 。确认模式 消息从 exchange–&gt;queue 投递失败则会返回一个 returnCallback 。退回模式 确认模式消息从 producer 到 exchange 则会返回一个 confirmCallback 。确认模式 设置ConnectionFactory的publisher-confirms=”true” 开启 确认模式。 修改application.yml： 12345678spring: rabbitmq: host: 192.168.192.25 port: 5672 username: dhz password: dhz virtual-host: &#x2F;dhzVm publisher-confirms: true 使用rabbitTemplate.setConfirmCallback设置回调函数 12345678910111213141516171819202122232425@SpringBootTest@RunWith(SpringRunner.class)public class ProducerTest &#123; @Autowired private RabbitTemplate rabbitTemplate; @Test public void confirmTest()&#123; rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() &#123; /* 不管交换机是否成功接收消息都会执行 1.correlationData:相关配置信息 2.ack：交换机是否成功收到参数 3.cause：2中失败原因 */ @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; if(ack) System.out.println(\"接收成功\"); else System.out.println(\"接收失败！失败原因为：\"+cause); &#125; &#125;); rabbitTemplate.convertAndSend(\"boot_topic_exchange11\",\"boot.test\",\"spring_boot_producer_message\"); &#125;&#125; 退回模式消息从 exchange–&gt;queue 投递失败则会返回一个 returnCallback 。退回模式 设置ConnectionFactory的publisher-returns=”true” 开启 确认模式。 修改application.yml： 123456789spring: rabbitmq: host: 192.168.129.25 port: 5672 username: dhz password: dhz virtual-host: &#x2F;dhzVm publisher-confirms: true publisher-returns: true 设置交换机处理失败消息的模式 模式1(默认)：如果没有路由到queue，则丢弃消息。 模式2：如果消息没有路由到queue，返回给消息发送方，执行回调函数。 12&#x2F;&#x2F;必须开启才会执行回调函数，不然失败的消息就会被丢弃rabbitTemplate.setMandatory(true); rabbitTemplate.setReturnCallback设置回调函数 12345678910111213141516171819202122232425@Testpublic void returnTest()&#123; //必须开启才会执行回调函数，不然失败的消息就会被丢弃 rabbitTemplate.setMandatory(true); rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() &#123; /* 1.message:消息对象 2.replyCode：错误码 3.replyText：错误信息 4.exchange：交换机 5.routingKey：路由键 */ @Override public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) &#123; System.out.println(\"message:\"+message); System.out.println(\"replyCode:\"+replyCode); System.out.println(\"replyText:\"+replyText); System.out.println(\"exchange:\"+exchange); System.out.println(\"routingKey:\"+routingKey); &#125; &#125;); rabbitTemplate.convertAndSend(\"boot_topic_exchange\",\"11boot.test\",\"spring_boot_producer_message\");&#125; 结果 Consumer Ack(消费者)ack指Acknowledge，确认。 表示消费端收到消息后的确认方式。有三种确认方式： 自动确认：acknowledge=”none”。收到即确认 手动确认：acknowledge=”manual”。收到后进行处理，根据处理结果确认 根据异常情况确认：acknowledge=”auto”，（这种方式使用麻烦，不作讲解） springboot中默认的不是自动也不是手动，默认方式的规则为： 可以手动进行拒收和签收，如果不拒收默认就是签收。 手动确认中不拒绝则一直保持在unack的状态，不会自动签收 自动确认则不能拒绝签收 设置手动签收 springboot修改application.yml中的acknowledge-mode为manual 1234567891011121314spring: rabbitmq: host: 192.168.129.25 port: 5672 username: dhz password: dhz virtual-host: &#x2F;dhzVm publisher-confirms: true publisher-returns: true listener: direct: acknowledge-mode: manual simple: acknowledge-mode: manual spring项目修改spring-rabbitmq.xml中的 Listener-container acknowledge=”manual” 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:rabbit&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit&#x2F;spring-rabbit.xsd&quot;&gt; &lt;!--加载rabbitmq.properties配置文件--&gt; &lt;context:property-placeholder location&#x3D;&quot;classpath:rabbitmq.properties&quot;&#x2F;&gt; &lt;!--定义rabbitmq connectionFactory--&gt; &lt;rabbit:connection-factory id&#x3D;&quot;connectionFactory&quot; host&#x3D;&quot;$&#123;rabbitmq.host&#125;&quot; port&#x3D;&quot;$&#123;rabbitmq.port&#125;&quot; username&#x3D;&quot;$&#123;rabbitmq.username&#125;&quot; password&#x3D;&quot;$&#123;rabbitmq.password&#125;&quot; virtual-host&#x3D;&quot;$&#123;rabbitmq.virtual-host&#125;&quot;&#x2F;&gt; &lt;bean id&#x3D;&quot;springQueueListener&quot; class&#x3D;&quot;com.dhz.rabbitmq.listener.SpringQueueListener&quot;&#x2F;&gt; &lt;!--配置队列和Bean的映射--&gt; &lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot; acknowledge&#x3D;&quot;manual&quot;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;simple_queue&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;work_queue&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;fanout_queue1&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;fanout_queue2&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;direct_queue1&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;direct_queue2&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;topic_queue1&quot;&#x2F;&gt; &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;topic_queue2&quot;&#x2F;&gt; &lt;&#x2F;rabbit:listener-container&gt;&lt;&#x2F;beans&gt; 注入Channel，进行签收或拒收 spring boot中直接在RabbitmqListener的函数的参数中注入Channel 1234567891011121314151617181920212223242526 @Component public class RabbitmqListener &#123;@RabbitListener(queues &#x3D; &quot;boot_queue&quot;) public void listenerQueue(Message message, Channel channel) throws IOException, InterruptedException &#123; long deliveryTag &#x3D; message.getMessageProperties().getDeliveryTag(); System.out.println(message); System.out.println(&quot;拒收&quot;); Thread.sleep(2000); &#x2F;* 拒收： basicNack(long deliveryTag, boolean multiple, boolean requeue) 参数： 1.deliveryTag：收到消息的tag 2.multiple：为true则可以接收多条消息 3.requeue：是否重回队列。重回后broker重新发送消息到消费端 *&#x2F; &#x2F;&#x2F; channel.basicNack(deliveryTag,true,true); &#x2F;* 签收： basicAck(long deliveryTag, boolean multiple) *&#x2F; channel.basicAck(deliveryTag,true); &#125; &#125; spring项目继承ChannelAwareMessageListener，实现有Channel参数的方法 消费端限流比如限流3个。也就是队列的unacked的消息最多只能有3个，达到三个后不再取其他的消息 确保消费端的确认模式一定为手动确认 修改prefetch数值 springboot修改application.yml文件 1234567891011121314spring: rabbitmq: host: 192.168.248.25 port: 5672 username: dhz password: dhz virtual-host: &#x2F;dhzVm listener: direct: acknowledge-mode: manual prefetch: 3 simple: acknowledge-mode: manual prefetch: 3 spring修改spring-rabbitmq.xml 1234&lt;!--配置队列和Bean的映射--&gt;&lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot; acknowledge&#x3D;&quot;manual&quot; prefetch&#x3D;&quot;2&quot;&gt; &lt;rabbit:listener ref&#x3D;&quot;test&quot; queue-names&#x3D;&quot;simple_queue&quot;&#x2F;&gt;&lt;&#x2F;rabbit:listener-container&gt; TTL(生产者)TTL指的是消息在中间件中的存活时间，可以对单独的消息设置，也可以对整个队列设置。 队列的TTL：对整个队列而言，到时间队列的所有消息统一过期 消息的TTL：当该消息在队列头部时（消费时），会单独判断这一消息是否过期。 如果两者都进行了设置，以时间短的为准。 设置队列的TTL spring方式，在spring-rabbitmq.xml中声明队列时加上参数 123456789101112&lt;!--TTL演示--&gt;&lt;rabbit:queue name&#x3D;&quot;TTL_queue&quot;&gt; &lt;!--TTL为毫秒值，如果值为数字，声明value-type，不然默认String--&gt; &lt;rabbit:queue-arguments&gt; &lt;entry key&#x3D;&quot;x-message-ttl&quot; value&#x3D;&quot;10000&quot; value-type&#x3D;&quot;java.lang.Integer&quot;&#x2F;&gt; &lt;&#x2F;rabbit:queue-arguments&gt;&lt;&#x2F;rabbit:queue&gt;&lt;rabbit:topic-exchange name&#x3D;&quot;TTL_exchange&quot;&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding pattern&#x3D;&quot;#.ttl&quot; queue&#x3D;&quot;TTL_queue&quot;&gt;&lt;&#x2F;rabbit:binding&gt; &lt;&#x2F;rabbit:bindings&gt;&lt;&#x2F;rabbit:topic-exchange&gt; springBoot方式，在配置类中构建队列Bean时指定参数 12345678910111213&#x2F;&#x2F;TTL演示@Bean(&quot;springBootTTLQueue&quot;)public Queue springBootTTLQueue()&#123; return QueueBuilder.durable(&quot;springBootTTLQueue&quot;).withArgument(&quot;x-message-ttl&quot;,10000).build();&#125;@Bean(&quot;springBootTTLExchange&quot;)public Exchange springBootTTLExchange()&#123; return ExchangeBuilder.topicExchange(&quot;springBootTTLExchange&quot;).durable(true).build();&#125;@Beanpublic Binding bingTTL(@Qualifier(&quot;springBootTTLQueue&quot;) Queue queue,@Qualifier(&quot;springBootTTLExchange&quot;) Exchange exchange)&#123; return BindingBuilder.bind(queue).to(exchange).with(&quot;#.ttl&quot;).noargs();&#125; 设置某个消息的TTL 创建MessagePostProcessor，设置时间 1234567MessagePostProcessor messagePostProcessor &#x3D; new MessagePostProcessor() &#123; @Override public Message postProcessMessage(Message message) throws AmqpException &#123; message.getMessageProperties().setExpiration(&quot;5000&quot;); return message; &#125;&#125;; 发送消息时传入1中的MessagePostProcessor 1234567891011@Testpublic void TTL_Message_test()&#123; MessagePostProcessor messagePostProcessor &#x3D; new MessagePostProcessor() &#123; @Override public Message postProcessMessage(Message message) throws AmqpException &#123; message.getMessageProperties().setExpiration(&quot;5000&quot;); return message; &#125; &#125;; rabbitTemplate.convertAndSend(&quot;springBootTTLExchange&quot;,&quot;test.ttl&quot;,&quot;spring_boot_ttl_message&quot;,messagePostProcessor);&#125; 死信队列死信队列，英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。死信交换机本质上和普通交换机没有区别，只是功能上的不同。 消息成为死信的三个条件 队列消息长度到达限制； 消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false； 原队列存在消息过期设置，消息到达超时时间未被消费； 代码实现 创建正常队列和交换机 12345678910111213&#x2F;&#x2F;1.正常队列和交换机@Bean(&quot;dLXNormalQueue&quot;)public Queue dLXNormalQueue()&#123; return QueueBuilder.durable(&quot;dLXNormalQueue&quot;).withArgument(&quot;x-message-ttl&quot;,10000).build();&#125;@Bean(&quot;dLXNormalExchange&quot;)public Exchange dLXNormalExchange()&#123; return ExchangeBuilder.topicExchange(&quot;dLXNormalExchange&quot;).durable(true).build();&#125;@Beanpublic Binding bingDLXNomral(@Qualifier(&quot;dLXNormalQueue&quot;) Queue queue,@Qualifier(&quot;dLXNormalExchange&quot;) Exchange exchange)&#123; return BindingBuilder.bind(queue).to(exchange).with(&quot;#.dlxnormal&quot;).noargs();&#125; 死信队列和交换机 12345678910111213&#x2F;&#x2F;2.死信队列和交换机@Bean(&quot;dLXQueue&quot;)public Queue dLXQueue()&#123; return QueueBuilder.durable(&quot;dLXQueue&quot;).build();&#125;@Bean(&quot;dLXExchange&quot;)public Exchange dLXExchange()&#123; return ExchangeBuilder.topicExchange(&quot;dLXExchange&quot;).durable(true).build();&#125;@Beanpublic Binding bingDLX(@Qualifier(&quot;dLXQueue&quot;) Queue queue,@Qualifier(&quot;dLXExchange&quot;) Exchange exchange)&#123; return BindingBuilder.bind(queue).to(exchange).with(&quot;#.dlx&quot;).noargs();&#125; 配置正常队列的Argument springboot中 12345678910111213141516&#x2F;&#x2F;1.正常队列和交换机@Bean(&quot;dLXNormalQueue&quot;)public Queue dLXNormalQueue()&#123; return QueueBuilder.durable(&quot;dLXNormalQueue&quot;) .withArgument(&quot;x-message-ttl&quot;,10000) .withArgument(&quot;x-dead-letter-exchange&quot;,&quot;dLXExchange&quot;) .withArgument(&quot;x-dead-letter-routing-key&quot;,&quot;x.dlx&quot;).build();&#125;@Bean(&quot;dLXNormalExchange&quot;)public Exchange dLXNormalExchange()&#123; return ExchangeBuilder.topicExchange(&quot;dLXNormalExchange&quot;).durable(true).build();&#125;@Beanpublic Binding bingDLXNomral(@Qualifier(&quot;dLXNormalQueue&quot;) Queue queue,@Qualifier(&quot;dLXNormalExchange&quot;) Exchange exchange)&#123; return BindingBuilder.bind(queue).to(exchange).with(&quot;#.dlxnormal&quot;).noargs();&#125; spring中 12345678910111213141516171819202122&lt;!--dlx演示--&gt;&lt;!--正常队列和交换机--&gt;&lt;rabbit:queue name&#x3D;&quot;dLXNormalQueue&quot;&gt; &lt;rabbit:queue-arguments&gt; &lt;entry key&#x3D;&quot;x-message-ttl&quot; value&#x3D;&quot;10000&quot; value-type&#x3D;&quot;java.lang.Integer&quot;&#x2F;&gt; &lt;entry key&#x3D;&quot;x-dead-letter-exchange&quot; value&#x3D;&quot;dLXExchange&quot;&#x2F;&gt; &lt;entry key&#x3D;&quot;x-dead-letter-routing-key&quot; value&#x3D;&quot;x.dlx&quot;&#x2F;&gt; &lt;&#x2F;rabbit:queue-arguments&gt;&lt;&#x2F;rabbit:queue&gt;&lt;rabbit:topic-exchange name&#x3D;&quot;dLXNormalExchange&quot;&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding pattern&#x3D;&quot;#.dlxnormal&quot; queue&#x3D;&quot;dLXNormalQueue&quot;&gt;&lt;&#x2F;rabbit:binding&gt; &lt;&#x2F;rabbit:bindings&gt;&lt;&#x2F;rabbit:topic-exchange&gt; &lt;!--死信队列和交换机--&gt;&lt;rabbit:queue name&#x3D;&quot;dLXQueue&quot;&#x2F;&gt;&lt;rabbit:topic-exchange name&#x3D;&quot;dLXExchange&quot;&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding pattern&#x3D;&quot;#.dlx&quot; queue&#x3D;&quot;dLXQueue&quot;&gt;&lt;&#x2F;rabbit:binding&gt; &lt;&#x2F;rabbit:bindings&gt;&lt;&#x2F;rabbit:topic-exchange&gt; 延迟队列实现方式：TTL+死信队列 日志监控1234567891011121314151617181920212223242526查看队列# rabbitmqctl list_queues查看exchanges# rabbitmqctl list_exchanges查看用户# rabbitmqctl list_users查看连接# rabbitmqctl list_connections查看消费者信息# rabbitmqctl list_consumers查看环境变量# rabbitmqctl environment查看未被确认的队列# rabbitmqctl list_queues name messages_unacknowledged查看单个队列的内存使用# rabbitmqctl list_queues name memory查看准备就绪的队列# rabbitmqctl list_queues name messages_ready 消息追踪(在’/‘虚拟机上)消息追踪就是自己创建一些队列(或trace)，然后和amq.rabbitmq.trace内部交换机绑定监控规则，这样对其他交换机的任何操作(生产、消费消息)都会记录在这个队列中。Firehose和rabbitmq_tracing本质一样，只是rabbitmq_tracing有GUI。 Firehose 开启 123rabbitmqctl trace_on：开启Firehose命令rabbitmqctl trace_off：关闭Firehose命令 创建队列test_trace 和amq.rabbitmq.trace绑定 routingkey为’#‘表示，记录所有的操作信息 rabbitmq_tracingrabbitmq_tracing和Firehose在实现上如出一辙，只不过rabbitmq_tracing的方式比Firehose多了一层GUI的包装，更容易使用和管理。 启用插件 1rabbitmq-plugins enable rabbitmq_tracing web界面会多出一个tracing 新增trace pattern处为记录的规则 format可以选择text或json，text便于人阅读，json便于代码解析 会自动创建一个队列，并且自动绑定amq.rabbitmq.trace 对其他队列做任何操作都可以被记录下来 消息可靠性保障消息补偿确保消息100%正常发送和消费 幂等性保障–乐观锁机制消费多条相同的消息，得到与消费该消息一次相同的结果。 集群搭建 单机多实例主要参考官方文档：https://www.rabbitmq.com/clustering.html 准备工作：rabbitmq可以正常工作 停止rabbitmq 1service rabbitmq-server stop 启动第一个节点 端口不能为5672 1RABBITMQ_NODE_PORT&#x3D;5673 RABBITMQ_NODENAME&#x3D;rabbit1 rabbitmq-server start 启动第二个节点 web管理插件端口占用,所以还要指定其web插件占用的端口号。 1RABBITMQ_NODE_PORT&#x3D;5674 RABBITMQ_SERVER_START_ARGS&#x3D;&quot;-rabbitmq_management listener [&#123;port,15674&#125;]&quot; RABBITMQ_NODENAME&#x3D;rabbit2 rabbitmq-server start 设置rabbit1为主节点 123rabbitmqctl -n rabbit1 stop_app rabbitmqctl -n rabbit1 reset rabbitmqctl -n rabbit1 start_app rabbit2操作为从节点 1234rabbitmqctl -n rabbit2 stop_apprabbitmqctl -n rabbit2 resetrabbitmqctl -n rabbit2 join_cluster rabbit1@&#39;主机名&#39; rabbitmqctl -n rabbit2 start_app 结果 存在的问题： 数据不同步，rabbit1宕机，1中数据会丢失 镜像集群设置的镜像队列可以通过开启的网页的管理端Admin-&gt;Policies，也可以通过命令。 rabbitmqctl set_policy my_ha “^” ‘{“ha-mode”:”all”}’ Name:策略名称 Pattern：匹配的规则，如果是匹配所有的队列，是^. Definition:使用ha-mode模式中的all，也就是同步所有匹配的队列。问号链接帮助文档。 负载均衡-HAProxyHAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案,包括Twitter，Reddit，StackOverflow，GitHub在内的多家知名互联网公司在使用。HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数。 安装HAProxy 123456789101112131415&#x2F;&#x2F;下载依赖包yum install gcc vim wget&#x2F;&#x2F;上传haproxy源码包&#x2F;&#x2F;解压tar -zxvf haproxy-1.6.5.tar.gz -C &#x2F;usr&#x2F;local&#x2F;&#x2F;进入目录、进行编译、安装cd &#x2F;usr&#x2F;local&#x2F;haproxy-1.6.5make TARGET&#x3D;linux31 PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;haproxymake install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;haproxy&#x2F;&#x2F;赋权groupadd -r -g 149 haproxyuseradd -g haproxy -r -s &#x2F;sbin&#x2F;nologin -u 149 haproxy&#x2F;&#x2F;创建haproxy配置文件mkdir &#x2F;etc&#x2F;haproxyvim &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg 配置HAProxy 配置文件路径：/etc/haproxy/haproxy.cfg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#logging optionsglobal log 127.0.0.1 local0 info maxconn 5120 chroot &#x2F;usr&#x2F;local&#x2F;haproxy uid 99 gid 99 daemon quiet nbproc 20 pidfile &#x2F;var&#x2F;run&#x2F;haproxy.piddefaults log global mode tcp option tcplog option dontlognull retries 3 option redispatch maxconn 2000 contimeout 5s clitimeout 60s srvtimeout 15s #front-end IP for consumers and producterslisten rabbitmq_cluster #HAProxy监听的端口，以后也通过此端口代码连接a bind 0.0.0.0:5672 mode tcp #balance url_param userid #balance url_param session_id check_post 64 #balance hdr(User-Agent) #balance hdr(host) #balance hdr(Host) use_domain_only #balance rdp-cookie #balance leastconn #balance source &#x2F;&#x2F;ip balance roundrobin # 节点的ip和端口,重试两次，失败两次a server node1 127.0.0.1:5673 check inter 5000 rise 2 fall 2 server node2 127.0.0.1:5674 check inter 5000 rise 2 fall 2listen stats # HAProxy管理控制台的ip(安装所在服务器的ip)和端口a bind 192.168.197.25:8100 mode http option httplog stats enable stats uri &#x2F;rabbitmq-stats stats refresh 5s 启动HAproxy负载 123456&#x2F;usr&#x2F;local&#x2F;haproxy&#x2F;sbin&#x2F;haproxy -f &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg&#x2F;&#x2F;查看haproxy进程状态ps -ef | grep haproxy访问如下地址对mq节点进行监控http:&#x2F;&#x2F;192.168.197.25:8100&#x2F;rabbitmq-stats 代码中访问mq集群地址，则变为访问haproxy地址:5672 代码测试 1234567891011121314151617181920212223242526public class Producer_HAproxy &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; &#x2F;&#x2F;1.创建连接工厂 ConnectionFactory connectionFactory &#x3D; new ConnectionFactory(); &#x2F;&#x2F;2.设置连接参数 connectionFactory.setHost(&quot;192.168.197.25&quot;);&#x2F;&#x2F; HAproxy的ip connectionFactory.setPort(5672);&#x2F;&#x2F; HAproxy的端口 &#x2F;&#x2F;3.创建连接Connection Connection connection &#x3D; connectionFactory.newConnection(); &#x2F;&#x2F;4.创建channel Channel channel &#x3D; connection.createChannel(); &#x2F;&#x2F;5.创建队列Queue channel.queueDeclare(&quot;hello_worlld&quot;,true,false,false,null); &#x2F;&#x2F;6.发送消息 channel.basicPublish(&quot;&quot;,&quot;hello_worlld&quot;,null,&quot;hello rabbitmq HAproxy test....&quot;.getBytes()); &#x2F;&#x2F;7.释放资源 channel.close(); connection.close(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"RabbitMQ","slug":"java/RabbitMQ","permalink":"https://donghuangzhong.github.io/categories/java/RabbitMQ/"}],"tags":[{"name":"消息队列","slug":"消息队列","permalink":"https://donghuangzhong.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}]},{"title":"blog_problem","slug":"blog-problem","date":"2021-06-06T02:30:41.000Z","updated":"2021-06-06T02:49:38.556Z","comments":true,"path":"2021/06/06/blog-problem/","link":"","permalink":"https://donghuangzhong.github.io/2021/06/06/blog-problem/","excerpt":"记录使用博客时常见的问题","text":"记录使用博客时常见的问题 访问不了github.com需要手动解析dns 访问https://github.com.ipaddress.com/www.github.com查看github.com对应的ip地址 修改 C:\\Windows\\System32\\drivers\\etc\\HOSTS文件，末尾追加 1140.82.112.3 github.com 前面的ip是查到的ip cmd中执行ipconfig/flushdns刷新DNS OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 原因：是Git的Http代理的问题，Git支持三种协议：git://、ssh:// 和 http://，本来push的时候应该走ssh隧道的，但是因为设置了http代理，所以就走了http的代理，于是就提交不了了。 解决方法：在gitbash中执行以下命令 1git config --global --unset http.proxy","categories":[{"name":"blog","slug":"blog","permalink":"https://donghuangzhong.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/tags/hexo/"}]},{"title":"前端problem","slug":"前端problem","date":"2021-06-04T01:25:58.000Z","updated":"2021-06-04T01:37:48.295Z","comments":true,"path":"2021/06/04/前端problem/","link":"","permalink":"https://donghuangzhong.github.io/2021/06/04/%E5%89%8D%E7%AB%AFproblem/","excerpt":"摘要","text":"摘要 idea新建vue module file-&gt;setting-&gt;plugins中安装vuejs，重启idea 新建module，选择JavaScript-&gt;vuejs","categories":[{"name":"前端","slug":"前端","permalink":"https://donghuangzhong.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"Vue","slug":"Vue","date":"2021-06-04T01:13:45.000Z","updated":"2021-06-06T01:28:34.439Z","comments":true,"path":"2021/06/04/Vue/","link":"","permalink":"https://donghuangzhong.github.io/2021/06/04/Vue/","excerpt":"摘要","text":"摘要 Vue概述Vue是MVVM模式，MVVM通过视图与模型的双向绑定，简化前端操作。Vue是一款前端渐进式框架，可以提高前端开发效率。 搭建示例工程vue是一个前端框架，也是其实是一个js文件；下载vue.js文件并在页面中引入该js文件。 vue.js的下载方式： 可以引用在线的vue.js； 12&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; 12&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt; 可以离线下载vue.js； 下载地址：https://github.com/vuejs/vue npm包资源管理器，可以下载vue.js 在idea中新建vuejs module(需要先安装vuejs的插件) 注：会默认集成node，如果没有没有node，需要执行 12#初始化npm init -y 下载vue，在terminal中 12#下载vue模块npm install vue --save 演示双向绑定与事件处理 创建页面，初始化vue； 获取显示数据； v-model实现双向绑定； v-on演示事件处理 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--此div类似view--&gt;&lt;div id=\"app\"&gt; num:&lt;input type=\"text\" v-model=\"num\"&gt;&lt;br&gt; &lt;button v-on:click=\"num++\"&gt;num++&lt;/button&gt;&lt;br&gt; &lt;h2&gt;name是&#123;&#123;name&#125;&#125;;num是&#123;&#123;num&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //Vue示例就是model var app = new Vue(&#123; el:\"#app\", data:&#123; name:\"张三\", num: 1 &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; div：view视图 New Vue()：model模型 Vue实例生命周期及钩子函数在创建vue实例的时候可以指定模板id、数据和方法；而如果要在实例化、模板渲染的过程中需要执行一些其它操作的话；那么可以使用钩子函数。 钩子函数会在vue实例的各个生命周期阶段自动调用；具体有：beforeCreate，created,beforeMount,mounted,updated,beforeUpdate，destroyed，beforeDestroy created钩子函数常用场景：用于初始化数据，ajax等 钩子函数不要使用箭头函数的方式编写。因为其中的this不是Vue实例 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--此div类似view--&gt;&lt;div id=\"app\"&gt; &#123;&#123;num&#125;&#125;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //创建Vue实例 var app=new Vue(&#123; el:\"#app\", data:&#123; num:\"0\" &#125;, created() &#123; this.num=\"1\"; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 插值、v-text和v-html插值可以使用在有需要显示vue实例数据的地方，可以在插值表达式中调用实例的数据属性和函数。 花括号 格式 1&#123;&#123;表达式&#125;&#125; &#x2F;&#x2F;默认是v-text不进行html的渲染 说明 123该表达式支持JS语法，可以调用js内置函数（必须有返回值）表达式必须有返回结果。例如 1 + 1，没有结果的表达式不允许使用，如：var a &#x3D; 1 + 1;可以直接获取Vue实例中定义的数据或函数 v-text和v-html 使用v-text和v-html指令来替代 双花括号 v-text：将数据输出到元素内部，双如果输出的数据有HTML代码，会作为普通文本输出 v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--此div类似view--&gt;&lt;div id=\"app\"&gt; 花括号插值：&#123;&#123;str&#125;&#125;&lt;br&gt; v-text插值：&lt;span v-text=\"str\"&gt;&lt;/span&gt;&lt;br&gt; v-html插值：&lt;span v-html=\"str\"&gt;&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //创建Vue实例 var app=new Vue(&#123; el:\"#app\", data:&#123; str:\"&lt;h2&gt;这是测试的字符串&lt;/h2&gt;\" &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 指令-v-model使用v-model实现了view和model双向数据绑定，既然是双向绑定，一定是在视图中可以修改数据，这样就限定了视图的元素类型。目前v-model的可使用元素有： input select textarea checkbox radio components（Vue中的自定义组件） 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!------------------------------------------------&gt;&lt;!--此div类似view--&gt;&lt;div id=\"app\"&gt; 多个复选框测试&lt;br&gt; &lt;input type=\"checkbox\" value=\"java\" v-model=\"lang\"&gt;java&lt;br&gt; &lt;input type=\"checkbox\" value=\"python\" v-model=\"lang\"&gt;python&lt;br&gt; &lt;input type=\"checkbox\" value=\"c\" v-model=\"lang\"&gt;c&lt;br&gt; 您选择的复选框是:&#123;&#123;lang.join(\",\")&#125;&#125;&lt;hr&gt; 单个复选框测试&lt;br&gt; &lt;input type=\"checkbox\" v-model=\"singleChcekBox\"&gt;True?&lt;br&gt; singleChcekBox:&#123;&#123;singleChcekBox&#125;&#125;&lt;hr&gt; radio单元框测试&lt;br&gt; &lt;input type=\"radio\" value=\"男\" v-model=\"sex\"&gt;男&lt;br&gt; &lt;input type=\"radio\" value=\"女\" v-model=\"sex\"&gt;女&lt;br&gt; 您的选择是:&#123;&#123;sex&#125;&#125;&lt;hr&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //创建Vue实例 var app=new Vue(&#123; el:\"#app\", data:&#123; lang:[], singleChcekBox:\"\", sex:\"\" &#125; &#125;);&lt;/script&gt;&lt;!------------------------------------------------&gt;&lt;/body&gt;&lt;/html&gt; 多个 checkbox 对应一个model时，model的类型是一个数组，单个checkbox值是boolean类型 radio对应的值是input的value值 input 和 textarea 默认对应的model是字符串 select 单选对应字符串，多选对应也是数组 指令-v-on使用v-on指令用于给页面元素绑定事件。 语法 12@事件名&#x3D;&quot;js片段或函数名&quot;v-on:事件名&#x3D;&quot;js片段或函数名&quot; &#x2F;&#x2F;不常用 事件修饰符 1v-on:xxxx.修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们 可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop ：阻止事件冒泡 .prevent ：阻止默认事件发生 .capture ：使用事件捕获模式 .self ：只有元素自身触发事件才执行。（冒泡或捕获的都不执行） .once ：只执行一次 案例 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!------------------------------------------------&gt;&lt;!--此div类似view--&gt;&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;button&quot; @click&#x3D;&quot;increse&quot; value&#x3D;&quot;num++&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; v-on:click&#x3D;&quot;num--&quot; value&#x3D;&quot;num--&quot;&#x2F;&gt;&lt;br&gt; num:&#123;&#123;num&#125;&#125;&lt;hr&gt; &lt;div @click&#x3D;&quot;dayin(&#39;点击div&#39;)&quot;&gt; &lt;input type&#x3D;&quot;button&quot; @click&#x3D;&quot;dayin(&#39;点击button&#39;)&quot; value&#x3D;&quot;有冒泡&quot;&gt; &lt;input type&#x3D;&quot;button&quot; @click.stop&#x3D;&quot;dayin(&#39;点击button&#39;)&quot; value&#x3D;&quot;阻止冒泡&quot;&gt; &lt;&#x2F;div&gt;&lt;hr&gt; &lt;a href&#x3D;&quot;https:www.baidu.com&quot;&gt;百度(未阻止默认事件)&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;https:www.baidu.com&quot; @click.prevent&#x3D;&quot;&quot;&gt;百度(阻止默认事件)&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; &#x2F;&#x2F;创建Vue实例 var app&#x3D;new Vue(&#123; el:&quot;#app&quot;, data:&#123; num:1 &#125;, methods:&#123; increse()&#123;this.num++;&#125;, dayin:function (str) &#123;console.log(str);&#125; &#125; &#125;);&lt;&#x2F;script&gt;&lt;!------------------------------------------------&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 指令v-for使用 遍历数组 可以在vue实例化的时候指定要遍历的数据，然后通过v-for指令在模板中遍历显示数据。一般情况下，要遍历的数据可以通过钩子函数created发送异步请求获取数据。 123&lt;li v-for&#x3D;&quot;(user,index) in users&quot;&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.sex&#125;&#125; &lt;&#x2F;li&gt; users：要遍历的数组，需要在vue的data中定义好。 user：循环变量 index：循环索引 注： (user,index)顺序固定，不能交换 遍历对象属性 123v-for&#x3D;&quot;value in object&quot;v-for&#x3D;&quot;(value,key) in object&quot;v-for&#x3D;&quot;(value,key,index) in object&quot; 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!------------------------------------------------&gt;&lt;!--此div类似view--&gt;&lt;div id&#x3D;&quot;app&quot;&gt; 遍历数组示例 &lt;ul&gt; &lt;li v-for&#x3D;&quot;(user,index) in users&quot;&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.sex&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;hr&gt; 遍历对象示例 &lt;ul&gt; &lt;li v-for&#x3D;&quot;(value,key,index) in student&quot;&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; &#x2F;&#x2F;创建Vue实例 var app&#x3D;new Vue(&#123; el:&quot;#app&quot;, data:&#123; users:[ &#123;name:&quot;张三&quot;,age:14,sex:&quot;男&quot;&#125;, &#123;name:&quot;李四&quot;,age:24,sex:&quot;女&quot;&#125;, &#123;name:&quot;王五&quot;,age:34,sex:&quot;未知&quot;&#125; ], student:&#123;studentId:&quot;1001&quot;,name:&quot;李华&quot;,birthday:&quot;1999-03-05&quot;,sex:&quot;男&quot;&#125; &#125; &#125;);&lt;&#x2F;script&gt;&lt;!------------------------------------------------&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 指令-v-if和v-show使用 语法 1234v-show&#x3D;&quot;布尔表达式&quot;v-if&#x3D;&quot;布尔表达式&quot;v-else-if&#x3D;&#x3D;&quot;布尔表达式&quot;v-else&#x3D;&quot;布尔表达式&quot; v-if系列不满足则消失，不会在f12中出现 v-show不满足则会隐藏，在f12中可以看到只是将style设置成 v-if和v-show都可以结合v-for使用，v-for优先级更高 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!------------------------------------------------&gt;&lt;!--此div类似view--&gt;&lt;div id&#x3D;&quot;app&quot;&gt; v-if示例 &lt;ul&gt; &lt;li v-for&#x3D;&quot;(user,index) in users&quot;&gt; &lt;span v-if&#x3D;&quot;user.sex&#x3D;&#x3D;&#39;男&#39;&quot; style&#x3D;&quot;background-color: #42b983&quot;&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.sex&#125;&#125; &lt;&#x2F;span&gt; &lt;span v-else-if&#x3D;&quot;user.sex&#x3D;&#x3D;&#39;女&#39;&quot; style&#x3D;&quot;background-color: #6bdb19&quot;&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.sex&#125;&#125; &lt;&#x2F;span&gt; &lt;span v-else style&#x3D;&quot;background-color: #5628c1&quot;&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.sex&#125;&#125; &lt;&#x2F;span&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;hr&gt; v-show示例 &lt;ul&gt; &lt;li v-for&#x3D;&quot;(user,index) in users&quot; v-show&#x3D;&quot;user.sex&#x3D;&#x3D;&#39;男&#39;&quot;&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.sex&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; &#x2F;&#x2F;创建Vue实例 var app&#x3D;new Vue(&#123; el:&quot;#app&quot;, data:&#123; users:[ &#123;name:&quot;张三&quot;,age:14,sex:&quot;男&quot;&#125;, &#123;name:&quot;李四&quot;,age:24,sex:&quot;女&quot;&#125;, &#123;name:&quot;王五&quot;,age:34,sex:&quot;未知&quot;&#125; ] &#125; &#125;);&lt;&#x2F;script&gt;&lt;!------------------------------------------------&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 指令-v-bind使用 可以对所有元素的属性设置vue实例的数据。简写为冒号写法，如下 1&lt;img v-bind:src&#x3D;&quot;vue实例中的数据属性名&quot; :height&#x3D;&quot;vue实例中的数据属性名&quot;&#x2F;&gt; class属性可以进行bool值的映射 redOrBule为bool值 1&lt;div :class&#x3D;&quot;&#123;red:redOrBule,blue:!redOrBule&#125;&quot;&gt;&lt;&#x2F;div&gt; 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; div&#123; width: 100px; height: 100px; color: white; &#125; .red&#123; background-color: red; &#125; .blue&#123; background-color: blue; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!------------------------------------------------&gt;&lt;!--此div类似view--&gt;&lt;div id&#x3D;&quot;app&quot;&gt; v-bind示例 &lt;button @click&#x3D;&quot;color&#x3D;&#39;red&#39;&quot;&gt;红色&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;color&#x3D;&#39;blue&#39;&quot;&gt;蓝色&lt;&#x2F;button&gt; &lt;div v-bind:class&#x3D;&quot;color&quot;&gt;&lt;&#x2F;div&gt; &lt;hr&gt; class特殊用法示例 &lt;button @click&#x3D;&quot;redOrBule&#x3D;!redOrBule&quot;&gt;点击切换红蓝颜色&lt;&#x2F;button&gt; &lt;div :class&#x3D;&quot;&#123;red:redOrBule,blue:!redOrBule&#125;&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; &#x2F;&#x2F;创建Vue实例 var app&#x3D;new Vue(&#123; el:&quot;#app&quot;, data:&#123; redOrBule:true, color:&quot;red&quot; &#125; &#125;);&lt;&#x2F;script&gt;&lt;!------------------------------------------------&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 计算属性的使用就是用computed下的函数名(没有括号)代替变量，在这个函数中可以对变量展示的样式进行处理，例如将毫秒值转换为年月日的时间。用methods下的函数也可以完成，只不过要带着括号(就是函数的调用)。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!------------------------------------------------&gt;&lt;!--此div类似view--&gt;&lt;div id=\"app\"&gt; computed:&#123;&#123;birth&#125;&#125;&lt;br&gt; methods:&#123;&#123;getBirth()&#125;&#125;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //创建Vue实例 var app=new Vue(&#123; el:\"#app\", data:&#123; birthday:1429032123201 &#125;, computed:&#123; birth()&#123; var date=new Date(this.birthday); return date.getFullYear()+\"-\"+date.getMonth()+\"-\"+date.getDay(); &#125; &#125;, methods:&#123; getBirth()&#123; var date=new Date(this.birthday); return date.getFullYear()+\"-\"+date.getMonth()+\"-\"+date.getDay(); &#125; &#125; &#125;);&lt;/script&gt;&lt;!------------------------------------------------&gt;&lt;/body&gt;&lt;/html&gt; watch基本和深度监控 watch监控：监听简单的属性值(例如title)，能够获取前后的变化。 深度监控：监听对象的属性(例如person.name)，不能获取旧值，只能获取新的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!------------------------------------------------&gt;&lt;!--此div类似view--&gt;&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"title\"&gt;&lt;br&gt; &lt;input type=\"text\" v-model=\"person.name\"&gt;&lt;br&gt; &#123;&#123;person.age&#125;&#125;&lt;button @click=\"person.age++\"&gt;+&lt;/button&gt;&lt;button @click=\"person.age--\"&gt;+&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //创建Vue实例 var app=new Vue(&#123; el:\"#app\", data:&#123; title:\"这是标题的示例\", person:&#123; name:\"张三\", age:12 &#125; &#125;, watch:&#123; //必须和属性名一样 title(newValue,oldValue)&#123; console.log(\"旧值:\"+oldValue+\"==&gt;新值:\"+newValue); &#125;, person: &#123; //开启深度监控；监控对象中的属性值变化 deep:true, //可以获取到最新的对象属性数据 handler(newObj)&#123; console.log(\"新名字:\"+newObj.name+\";新年龄:\"+newObj.age); &#125; &#125; &#125; &#125;);&lt;/script&gt;&lt;!------------------------------------------------&gt;&lt;/body&gt;&lt;/html&gt; 组件使用组件使用场景：在项目需要重用某个模块（头部、尾部、新闻。。。）的时候，可以将模块抽取成组件，其它页面中注册组件并引用。 全局注册：在任何vue实例中都可以引用，如：一般网站的头部导航菜单 局部注册：可以在有需要的页面引入组件，如：商城网站首页页面中各种活动模块 组件其实也是一个Vue实例，因此它在定义时也会接收：data、methods、生命周期函数等 data的定义方式比较特殊，必须是一个函数。 template中不能直接插值，需要用元素(div或者span作为根，必须有根元素)包裹起来，推荐用飘号”`”来包裹html代码段 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!------------------------------------------------&gt;&lt;!--此div类似view--&gt;&lt;div id=\"app\"&gt; &lt;counter_global&gt;&lt;/counter_global&gt; &lt;counter_local&gt;&lt;/counter_local&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //创建组件 const counter=&#123; template:\"&lt;button @click='num++'&gt;你共点击了&#123;&#123;num&#125;&#125;次&lt;/button&gt;\", data()&#123; return &#123;num:0&#125;; &#125; &#125;; //全局注册组件 Vue.component(\"counter_global\", counter); //创建Vue实例 var app=new Vue(&#123; el:\"#app\", //局部注册组件 components:&#123; counter_local:counter &#125; &#125;);&lt;/script&gt;&lt;!------------------------------------------------&gt;&lt;/body&gt;&lt;/html&gt; 父组件向子组件通信就是父组件将数据传递到子组件 传递普通属性 用props:[“title”]来引入传递的属性 12345678910111213141516171819&lt;div id&#x3D;&quot;app&quot;&gt; &lt;comp_simple :title&#x3D;&quot;fuTitle&quot;&gt;&lt;&#x2F;comp_simple&gt;&lt;hr&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; const comp_simple&#x3D;&#123; template:&quot;&lt;span&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;span&gt;&quot;, props:[&quot;title&quot;] &#125;; Vue.component(&quot;comp_simple&quot;, comp_simple); var app&#x3D;new Vue(&#123; el:&quot;#app&quot;, data:&#123; fuTitle:&quot;这是父的title&quot;, &#125; &#125;);&lt;&#x2F;script&gt; 传递数组属性 在props中配置传入数组的默认值 12345678910111213141516171819202122232425262728&lt;div id&#x3D;&quot;app&quot;&gt; &lt;comp_array :items&#x3D;&quot;persons&quot;&gt;&lt;&#x2F;comp_array&gt;&lt;hr&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; const comp_array&#x3D;&#123; template:&#39;&lt;ul&gt;&lt;li v-for&#x3D;&quot;item in items&quot;&gt;&#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&#39;, props:&#123; items:&#123; type:Array, default:[] &#125; &#125; &#125;; Vue.component(&quot;comp_array&quot;, comp_array); var app&#x3D;new Vue(&#123; el:&quot;#app&quot;, data:&#123; persons:[ &#123;name:&quot;张三&quot;,age:&quot;12&quot;&#125;, &#123;name:&quot;李四&quot;,age:&quot;22&quot;&#125;, &#123;name:&quot;王五&quot;,age:&quot;33&quot;&#125; ] &#125; &#125;);&lt;&#x2F;script&gt; 传递对象 在props中配置传入对象的默认值，使用函数返回值方式 1234567891011121314151617181920212223242526&lt;div id&#x3D;&quot;app&quot;&gt; &lt;comp_array :items&#x3D;&quot;persons&quot;&gt;&lt;&#x2F;comp_array&gt;&lt;hr&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; const comp_obj&#x3D;&#123; template:&quot;&lt;span&gt;&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.password&#125;&#125;&lt;&#x2F;span&gt;&quot;, props:&#123; user:&#123; type: Object, default()&#123; return &#123;name:&quot;qwer&quot;,password: &quot;asdf&quot;&#125; &#125; &#125; &#125; &#125;; Vue.component(&quot;comp_obj&quot;, comp_obj); var app&#x3D;new Vue(&#123; el:&quot;#app&quot;, data:&#123; user:&#123;name:&quot;admin&quot;,password:&quot;123456&quot;&#125; &#125; &#125;);&lt;&#x2F;script&gt; 汇总 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!------------------------------------------------&gt;&lt;!--此div类似view--&gt;&lt;div id&#x3D;&quot;app&quot;&gt; 简单的属性传递(父-》子): &lt;comp_simple :title&#x3D;&quot;fuTitle&quot;&gt;&lt;&#x2F;comp_simple&gt;&lt;hr&gt; 数组的传递： &lt;comp_array :items&#x3D;&quot;persons&quot;&gt;&lt;&#x2F;comp_array&gt;&lt;hr&gt; 对象的传递： &lt;comp_obj :user&#x3D;&quot;user&quot;&gt;&lt;&#x2F;comp_obj&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; &#x2F;&#x2F;传递普通属性的组件 const comp_simple&#x3D;&#123; template:&quot;&lt;span&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;span&gt;&quot;, props:[&quot;title&quot;] &#125;; &#x2F;&#x2F;传递数组的组件 const comp_array&#x3D;&#123; template:&#39;&lt;ul&gt;&lt;li v-for&#x3D;&quot;item in items&quot;&gt;&#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&#39;, props:&#123; items:&#123; type:Array, default:[] &#125; &#125; &#125;; &#x2F;&#x2F;传递对象的组件 const comp_obj&#x3D;&#123; template:&quot;&lt;span&gt;&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.password&#125;&#125;&lt;&#x2F;span&gt;&quot;, props:&#123; user:&#123; type: Object, default()&#123; return &#123;name:&quot;qwer&quot;,password: &quot;asdf&quot;&#125; &#125; &#125; &#125; &#125;; &#x2F;&#x2F;全局注册组件 Vue.component(&quot;comp_simple&quot;, comp_simple); Vue.component(&quot;comp_array&quot;, comp_array); Vue.component(&quot;comp_obj&quot;, comp_obj); &#x2F;&#x2F;创建Vue实例 var app&#x3D;new Vue(&#123; el:&quot;#app&quot;, data:&#123; fuTitle:&quot;这是父的title&quot;, persons:[ &#123;name:&quot;张三&quot;,age:&quot;12&quot;&#125;, &#123;name:&quot;李四&quot;,age:&quot;22&quot;&#125;, &#123;name:&quot;王五&quot;,age:&quot;33&quot;&#125; ], user:&#123;name:&quot;admin&quot;,password:&quot;123456&quot;&#125; &#125; &#125;);&lt;&#x2F;script&gt;&lt;!------------------------------------------------&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 子组件向父组件通信不能通过直接修改传到子组件中的值的做法，正确做法为在父组件中定义修改的方法，传递到子组件中，在子组件中定义方法嵌入this.$emit(&quot;xxx&quot;);来实现 this是子类对象 xxx为父组件中的方法传到子组件中的名称 this.$emit(“xxx”，参数)，此方法可以添加参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!------------------------------------------------&gt;&lt;!--此div类似view--&gt;&lt;div id=\"app\"&gt; 父组件中的num:&#123;&#123;num&#125;&#125;&lt;hr&gt; &lt;comp @plus=\"jia\" @reduce=\"jian\" :num_zi=\"num\"&gt;&lt;/comp&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; const comp=&#123; template:` &lt;div&gt; 子组件中的num_zi:&#123;&#123;num_zi&#125;&#125;&lt;br&gt; &lt;button @click=\"numPlus\"&gt;+&lt;/button&gt; &lt;button @click=\"numReduce\"&gt;-&lt;/button&gt; &lt;/div&gt; `, props:[\"num_zi\"], methods: &#123; numPlus()&#123; return this.$emit('plus'); &#125;, numReduce()&#123; return this.$emit('reduce'); &#125; &#125; &#125;; //全局注册组件 Vue.component(\"comp\", comp); //创建Vue实例 var app=new Vue(&#123; el:\"#app\", data:&#123; num:1 &#125;, methods:&#123; jia()&#123; this.num++; &#125;, jian()&#123; this.num--; &#125; &#125; &#125;);&lt;/script&gt;&lt;!------------------------------------------------&gt;&lt;/body&gt;&lt;/html&gt; axiosVuejs 并没有直接处理ajax的组件，但可以使用axios或vue-resource组件实现对异步请求的操作。 vue-resource是Vue.js的插件提供了使用XMLHttpRequest或JSONP进行Web请求和处理响应的服务。 当vue更新到2.0之后，作者就宣告不再对vue-resource更新，而是推荐axios。 vue-resource的github地址： https://github.com/pagekit/vue-resource Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。axios的github地址：https://github.com/axios/axios axios的作用：发送异步请求获取数据。常见的方法：get、post；在发送的时候可以指定参数（地址、请求方式和请求头部信息）；返回数据结构（data/status/statusText/headers/config） axios的引入Axios 就是一个js文件，类似于Vue.js 使用npm 12# 如果使用npm则可以如下安装npm install axios 使用公共CDN(内容分发网络) 12&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt; 引入本地的js文件 axios的详解axios可以使用的方法有： 1234567axios(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) config请求配置 这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method ，请求将默认使用 get 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&#123; &#x2F;&#x2F; url 是用于请求的服务器 URL url: &quot;&#x2F;user&quot;, &#x2F;&#x2F; method 是创建请求时使用的方法 method: &quot;get&quot;, &#x2F;&#x2F; 默认是 get &#x2F;&#x2F; baseURL 将自动加在 url 前面，除非 url 是一个绝对 URL。 &#x2F;&#x2F; 它可以通过设置一个 baseURL 便于为 axios 实例的方法传递相对 URL baseURL: &quot;https:&#x2F;&#x2F;some-domain.com&#x2F;api&#x2F;&quot;, &#x2F;&#x2F; transformRequest 允许在向服务器发送前，修改请求数据 &#x2F;&#x2F; 只能用在 &quot;PUT&quot;, &quot;POST&quot; 和 &quot;PATCH&quot; 这几个请求方法 &#x2F;&#x2F; 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) &#123; &#x2F;&#x2F; 对 data 进行任意转换处理 return data; &#125;], &#x2F;&#x2F; transformResponse 在传递给 then&#x2F;catch 前，允许修改响应数据 transformResponse: [function (data) &#123; &#x2F;&#x2F; 对 data 进行任意转换处理 return data; &#125;], &#x2F;&#x2F; headers 是即将被发送的自定义请求头 headers: &#123;&quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;&#125;, &#x2F;&#x2F; params 是即将与请求一起发送的 URL 参数 &#x2F;&#x2F; 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, &#x2F;&#x2F; paramsSerializer 是一个负责 params 序列化的函数 &#x2F;&#x2F; (e.g. https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;qs, http:&#x2F;&#x2F;api.jquery.com&#x2F;jquery.param&#x2F;) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &quot;brackets&quot;&#125;) &#125;, &#x2F;&#x2F; data 是作为请求主体被发送的数据 &#x2F;&#x2F; 只适用于这些请求方法 &quot;PUT&quot;, &quot;POST&quot;, 和 &quot;PATCH&quot; &#x2F;&#x2F; 在没有设置 transformRequest 时，必须是以下类型之一： &#x2F;&#x2F; - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams &#x2F;&#x2F; - 浏览器专属：FormData, File, Blob &#x2F;&#x2F; - Node 专属： Stream data: &#123; firstName: &quot;Fred&quot; &#125;, &#x2F;&#x2F; timeout 指定请求超时的毫秒数(0 表示无超时时间) &#x2F;&#x2F; 如果请求话费了超过 timeout 的时间，请求将被中断 timeout: 1000, &#x2F;&#x2F; withCredentials 表示跨域请求时是否需要使用凭证 withCredentials: false, &#x2F;&#x2F; 默认的 &#x2F;&#x2F; adapter 允许自定义处理请求，以使测试更轻松 &#x2F;&#x2F; 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; &#x2F;* ... *&#x2F; &#125;, &#x2F;&#x2F; auth 表示应该使用 HTTP 基础验证，并提供凭据 &#x2F;&#x2F; 这将设置一个 Authorization 头，覆写掉现有的任意使用 headers 设置的自定义 Authorization头 auth: &#123; username: &quot;janedoe&quot;, password: &quot;s00pers3cret&quot; &#125;, &#x2F;&#x2F; responseType 表示服务器响应的数据类型，可以是 &quot;arraybuffer&quot;, &quot;blob&quot;, &quot;document&quot;, &quot;json&quot;, &quot;text&quot;, &quot;stream&quot; responseType: &quot;json&quot;, &#x2F;&#x2F; 默认的 &#x2F;&#x2F; xsrfCookieName 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: &quot;XSRF-TOKEN&quot;, &#x2F;&#x2F; default &#x2F;&#x2F; xsrfHeaderName 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: &quot;X-XSRF-TOKEN&quot;, &#x2F;&#x2F; 默认的 &#x2F;&#x2F; onUploadProgress 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; &#x2F;&#x2F; 对原生进度事件的处理 &#125;, &#x2F;&#x2F; onDownloadProgress 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; &#x2F;&#x2F; 对原生进度事件的处理 &#125;, &#x2F;&#x2F; maxContentLength 定义允许的响应内容的最大尺寸 maxContentLength: 2000, &#x2F;&#x2F; validateStatus 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 validateStatus 返回 true (或者设置为 null 或 undefined)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;&#x3D; 200 &amp;&amp; status &lt; 300; &#x2F;&#x2F; 默认的 &#125;, &#x2F;&#x2F; maxRedirects 定义在 node.js 中 follow 的最大重定向数目 &#x2F;&#x2F; 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, &#x2F;&#x2F; 默认的 &#x2F;&#x2F; httpAgent 和 httpsAgent 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： &#x2F;&#x2F; keepAlive 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), &#x2F;&#x2F; &quot;proxy&quot; 定义代理服务器的主机名称和端口 &#x2F;&#x2F; auth 表示 HTTP 基础验证应当用于连接代理，并提供凭据 &#x2F;&#x2F; 这将会设置一个 Proxy-Authorization 头，覆写掉已有的通过使用 header 设置的自定义 Proxy-Authorization 头。 proxy: &#123; host: &quot;127.0.0.1&quot;, port: 9000, auth: &#123;username: &quot;mikeymike&quot;, password: &quot;rapunz3l&quot;&#125; &#125;, &#x2F;&#x2F; cancelToken 指定用于取消请求的 cancel token &#x2F;&#x2F; （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123;&#125;) &#125; 响应结构 12345678910111213141516&#123; &#x2F;&#x2F; data 由服务器提供的响应 data: &#123;&#125;, &#x2F;&#x2F; status 来自服务器响应的 HTTP 状态码 status: 200, &#x2F;&#x2F; statusText 来自服务器响应的 HTTP 状态信息 statusText: &#39;OK&#39;, &#x2F;&#x2F; headers 服务器响应的头 headers: &#123;&#125;, &#x2F;&#x2F; config 是为请求提供的配置信息 config: &#123;&#125; &#125; axios的使用 在axios中，不能使用this因为，this在axios回调函数中表示窗口，不是vue实例 可以使用axios获取对应服务器数据；如果不是同一个服务的数据则可能会出现跨域请求；需要在响应的服务器上配置跨域。 跨域：在前端js中如果发送异步请求的话，请求的地址与当前服务器的ip或者端口号不同都是跨域请求，可以使用如下方式在服务器端进行配置： axios不能通过静态网页的方式 js对象的键值可以加引号也可以不加引号，但是json中的键值必须有引号 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;js&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!----------------------------------------------&gt;&lt;div id&#x3D;&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;person in persons&quot;&gt; &#123;&#123;person.name&#125;&#125;--&#123;&#123;person.age&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; var app &#x3D; new Vue(&#123; el:&quot;#app&quot;, data:&#123; persons:[] &#125;, created() &#123; &#x2F;&#x2F;用配置文件的方法 axios(&#123;url:&quot;personData.json&quot;,method:&quot;get&quot;&#125;) .then(res&#x3D;&gt;&#123; console.log(res); &#x2F;&#x2F;不能使用this，在axios回调函数中表示窗口，不是vue实例 app.persons&#x3D;res.data; &#125;) .catch(error&#x3D;&gt;&#123; alert(error); &#125;); &#x2F;&#x2F;用get的方法 axios.get(&quot;personData.json&quot;) .then(res&#x3D;&gt;&#123; console.log(res); &#x2F;&#x2F;不能使用this，在axios回调函数中表示窗口，不是vue实例 app.persons&#x3D;res.data; &#125;) .catch(error&#x3D;&gt;&#123; alert(error); &#125;); 用post的方法 axios.post(&quot;personData.json&quot;) .then(res&#x3D;&gt;&#123; console.log(res); &#x2F;&#x2F;不能使用this，在axios回调函数中表示窗口，不是vue实例 app.persons&#x3D;res.data; &#125;) .catch(error&#x3D;&gt;&#123; alert(error); &#125;); &#125; &#125;);&lt;&#x2F;script&gt;&lt;!--------------------------------------------------&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://donghuangzhong.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://donghuangzhong.github.io/tags/vue/"}]},{"title":"Dubbo","slug":"Dubbo","date":"2021-05-30T00:50:56.000Z","updated":"2021-05-30T01:22:10.289Z","comments":true,"path":"2021/05/30/Dubbo/","link":"","permalink":"https://donghuangzhong.github.io/2021/05/30/Dubbo/","excerpt":"1.软件架构的描述 2.duboo概述 3.Zookeeper安装使用","text":"1.软件架构的描述 2.duboo概述 3.Zookeeper安装使用 分布式RPC框架Apache Dubbo软件架构的演进过程软件架构的发展经历了由单体架构、垂直架构、SOA架构到微服务架构的演进过程，下面我们分别了解一下这几个架构。 单体架构 架构说明： ​ 全部功能集中在一个项目内（All in one）。 架构优点： ​ 架构简单，前期开发成本低、开发周期短，适合小型项目。 架构缺点： ​ 全部功能集成在一个工程中，对于大型项目不易开发、扩展和维护。 ​ 技术栈受限，只能使用一种语言开发。 ​ 系统性能扩展只能通过扩展集群节点，成本高。 垂直架构 架构说明： ​ 按照业务进行切割，形成小的单体项目。 架构优点： ​ 技术栈可扩展（不同的系统可以用不同的编程语言编写）。 架构缺点： ​ 功能集中在一个项目中，不利于开发、扩展、维护。 ​ 系统扩张只能通过集群的方式。 ​ 项目之间功能冗余、数据冗余、耦合性强。 SOA架构SOA全称为Service-Oriented Architecture，即面向服务的架构。它可以根据需求通过网络对松散耦合的粗粒度应用组件(服务)进行分布式部署、组合和使用。一个服务通常以独立的形式存在于操作系统进程中。 站在功能的角度，把业务逻辑抽象成可复用的服务，通过服务的编排实现业务的快速再生，目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用。 架构说明： ​ 将重复功能或模块抽取成组件的形式，对外提供服务，在项目与服务之间使用ESB（企业服务总线）的形式作为通信的桥梁。 架构优点： ​ 重复功能或模块抽取为服务，提高开发效率。 ​ 可重用性高。 ​ 可维护性高。 架构缺点： ​ 各系统之间业务不同，很难确认功能或模块是重复的。 ​ 抽取服务的粒度大。 ​ 系统和服务之间耦合度高。 微服务架构 架构说明： ​ 将系统服务层完全独立出来，抽取为一个一个的微服务。 ​ 抽取的粒度更细，遵循单一原则。 ​ 采用轻量级框架协议传输。 架构优点： ​ 服务拆分粒度更细，有利于提高开发效率。 ​ 可以针对不同服务制定对应的优化方案。 ​ 适用于互联网时代，产品迭代周期更短。 架构缺点： ​ 粒度太细导致服务太多，维护成本高。 ​ 分布式系统开发的技术成本高，对团队的挑战大。 Apache Dubbo概述Dubbo简介Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。 什么是RPC？ RPC全称为remote procedure call，即远程过程调用。比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。 需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。 RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo等。 Dubbo官网地址：http://dubbo.apache.org Dubbo提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 Dubbo架构Dubbo架构图（Dubbo官方提供）如下： 节点角色说明： 节点 角色名称 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 虚线都是异步访问，实线都是同步访问蓝色虚线:在启动时完成的功能红色虚线(实线)都是程序运行过程中执行的功能 调用关系说明: 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 服务注册中心Zookeeper通过前面的Dubbo架构图可以看到，Registry（服务注册中心）在其中起着至关重要的作用。Dubbo官方推荐使用Zookeeper作为服务注册中心。 Zookeeper介绍Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 。 为了便于理解Zookeeper的树型目录服务，我们先来看一下我们电脑的文件系统(也是一个树型目录结构)： 我的电脑可以分为多个盘符（例如C、D、E等），每个盘符下可以创建多个目录，每个目录下面可以创建文件，也可以创建子目录，最终构成了一个树型结构。通过这种树型结构的目录，我们可以将文件分门别类的进行存放，方便我们后期查找。而且磁盘上的每个文件都有一个唯一的访问路径，例如：C:\\Windows\\itcast\\hello.txt。 Zookeeper树型目录服务： 流程说明： 服务提供者(Provider)启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址 服务消费者(Consumer)启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址 监控中心(Monitor)启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址 安装Zookeeper 下载地址：http://archive.apache.org/dist/zookeeper/ 本次使用的Zookeeper版本为3.4.6，以WSL示例 注：安装前要安装jdk 下载zookeeper-3.4.6.tar.gz，进入linux系统解压 WSL中/mnt/c就是c盘 sudo tar -zxvf zookeeper-3.4.6.tar.gz -C /usr/local //-C 指定解压位置 122. 进入zookeeper-3.4.6目录，创建data目录 mkdir data 123. 进入conf目录 ，把zoo_sample.cfg 改名为zoo.cfg cd conf mv zoo_sample.cfg zoo.cfg 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543554. 打开zoo.cfg文件, 修改data属性：dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper-3.4.6&#x2F;data### 启动、停止Zookeeper进入Zookeeper的bin目录，启动服务命令 .&#x2F;zkServer.sh start停止服务命令.&#x2F;zkServer.sh stop查看服务状态：.&#x2F;zkServer.sh status## 4. Dubbo快速入门Dubbo作为一个RPC框架，其最核心的功能就是要实现跨网络的远程调用。本小节就是要创建两个应用，一个作为服务的提供方，一个作为服务的消费方。通过Dubbo来实现服务消费方远程调用服务提供方的方法。### 4.1 服务提供方开发开发步骤：（1）创建maven工程（打包方式为war）dubbodemo_provider，在pom.xml文件中导入如下坐标~~~xml&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;&#x2F;spring.version&gt;&lt;&#x2F;properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-beans&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-aspects&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jms&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context-support&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- dubbo相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;dubbo&lt;&#x2F;artifactId&gt; &lt;version&gt;2.6.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt; &lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt; &lt;version&gt;3.4.7&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;&#x2F;groupId&gt; &lt;artifactId&gt;zkclient&lt;&#x2F;artifactId&gt; &lt;version&gt;0.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javassist&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javassist&lt;&#x2F;artifactId&gt; &lt;version&gt;3.12.1.GA&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2.47&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3.2&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;&#x2F;source&gt; &lt;target&gt;1.8&lt;&#x2F;target&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt; &lt;configuration&gt; &lt;!-- 指定端口 --&gt; &lt;port&gt;8081&lt;&#x2F;port&gt; &lt;!-- 请求路径 --&gt; &lt;path&gt;&#x2F;&lt;&#x2F;path&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt;~~~（2）配置web.xml文件~~~xml&lt;!DOCTYPE web-app PUBLIC &quot;-&#x2F;&#x2F;Sun Microsystems, Inc.&#x2F;&#x2F;DTD Web Application 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;dtd&#x2F;web-app_2_3.dtd&quot; &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:applicationContext*.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt; &lt;&#x2F;listener&gt;&lt;&#x2F;web-app&gt;~~~（3）创建服务接口~~~javapackage com.itheima.service;public interface HelloService &#123; public String sayHello(String name);&#125;~~~（4）创建服务实现类~~~javapackage com.itheima.service.impl;import com.alibaba.dubbo.config.annotation.Service;import com.itheima.service.HelloService;@Servicepublic class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; return &quot;hello &quot; + name; &#125;&#125;~~~注意：服务实现类上使用的Service注解是Dubbo提供的，用于对外发布服务（5）在src&#x2F;main&#x2F;resources下创建applicationContext-service.xml ~~~xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt; &lt;dubbo:application name&#x3D;&quot;dubbodemo_provider&quot; &#x2F;&gt; &lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt; &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;192.168.134.129:2181&quot;&#x2F;&gt; &lt;!-- 注册 协议和port 端口默认是20880 --&gt; &lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20881&quot;&gt;&lt;&#x2F;dubbo:protocol&gt; &lt;!-- 扫描指定包，加入@Service注解的类会被发布为服务 --&gt; &lt;dubbo:annotation package&#x3D;&quot;com.itheima.service.impl&quot; &#x2F;&gt;&lt;&#x2F;beans&gt;~~~（6）启动服务tomcat7:run### 4.2 服务消费方开发开发步骤：（1）创建maven工程（打包方式为war）dubbodemo_consumer，pom.xml配置和上面服务提供者相同，只需要将Tomcat插件的端口号改为8082即可（2）配置web.xml文件~~~xml&lt;!DOCTYPE web-app PUBLIC &quot;-&#x2F;&#x2F;Sun Microsystems, Inc.&#x2F;&#x2F;DTD Web Application 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;dtd&#x2F;web-app_2_3.dtd&quot; &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:applicationContext-web.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt;&lt;&#x2F;web-app&gt;~~~（3）将服务提供者工程中的HelloService接口复制到当前工程（4）编写Controller~~~javapackage com.itheima.controller;import com.alibaba.dubbo.config.annotation.Reference;import com.itheima.service.HelloService;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping(&quot;&#x2F;demo&quot;)public class HelloController &#123; @Reference private HelloService helloService; @RequestMapping(&quot;&#x2F;hello&quot;) @ResponseBody public String getName(String name)&#123; &#x2F;&#x2F;远程调用 String result &#x3D; helloService.sayHello(name); System.out.println(result); return result; &#125;&#125;~~~注意：Controller中注入HelloService使用的是Dubbo提供的@Reference注解（5）在src&#x2F;main&#x2F;resources下创建applicationContext-web.xml~~~xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt; &lt;dubbo:application name&#x3D;&quot;dubbodemo-consumer&quot; &#x2F;&gt; &lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt; &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;192.168.134.129:2181&quot;&#x2F;&gt; &lt;!-- 扫描的方式暴露接口 --&gt; &lt;dubbo:annotation package&#x3D;&quot;com.itheima.controller&quot; &#x2F;&gt;&lt;&#x2F;beans&gt;~~~（6）运行测试tomcat7:run启动在浏览器输入http:&#x2F;&#x2F;localhost:8082&#x2F;demo&#x2F;hello.do?name&#x3D;Jack，查看浏览器输出结果**思考一：**上面的Dubbo入门案例中我们是将HelloService接口从服务提供者工程(dubbodemo_provider)复制到服务消费者工程(dubbodemo_consumer)中，这种做法是否合适？还有没有更好的方式？**答：**这种做法显然是不好的，同一个接口被复制了两份，不利于后期维护。更好的方式是单独创建一个maven工程，将此接口创建在这个maven工程中。需要依赖此接口的工程只需要在自己工程的pom.xml文件中引入maven坐标即可。**思考二：**在服务消费者工程(dubbodemo_consumer)中只是引用了HelloService接口，并没有提供实现类，Dubbo是如何做到远程调用的？**答：**Dubbo底层是基于代理技术为HelloService接口创建代理对象，远程调用是通过此代理对象完成的。可以通过开发工具的debug功能查看此代理对象的内部结构。另外，Dubbo实现网络传输底层是基于Netty框架完成的。**思考三：**上面的Dubbo入门案例中我们使用Zookeeper作为服务注册中心，服务提供者需要将自己的服务信息注册到Zookeeper，服务消费者需要从Zookeeper订阅自己所需要的服务，此时Zookeeper服务就变得非常重要了，那如何防止Zookeeper单点故障呢？**答：**Zookeeper其实是支持集群模式的，可以配置Zookeeper集群来达到Zookeeper服务的高可用，防止出现单点故障。## 5. Dubbo管理控制台我们在开发时，需要知道Zookeeper注册中心都注册了哪些服务，有哪些消费者来消费这些服务。我们可以通过部署一个管理中心来实现。其实管理中心就是一个web应用，部署到tomcat即可。### 5.1 安装安装步骤：（1）将资料中的dubbo-admin-2.6.0.war文件复制到tomcat的webapps目录下（2）启动tomcat，此war文件会自动解压（3）修改WEB-INF下的dubbo.properties文件，注意dubbo.registry.address对应的值需要对应当前使用的Zookeeper的ip地址和端口号​ dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;192.168.134.129:2181​ dubbo.admin.root.password&#x3D;root​ dubbo.admin.guest.password&#x3D;guest（4）重启tomcat### 5.2 使用操作步骤：（1）访问http:&#x2F;&#x2F;localhost:8080&#x2F;dubbo-admin-2.6.0&#x2F;，输入用户名(root)和密码(root)![5](Dubbo&#x2F;5.png)（2）启动服务提供者工程和服务消费者工程，可以在查看到对应的信息![6](Dubbo&#x2F;6.png)![7](Dubbo&#x2F;7.png)![8](Dubbo&#x2F;8.png)![9](Dubbo&#x2F;9.png)## 6. Dubbo相关配置说明### 6.1 包扫描&#96;&#96;&#96;xml&lt;dubbo:annotation package&#x3D;&quot;com.itheima.service&quot; &#x2F;&gt; 服务提供者和服务消费者都需要配置，表示包扫描，作用是扫描指定包(包括子包)下的类。 如果不使用包扫描，也可以通过如下配置的方式来发布服务： 12&lt;bean id=\"helloService\" class=\"com.itheima.service.impl.HelloServiceImpl\" /&gt;&lt;dubbo:service interface=\"com.itheima.api.HelloService\" ref=\"helloService\" /&gt; 作为服务消费者，可以通过如下配置来引用服务： 12&lt;!-- 生成远程服务代理，可以和本地bean一样使用helloService --&gt;&lt;dubbo:reference id=\"helloService\" interface=\"com.itheima.api.HelloService\" /&gt; 上面这种方式发布和引用服务，一个配置项(dubbo:service、dubbo:reference)只能发布或者引用一个服务，如果有多个服务，这种方式就比较繁琐了。推荐使用包扫描方式。 6.2 协议1&lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; 一般在服务提供者一方配置，可以指定使用的协议名称和端口号。 其中Dubbo支持的协议有：dubbo、rmi、hessian、http、webservice、rest、redis等。 推荐使用的是dubbo协议。 dubbo 协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。 也可以在同一个工程中配置多个协议，不同服务可以使用不同的协议，例如： 1234567&lt;!-- 多协议配置 --&gt;&lt;dubbo:protocol name=\"dubbo\" port=\"20880\" /&gt;&lt;dubbo:protocol name=\"rmi\" port=\"1099\" /&gt;&lt;!-- 使用dubbo协议暴露服务 --&gt;&lt;dubbo:service interface=\"com.itheima.api.HelloService\" ref=\"helloService\" protocol=\"dubbo\" /&gt;&lt;!-- 使用rmi协议暴露服务 --&gt;&lt;dubbo:service interface=\"com.itheima.api.DemoService\" ref=\"demoService\" protocol=\"rmi\" /&gt; 6.3 启动时检查1&lt;dubbo:consumer check=\"false\"/&gt; 上面这个配置需要配置在服务消费者一方，如果不配置默认check值为true。Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。可以通过将check值改为false来关闭检查。 建议在开发阶段将check值设置为false，在生产环境下改为true。 6.4 负载均衡负载均衡（Load Balance）：其实就是将请求分摊到多个操作单元上进行执行，从而共同完成工作任务。 在集群负载均衡时，Dubbo 提供了多种均衡策略（包括随机、轮询、最少活跃调用数、一致性Hash），缺省为random随机调用。 配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下： 12345678910111213141516@Controller@RequestMapping(\"/demo\")public class HelloController &#123; //在服务消费者一方配置负载均衡策略 @Reference(check = false,loadbalance = \"random\") private HelloService helloService; @RequestMapping(\"/hello\") @ResponseBody public String getName(String name)&#123; //远程调用 String result = helloService.sayHello(name); System.out.println(result); return result; &#125;&#125; 1234567//在服务提供者一方配置负载均衡@Service(loadbalance = \"random\")public class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; return \"hello \" + name; &#125;&#125; 可以通过启动多个服务提供者来观察Dubbo负载均衡效果。 注意：因为我们是在一台机器上启动多个服务提供者，所以需要修改tomcat的端口号和Dubbo服务的端口号来防止端口冲突。 在实际生产环境中，多个服务提供者是分别部署在不同的机器上，所以不存在端口冲突问题。 7. 解决Dubbo无法发布被事务代理的Service问题前面我们已经完成了Dubbo的入门案例，通过入门案例我们可以看到通过Dubbo提供的标签配置就可以进行包扫描，扫描到@Service注解的类就可以被发布为服务。 但是我们如果在服务提供者类上加入@Transactional事务控制注解后，服务就发布不成功了。原因是事务控制的底层原理是为服务提供者类创建代理对象，而默认情况下Spring是基于JDK动态代理方式创建代理对象，而此代理对象的完整类名为com.sun.proxy.$Proxy42（最后两位数字不是固定的），导致Dubbo在发布服务前进行包匹配时无法完成匹配，进而没有进行服务的发布。 7.1 问题展示在入门案例的服务提供者dubbodemo_provider工程基础上进行展示 操作步骤： （1）在pom.xml文件中增加maven坐标 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; （2）在applicationContext-service.xml配置文件中加入数据源、事务管理器、开启事务注解的相关配置 1234567891011121314&lt;!--数据源--&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\" /&gt;&lt;/bean&gt;&lt;!-- 事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!--开启事务控制的注解支持--&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 上面连接的数据库可以自行创建 （3）在HelloServiceImpl类上加入@Transactional注解 （4）启动服务提供者和服务消费者，并访问 上面的错误为没有可用的服务提供者 查看dubbo管理控制台发现服务并没有发布，如下： 可以通过断点调试的方式查看Dubbo执行过程，Dubbo通过AnnotationBean的postProcessAfterInitialization方法进行处理 7.2 解决方案通过上面的断点调试可以看到，在HelloServiceImpl类上加入事务注解后，Spring会为此类基于JDK动态代理技术创建代理对象，创建的代理对象完整类名为com.sun.proxy.$Proxy35，导致Dubbo在进行包匹配时没有成功（因为我们在发布服务时扫描的包为com.itheima.service），所以后面真正发布服务的代码没有执行。 解决方式操作步骤： （1）修改applicationContext-service.xml配置文件，开启事务控制注解支持时指定proxy-target-class属性，值为true。其作用是使用cglib代理方式为Service类创建代理对象 12&lt;!--开启事务控制的注解支持--&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\" proxy-target-class=\"true\"/&gt; （2）修改HelloServiceImpl类，在Service注解中加入interfaceClass属性，值为HelloService.class，作用是指定服务的接口类型 1234567@Service(interfaceClass = HelloService.class)@Transactionalpublic class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; return \"hello \" + name; &#125;&#125; 此处也是必须要修改的，否则会导致发布的服务接口为SpringProxy，而不是HelloService接口，如下：","categories":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://donghuangzhong.github.io/categories/Dubbo/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://donghuangzhong.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"RPC","slug":"RPC","permalink":"https://donghuangzhong.github.io/tags/RPC/"}]},{"title":"ssm","slug":"ssm","date":"2021-05-28T07:22:51.000Z","updated":"2021-05-30T00:14:40.264Z","comments":true,"path":"2021/05/28/ssm/","link":"","permalink":"https://donghuangzhong.github.io/2021/05/28/ssm/","excerpt":"快速搭建ssm框架","text":"快速搭建ssm框架 目录结构 创建数据库test数据库下有一个user表 用骨架创建maven web项目,引入坐标123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;dependencies&gt; &lt;!--dao层的配置--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.23&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.18&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.4.5&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--junit测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.13.2&lt;&#x2F;version&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!--spring相关坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--springmvc相关坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 创建配置文件 jdbc.properties 1234jdbc.driver&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;&#x2F;testjdbc.username&#x3D;rootjdbc.password&#x3D;root applicationContext-dao.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;&lt;!--只负责配置dao层的spring配置--&gt; &lt;!--加载jdbc.properties--&gt; &lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt; &lt;!--配置dataSource数据源--&gt; &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置SqlSessionFactoryBean--&gt; &lt;bean class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt; &lt;!--&lt;property name&#x3D;&quot;typeAliasesPackage&quot; value&#x3D;&quot;com.dhz.domain&quot;&#x2F;&gt;--&gt; &lt;!--&lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:springContext.xml&quot;&#x2F;&gt;--&gt; &lt;&#x2F;bean&gt; &lt;!--扫描mapper生成代理对象--&gt; &lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.dhz.mapper&quot;&#x2F;&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; applicationContext-service.xml 12345678910111213141516171819202122232425&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;&lt;!--只负责配置service层的spring配置--&gt; &lt;!--扫描service层的注解--&gt; &lt;context:component-scan base-package&#x3D;&quot;com.dhz.service&quot;&#x2F;&gt; &lt;!--配置事务管理器--&gt; &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--事务注解驱动--&gt; &lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&#x2F;&quot;&#x2F;&gt; &lt;&#x2F;beans&gt; springmvc.xml 1234567891011121314151617181920212223242526272829&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt; &lt;!--扫描注解--&gt; &lt;context:component-scan base-package&#x3D;&quot;com.dhz.controller&quot;&#x2F;&gt; &lt;!--配置视图解析器--&gt; &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;pages&#x2F;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--mvc注解驱动--&gt; &lt;mvc:annotation-driven&#x2F;&gt; &lt;!--静态资源权限开放--&gt; &lt;mvc:default-servlet-handler&#x2F;&gt;&lt;&#x2F;beans&gt; web.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE web-app PUBLIC &quot;-&#x2F;&#x2F;Sun Microsystems, Inc.&#x2F;&#x2F;DTD Web Application 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;dtd&#x2F;web-app_2_3.dtd&quot; &gt;&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot; id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;3.0&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt; &lt;!--全局的初始化参数--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:applicationContext*.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;context-param&gt; &lt;!--Spring的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt; &lt;&#x2F;listener&gt; &lt;!--SpringMVC的前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;2&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; &lt;!--全局乱码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt; &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt; &lt;&#x2F;web-app&gt; web.xml需要修改webapp标签 实体类和mapper User.java 12345678910111213141516package com.dhz.domain;public class User &#123; private String id; private String username; private String password; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id&#x3D;&#39;&quot; + id + &#39;\\&#39;&#39; + &quot;, username&#x3D;&#39;&quot; + username + &#39;\\&#39;&#39; + &quot;, password&#x3D;&#39;&quot; + password + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125;&#125; UserMappper.java 1234public interface UserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll();&#125; service和controller UserServiceImpl.java 123456789101112@Service@Transactionalpublic class UserServiceImpl implements UserService &#123; @Autowired UserMapper userMapper; @Override public List&lt;User&gt; findAll() &#123; return userMapper.findAll(); &#125;&#125; UserController.java 12345678910111213141516@Controller@RequestMapping(&quot;&#x2F;user&quot;)public class UserController &#123; @Autowired private UserService userService; @RequestMapping(&quot;&#x2F;findAll&quot;) ModelAndView findAll(ModelAndView modelAndView)&#123; List&lt;User&gt; users &#x3D; userService.findAll(); modelAndView.setViewName(&quot;show&quot;); modelAndView.addObject(&quot;userss&quot;,users); return modelAndView; &#125;&#125; 前端页面和spring测试 show.jsp 123456789&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;$&#123;userss&#125;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; ssmTest.java 1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;&quot;classpath:applicationContext-dao.xml&quot;,&quot;classpath:applicationContext-service.xml&quot;&#125;)public class ssmTest &#123; @Autowired private UserMapper userMapper; @Test public void test1()&#123; List&lt;User&gt; users &#x3D; userMapper.findAll(); System.out.println(users); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"},{"name":"ssm","slug":"ssm","permalink":"https://donghuangzhong.github.io/tags/ssm/"}]},{"title":"sublime text","slug":"sublime-text","date":"2021-03-26T00:13:15.000Z","updated":"2021-03-30T08:51:33.505Z","comments":true,"path":"2021/03/26/sublime-text/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/26/sublime-text/","excerpt":"sublime的相关配置","text":"sublime的相关配置 配置JS打开sublime text 新建文件，命名为JavaScript.sublime-build 1234&#123; &quot;cmd&quot;: [&quot;node&quot;, &quot;$file&quot;], &quot;selector&quot;: &quot;source.js&quot;&#125; 代码提示Sublime Text 3\\Data\\Packages\\SublimeCodeIntel目录下 1234567891011121314151617181920212223242526&#123; &quot;PHP&quot;: &#123; &quot;php&quot;: &#39;&#x2F;usr&#x2F;bin&#x2F;php&#39;, &quot;phpExtraPaths&quot;: [], &quot;phpConfigFile&quot;: &#39;php.ini&#39; &#125;, &quot;JavaScript&quot;: &#123; &quot;javascriptExtraPaths&quot;: [] &#125;, &quot;Perl&quot;: &#123; &quot;perl&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;perl&quot;, &quot;perlExtraPaths&quot;: [] &#125;, &quot;Ruby&quot;: &#123; &quot;ruby&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;ruby&quot;, &quot;rubyExtraPaths&quot;: [] &#125;, &quot;Python&quot;: &#123; &quot;python&quot;: &#39;&#x2F;usr&#x2F;bin&#x2F;python&#39;, &quot;pythonExtraPaths&quot;: [] &#125;, &quot;Python3&quot;: &#123; &quot;python&quot;: &#39;&#x2F;usr&#x2F;bin&#x2F;python3&#39;, &quot;pythonExtraPaths&quot;: [] &#125;&#125; 激活12345678910111213----- BEGIN LICENSE -----Member J2TeaMSingle User LicenseEA7E-1011316D7DA350E 1B8B0760 972F8B60 F3E64036B9B4E234 F356F38F 0AD1E3B7 0E9C5FADFA0A2ABE 25F65BD8 D51458E5 3923CE8087428428 79079A01 AA69F319 A1AF29A4A684C2DC 0B1583D4 19CBD290 217618CD5653E0A0 BACE3948 BB2EE45E 422D2C87DD9AF44B 99C49590 D2DBDEE1 75860FD28C8BB2AD B2ECE5A4 EFC08AF2 25A9B864------ END LICENSE ------​ 123456789101112ZYNGA INC.50 User LicenseEA7E-811825927BA117 84C9300F 4A0CCBC4 34A56B44985E4562 59F2B63B CCCFF92F 0E646B830FD6487D 1507AE29 9CC4F9F5 0A6F32E30343D868 C18E2CD5 27641A71 25475648309705B3 E468DDC4 1B766A18 7952D28CE627DDBA 960A2153 69A2D98A C87C060745DC6049 8C04EC29 D18DFA40 442C680B1342224D 44D90641 33A3B9F2 46AADB8F 123456789101112ZYNGA INC.50 User LicenseEA7E-811825927BA117 84C9300F 4A0CCBC4 34A56B44985E4562 59F2B63B CCCFF92F 0E646B830FD6487D 1507AE29 9CC4F9F5 0A6F32E30343D868 C18E2CD5 27641A71 25475648309705B3 E468DDC4 1B766A18 7952D28CE627DDBA 960A2153 69A2D98A C87C060745DC6049 8C04EC29 D18DFA40 442C680B1342224D 44D90641 33A3B9F2 46AADB8F 1234567891011Member J2TeaMSingle User LicenseEA7E-1011316D7DA350E 1B8B0760 972F8B60 F3E64036B9B4E234 F356F38F 0AD1E3B7 0E9C5FADFA0A2ABE 25F65BD8 D51458E5 3923CE8087428428 79079A01 AA69F319 A1AF29A4A684C2DC 0B1583D4 19CBD290 217618CD5653E0A0 BACE3948 BB2EE45E 422D2C87DD9AF44B 99C49590 D2DBDEE1 75860FD28C8BB2AD B2ECE5A4 EFC08AF2 25A9B864 更改插件的安装目录1C:\\Users\\DongHuangZhong\\AppData\\Roaming 此文件夹下的sublime目录删除 在sublime安装目录下新建Data，重新安装pacake control 的添加右键菜单 open_with_sublime.reg 123456789101112Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\*\\shell\\SublimeText3]@&#x3D;&quot;Open with Sublime Text 3 &quot;&quot;Icon&quot;&#x3D;&quot;E:\\\\bianchenggongju\\\\Sublime Text 3\\\\sublime_text.exe,0&quot;[HKEY_CLASSES_ROOT\\*\\shell\\SublimeText3\\command]@&#x3D;&quot;E:\\\\bianchenggongju\\\\Sublime Text 3\\\\sublime_text.exe %1&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\SublimeText3]@&#x3D;&quot;Open with Sublime Text 3 &quot;&quot;Icon&quot;&#x3D;&quot;E:\\\\bianchenggongju\\\\Sublime Text 3\\\\sublime_text.exe,0&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\SublimeText3\\command] @&#x3D;&quot;E:\\\\bianchenggongju\\\\Sublime Text 3\\\\sublime_text.exe %1&quot;","categories":[{"name":"sublime","slug":"sublime","permalink":"https://donghuangzhong.github.io/categories/sublime/"},{"name":"js","slug":"sublime/js","permalink":"https://donghuangzhong.github.io/categories/sublime/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://donghuangzhong.github.io/tags/js/"},{"name":"sublime","slug":"sublime","permalink":"https://donghuangzhong.github.io/tags/sublime/"}]},{"title":"js","slug":"js","date":"2021-03-22T05:41:16.000Z","updated":"2021-03-30T10:06:19.539Z","comments":true,"path":"2021/03/22/js/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/22/js/","excerpt":"摘要","text":"摘要 表格相关编辑模式禁止换行123456789101112131415161718&#x2F;&#x2F; 编辑状态下右侧表格禁止换行idp.event.register(&quot;grid_main&quot;, &quot;beforeSelectRow&quot;, function(e, data) &#123; &#x2F;&#x2F; debugger; if (!idp.uiview.fsmController.cannot(&quot;cancel&quot;)) &#123; idp.warn(idp.lang.get(&#39;EaoTag_CRow_check&#39;) || &quot;请先保存再切换行&quot;); return false; &#125; return true;&#125;);&#x2F;&#x2F;编辑状态下禁止编辑其他行idp.event.register(&quot;grid_main&quot;, &quot;beforeEdit&quot;, function(e, index) &#123; &#x2F;&#x2F; debugger; var selectRow &#x3D; idp.control.get(&quot;grid_main&quot;).getSelectedRow(); var curIndex &#x3D; selectRow.__index; if (index !&#x3D;&#x3D; curIndex) return false;&#125;); 默认选中首行第二种失效用第一种 123456idp.event.register(&quot;grid_467637&quot;, &quot;afterLoadData&quot;, function(e, p) &#123; var length &#x3D; idp.control.get(&quot;grid_467637&quot;).getData().length; if (length &gt; 0) &#123; idp.control.get(&quot;grid_467637&quot;).select(0); &#125; &#125;); 123456idp.event.register(&quot;grid_467637&quot;, &quot;afterShowData&quot;, function(e, data) &#123; var length &#x3D; idp.control.get(&quot;grid_467637&quot;).getData().length; if (length &gt; 0) &#123; idp.control.get(&quot;grid_467637&quot;).select(0); &#125;&#125;); 新增行相关afterAddGridRow执行时，只是新增一行，不改变状态机，等到执行完afterAddGridRow后进入编辑状态机(不会自动触发编辑选择新增行)，此时点击任意行都会触发编辑-&gt;选中事件，所以要手动进行选择一下 12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;&#x2F; 新增行后赋值初始数据 idp.event.register(&quot;grid_main&quot;, &quot;afterAddGridRow&quot;, function(table, row, id) &#123; debugger; var index &#x3D; idp.control.get(&quot;grid_main&quot;).rows.length - 1; if (index &gt;&#x3D; 0) &#123; idp.control.get(&quot;grid_main&quot;).select(index); &#125; var data &#x3D; idp.control.get(&quot;grid_main&quot;).getData(); $(&quot;.lee-panel-footer&quot;).css(&quot;pointer-events&quot;, &quot;none&quot;); function formatNum(number, len, ch) &#123; ch &#x3D; &quot;&quot; + ch; number &#x3D; &quot;&quot; + number; var strLength &#x3D; len - number.length; for (var i &#x3D; 0; i &lt; strLength; i++) &#123; number &#x3D; ch + number; &#125; return number; &#125; var codeid &#x3D; idp.control.get(&quot;grid_tagtype&quot;).getSelectedRow().CODE; var id &#x3D; idp.control.get(&quot;grid_tagtype&quot;).getSelectedRow().ID; var num; idp.service.fetch(&#39;&#x2F;api&#x2F;eao&#x2F;v1.0&#x2F;pub&#x2F;tag&#x2F;getOrderNum&#39;, id, false).done(function(data) &#123; num &#x3D; data.appendData; &#125;).fail(function(error) &#123; console.log(error); &#125;); if (num &#x3D;&#x3D; 0) &#123; num &#x3D; formatNum(codeid, 4, &quot;0&quot;) + &quot;00001&quot;; &#125; var ordernum &#x3D; num; idp.control.get(&quot;grid_main&quot;).updateRow(data.length - 1, &#123; &quot;ORDERNUM&quot;: ordernum &#125;); idp.control.get(&quot;grid_main&quot;).updateRow(data.length - 1, &#123; &quot;TYPEID&quot;: idp.control.get(&quot;grid_tagtype&quot;).getSelected().ID &#125;); &#125;); 修改idp的删除方法(左侧删除计数)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#x2F;&#x2F; 修改的idp删除方法function dele(extParam, isFront) &#123; var self &#x3D; idp.uiview; if (idp.uiview.gridController.mainGrid.getSelectedRows().length &gt; 1) &#123; idp.warn(idp.lang.get(&quot;SEL_DATA_TO_DEL&quot;)); return; &#125; var bindings &#x3D; idp.uiview.gridController.grids[idp.uiview.gridController.mainGrid.id]; var grid &#x3D; bindings.grid; var data &#x3D; idp.uiview.gridController.mainGrid.getSelected(); if (data) &#123; if (isFront) &#123; grid.endEdit(); if (data.__status &#x3D;&#x3D; &quot;add&quot;) &#123; grid.remove(data); &#125; else &#123; grid.deleteRow(data); &#125; &#125; else &#123; idp.confirm(idp.lang.get(&quot;DELETE_CONFIRM&quot;), function() &#123; if (data[&quot;__status&quot;] &#x3D;&#x3D; &quot;add&quot;) &#123; self.gridController.mainGrid.remove(data); &#125; else &#123; idp.loading(idp.lang.get(&quot;DELETING&quot;)); idp.service.deleteData(&quot;&quot;, self.config.styleid, data[self.modelController.pkcol], null, extParam).then(function(res) &#123; idp.loaded(); if (res.Code &#x3D;&#x3D; &quot;ok&quot;) &#123; idp.tips(idp.lang.get(&quot;DELETE_SUCESS&quot;)); self.gridController.mainGrid.remove(data); try &#123; self.gridController.mainGrid.options.total &#x3D; self.gridController.mainGrid.options.total - 1; self.gridController.mainGrid._buildPager(); &#125; catch (e) &#123; &#125; debugger; updateTagTypeNum(); &#x2F;&#x2F; idp.control.get(&quot;grid_tagtype&quot;).select(idp.control.get(&quot;grid_tagtype&quot;).getSelected().__index); &#125; else if (res.Code &#x3D;&#x3D; &quot;lockdata&quot;) &#123; idp.error(idp.lang.get(&quot;DELETE_LOCK&quot;)); &#x2F;&#x2F; defer.resolve(false); &#125; &#125;); &#125; &#125;); &#125; &#125; else &#123; idp.warn(idp.lang.get(&quot;SEL_DATA_TO_DEL&quot;)); return; &#125;&#125; 修改保存按钮(保存后更新计数）12$(&quot;.lee-panel-footer&quot;).css(&quot;pointer-events&quot;,&quot;&quot;);return idp.uiview.saveData().then(function(flag)&#123;if(flag)&#123;updateTagTypeNum();return true;&#125;else return false;&#125;); 模拟下载模板（XLSX.js）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#x2F;&#x2F;模拟实现下载function downloadEx(blob, filename) &#123; var eleLink &#x3D; document.createElement(&#39;a&#39;); eleLink.download &#x3D; filename; eleLink.style.display &#x3D; &#39;none&#39;; &#x2F;&#x2F; 字符内容转变成blob地址 var blob &#x3D; new Blob([blob]); eleLink.href &#x3D; URL.createObjectURL(blob); &#x2F;&#x2F; 触发点击 document.body.appendChild(eleLink); eleLink.click(); &#x2F;&#x2F; 然后移除 document.body.removeChild(eleLink);&#125;function sheet2blob(sheet, sheetName) &#123; sheetName &#x3D; sheetName || &#39;sheet1&#39;; var workbook &#x3D; &#123; SheetNames: [sheetName], Sheets: &#123;&#125; &#125;; workbook.Sheets[sheetName] &#x3D; sheet; &#x2F;&#x2F; 生成excel的配置项 var wopts &#x3D; &#123; bookType: &#39;xlsx&#39;, &#x2F;&#x2F; 要生成的文件类型 bookSST: false, &#x2F;&#x2F; 是否生成Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本IOS设备上有更好的兼容性 type: &#39;binary&#39; &#125;; var wbout &#x3D; XLSX.write(workbook, wopts); var blob &#x3D; new Blob([s2ab(wbout)], &#123; type: &quot;application&#x2F;octet-stream&quot; &#125;); &#x2F;&#x2F; 字符串转ArrayBuffer function s2ab(s) &#123; var buf &#x3D; new ArrayBuffer(s.length); var view &#x3D; new Uint8Array(buf); for (var i &#x3D; 0; i !&#x3D; s.length; ++i) view[i] &#x3D; s.charCodeAt(i) &amp; 0xFF; return buf; &#125; return blob;&#125;&#x2F;&#x2F; 导入模板下载function ddd() &#123; &#x2F;&#x2F; debugger; var jsonDatas &#x3D; [&#123; &quot;标签名称&quot;: &quot;&quot;, &quot;类别名称&quot;: &quot;&quot; &#125;]; var sheet &#x3D; XLSX.utils.json_to_sheet(jsonDatas); downloadEx(sheet2blob(sheet), &quot;importTemplate&quot; + &#39;.xlsx&#39;);&#125; 自定义操作单元格 row中有点击所在行(此时未选择此行)的信息，通过传参过去给点击事件函数 点击超链接-&gt;执行点击事件函数(此时未选中行)-&gt;执行完点击事件触发选中行事件，所以需要在点击事件函数中手动选择一下行，但这样会触发两次选择行事件，所以第一次选择行之前要加条件(比如在非编辑状态下才能执行第一次选中行)，不执行第一次手动选择行，让第二次执行的选择行事件负责给出错误提示信息(不然会出现两次错误提示信息) 12345function(row,index)&#123; var data&#x3D;JSON.stringify(row); return &quot;&lt;a href&#x3D;&#39;javascript:void(0)&#39; onclick&#x3D;&#39;edit(&quot;+data+&quot;)&#39;&gt;&quot;+&#39;编辑&#39;+&quot;&lt;&#x2F;a&gt;&amp;nbsp;&quot;+&quot;&lt;a href&#x3D;&#39;javascript:void(0)&#39; onclick&#x3D;&#39;del(&quot;+data+&quot;)&#39;&gt;&quot;+&#39;删除&#39;+&quot;&lt;&#x2F;a&gt;&quot;;&#125; 1234567891011121314151617181920212223242526function edit(args) &#123; &#x2F;&#x2F; debugger; if (!idp.uiview.fsmController.cannot(&quot;cancel&quot;)) &#123; if (idp.control.get(&quot;grid_main&quot;).getSelected() !&#x3D; null &amp;&amp; idp.control.get(&quot;grid_main&quot;).getSelected().__index &#x3D;&#x3D; args.__index) &#123; idp.warn(idp.lang.get(&#39;EAM_FD_ACTCONTROL_07&#39;) || &#39;请勿重复编辑此行&#39;); return; &#125; return; &#125; idp.control.get(&quot;grid_main&quot;).select(args.__index); idp.uiview.fsmController.action(&#39;modify&#39;); return idp.uiview.edit();&#125;function del(args) &#123; if (!idp.uiview.fsmController.cannot(&quot;cancel&quot;)) &#123; if (idp.control.get(&quot;grid_main&quot;).getSelected() !&#x3D; null &amp;&amp; idp.control.get(&quot;grid_main&quot;).getSelected().__index &#x3D;&#x3D; args.__index) &#123; idp.warn(idp.lang.get(&#39;EAM_FD_ACTCONTROL_07&#39;) || &#39;请先保存再删除本行&#39;); return; &#125; return; &#125; idp.control.get(&quot;grid_main&quot;).select(args.__index); return idp.uiview.deleteListTmp();&#125; 导入控件类型非varchar必填 回调函数，自动选择第一行 123456789return idp.importExcel(&#39;4ea45461-8f52-b35f-c25e-eaa81025bcd0&#39;,null,function()&#123; var length &#x3D; idp.control.get(&quot;grid_467637&quot;).getData().length; if (length &gt; 0) &#123; idp.control.get(&quot;grid_467637&quot;).select(0); &#125;&#125;);return idp.importExcel(&#39;4ea45461-8f52-b35f-c25e-eaa81025bcd0&#39;,null,function()&#123; var length &#x3D; idp.control.get(&quot;grid_467637&quot;).getData().length; if (length &gt; 0) &#123; idp.control.get(&quot;grid_467637&quot;).select(0); &#125;&#125;); 导出修改修改的源文件 12345678910111213141516171819202122232425idp.exportExcel &#x3D; function (id, sheetName) &#123; var $grid &#x3D; $(&quot;#&quot; + id).leeUI(); if (!sheetName) sheetName &#x3D; &quot;Sheet1&quot;; var obj &#x3D; &#123;&#125;; obj.rowsData &#x3D; $grid.getData(); var colheader &#x3D; []; $.each($grid.options.columns, function (i, item) &#123; if (!item.hide &amp;&amp; item.id !&#x3D; &#39;gridset&#39;) &#123; if (item.editor) &#123; item.columnType &#x3D; item.editor.type; &#125; colheader.push(item); &#125; &#125;); obj.colHeaders &#x3D; colheader; var extend &#x3D; idp.event.triggerHandler(id, &quot;beforeExcelExport&quot;, [obj]); if (extend) &#123; $.extend(true, obj, extend); &#125; var url &#x3D; IDPENV.API_RUNTIME + &quot;&#x2F;ExcelGrid&#x2F;exportMX?fileName&#x3D;导出&amp;sheetName&#x3D;&quot; + sheetName; url +&#x3D; &quot;&amp;SessionId&#x3D;&quot; + window.localStorage.session; idp.downLoadFile(url, JSON.stringify(obj).replace(&#x2F;\\&#39;&#x2F;g, &quot;&amp;apos;&quot;).replace(&#x2F;\\&quot;&#x2F;g, &quot;&quot;&quot;));&#125; 12345678910111213141516171819202122232425function exportt(id, sheetName) &#123; var $grid &#x3D; $(&quot;#&quot; + id).leeUI(); if (!sheetName) sheetName &#x3D; &quot;Sheet1&quot;; var obj &#x3D; &#123;&#125;; obj.rowsData &#x3D; $grid.getData(); var colheader &#x3D; []; var columns&#x3D;[]; $.each($grid.options.columns, function (i, item) &#123; &#x2F;&#x2F;新增的过滤条件 if (!item.hide &amp;&amp; item.id !&#x3D; &#39;gridset&#39;&amp;&amp;item.__id!&#x3D;&quot;CAOZUO&quot;) &#123; if (item.editor) &#123; item.columnType &#x3D; item.editor.type; &#125; colheader.push(item); &#125; &#125;); obj.colHeaders &#x3D; colheader; var extend &#x3D; idp.event.triggerHandler(id, &quot;beforeExcelExport&quot;, [obj]); if (extend) &#123; $.extend(true, obj, extend); &#125; var url &#x3D; IDPENV.API_RUNTIME + &quot;&#x2F;ExcelGrid&#x2F;exportMX?fileName&#x3D;导出&amp;sheetName&#x3D;&quot; + sheetName; url +&#x3D; &quot;&amp;SessionId&#x3D;&quot; + window.localStorage.session; idp.downLoadFile(url, JSON.stringify(obj).replace(&#x2F;\\&#39;&#x2F;g, &quot;&amp;apos;&quot;).replace(&#x2F;\\&quot;&#x2F;g, &quot;&quot;&quot;)); &#125; 有弹窗的修改用filter过滤虚字段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&#x2F;&#x2F; 修改的idp导出函数function cex(id, sheetName) &#123; var g &#x3D; idp.uiview.gridController.getExportOptions(id); var eType &#x3D; $(&quot;#exportSet&quot;).val(); var options &#x3D; &#123; &quot;sqlId&quot;: g.styleid, &quot;fields&quot;: g.filter, &quot;orders&quot;: g.orders, &quot;page&quot;: g.curPage, &quot;pageSize&quot;: g.pageSize ? g.pageSize : 10000, &quot;count&quot;: true, &quot;columns&quot;: g.columns.filter(item &#x3D;&gt; item.id !&#x3D; &quot;CAOZUO&quot;) &#125; debugger; if (g.usePager) &#123; if (eType &#x3D;&#x3D; &quot;2&quot;) &#123; options.page &#x3D; 1; options.pageSize &#x3D; g.total; &#125; else if (eType &#x3D;&#x3D; &quot;3&quot;) &#123; var statrPage &#x3D; $(&quot;#exportSetStart&quot;).val(); var endPage &#x3D; $(&quot;#exportSetEnd&quot;).val(); if (statrPage &#x3D;&#x3D; &quot;&quot; || endPage &#x3D;&#x3D; &quot;&quot;) &#123; idp.error(lang.get(&quot;ENTER_START_END_PAGE&quot;)); return false; &#125; if (Number(statrPage) &lt;&#x3D; 0 || Number(endPage) &lt;&#x3D; 0) &#123; idp.error(lang.get(&quot;ENTER_STARTEND_PAGE&quot;)); return false; &#125; if (Number(statrPage) &gt; Number(endPage)) &#123; idp.error(lang.get(&quot;START_LARGER_END&quot;)); return false; &#125; if (statrPage &gt; g.pageCount || endPage &gt; g.pageCount) &#123; idp.error(lang.get(&quot;EXPORT_EXCEED_MAX&quot;)); return false; &#125; options.page &#x3D; Number(statrPage); options.pageSize &#x3D; g.pageSize; options.endPage &#x3D; Number(endPage); &#x2F;&#x2F;options.pageSize &#x3D; (Number(endPage) - Number(statrPage) + 1) * g.pageSize; &#125; else &#123; options.page &#x3D; g.curPage; &#125; &#125; else &#123; options.page &#x3D; 1; options.pageSize &#x3D; g.total; &#125; var url &#x3D; IDPENV.API_RUNTIME + &quot;&#x2F;ExcelGrid&#x2F;export?fileName&#x3D;export&amp;sheetName&#x3D;&quot; + sheetName; url +&#x3D; &quot;&amp;SessionId&#x3D;&quot; + window.localStorage.session; idp.uiview.downLoadFile(url, JSON.stringify(options)); &#x2F;&#x2F;this.writeAudit(&quot;export&quot;); return true;&#125;&#x2F;&#x2F; 修改的idp导出函数function exx(id, sheetName) &#123; debugger; var self &#x3D; idp.uiview; if (!id) id &#x3D; self.gridController.mainGridID; if (self.gridController.isPager(id)) &#123; if (!idp.uiview._exportLoad) &#123; var html &#x3D; $(&quot;&lt;div id&#x3D;&#39;exportInfo&#39; style&#x3D;&#39;display:none;&#39; &gt;&lt;div style&#x3D;&#39;margin:5px;&#39;&gt;&lt;input id&#x3D;&#39;exportSet&#39; value&#x3D;&#39;1&#39;&#x2F;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&#39;exportNumberWrap&#39; &gt;&lt;div style&#x3D;&#39;margin:15px;display:inline-block&#39;&gt;开始&lt;&#x2F;div&gt;&lt;div style&#x3D;&#39;margin:5px;display:inline-block&#39;&gt;&lt;input id&#x3D;&#39;exportSetStart&#39; value&#x3D;&#39;1&#39; style&#x3D;&#39;width:60px;&#39;&#x2F;&gt;&lt;&#x2F;div&gt;&lt;div style&#x3D;&#39;margin:5px;display:inline-block&#39;&gt;结束&lt;&#x2F;div&gt; &lt;div style&#x3D;&#39;margin:5px;display:inline-block&#39;&gt;&lt;input id&#x3D;&#39;exportSetEnd&#39; style&#x3D;&#39;width:60px;&#39;&#x2F;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&quot;); $(&quot;body&quot;).append(html); $(&quot;#exportSet&quot;).leeRadioList(&#123; data: [&#123; id: &quot;1&quot;, text: idp.lang.get(&quot;CURRENT_PAGE&quot;) &#125;, &#123; id: &quot;2&quot;, text: idp.lang.get(&quot;ALL_PAGES&quot;) &#125;, &#123; id: &quot;3&quot;, text: idp.lang.get(&quot;SEL_PAGE_NUM&quot;) &#125;], onChangeValue: function(row) &#123; if (row &#x3D;&#x3D; &quot;3&quot;) &#123; $(&quot;.exportNumberWrap&quot;).show(); &#125; else &#123; $(&quot;.exportNumberWrap&quot;).hide(); &#125; &#125; &#125;); $(&quot;.exportNumberWrap&quot;).hide(); $(&quot;#exportSetStart,#exportSetEnd&quot;).leeTextBox(&#123; digits: true &#125;); idp.uiview._exportLoad &#x3D; true; &#125; $(&quot;body&quot;).css(&quot;overflow&quot;, &quot;auto&quot;); $.leeDialog.open(&#123; title: idp.lang.get(&quot;EXPORT_CONFIG&quot;), width: &quot;400&quot;, height: &#39;120&#39;, targetBody: true, target: $(&quot;#exportInfo&quot;), overflow: &quot;hidden&quot;, isResize: false, max: false, onStopResize: function() &#123;&#125;, buttons: [&#123; text: idp.lang.get(&quot;CANCEL&quot;), cls: &#39;lee-dialog-btn-cancel &#39;, onclick: function(item, dialog) &#123; dialog.close(); &#125; &#125;, &#123; text: idp.lang.get(&quot;OK&quot;), cls: &#39;lee-btn-primary lee-dialog-btn-ok&#39;, onclick: function(item, dialog) &#123; if (cex(id, sheetName)) &#123; dialog.close(); &#125; &#125; &#125;] &#125;); $(&quot;body&quot;).css(&quot;overflow&quot;, &quot;hidden&quot;); &#125; else &#123; cex(id, sheetName); &#125;&#125; 连接数据库写实体1234567891011121314151617181920212223242526272829303132333435363738394041424344@Data@Builder@NoArgsConstructor@AllArgsConstructor@Entity@DynamicUpdate@Table(name &#x3D; &quot;eaotag&quot;)public class EaoTagEntity &#123; @Id @Column(name &#x3D; &quot;id&quot;) private String id; @Basic @Column(name &#x3D; &quot;name&quot;) private String name; @Basic @Column(name &#x3D; &quot;orderNum&quot;) private int orderNum; @Basic @Column(name &#x3D;&quot;createdBy&quot;) private String createdBy; @Basic @Column(name &#x3D;&quot;createdOn&quot;) private Timestamp createdOn; @Basic @Column(name &#x3D; &quot;lastChangedBy&quot;) private String lastChangedBy; @Basic @Column(name &#x3D;&quot;lastChangedOn&quot;) private Timestamp lastChangedOn; @Basic @Column(name &#x3D; &quot;typeId&quot;) private String typeId;&#125; 用JPA写接口12345678&#x2F;&#x2F;包含多语字段用public interface EaoTagTypeRepository extends CafJpaRepository&lt;EaoTagTypeEntity,String&gt; &#123; EaoTagTypeEntity findByName(String name);&#125; 123456789101112131415161718192021222324252627282930public interface EaoTagRepository extends DataRepository&lt;EaoTagEntity,String&gt; &#123; int deleteByName(String name); int countByTypeId(String typeid); int deleteByOrderNum(int orderNum); @Query(&quot;SELECT max(orderNum) from EaoTagEntity WHERE typeId &#x3D; :typeId&quot;) Object getMaxOrOrderNum(@Param(&quot;typeId&quot;)String typeId); EaoTagEntity findByName(String name); @Override &lt;S extends EaoTagEntity&gt; S saveAndFlush(S s); @Override &lt;S extends EaoTagEntity&gt; S save(S s); @Modifying @Transactional @Query(&quot;update EaoTagEntity set typeId&#x3D;:typeId,orderNum&#x3D;:orderNum,createdBy&#x3D;:createdBy,createdOn&#x3D;:createdOn,lastChangedBy&#x3D;:lastChangedBy,lastChangedOn&#x3D;:lastChangedOn where name&#x3D;:name&quot;) int update(@Param(&quot;typeId&quot;) String typeId, @Param(&quot;orderNum&quot;) int orderNum,@Param(&quot;createdBy&quot;) String createdBy, @Param(&quot;createdOn&quot;) Timestamp createdOn, @Param(&quot;lastChangedBy&quot;) String lastChangedBy, @Param(&quot;lastChangedOn&quot;) Timestamp lastChangedOn, @Param(&quot;name&quot;) String name); @Override List&lt;EaoTagEntity&gt; findAll();&#125; API相关在api的包中新建webservice接口12345678910111213141516171819package com.inspur.gs.eao.pub.api.webservice;@Path(&quot;&#x2F;tag&quot;)@Produces(MediaType.APPLICATION_JSON)@Consumes(MediaType.APPLICATION_JSON)public interface EaoTagWebService &#123; @POST @Path(&quot;&#x2F;countByType&quot;) OperationResult countByType(List&lt;String&gt; ids) throws JsonProcessingException; @POST @Path(&quot;&#x2F;getOrderNum&quot;) OperationResult getOrderNum(String typeId); @POST @Path(&quot;&#x2F;excelImport&quot;) @Consumes(&#123;&quot;multipart&#x2F;form-data&quot;&#125;) OperationResult excelImport(@Multipart(&quot;file&quot;) Attachment var1);&#125; 在core中webservice(同级)写实现类注入需要的eaoTagRepository 1234567891011121314151617181920212223242526272829public class EaoTagWebServiceImpl implements EaoTagWebService &#123; private final EaoTagRepository eaoTagRepository; public EaoTagWebServiceImpl(EaoTagRepository eaoTagRepository) &#123; this.eaoTagRepository &#x3D; eaoTagRepository; &#125; @Override public OperationResult countByType(List&lt;String&gt; ids) throws JsonProcessingException &#123; List&lt;Integer&gt; nums&#x3D;new ArrayList&lt;Integer&gt;(); for (String id : ids) &#123; nums.add(eaoTagRepository.countByTypeId(id)); &#125;&#x2F;&#x2F; JsonNode ids &#x3D; jsonNode.get(&quot;ids&quot;);&#x2F;&#x2F; for (JsonNode id : ids) &#123;&#x2F;&#x2F; nums.add(eaoTagRepository.countByTypeId(id.toString()));&#x2F;&#x2F; &#125;&#x2F;&#x2F; System.out.println(nums); ObjectMapper objectMapper &#x3D; new ObjectMapper(); String nums_json &#x3D; objectMapper.writeValueAsString(nums); return new OperationResult(ResultType.SUCCESS,&quot;查询成功&quot;,nums); &#125;&#125; 放到spring中 前端调用1234567891011121314idp.service.fetch(&#39;&#x2F;api&#x2F;eao&#x2F;v1.0&#x2F;pub&#x2F;tag&#x2F;countByType&#39;, ids, false).done(function(data) &#123; console.log(data); var grid_data &#x3D; idp.control.get(&quot;grid_tagtype&quot;).getData(); for (var i &#x3D; 0; i &lt; grid_data.length; i++) &#123; var show_name &#x3D; grid_data[i][&quot;NAME$LANGUAGE$&quot;]; var index &#x3D; show_name.indexOf(&quot;(&quot;); var fname &#x3D; show_name.slice(0, index + 1) + data.appendData[i] + &quot;)&quot;; idp.control.get(&quot;grid_tagtype&quot;).updateRow(i, &#123; &quot;NAME$LANGUAGE$&quot;: fname &#125;); &#125; &#125;).fail(function(error) &#123; console.log(error); &#125;); 扩展相关在core.service包中写xxxservice类,注入eaoTagRepository123456789101112@Transactionalpublic class EaoTagTypeServiceImpl implements IExcelImportEvent&#123; private final EaoTagTypeRepository eaoTagTypeRepository; private final EaoTagRepository eaoTagRepository; public EaoTagTypeServiceImpl(EaoTagTypeRepository eaoTagTypeRepository, EaoTagRepository eaoTagRepository) &#123; this.eaoTagTypeRepository &#x3D; eaoTagTypeRepository; this.eaoTagRepository &#x3D; eaoTagRepository; &#125;&#125; 放入spring(core.config.DemoAutoConfiguration)1234@Beanpublic EaoTagTypeServiceImpl eaoTagTypeService(EaoTagTypeRepository eaoTagTypeRepository, EaoTagRepository eaoTagRepository)&#123; return new EaoTagTypeServiceImpl(eaoTagTypeRepository, eaoTagRepository);&#125; 功能相关日期格式化12345678910111213141516Date.prototype.Format = function(fmt) &#123; var o = &#123; \"M+\": this.getMonth() + 1, //月份 \"d+\": this.getDate(), //日 \"H+\": this.getHours(), //小时 \"m+\": this.getMinutes(), //分 \"s+\": this.getSeconds(), //秒 \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度 \"S\": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return fmt;&#125;//var dateStr=new Date().Format(\"yyMMdd\"); 数字格式化123456789function formatNum(number, len, ch) &#123; ch &#x3D; &quot;&quot; + ch; number &#x3D; &quot;&quot; + number; var strLength &#x3D; len - number.length; &#x2F;&#x2F;格式长度减去数字的长度，就是数字前补&quot;0&quot;的个数 for (var i &#x3D; 0; i &lt; strLength; i++) &#123; number &#x3D; ch + number; &#125; return number; &#125;","categories":[{"name":"js","slug":"js","permalink":"https://donghuangzhong.github.io/categories/js/"},{"name":"常用js","slug":"js/常用js","permalink":"https://donghuangzhong.github.io/categories/js/%E5%B8%B8%E7%94%A8js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://donghuangzhong.github.io/tags/js/"}]},{"title":"idea","slug":"idea","date":"2021-03-17T01:27:30.000Z","updated":"2021-07-01T02:11:37.904Z","comments":true,"path":"2021/03/17/idea/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/17/idea/","excerpt":"记录idea的相关操作","text":"记录idea的相关操作 对齐注释file–&gt;settings–&gt;editor–&gt;code style–&gt;xml 取消勾选Line comment at first column 或者 idea 设置maven 自动更新","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"idea","slug":"java/idea","permalink":"https://donghuangzhong.github.io/categories/java/idea/"}],"tags":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/tags/java/"},{"name":"idea","slug":"idea","permalink":"https://donghuangzhong.github.io/tags/idea/"}]},{"title":"spring_boot","slug":"spring-boot","date":"2021-03-16T05:40:40.000Z","updated":"2021-06-24T11:42:13.175Z","comments":true,"path":"2021/03/16/spring-boot/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/16/spring-boot/","excerpt":"摘要","text":"摘要 Spring Boot概述Spring Boot是一个便捷搭建 基于spring工程的脚手架；作用是帮助开发人员快速搭建大型的spring 项目。简化工程的配置，依赖管理；实现开发人员把时间都集中在业务开发上。 spring的优缺点 优点 1Spring是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的Enterprise JavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。 缺点 12345虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。 springBoot的特点 为基于Spring的开发提供更快的入门体验 开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等 SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式 Spring Boot入门实现可以在浏览器中访问http://localhost:8080/hello输出一串字符 创建一个普通的maven工程 添加SpringBoot的起步依赖 SpringBoot要求，项目要继承SpringBoot的起步依赖spring-boot-starter-parent SpringBoot要集成SpringMVC进行Controller的开发，所以项目要导入web的启动依赖 修改pom.xml 123456789101112131415&lt;!--继承SpringBoot的起步依赖spring-boot-starter-parent--&gt;&lt;parent&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;version&gt;2.3.9.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt;&lt;!--导入web的启动依赖--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3.9.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 编写启动类要通过SpringBoot提供的引导类起步SpringBoot才可以进行访问，注意该类不能从组件的默认包启动，所以需要建立一个包，然后将引导类放入其中。 123456@SpringBootApplicationpublic class AppRun &#123; public static void main(String[] args) &#123; SpringApplication.run(AppRun.class,args); &#125;&#125; 编写Controller12345678910@Controllerpublic class TestController &#123; @RequestMapping(&quot;hello&quot;) @ResponseBody String hello()&#123; return &quot;hello spring_boot&quot;; &#125;&#125; 运行启动类中的main方测试网址：http://localhost:8080/hello 原始注入方式可以使用@Value获取配置文件配置项并结合@Bean注册组件到Spring jdbc.properties:（在resources目录下） 1234jdbc.driverClassName&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testjdbc.username&#x3D;rootjdbc.password&#x3D;root spring配置类config: 123456789101112131415161718192021222324252627@Configuration@PropertySource(\"classpath:jdbc.properties\")public class Config &#123; @Value(\"$&#123;jdbc.driverClassName&#125;\") private String driverClassName; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean DataSource druid()&#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(driverClassName); druidDataSource.setUrl(url); druidDataSource.setUsername(username); druidDataSource.setPassword(password); return druidDataSource; &#125;&#125; Spring Boot属性注入方式名字必须为application.properties或application.yml 复杂方式(不推荐)创建application.properties文件(resources目录下)1234jdbc.driverClassName&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testjdbc.username&#x3D;rootjdbc.password&#x3D;root 创建配置项类JdbcProperties类并加注解12345678910111213141516171819202122232425262728293031323334353637383940@Component &#x2F;&#x2F;与ConfigurationProperties搭配使用(注入时)@ConfigurationProperties(prefix &#x3D; &quot;jdbc&quot;)public class JdbcProperties &#123; private String driverClassName; private String url; private String username; private String password; public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName &#x3D; driverClassName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url &#x3D; url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username &#x3D; username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password &#x3D; password; &#125;&#125; 在spring的配置类中通过函数参数注入JdbcProperties12345678910@BeanDataSource druid(JdbcProperties jdbcProperties)&#123; DruidDataSource druidDataSource &#x3D; new DruidDataSource(); druidDataSource.setDriverClassName(jdbcProperties.getDriverClassName()); druidDataSource.setUrl(jdbcProperties.getUrl()); druidDataSource.setUsername(jdbcProperties.getUsername()); druidDataSource.setPassword(jdbcProperties.getPassword()); return druidDataSource;&#125; 简单方式（推荐）需求：将配置文件中的配置项读取到一个对象中； 实现：可以使用Spring Boot提供的注解@ConfigurationProperties，该注解可以将Spring Boot的配置文件（默认必须为application.properties或application.yml）中的配置项读取到一个对象中。 创建application.properties文件(resources目录下)1234jdbc.driverClassName&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testjdbc.username&#x3D;rootjdbc.password&#x3D;root 使用@ConfigurationProperties在方法上面使用在spring的配置类中，会按照属性名对应自动注入 12345@Bean@ConfigurationProperties(prefix = \"pjdbc\")public DataSource dataSource() &#123; return new DruidDataSource();&#125; 多个yml文件配置yaml与properties配置文件除了展示形式不相同以外，其它功能和作用都是一样的；在项目中原路的读取方式不需要改变。 1）yml配置文件的特征： 树状层级结构展示配置项； 配置项之间如果有关系的话需要分行空两格； 配置项如果有值的话，那么需要在 :之后空一格再写配置项值； 将application.properties配置文件修改为application.yml的话： 123456789101112jdbc: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/heima username: root password: rootkey: abc: cba def://集合或列表 - g - h - j 2）多个yml配置文件；在spring boot中是被允许的。这些配置文件的名称必须为application-***.yml，并且这些配置文件必须要在application.yml配置文件中激活之后才可以使用。 1234#激活配置文件;需要指定其它的配置文件名称spring: profiles: active: abc,def &#x2F;&#x2F;abc对应application-abc.yml 3）如果properties和yml配置文件同时存在在spring boot项目中；那么这两类配置文件都有效。在两个配置文件中如果存在同名的配置项的话会以properties文件的为主。 自动配置原理目标：了解Spring Boot项目的配置加载流程 小结： 在 External Libraries\\*spring-boot-autocnfig\\META-INF\\spring.fatories文件中定义了很多自动配置类；可以根据在pom.xml文件中添加的 启动器依赖自动配置组件 通过如下流程可以去修改application配置文件，改变自动配置的组件默认参数 在org.springframework.boot.autoconfigure中分类的文件夹下找jar包 对应的xxxProperties中有个prefix，代表本类前缀，通过prefix.属性名就可以修改 修改tomcat端口示例找到相关的xxxProperties文件，查看prefix端口相关的在web文件夹下的org.springframework.boot.autoconfigure.web.ServerProperties 12 修改application.properties lombok应用 编写数据库表对应的实体类；一般情况下需要编写get/set/toString等这些方法会耗时并且会让实体类看起来比较臃肿。可以使用lombok插件对实体类进行简化。 lombok是一个插件工具类包；提供了一些注解@Data、@Getter等这些注解去简化实体类中的构造方法、get/set等方法的编写。 在IDEA中安装lombok插件； 添加lombok对应的依赖到项目pom.xml文件； 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 改造实体类使用lombok注解 在Bean上使用的注解：@Data ：自动提供getter和setter、hashCode、equals、toString等方法@Getter：自动提供getter方法@Setter：自动提供setter方法@Slf4j：自动在bean中提供log变量，其实用的是slf4j的日志功能。 Spring Boot整合-SpringMVC静态资源 在spring boot项目中静态资源可以放置在如下目录： 访问时不用加前缀，直接localhost+资源名称，例如localhost/test.jpg Spring Boot整合-SpringMVC拦截器目标：可以在Spring Boot项目中配置自定义SpringMVC拦截器 分析： 编写拦截器（实现HandlerInterceptor）； 编写配置类实现 WebMvcConfigurer，在该类中添加各种组件； 测试 编写拦截器（实现HandlerInterceptor）123456789101112131415161718public class MyIntercepter implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle running&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle running&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion running&quot;); &#125;&#125; 编写配置类实现 WebMvcConfigurer，重写方法添加12345678910111213@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Bean MyIntercepter myIntercepter()&#123; return new MyIntercepter(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyIntercepter()).addPathPatterns(&quot;&#x2F;*&quot;); &#125;&#125; Spring Boot整合-事务和连接池数据库声明 事务配置 添加事务相关的启动器依赖，mysql相关依赖； 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 编写业务类UserService使用事务注解@Transactional 整合hikari连接池 修改application.yml 123456spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test username: root password: root 测试即可 Spring Boot整合-Mybatis目标：配置Mybatis在Spring Boot工程中的整合包，设置mybatis的实体类别名，输出执行sql语句配置项 分析： 添加启动器依赖； 配置Mybatis：实体类别名包，日志，映射文件等； 配置MapperScan 小结： 添加mybatis官方对于spring boot的一个启动器 123456&lt;!--mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt; 配置mybatis 1234567mybatis: # 实体类别名包路径 type-aliases-package: com.itheima.pojo # 映射文件路径 # mapper-locations: classpath:mappers/*.xml configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 设置启动器类中的mapper扫描 Spring Boot整合-通用Mapper目标：配置通用Mapper组件到Spring Boot项目中并使用Mapper接口 分析： 通用Mapper：可以实现自动拼接sql语句；所有的mapper都不需要编写任何方法也就是不用编写sql语句。可以提高开发效率。 添加启动器依赖； 123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.5&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 修改User实体类添加jpa注解； @KeySql(useGeneratedKeys = true)为主键回填 其他字段的可以不填，主键的 @Id@Column(name = “id”)必填 123456789101112131415161718@Data@Table(name = \"user\")public class User &#123; @Id @KeySql(useGeneratedKeys = true) @Column(name = \"id\") private int id; @Column(name = \"username\") private String username; @Column(name = \"password\") private String password; @Column(name = \"birthday\") private String birthday;&#125; 改造UserMapper继承Mapper； 12345import com.dhz.pojo.User;import tk.mybatis.mapper.common.Mapper;public interface UserMapper extends Mapper&lt;User&gt;&#123;&#125; 修改启动引导类Application中的Mapper扫描注解； import tk.mybatis.spring.annotation.MapperScan;用的是这个mapperscan 1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import tk.mybatis.spring.annotation.MapperScan;@SpringBootApplication@MapperScan(&quot;com.dhz.mapper&quot;)public class AppRun &#123; public static void main(String[] args) &#123; SpringApplication.run(AppRun.class,args); &#125;&#125; 改造UserService实现业务功能； 在启动引导类上面的mapper扫描注解 一定要修改为 通用mapper的扫描注解 Spring Boot整合-Junit 添加启动器依赖spring-boot-starter-test； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 光标移动到要测试的方法上按ctrl+shift+t,勾选要测试的方法，自动生成测试类 加注解，注入测试 123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class UserServiceTest &#123; @Autowired private UserService userService; @Test public void findAll() &#123; System.out.println(userService.findAll()); &#125;&#125; 在Spring Boot项目中如果编写测试类则必须要在类上面添加@SpringBootTest Spring Boot整合-redis 添加启动器依赖；spring-boot-starter-data-redis 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 配置application.yml中修改redis的连接参数；（redis需要启动） 1234spring: redis: host: localhost port: 6379 编写测试类应用RedisTemplate操作redis中的5种数据类型（string/hash/list/set/sorted set） 123456789101112131415161718192021222324252627282930313233343536373839404142434445@RunWith(SpringRunner.class)@SpringBootTestpublic class RedisTest &#123; @Autowired private RedisTemplate redisTemplate; @Test public void test()&#123; &#x2F;&#x2F;string 字符串 &#x2F;&#x2F;redisTemplate.opsForValue().set(&quot;str&quot;, &quot;heima&quot;); redisTemplate.boundValueOps(&quot;str&quot;).set(&quot;zhangsan&quot;); System.out.println(&quot;str &#x3D; &quot; + redisTemplate.opsForValue().get(&quot;str&quot;)); &#x2F;&#x2F;hash 散列 redisTemplate.boundHashOps(&quot;h_key&quot;).put(&quot;name&quot;, &quot;zhangsan&quot;); redisTemplate.boundHashOps(&quot;h_key&quot;).put(&quot;age&quot;, 13); &#x2F;&#x2F;获取所有域 Set set &#x3D; redisTemplate.boundHashOps(&quot;h_key&quot;).keys(); System.out.println(&quot; hash散列的所有域：&quot; + set); &#x2F;&#x2F;获取所有值 List list &#x3D; redisTemplate.boundHashOps(&quot;h_key&quot;).values(); System.out.println(&quot; hash散列的所有域的值：&quot; + list); &#x2F;&#x2F;list 列表 redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;c&quot;); redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;b&quot;); redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;a&quot;); &#x2F;&#x2F;获取全部元素 list &#x3D; redisTemplate.boundListOps(&quot;l_key&quot;).range(0, -1); System.out.println(&quot; list列表中的所有元素：&quot; + list); &#x2F;&#x2F; set 集合 redisTemplate.boundSetOps(&quot;s_key&quot;).add(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); set &#x3D; redisTemplate.boundSetOps(&quot;s_key&quot;).members(); System.out.println(&quot; set集合中的所有元素：&quot; + set); &#x2F;&#x2F; sorted set 有序集合 redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;a&quot;, 30); redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;b&quot;, 20); redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;c&quot;, 10); set &#x3D; redisTemplate.boundZSetOps(&quot;z_key&quot;).range(0, -1); System.out.println(&quot; zset有序集合中的所有元素：&quot; + set); &#125;&#125; Spring Boot项目部署 添加打包组件，后maven-&gt;pacage 123456789&lt;build&gt; &lt;plugins&gt; &lt;!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 部署运行 1java -jar 包名","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"},{"name":"spring_boot","slug":"spring-boot","permalink":"https://donghuangzhong.github.io/tags/spring-boot/"}]},{"title":"Redis","slug":"Redis","date":"2021-03-03T23:22:40.000Z","updated":"2021-07-10T01:12:50.922Z","comments":true,"path":"2021/03/04/Redis/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/04/Redis/","excerpt":"redis 概念 下载安装 命令操作 数据结构 持久化操作 使用Java客户端操作redis","text":"redis 概念 下载安装 命令操作 数据结构 持久化操作 使用Java客户端操作redis 概述 概念： redis是一款高性能的NOSQL系列的非关系型数据库 NOSQL：NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 NOSQL和关系型数据库比较 12345678910111213141516171819优点：1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。缺点：1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。3）不提供关系型数据库对事务的处理。非关系型数据库的优势：1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。关系型数据库的优势：1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 支持的数据类型 123451) 字符串类型 string2) 哈希类型 hash3) 列表类型 list4) 集合类型 set5) 有序集合类型 sortedset redis的应用场景 1234567• 缓存（数据查询、短连接、新闻内容、商品内容等等）• 聊天室的在线好友列表• 任务队列。（秒杀、抢购、12306等等）• 应用排行榜• 网站访问统计• 数据过期处理（可以精确到毫秒• 分布式集群架构中的session分离 下载安装1234561. 官网：https:&#x2F;&#x2F;redis.io2. 中文网：http:&#x2F;&#x2F;www.redis.net.cn&#x2F;3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 注册为系统服务 1234567注册服务 redis-server --service-install redis.windows.conf删除服务 redis-server --service-uninstall开启服务 redis-server --service-start停止服务 redis-server --service-stop 命令操作12345678redis的数据结构：* redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 字符串类型 string1234567891. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot;3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 哈希类型 hash123456789101112131415161718191. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 12. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 列表类型 list123456789101112131415161718192021列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 集合类型 set123456789101112集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 有序集合类型 sortedset12345678910111213141516171819202122232425有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 通用命令1231. keys * : 查询所有的键2. type key ： 获取键对应的value的类型3. del key：删除指定的key value 持久化redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 123456789101112131415161718192021redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 Java客户端 Jedis Jedis: 一款java操作redis数据库的工具. 持久化：redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 使用步骤 下载jedis的jar包 使用 123456&#x2F;&#x2F;1. 获取连接 Jedis jedis &#x3D; new Jedis(&quot;localhost&quot;,6379); &#x2F;&#x2F;2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); &#x2F;&#x2F;3. 关闭连接 jedis.close(); Jedis操作各种redis中的数据结构字符串类型 string1234567891011121314151617setget&#x2F;&#x2F;1. 获取连接Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口&#x2F;&#x2F;2. 操作&#x2F;&#x2F;存储jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);&#x2F;&#x2F;获取String username &#x3D; jedis.get(&quot;username&quot;);System.out.println(username);&#x2F;&#x2F;可以使用setex()方法存储可以指定过期时间的 key valuejedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);&#x2F;&#x2F;将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对&#x2F;&#x2F;3. 关闭连接jedis.close(); 哈希类型 hash ： map格式1234567891011121314151617181920212223242526272829hsethgethgetAll&#x2F;&#x2F;1. 获取连接Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口&#x2F;&#x2F;2. 操作&#x2F;&#x2F; 存储hashjedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;);jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;);jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;);&#x2F;&#x2F; 获取hashString name &#x3D; jedis.hget(&quot;user&quot;, &quot;name&quot;);System.out.println(name);&#x2F;&#x2F; 获取hash的所有map中的数据Map&lt;String, String&gt; user &#x3D; jedis.hgetAll(&quot;user&quot;);&#x2F;&#x2F; keysetSet&lt;String&gt; keySet &#x3D; user.keySet();for (String key : keySet) &#123;&#x2F;&#x2F;获取valueString value &#x3D; user.get(key);System.out.println(key + &quot;:&quot; + value);&#125;&#x2F;&#x2F;3. 关闭连接jedis.close(); 列表类型 list ： linkedlist格式。支持重复元素12345678910111213141516171819202122232425262728lpush &#x2F; rpushlpop &#x2F; rpoplrange start end : 范围获取&#x2F;&#x2F;1. 获取连接Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口&#x2F;&#x2F;2. 操作&#x2F;&#x2F; list 存储jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);&#x2F;&#x2F;从左边存jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);&#x2F;&#x2F;从右边存&#x2F;&#x2F; list 范围获取List&lt;String&gt; mylist &#x3D; jedis.lrange(&quot;mylist&quot;, 0, -1);System.out.println(mylist);&#x2F;&#x2F; list 弹出String element1 &#x3D; jedis.lpop(&quot;mylist&quot;);&#x2F;&#x2F;cSystem.out.println(element1);String element2 &#x3D; jedis.rpop(&quot;mylist&quot;);&#x2F;&#x2F;cSystem.out.println(element2);&#x2F;&#x2F; list 范围获取List&lt;String&gt; mylist2 &#x3D; jedis.lrange(&quot;mylist&quot;, 0, -1);System.out.println(mylist2);&#x2F;&#x2F;3. 关闭连接jedis.close(); 集合类型 set ： 不允许重复元素123456789101112131415saddsmembers:获取所有元素&#x2F;&#x2F;1. 获取连接Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口&#x2F;&#x2F;2. 操作&#x2F;&#x2F; set 存储jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;);&#x2F;&#x2F; set 获取Set&lt;String&gt; myset &#x3D; jedis.smembers(&quot;myset&quot;);System.out.println(myset);&#x2F;&#x2F;3. 关闭连接jedis.close(); 有序集合类型 sortedset：不允许重复元素，且元素有顺序zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close();jedis连接池： JedisPool使用123456789101112131415161. 创建JedisPool连接池对象2. 调用方法 getResource()方法获取Jedis连接&#x2F;&#x2F;0.创建一个配置对象JedisPoolConfig config &#x3D; new JedisPoolConfig();config.setMaxTotal(50);config.setMaxIdle(10);&#x2F;&#x2F;1.创建Jedis连接池对象JedisPool jedisPool &#x3D; new JedisPool(config,&quot;localhost&quot;,6379);&#x2F;&#x2F;2.获取连接Jedis jedis &#x3D; jedisPool.getResource();&#x2F;&#x2F;3. 使用jedis.set(&quot;hehe&quot;,&quot;heihei&quot;);&#x2F;&#x2F;4. 关闭 归还到连接池中jedis.close(); 连接池工具类12345678910111213141516171819202122232425262728293031public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; &#x2F;&#x2F;读取配置文件 InputStream is &#x3D; JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); &#x2F;&#x2F;创建Properties对象 Properties pro &#x3D; new Properties(); &#x2F;&#x2F;关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;获取数据，设置到JedisPoolConfig中 JedisPoolConfig config &#x3D; new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); &#x2F;&#x2F;初始化JedisPool jedisPool &#x3D; new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); &#125; &#x2F;** * 获取连接方法 *&#x2F; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; ​","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://donghuangzhong.github.io/tags/redis/"}]},{"title":"Cookie&Session","slug":"Cookie-Session","date":"2021-03-03T09:46:32.000Z","updated":"2021-03-04T23:52:59.162Z","comments":true,"path":"2021/03/03/Cookie-Session/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/03/Cookie-Session/","excerpt":"会话技术 Cookie Session","text":"会话技术 Cookie Session 会话技术1. 会话：一次会话中包含多次请求和响应。 * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 2. 功能：在一次会话的范围内的多次请求间，共享数据 3. 方式： 1. 客户端会话技术：Cookie 2. 服务器端会话技术：SessionCookie： 客户端会话技术，将数据保存到客户端 实现原理：基于响应头set-cookie和请求头cookie实现 使用步骤1234561. 创建Cookie对象，绑定数据 * new Cookie(String name, String value) 2. 发送Cookie对象 * response.addCookie(Cookie cookie) 3. 获取Cookie，拿到数据 * Cookie[] request.getCookies() cookie的细节12345678910111213141516171819202122232425262728293031323334351. 一次可不可以发送多个cookie? * 可以 * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。2. cookie在浏览器中保存多长时间？ 1. 默认情况下，当浏览器关闭后，Cookie数据被销毁 2. 持久化存储： * setMaxAge(int seconds) 1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 2. 负数：默认值 3. 零：删除cookie信息 3. cookie能不能存中文？ * 在tomcat 8 之前 cookie中不能直接存储中文数据。 * 需要将中文数据转码---一般采用URL编码(%E3) * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 4. cookie共享问题？ 1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ * 默认情况下cookie不能共享 * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 * 如果要共享，则可以将path设置为&quot;&#x2F;&quot; 2. 不同的tomcat服务器间cookie共享问题？ * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享 5. Cookie的特点和作用 1. cookie存储数据在客户端浏览器 2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) * 作用： 1. cookie一般用于存出少量的不太敏感的数据 2. 在不登录的情况下，完成服务器对客户端的身份识别 案例：记住上一次访问时间 需求分析 1234567891011121314151. 需求： 1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 2. 分析： 1. 可以采用Cookie来完成 2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie 1. 有：不是第一次访问 1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20 2. 写回Cookie：lastTime&#x3D;2018年6月10日11:50:01 2. 没有：是第一次访问 1. 响应数据：您好，欢迎您首次访问 2. 写回Cookie：lastTime&#x3D;2018年6月10日11:50:01 3.注意事项 建议使用url编解码，因为不支持空格等特殊字符 代码 1234567891011121314151617181920212223242526272829303132@WebServlet(&quot;&#x2F;cookie&quot;)public class CookieServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); boolean flag&#x3D;false; Cookie[] cookies &#x3D; req.getCookies(); if (cookies!&#x3D;null&amp;&amp;cookies.length&gt;0) &#123; for (Cookie cookie : cookies) &#123; if (&quot;lastTime&quot;.equals(cookie.getName()))&#123; resp.getWriter().write(&quot;欢迎回来您上一次访问本网站的时间是&quot;+ URLDecoder.decode(cookie.getValue(),&quot;utf-8&quot;)); flag&#x3D;true; break; &#125;&#125; if(flag&#x3D;&#x3D;false)resp.getWriter().write(&quot;欢迎您，这是您第一次访问本网站&quot;); &#125;else &#123; resp.getWriter().write(&quot;欢迎您，这是您第一次访问本网站&quot;); &#125; SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy年MM月d日 HH:mm:ss&quot;); Cookie coo &#x3D; new Cookie(&quot;lastTime&quot;, URLEncoder.encode(simpleDateFormat.format(new Date()),&quot;utf-8&quot;)); coo.setMaxAge(60); resp.addCookie(coo); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125;&#125; Session：主菜 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。 原理：Session的实现是依赖于Cookie的。 使用步骤1234567快速入门： 1. 获取HttpSession对象： HttpSession session &#x3D; request.getSession(); 2. 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) session的细节12345678910111213141516171819202122232425262728291. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ * 默认情况下。不是。 * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c &#x3D; new Cookie(&quot;JSESSIONID&quot;,session.getId()); c.setMaxAge(60*60); response.addCookie(c);2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 * session的钝化： * 在服务器正常关闭之前，将session对象系列化到硬盘上 * session的活化： * 在服务器启动后，将session文件转化为内存中的session对象即可。 3. session什么时候被销毁？ 1. 服务器关闭 2. session对象调用invalidate() 。 3. session默认失效时间 30分钟 选择性配置修改 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt; &lt;&#x2F;session-config&gt; 4. session的特点 1. session用于存储一次会话的多次请求的数据，存在服务器端 2. session可以存储任意类型，任意大小的数据 * session与Cookie的区别： 1. session存储数据在服务器端，Cookie在客户端 2. session没有数据大小限制，Cookie有 3. session数据安全，Cookie相对于不安全 案例：验证码1. 案例需求： 1. 访问带有验证码的登录页面login.jsp 2. 用户输入用户名，密码以及验证码。 * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 * 如果验证码输入有误，跳转登录页面，提示：验证码错误 * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 2. 分析：​","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"web相关","slug":"java/web相关","permalink":"https://donghuangzhong.github.io/categories/java/web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"cookie","slug":"cookie","permalink":"https://donghuangzhong.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"https://donghuangzhong.github.io/tags/session/"}]},{"title":"Response","slug":"Response","date":"2021-03-03T09:39:16.000Z","updated":"2021-03-04T10:53:10.641Z","comments":true,"path":"2021/03/03/Response/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/03/Response/","excerpt":"HTTP协议：响应消息 Response对象 ServletContext对象","text":"HTTP协议：响应消息 Response对象 ServletContext对象 请求消息 响应消息：服务器端发送给客户端的数据 数据格式 12341. 响应行2. 响应头3. 响应空行4. 响应体 响应行123456789101112131. 响应行 1. 组成：协议&#x2F;版本 响应状态码 状态码描述 2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1. 状态码都是3位数字 2. 分类： 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误。 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头123456782. 响应头： 1. 格式：头名称： 值 2. 常见的响应头： 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据 * 值： * in-line:默认值,在当前页面内打开 * attachment;filename&#x3D;xxx：以附件形式打开响应体。文件下载 响应空行响应体:传输的数据123456789101112131415* 响应字符串格式 HTTP&#x2F;1.1 200 OK Content-Type: text&#x2F;html;charset&#x3D;UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; hello , response &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; Response对象设置响应行1231. 设置响应行 1. 格式：HTTP&#x2F;1.1 200 ok 2. 设置状态码：setStatus(int sc) 设置响应头12. 设置响应头：setHeader(String name, String value) 特殊的设置响应格式 1response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); 设置响应体123456783. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 重定向12&#x2F;&#x2F;简单的重定向方法response.sendRedirect(&quot;&#x2F;day15&#x2F;responseDemo2&quot;); 重定向和转发的区别 12345678* 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据* 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 路径相关相对路径12345671. 相对路径：通过相对路径不可以确定唯一资源 * 如：.&#x2F;index.html * 不以&#x2F;开头，以.开头路径 * 规则：找到当前资源和目标资源之间的相对位置关系 * .&#x2F;：当前目录 * ..&#x2F;:后退一级目录 绝对路径1232. 绝对路径：通过绝对路径可以确定唯一资源 * 如：http:&#x2F;&#x2F;localhost&#x2F;day15&#x2F;responseDemo2 &#x2F;day15&#x2F;responseDemo2 * 以&#x2F;开头的路径 规则123456* 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * &lt;a&gt; , &lt;form&gt; 重定向... * 给服务器使用：不需要加虚拟目录 * 转发路径 乱码问题123456* 乱码问题： 1. PrintWriter pw &#x3D; response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); &#x2F;&#x2F;简单的形式，设置编码，是在获取流之前设置 ServletContext对象： 概念：代表整个web应用，可以和程序的容器(服务器)来通信 获取123452. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); 功能1234567891011121314151617181920211. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型&#x2F;小类型 text&#x2F;html image&#x2F;jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) String b &#x3D; context.getRealPath(&quot;&#x2F;b.txt&quot;);&#x2F;&#x2F;web目录下资源访问 System.out.println(b); String c &#x3D; context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;c.txt&quot;);&#x2F;&#x2F;WEB-INF目录下的资源访问 System.out.println(c); String a &#x3D; context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;a.txt&quot;);&#x2F;&#x2F;src目录下的资源访问 System.out.println(a); 案例：文件下载1234* 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载 12345* 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： * content-disposition:attachment;filename&#x3D;xxx 1234567* 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename&#x3D;xxx 4. 将数据写出到response输出流 12345* 问题： * 中文文件问题 * 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"web相关","slug":"java/web相关","permalink":"https://donghuangzhong.github.io/categories/java/web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"response","slug":"response","permalink":"https://donghuangzhong.github.io/tags/response/"}]},{"title":"Servlet&HTTP&Request","slug":"Servlet-HTTP-Request","date":"2021-03-03T08:45:58.000Z","updated":"2021-03-04T10:10:32.642Z","comments":true,"path":"2021/03/03/Servlet-HTTP-Request/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/03/Servlet-HTTP-Request/","excerpt":"Servlet HTTP协议 Request","text":"Servlet HTTP协议 Request Servlet：Servlet的体系结构123456789101112Servlet -- 接口 |GenericServlet -- 抽象类 |HttpServlet -- 抽象类* GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可* HttpServlet：对http协议的一种封装，简化操作 1. 定义类继承HttpServlet 2. 复写doGet&#x2F;doPost方法 Servlet相关配置1234561. urlpartten:Servlet访问路径 1. 一个Servlet可以定义多个访问路径 ： @WebServlet(&#123;&quot;&#x2F;d4&quot;,&quot;&#x2F;dd4&quot;,&quot;&#x2F;ddd4&quot;&#125;) 2. 路径定义规则： 1. &#x2F;xxx：路径匹配 2. &#x2F;xxx&#x2F;xxx:多层路径，目录结构 3. *.do：扩展名匹配 HTTP： 概念：Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了客户端和服务器端通信时，发送数据的格式 特点 12341. 基于TCP&#x2F;IP的高级协议2. 默认端口号:803. 基于请求&#x2F;响应模型的:一次请求对应一次响应4. 无状态的：每次请求之间相互独立，不能交互数据 历史版本 12* 1.0：每一次请求响应都会建立新的连接* 1.1：复用连接 请求消息数据格式请求行12345678910111213请求方式 请求url 请求协议&#x2F;版本GET &#x2F;login.html HTTP&#x2F;1.1* 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 请求头客户端浏览器告诉服务器一些信息 12345678910请求头名称: 请求头值* 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http:&#x2F;&#x2F;localhost&#x2F;login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 请求空行空行，就是用于分割POST请求的请求头，和请求体的。 请求体(正文)封装POST请求消息的请求参数的 123456789101112* 字符串格式：POST &#x2F;login.html HTTP&#x2F;1.1Host: localhostUser-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko&#x2F;20100101 Firefox&#x2F;60.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateReferer: http:&#x2F;&#x2F;localhost&#x2F;login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1username&#x3D;zhangsan Request：request对象和response对象的原理 request和response对象是由服务器创建的。我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 request对象继承体系结构123456request对象继承体系结构： ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat) request功能获取请求行数据12345678910111213141516171819202122* GET &#x2F;day14&#x2F;demo1?name&#x3D;zhangsan HTTP&#x2F;1.1* 方法： 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：&#x2F;day14 * String getContextPath() 3. 获取Servlet路径: &#x2F;demo1 * String getServletPath() 4. 获取get方式请求参数：name&#x3D;zhangsan * String getQueryString() 5. (*)获取请求URI：&#x2F;day14&#x2F;demo1 * String getRequestURI(): &#x2F;day14&#x2F;demo1 * StringBuffer getRequestURL() :http:&#x2F;&#x2F;localhost&#x2F;day14&#x2F;demo1 * URL:统一资源定位符 ： http:&#x2F;&#x2F;localhost&#x2F;day14&#x2F;demo1 中华人民共和国 * URI：统一资源标识符 : &#x2F;day14&#x2F;demo1 共和国 6. 获取协议及版本：HTTP&#x2F;1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() 获取请求头数据123* 方法： * (*)String getHeader(String name):通过请求头的名称获取请求头的值 * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 获取请求体数据12345678* 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数* 步骤： 1. 获取流对象 * BufferedReader getReader()：获取字符输入流，只能操作字符数据 * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 * 在文件上传知识点后讲解 2. 再从流对象中拿数据 获取请求参数通用方式1234567891011121314不论get还是post请求方式都可以使用下列方法来获取请求参数1. String getParameter(String name):根据参数名称获取参数值 username&#x3D;zs&amp;password&#x3D;1232. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby&#x3D;xx&amp;hobby&#x3D;game3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合* 中文乱码问题： * get方式：tomcat 8 已经将get方式乱码问题解决了 * post方式：会乱码 * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;); 请求转发123456789一种在服务器内部的资源跳转方式1. 步骤： 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 2. 特点： 1. 浏览器地址栏路径不发生变化 2. 只能转发到当前服务器内部资源中。 3. 转发是一次请求 共享数据1234567共享数据： * 域对象：一个有作用范围的对象，可以在范围内共享数据 * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 * 方法： 1. void setAttribute(String name,Object obj):存储数据 2. Object getAttitude(String name):通过键获取值 3. void removeAttribute(String name):通过键移除键值对 获取ServletContext1ServletContext getServletContext() BeanUtils工具类1234567891011121314151617BeanUtils工具类，简化数据封装 * 用于封装JavaBean的 1. JavaBean：标准的Java类 1. 要求： 1. 类必须被public修饰 2. 必须提供空参的构造器 3. 成员变量必须使用private修饰 4. 提供公共setter和getter方法 2. 功能：封装数据 2. 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() --&gt; Username--&gt; username 3. 方法： 1. setProperty() 2. getProperty() 3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"web相关","slug":"java/web相关","permalink":"https://donghuangzhong.github.io/categories/java/web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/tags/java/"},{"name":"web","slug":"web","permalink":"https://donghuangzhong.github.io/tags/web/"}]},{"title":"Mybatis_多表+注解","slug":"Mybatis-多表-注解","date":"2021-02-25T06:57:41.000Z","updated":"2021-05-26T02:25:18.127Z","comments":true,"path":"2021/02/25/Mybatis-多表-注解/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/25/Mybatis-%E5%A4%9A%E8%A1%A8-%E6%B3%A8%E8%A7%A3/","excerpt":"Mybatis注解方式 分步查询","text":"Mybatis注解方式 分步查询 1.Mybatis多表查询一对一查询一对一查询的模型MapperScannerConfigurer用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询的语句对应的sql语句：select * from orders o,user u where o.uid=u.id; 查询的结果如下： 创建Order和User实体123456789101112131415161718public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125;public class User &#123; private int id; private String username; private String password; private Date birthday;&#125; 创建OrderMapper接口123public interface OrderMapper &#123; List&lt;Order&gt; findAll();&#125; 配置OrderMapper.xml无歧义不用单独配 123456789101112&lt;mapper namespace=\"com.dhz.mapper.OrderMapper\"&gt; &lt;resultMap id=\"orderMap\" type=\"order\"&gt; &lt;id column=\"oid\" property=\"id\"/&gt; &lt;result column=\"uid\" property=\"user.id\"&gt;&lt;/result&gt; &lt;result column=\"username\" property=\"user.username\"&gt;&lt;/result&gt; &lt;result column=\"password\" property=\"user.password\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"user.birthday\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"orderMap\"&gt; SELECT *,o.id oid,u.id uid FROM orders o,USER u WHERE o.uid=u.id; &lt;/select&gt;&lt;/mapper&gt; 其中还可以配置如下： 1234567891011&lt;resultMap id=\"orderMap\" type=\"com.itheima.domain.Order\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"ordertime\" column=\"ordertime\"&gt;&lt;/result&gt; &lt;result property=\"total\" column=\"total\"&gt;&lt;/result&gt; &lt;association property=\"user\" javaType=\"com.itheima.domain.User\"&gt; &lt;result column=\"uid\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"password\" property=\"password\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt; 测试结果12345OrderMapper mapper = sqlSession.getMapper(OrderMapper.class);List&lt;Order&gt; all = mapper.findAll();for(Order order : all)&#123; System.out.println(order);&#125; 一对多查询一对多查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 一对多查询的语句对应的sql语句：select *,o.id oid from user u left join orders o on u.id=o.uid; 查询的结果如下： 修改User实体12345678910111213141516171819public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125;public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList;&#125; 创建UserMapper接口123public interface UserMapper &#123; List&lt;User&gt; findAll();&#125; 配置UserMapper.xml1234567891011121314151617&lt;mapper namespace=\"com.dhz.mapper.UserMapper\"&gt; &lt;resultMap id=\"orderMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"uid\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"password\" column=\"password\"/&gt; &lt;result property=\"birthday\" column=\"birthday\"/&gt; &lt;collection property=\"orders\" ofType=\"order\"&gt; &lt;id property=\"id\" column=\"oid\"/&gt; &lt;result property=\"ordertime\" column=\"ordertime\"/&gt; &lt;result property=\"total\" column=\"total\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"orderMap\"&gt; SELECT *,o.id oid FROM USER u,orders o WHERE u.id=o.uid &lt;/select&gt;&lt;/mapper&gt; 测试结果12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAll();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Order&gt; orderList = user.getOrderList(); for(Order order : orderList)&#123; System.out.println(order); &#125; System.out.println(\"----------------------------------\");&#125; 多对多查询多对多查询的模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 多对多查询的语句对应的sql语句：select u.,r.,r.id rid from user u left join user_role ur on u.id=ur.user_id inner join role r on ur.role_id=r.id; 查询的结果如下： 创建Role实体，修改User实体1234567891011121314151617public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList; //代表当前用户具备哪些角色 private List&lt;Role&gt; roleList;&#125;public class Role &#123; private int id; private String roleName; private String roleDesc;&#125; 添加UserMapper接口方法1List&lt;User&gt; findAllUserAndRole(); 配置UserMapper.xml1234567891011121314&lt;resultMap id=\"userRoleMap\" type=\"com.itheima.domain.User\"&gt; &lt;result column=\"id\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"password\" property=\"password\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;collection property=\"roleList\" ofType=\"com.dhz.domain.Role\"&gt; &lt;result column=\"rid\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"rolename\" property=\"rolename\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"findAllUserAndRole\" resultMap=\"userRoleMap\"&gt; select u.*,r.*,r.id rid from user u left join user_role ur on u.id=ur.user_id inner join role r on ur.role_id=r.id&lt;/select&gt; 测试结果12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAllUserAndRole();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Role&gt; roleList = user.getRoleList(); for(Role role : roleList)&#123; System.out.println(role); &#125; System.out.println(\"----------------------------------\");&#125; 知识小结MyBatis多表配置方式： 一对一配置：使用做配置 一对多配置：使用+做配置 多对多配置：使用+做配置 2.Mybatis的注解开发MyBatis的常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper 映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。 @Insert：实现新增 @Update：实现更新 @Delete：实现删除 @Select：实现查询 @Result：实现结果集封装 @Results：可以与@Result 一起使用，封装多个结果集 @One：实现一对一结果集封装 @Many：实现一对多结果集封装 MyBatis的增删改查我们完成简单的user表的增删改查的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445private UserMapper userMapper;@Beforepublic void before() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(UserMapper.class);&#125;@Testpublic void testAdd() &#123; User user = new User(); user.setUsername(\"测试数据\"); user.setPassword(\"123\"); user.setBirthday(new Date()); userMapper.add(user);&#125;@Testpublic void testUpdate() throws IOException &#123; User user = new User(); user.setId(16); user.setUsername(\"测试数据修改\"); user.setPassword(\"abc\"); user.setBirthday(new Date()); userMapper.update(user);&#125;@Testpublic void testDelete() throws IOException &#123; userMapper.delete(16);&#125;@Testpublic void testFindById() throws IOException &#123; User user = userMapper.findById(1); System.out.println(user);&#125;@Testpublic void testFindAll() throws IOException &#123; List&lt;User&gt; all = userMapper.findAll(); for(User user : all)&#123; System.out.println(user); &#125;&#125; 修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可 1234&lt;mappers&gt; &lt;!--扫描使用注解的类--&gt; &lt;mapper class=\"com.itheima.mapper.UserMapper\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 或者指定扫描包含映射关系的接口所在的包也可以 //常用 1234&lt;mappers&gt; &lt;!--扫描使用注解的类所在的包--&gt; &lt;package name=\"com.itheima.mapper\"&gt;&lt;/package&gt;&lt;/mappers&gt; MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置 一对一查询一对一查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询的语句对应的sql语句： select * from orders; select * from user where id=查询出订单的uid;查询的结果如下： 创建Order和User实体123456789101112131415161718public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125;public class User &#123; private int id; private String username; private String password; private Date birthday;&#125; 创建OrderMapper接口123public interface OrderMapper &#123; List&lt;Order&gt; findAll();&#125; 使用注解配置Mapper 无歧义的会自动注入，主键最好不要省略 12345678910111213141516171819//方式一 @Select(\"SELECT * FROM orders\") @Results(&#123; @Result(id = true,property = \"id\",column = \"id\"), @Result(javaType = User.class,property = \"user\",column = \"uid\", one = @One(select = \"com.dhz.mapper.UserMapper.findById\") ) &#125;) List&lt;Order&gt; findAll();//方式二 @Select(\"SELECT *,o.id oid FROM orders o,USER u WHERE o.uid=u.id\") @Results(&#123; @Result(property =\"id\",column = \"oid\"), @Result(property =\"user.username\",column = \"username\"), @Result(property =\"user.password\",column = \"password\"), @Result(property =\"user.birthday\",column = \"birthday\") &#125;) List&lt;Order&gt; findAll(); 123456public interface UserMapper &#123; @Select(\"select * from user where id=#&#123;id&#125;\") User findById(int id); &#125; 测试结果1234567@Testpublic void testSelectOrderAndUser() &#123; List&lt;Order&gt; all = orderMapper.findAll(); for(Order order : all)&#123; System.out.println(order); &#125;&#125; 一对多查询一对多查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 一对多查询的语句对应的sql语句： select * from user; select * from orders where uid=查询出用户的id;查询的结果如下： 修改User实体12345678910111213141516171819public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125;public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList;&#125; 创建UserMapper接口1List&lt;User&gt; findAllUserAndOrder(); 使用注解配置Mapper12345678910111213141516171819public interface UserMapper &#123; @Select(\"select * from user\") @Results(&#123; @Result(id = true,property = \"id\",column = \"id\"), @Result(property = \"username\",column = \"username\"), @Result(property = \"password\",column = \"password\"), @Result(property = \"birthday\",column = \"birthday\"), @Result(property = \"orderList\",column = \"id\", javaType = List.class, many = @Many(select = \"com.itheima.mapper.OrderMapper.findByUid\")) &#125;) List&lt;User&gt; findAllUserAndOrder();&#125;public interface OrderMapper &#123; @Select(\"select * from orders where uid=#&#123;uid&#125;\") List&lt;Order&gt; findByUid(int uid);&#125; 测试结果123456789List&lt;User&gt; all = userMapper.findAllUserAndOrder();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Order&gt; orderList = user.getOrderList(); for(Order order : orderList)&#123; System.out.println(order); &#125; System.out.println(\"-----------------------------\");&#125; 多对多查询多对多查询的模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 2.6.2 多对多查询的语句对应的sql语句： select * from user; SELECT * FROM sys_user_role uo,sys_role r WHERE uo.roleId=r.id AND uo.userId=用户的uid查询的结果如下(uid=1)： 2.6.3 创建Role实体，修改User实体1234567891011121314151617public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orders; //代表当前用户具备哪些角色 private List&lt;Role&gt; roles;&#125;public class Role &#123; private int id; private String roleName; private String roleDesc;&#125; 添加UserMapper接口方法1List&lt;User&gt; findAllUserAndRole(); 使用注解配置Mapper12345678910111213141516 @Select(\"select * from user\") @Results(&#123; @Result(id = true, property = \"id\",column = \"id\"), @Result(javaType = List.class,property = \"roles\",column = \"id\", many = @Many(select = \"com.dhz.mapper.RoleMapper.findByUid\") ) &#125;) List&lt;User&gt; findAllUserAndRole();public interface RoleMapper &#123; @Select(\"SELECT * FROM sys_user_role uo,sys_role r WHERE uo.roleId=r.id AND uo.userId=#&#123;uid&#125;\") List&lt;Role&gt; findByUid(int uid);&#125; 2.6.6 测试结果12345UserMapper userMapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; users = userMapper.findAllUserAndRole();for (User user : users) &#123; System.out.println(user);&#125; SSM框架整合1.1 原始方式整合1.准备工作 2.创建Maven工程 3.导入Maven坐标参考：素材/配置文件/pom.xml文件 4.编写实体类123456public class Account &#123; private int id; private String name; private double money; //省略getter和setter方法&#125; 5.编写Mapper接口123456public interface AccountMapper &#123; //保存账户数据 void save(Account account); //查询账户数据 List&lt;Account&gt; findAll();&#125; 6.编写Service接口1234public interface AccountService &#123; void save(Account account); //保存账户数据 List&lt;Account&gt; findAll(); //查询账户数据&#125; 7.编写Service接口实现123456789101112131415@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123; public void save(Account account) &#123; SqlSession sqlSession = MyBatisUtils.openSession(); AccountMapper accountMapper = sqlSession.getMapper(AccountMapper.class); accountMapper.save(account); sqlSession.commit(); sqlSession.close(); &#125; public List&lt;Account&gt; findAll() &#123; SqlSession sqlSession = MyBatisUtils.openSession(); AccountMapper accountMapper = sqlSession.getMapper(AccountMapper.class); return accountMapper.findAll(); &#125;&#125; 8.编写Controller123456789101112131415161718@Controllerpublic class AccountController &#123; @Autowired private AccountService accountService; @RequestMapping(\"/save\") @ResponseBody public String save(Account account)&#123; accountService.save(account); return \"save success\"; &#125; @RequestMapping(\"/findAll\") public ModelAndView findAll()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"accountList\"); modelAndView.addObject(\"accountList\",accountService.findAll()); return modelAndView; &#125;&#125; 9.编写添加页面1234567891011121314&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;保存账户信息表单&lt;/h1&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/save.action\" method=\"post\"&gt; 用户名称&lt;input type=\"text\" name=\"name\"&gt;&lt;br/&gt; 账户金额&lt;input type=\"text\" name=\"money\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"保存\"&gt;&lt;br/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 10.编写列表页面1234567891011121314&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;账户id&lt;/th&gt; &lt;th&gt;账户名称&lt;/th&gt; &lt;th&gt;账户金额&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;accountList&#125;\" var=\"account\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;account.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;account.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;account.money&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 11.编写相应配置文件(文件参考目录：素材/配置文件)•Spring配置文件：applicationContext.xml •SprngMVC配置文件：spring-mvc.xml •MyBatis映射文件：AccountMapper.xml •MyBatis核心文件：sqlMapConfig.xml •数据库连接信息文件：jdbc.properties •Web.xml文件：web.xml •日志文件：[log4j.xml]( 12.测试添加账户 13.测试账户列表 1.2 Spring整合MyBatis1.整合思路 2.将SqlSessionFactory配置到Spring容器中1234567891011121314&lt;!--加载jdbc.properties--&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;&lt;!--配置数据源--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/bean&gt;&lt;!--配置MyBatis的SqlSessionFactory--&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:sqlMapConfig.xml\"/&gt;&lt;/bean&gt; 3.扫描Mapper，让Spring容器产生Mapper实现类1234&lt;!--配置Mapper扫描--&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.itheima.mapper\"/&gt;&lt;/bean&gt; 4.配置声明式事务控制12345678910111213&lt;!--配置声明式事务控制--&gt;&lt;bean id=\"transacionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transacionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/&gt;&lt;/aop:config&gt; 5.修改Service实现类代码12345678910111213@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountMapper accountMapper; public void save(Account account) &#123; accountMapper.save(account); &#125; public List&lt;Account&gt; findAll() &#123; return accountMapper.findAll(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://donghuangzhong.github.io/tags/Mybatis/"}]},{"title":"Mybatis_Dao","slug":"Mybatis-Dao","date":"2021-02-25T03:19:34.000Z","updated":"2021-03-05T01:49:12.439Z","comments":true,"path":"2021/02/25/Mybatis-Dao/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/25/Mybatis-Dao/","excerpt":"Mybatis代理方式实现(无需Mapper(Dao)的实现类) 动态SQL 自定义类型转换(Date) 分页助手插件","text":"Mybatis代理方式实现(无需Mapper(Dao)的实现类) 动态SQL 自定义类型转换(Date) 分页助手插件 Mybatis的Dao层实现传统开发方式编写UserDao接口123public interface UserDao &#123; List&lt;User&gt; findAll() throws IOException;&#125; 编写UserDaoImpl实现123456789101112public class UserDaoImpl implements UserDao &#123; public List&lt;User&gt; findAll() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.findAll\"); sqlSession.close(); return userList; &#125;&#125; 测试传统方式123456@Testpublic void testTraditionDao() throws IOException &#123; UserDao userDao = new UserDaoImpl(); List&lt;User&gt; all = userDao.findAll(); System.out.println(all);&#125; 代理开发方式代理开发方式介绍采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper 接口开发需要遵循以下规范： 1) Mapper.xml文件中的namespace与mapper接口的全限定名相同 2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 编写UserMapper接口 测试代理方式1234567891011@Testpublic void testProxyDao() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findById(1); System.out.println(user); sqlSession.close();&#125; 知识小结MyBatis的Dao层实现的两种方式： 手动对Dao进行实现：传统开发方式 代理方式对Dao进行实现： **UserMapper userMapper = sqlSession.getMapper(UserMapper.class);**MyBatis映射文件深入动态sql语句动态sql语句概述Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。 参考的官方文档，描述如下： 动态 SQL 之&lt;if&gt;我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 1234567891011&lt;select id=\"findByCondition\" parameterType=\"user\" resultType=\"user\"&gt; select * from User &lt;where&gt; &lt;if test=\"id!=0\"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 当查询条件id和username都存在时，控制台打印的sql语句如下： 12345678 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User condition = new User(); condition.setId(1); condition.setUsername(\"lucy\"); User user = userMapper.findByCondition(condition); … … … 当查询条件只有id存在时，控制台打印的sql语句如下： 1234567 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User condition = new User();condition.setId(1);User user = userMapper.findByCondition(condition);… … … 动态 SQL 之&lt;foreach&gt;循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。 12345678&lt;select id=\"findByIds\" parameterType=\"list\" resultType=\"user\"&gt; select * from User &lt;where&gt; &lt;foreach collection=\"list\" open=\"id in(\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 测试代码片段如下： 1234567 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);int[] ids = new int[]&#123;2,5&#125;;List&lt;User&gt; userList = userMapper.findByIds(ids);System.out.println(userList);… … … foreach标签的属性含义如下： 标签用于遍历集合，它的属性： •collection：代表要遍历的集合元素，注意编写时不要写#{}，list或者array •open：代表语句的开始部分 •close：代表结束部分 •item：代表遍历集合的每个元素，生成的变量名 •sperator：代表分隔符 SQL片段抽取Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的 12345678910111213&lt;!--抽取sql片段简化编写--&gt;&lt;sql id=\"selectUser\" select * from User&lt;/sql&gt;&lt;select id=\"findById\" parameterType=\"int\" resultType=\"user\"&gt; &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; where id=#&#123;id&#125;&lt;/select&gt;&lt;select id=\"findByIds\" parameterType=\"list\" resultType=\"user\"&gt; &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=\"array\" open=\"id in(\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; MyBatis核心配置文件深入typeHandlers标签无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器（截取部分）。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。 开发步骤： ①定义转换类继承类BaseTypeHandler ②覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时 mysql的字符串类型转换成 java的Type类型的方法 ③在MyBatis核心配置文件中进行注册 测试转换是否正确 1234567891011121314151617public class DateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; public void setNonNullParameter(PreparedStatement ps, int i, Date parameter, JdbcType jdbcType) throws SQLException &#123; ps.setLong(i,parameter.getTime()); &#125; public Date getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return new Date(rs.getLong(columnName)); &#125; public Date getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return new Date(rs.getLong(columnIndex)); &#125; public Date getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return new Date(cs.getLong(columnIndex)); &#125;&#125; 1234&lt;!--注册类型自定义转换器--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=\"com.itheima.typeHandlers.MyDateTypeHandler\"&gt;&lt;/typeHandler&gt;&lt;/typeHandlers&gt; 测试添加操作： 12user.setBirthday(new Date());userMapper.save(user); plugins标签MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据 开发步骤： ①导入通用PageHelper的坐标 ②在mybatis核心配置文件中配置PageHelper插件 ③测试分页数据获取 ①导入通用PageHelper坐标1234567891011&lt;!-- 分页助手 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; ②在mybatis核心配置文件中配置PageHelper插件12345&lt;!-- 注意：分页助手的插件 配置在通用馆mapper之前 --&gt; &lt;plugins&gt; &lt;!-- PageHelper5版本配置 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"/&gt; &lt;/plugins&gt; ③测试分页代码实现12345678910@Testpublic void testPageHelper()&#123; //设置分页参数 PageHelper.startPage(1,2); List&lt;User&gt; select = userMapper2.select(null); for(User user : select)&#123; System.out.println(user); &#125;&#125; 获得分页相关的其他参数 12345678//其他分页的数据PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(select);System.out.println(\"总条数：\"+pageInfo.getTotal());System.out.println(\"总页数：\"+pageInfo.getPages());System.out.println(\"当前页：\"+pageInfo.getPageNum());System.out.println(\"每页显示长度：\"+pageInfo.getPageSize());System.out.println(\"是否第一页：\"+pageInfo.isIsFirstPage());System.out.println(\"是否最后一页：\"+pageInfo.isIsLastPage()); 知识小结MyBatis核心配置文件常用标签： 1、properties标签：该标签可以加载外部的properties文件 2、typeAliases标签：设置类型别名 3、environments标签：数据源环境配置标签 4、typeHandlers标签：配置自定义类型处理器 5、plugins标签：配置MyBatis的插件","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://donghuangzhong.github.io/tags/mybatis/"}]},{"title":"Mybatis","slug":"Mybatis","date":"2021-02-24T09:41:45.000Z","updated":"2021-03-05T01:44:03.476Z","comments":true,"path":"2021/02/24/Mybatis/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/24/Mybatis/","excerpt":"Mybatis简介和xml方式配置","text":"Mybatis简介和xml方式配置 Mybatis简介原始jdbc操作（查询数据） 原始jdbc操作（插入数据） 原始jdbc操作的分析原始jdbc开发存在的问题如下： ①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能 ②sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。 ③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置 应对上述问题给出的解决方案： ①使用数据库连接池初始化连接资源 ②将sql语句抽取到xml配置文件中 ③使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 什么是Mybatismybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。 Mybatis的快速入门MyBatis开发步骤MyBatis官网地址：http://www.mybatis.org/mybatis-3/ MyBatis开发步骤： ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml ⑥编写测试类 环境搭建1)导入MyBatis的坐标和其他相关坐标 1234567891011121314151617181920212223242526&lt;!--mybatis坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql驱动坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--单元测试坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--日志坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; 2) 创建user数据表 3) 编写User实体 123456public class User &#123; private int id; private String username; private String password; //省略get个set方法&#125; 4)编写UserMapper映射文件 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"userMapper\"&gt; &lt;select id=\"findAll\" resultType=\"com.dhz.domain.User\"&gt; select * from User &lt;/select&gt;&lt;/mapper&gt; 5) 编写MyBatis核心文件 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;!-- 数据源环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///test\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;!-- 加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"com\\dhz\\mapper\\UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写测试代码123456789101112//加载核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");//获得sqlSession工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);//获得sqlSession对象SqlSession sqlSession = sqlSessionFactory.openSession();//执行sql语句List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.findAll\");//打印结果System.out.println(uselrList);//释放资源sqlSession.close(); 知识小结MyBatis开发步骤： ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml ⑥编写测试类 MyBatis的映射文件概述 MyBatis的增删改查操作MyBatis的插入数据操作1)编写UserMapper映射文件 12345&lt;mapper namespace=\"userMapper\"&gt; &lt;insert id=\"add\" parameterType=\"com.dhz.domain.User\"&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 2)编写插入实体User的代码 123456789InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int insert = sqlSession.insert(\"userMapper.add\", user);System.out.println(insert);//提交事务sqlSession.commit();sqlSession.close(); 3)插入操作注意问题 • 插入语句使用insert标签 • 在映射文件中使用parameterType属性指定要插入的数据类型 •Sql语句中使用#{实体属性名}方式引用实体中的属性值 •插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象); •插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() MyBatis的修改数据操作1)编写UserMapper映射文件 12345&lt;mapper namespace=\"userMapper\"&gt; &lt;update id=\"update\" parameterType=\"com.itheima.domain.User\"&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 2)编写修改实体User的代码 1234567InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int update = sqlSession.update(\"userMapper.update\", user);System.out.println(update);sqlSession.commit();sqlSession.close(); 3)修改操作注意问题 • 修改语句使用update标签 • 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); MyBatis的删除数据操作1)编写UserMapper映射文件 12345&lt;mapper namespace=\"userMapper\"&gt; &lt;delete id=\"delete\" parameterType=\"java.lang.Integer\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 2)编写删除数据的代码 1234567InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int delete = sqlSession.delete(\"userMapper.delete\",3);System.out.println(delete);sqlSession.commit();sqlSession.close(); 3)删除操作注意问题 • 删除语句使用delete标签 •Sql语句中使用#{任意字符串}方式引用传递的单个参数 •删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); 知识小结1234567891011121314151617增删改查映射配置与API：查询数据： List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.findAll\"); &lt;select id=\"findAll\" resultType=\"com.itheima.domain.User\"&gt; select * from User &lt;/select&gt;添加数据： sqlSession.insert(\"userMapper.add\", user); &lt;insert id=\"add\" parameterType=\"com.itheima.domain.User\"&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;修改数据： sqlSession.update(\"userMapper.update\", user); &lt;update id=\"update\" parameterType=\"com.itheima.domain.User\"&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;删除数据：sqlSession.delete(\"userMapper.delete\",3); &lt;delete id=\"delete\" parameterType=\"java.lang.Integer\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; MyBatis核心配置文件概述MyBatis核心配置文件层级关系 MyBatis常用配置解析1)environments标签 数据库环境的配置，支持多环境配置 其中，事务管理器（transactionManager）类型有两种： •JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 •MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： •UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 •POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 •JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 2)mapper标签 该标签的作用是加载映射的，加载方式有如下几种： •使用相对于类路径的资源引用，例如： •使用完全限定资源定位符（URL），例如： •使用映射器接口实现类的完全限定类名，例如： •将包内的映射器接口实现全部注册为映射器，例如： 3)Properties标签 实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件 4)typeAliases标签（在SqlMapConfig.xml里，注意顺序） 类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下 配置typeAliases，为com.itheima.domain.User定义别名为user 上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名 知识小结核心配置文件常用配置： properties标签：该标签可以加载外部的properties文件 1&lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt; typeAliases标签：设置类型别名 1&lt;typeAlias type=\"com.itheima.domain.User\" alias=\"user\"&gt;&lt;/typeAlias&gt; mappers标签：加载映射配置 1&lt;mapper resource=\"com/itheima/mapper/UserMapping.xml\"&gt;&lt;/mapper&gt; environments标签：数据源环境配置标签 MyBatis相应APISqlSession工厂构建器SqlSessionFactoryBuilder常用API：SqlSessionFactory build(InputStream inputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 1234String resource = \"org/mybatis/builder/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); 其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。 SqlSession工厂对象SqlSessionFactorySqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个： SqlSession会话对象SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有： 12345&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter) 操作事务的方法主要有： 12void commit() void rollback()","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://donghuangzhong.github.io/tags/Mybatis/"}]},{"title":"springmvc_快速操作","slug":"springmvc-快速操作","date":"2021-02-21T00:47:24.000Z","updated":"2021-03-05T01:40:30.976Z","comments":true,"path":"2021/02/21/springmvc-快速操作/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/21/springmvc-%E5%BF%AB%E9%80%9F%E6%93%8D%E4%BD%9C/","excerpt":"快速搭建springmvc环境","text":"快速搭建springmvc环境 快速搭建环境创建maven项目选中webapp,修改web.xml maven-archetype-webapp创建web.xml默认不支持EL 修改web.xml如下 123&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot; id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;3.0&quot;&gt;...&lt;&#x2F;web-app&gt; 新建各种包和配置文件新建包controller、service、dao、domain、utils 新建配置文件(resources下)applicationContext.xml、spring-mvc.xml、jdbc.properties、log4j.properties applicationContext.xml 1234567891011121314151617181920212223&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!--1、加载jdbc.properties--&gt; &lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt; &lt;!--2、配置数据源对象--&gt; &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--3、配置JdbcTemplate对象--&gt; &lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;context:component-scan base-package&#x3D;&quot;com.dhz&quot;&gt;&lt;&#x2F;context:component-scan&gt;&lt;&#x2F;beans&gt; spring-mvc.xml 12345678910111213141516171819202122&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!--1、mvc注解驱动--&gt; &lt;mvc:annotation-driven&#x2F;&gt; &lt;!--2、配置视图解析器--&gt; &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;pages&#x2F;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--3、静态资源权限开放--&gt; &lt;mvc:default-servlet-handler&#x2F;&gt; &lt;!--4、组件扫描 扫描Controller--&gt; &lt;context:component-scan base-package&#x3D;&quot;com.dhz.controller&quot;&#x2F;&gt;&lt;&#x2F;beans&gt; jdbc.properties 1234jdbc.driver&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testjdbc.username&#x3D;rootjdbc.password&#x3D;root log4j.properties 123456789101112131415### direct log messages to stdout ###log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target&#x3D;System.outlog4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file&#x3D;org.apache.log4j.FileAppenderlog4j.appender.file.File&#x3D;c:&#x2F;mylog.loglog4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; ###log4j.rootLogger&#x3D;info, stdout 导入需要坐标(pom.xml)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.32&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;&#x2F;groupId&gt; &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt; &lt;version&gt;0.9.1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.10&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;3.0.1&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2.1&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-logging&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt; &lt;version&gt;1.7.7&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2.17&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; web集成spring和springmvc(web.xml)1234567891011121314151617181920212223&lt;!--全局的初始化参数--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;context-param&gt; &lt;!--Spring的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt; &lt;&#x2F;listener&gt; &lt;!--SpringMVC的前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;2&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://donghuangzhong.github.io/tags/springmvc/"}]},{"title":"SpringMVC的文件上传","slug":"SpringMVC的文件上传","date":"2021-02-20T05:19:05.000Z","updated":"2021-03-04T03:05:18.861Z","comments":true,"path":"2021/02/20/SpringMVC的文件上传/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/20/SpringMVC%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"摘要","text":"摘要 SpringMVC的文件上传客户端表单实现(应用)文件上传客户端表单需要满足： 表单项type=“file” 表单的提交方式是post 表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data” 12345&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/quick22\" method=\"post\" enctype=\"multipart/form-data\"&gt; 名称&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; 文件1&lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; 文件上传的原理(理解) 单文件上传的代码实现1(应用)添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 配置多媒体解析器 12345&lt;!--配置文件上传解析器--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt; &lt;property name=\"maxUploadSize\" value=\"500000\"/&gt; &lt;/bean&gt; 后台程序 123456789@RequestMapping(\"/upload1\")@ResponseBodypublic String upload1(String username, MultipartFile uploadFile) throws IOException &#123; System.out.println(username); System.out.println(uploadFile); String filename = uploadFile.getOriginalFilename(); uploadFile.transferTo(new File(\"E:/upload/\"+filename)); return username+\"\\n\"+uploadFile.toString();&#125; 多文件上传的代码实现(应用)多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可 123456&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/upload2\" method=\"post\" enctype=\"multipart/form-data\"&gt; 名称&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; 文件1&lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;br/&gt; 文件2&lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 1234567891011@RequestMapping(\"/upload2\")@ResponseBodypublic String upload2(String username, MultipartFile[] uploadFile) throws IOException &#123; System.out.println(username); System.out.println(uploadFile); for (MultipartFile file : uploadFile) &#123; String filename = file.getOriginalFilename(); file.transferTo(new File(\"E:/upload/\"+filename)); &#125; return username+\"\\n\"+uploadFile.toString();&#125; 知识要点(理解，记忆) SpringMVC的拦截器拦截器的作用(理解)Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（InterceptorChain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。 interceptor和filter区别(理解，记忆)关于interceptor和filter的区别，如图所示： 快速入门(应用)自定义拦截器很简单，只有如下三步： ①创建拦截器类实现HandlerInterceptor接口 ②配置拦截器 ③测试拦截器的拦截效果 编写拦截器： 1234567891011121314151617181920public class MyInterceptor1 implements HandlerInterceptor &#123; //在目标方法执行之前 执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"preHandle.....\"); return \"yes\".equals(request.getParameter(\"status\")); &#125; //在目标方法执行之后 视图对象返回之前执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"postHandle....\"); &#125; //在流程都执行完毕后 执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"afterCompletion...\"); &#125;&#125; 配置：在SpringMVC的配置文件中配置 1234567&lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.dhz.interceptor.MyInterceptor1\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 编写测试程序测试： 编写Controller,发请求到controller,跳转页面 12345@RequestMapping(value = \"/save\",method = RequestMethod.GET)public String save()&#123; System.out.println(\"controller save ...\"); return \"save\";&#125; 页面 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;save ........&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 快速入门详解(应用)拦截器在预处理后什么情况下会执行目标资源，什么情况下不执行目标资源，以及在有多个拦截器的情况下拦截器的执行顺序是什么? 再编写一个拦截器2， 1234567891011121314151617public class MyInterceptor2 implements HandlerInterceptor &#123; //在目标方法执行之前 执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123; System.out.println(\"preHandle22222.....\"); return true; &#125; //在目标方法执行之后 视图对象返回之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; System.out.println(\"postHandle2222...\"); &#125; //在流程都执行完毕后 执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; System.out.println(\"afterCompletion2222....\"); &#125;&#125; 配置拦截器2 12345678910111213&lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.itheima.interceptor.MyInterceptor2\"/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.itheima.interceptor.MyInterceptor1\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 结论： 当拦截器的preHandle方法返回true则会执行目标资源，如果返回false则不执行目标资源 多个拦截器情况下，配置在前的先执行，配置在后的后执行 拦截器中的方法执行顺序是：preHandler——-目标资源—-postHandle—- afterCompletion 知识小结(记忆)拦截器中的方法说明如下 06-SpringMVC拦截器-用户登录权限控制分析(理解)在day06-Spring练习案例的基础之上：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作 需求图： 07-SpringMVC拦截器-用户登录权限控制代码实现1(应用)判断用户是否登录 本质：判断session中有没有user，如果没有登陆则先去登陆，如果已经登陆则直接放行访问目标资源 先编写拦截器如下： 1234567891011121314public class PrivilegeInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException &#123; //逻辑：判断用户是否登录 本质：判断session中有没有user HttpSession session = request.getSession(); User user = (User) session.getAttribute(\"user\"); if(user==null)&#123; //没有登录 response.sendRedirect(request.getContextPath()+\"/login.jsp\"); return false; &#125; //放行 访问目标资源 return true; &#125;&#125; 然后配置该拦截器：找到项目案例的spring-mvc.xml，添加如下配置： 12345678&lt;!--配置权限拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.itheima.interceptor.PrivilegeInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 08-SpringMVC拦截器-用户登录权限控制代码实现2(应用)在登陆页面输入用户名密码，点击登陆，通过用户名密码进行查询，如果登陆成功，则将用户信息实体存入session，然后跳转到首页，如果登陆失败则继续回到登陆页面 在UserController中编写登陆逻辑 12345678910@RequestMapping(\"/login\") public String login(String username,String password,HttpSession session)&#123; User user = userService.login(username,password); if(user!=null)&#123; //登录成功 将user存储到session session.setAttribute(\"user\",user); return \"redirect:/index.jsp\"; &#125; return \"redirect:/login.jsp\"; &#125; service层代码如下： 12345//service层public User login(String username, String password) &#123; User user = userDao.findByUsernameAndPassword(username,password); return user;&#125; dao层代码如下： 12345//dao层 public User findByUsernameAndPassword(String username, String password) throws EmptyResultDataAccessException&#123; User user = jdbcTemplate.queryForObject(\"select * from sys_user where username=? and password=?\", new BeanPropertyRowMapper&lt;User&gt;(User.class), username, password); return user; &#125; 此时仍然登陆不上，因为我们需要将登陆请求url让拦截器放行,添加资源排除的配置 12345678910&lt;!--配置权限拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--配置哪些资源排除拦截操作--&gt; &lt;mvc:exclude-mapping path=\"/user/login\"/&gt; &lt;bean class=\"com.itheima.interceptor.PrivilegeInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 09-SpringMVC拦截器-用户登录权限控制代码实现3(应用)JdbcTemplate.queryForObject对象如果查询不到数据会抛异常，导致程序无法达到预期效果，如何来解决该问题？ 在业务层处理来自dao层的异常，如果出现异常service层返回null,而不是将异常抛给controller 因此改造登陆的业务层代码,添加异常的控制 12345678public User login(String username, String password) &#123; try &#123; User user = userDao.findByUsernameAndPassword(username,password); return user; &#125;catch (EmptyResultDataAccessException e)&#123; return null; &#125; &#125; SpringMVC异常处理机制异常处理的思路系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。 系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图： 异常处理两种方式① 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver ② 实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器 简单异常处理器SimpleMappingExceptionResolverSpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置 12345678910&lt;!--配置简单映射异常处理器--&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;property name=\"defaultErrorView\" value=\"error\"/&gt; &lt;!--默认异常，服从前后缀(jsp/error.jsp)--&gt; &lt;property name=\"exceptionMappings\"&gt; &lt;map&gt; &lt;entry key=\"com.dhz.exception.MyExcepton\" value=\"error1\"/&gt; &lt;!--自定义异常--&gt; &lt;entry key=\"java.lang.ArithmeticException\" value=\"error2\"/&gt; &lt;!--除数为0异常--&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 测试 123456789101112131415161718@RequestMapping(&quot;&#x2F;yichang&#x2F;&#123;id&#125;&quot;)@ResponseBodypublic void yichang(@PathVariable(value &#x3D; &quot;id&quot;) int id) throws MyExcepton &#123; System.out.println(&quot;---------------------&quot;); if (id&#x3D;&#x3D;0)&#123; System.out.println(&quot;0.....&quot;); int j&#x3D;1&#x2F;0; &#125; else if (id&#x3D;&#x3D;1)&#123; System.out.println(&quot;1.....&quot;); int k&#x3D;Integer.parseInt(&quot;张三&quot;); &#125; else &#123; System.out.println(&quot;2.....&quot;); throw new MyExcepton(); &#125;&#125; 自定义异常处理步骤①创建异常处理器类实现HandlerExceptionResolver 123456789101112131415161718public class MyExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; ModelAndView modelAndView = new ModelAndView(); if (ex instanceof MyExcepton) &#123; modelAndView.addObject(\"error_info\",\"自定义异常\"); &#125; else if (ex instanceof ArithmeticException)&#123; modelAndView.addObject(\"error_info\",\"除数为0异常\"); &#125; else &#123; modelAndView.addObject(\"error_info\",\"通用异常\"); &#125; modelAndView.setViewName(\"error_msg\"); return modelAndView; &#125;&#125; ②配置异常处理器 1&lt;bean class=\"com.dhz.resovler.MyExceptionResolver\"/&gt; ③编写异常页面 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;error_info&#125;&lt;/body&gt;&lt;/html&gt; ④测试异常跳转 123456789101112131415161718@RequestMapping(\"/yichang/&#123;id&#125;\")@ResponseBodypublic void yichang(@PathVariable(value = \"id\") int id) throws MyExcepton &#123; System.out.println(\"---------------------\"); if (id==0)&#123; System.out.println(\"0.....\"); int j=1/0; &#125; else if (id==1)&#123; System.out.println(\"1.....\"); int k=Integer.parseInt(\"张三\"); &#125; else &#123; System.out.println(\"2.....\"); throw new MyExcepton(); &#125;&#125; 1.5 知识要点异常处理方式 配置简单异常处理器SimpleMappingExceptionResolver 自定义异常处理器自定义异常处理步骤 ①创建异常处理器类实现HandlerExceptionResolver ②配置异常处理器 ③编写异常页面 ④测试异常跳转","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"SpringMVC的请求和响应","slug":"SpringMVC的请求和响应","date":"2021-02-18T10:26:01.000Z","updated":"2021-03-05T01:40:05.761Z","comments":true,"path":"2021/02/18/SpringMVC的请求和响应/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/18/SpringMVC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/","excerpt":"springmvc的请求响应 静态资源引用开启 全局乱码过滤器 自定义类型转换器","text":"springmvc的请求响应 静态资源引用开启 全局乱码过滤器 自定义类型转换器 SpringMVC的请求和响应SpringMVC的数据响应数据响应方式(理解) 页面跳转 直接返回字符串 通过ModelAndView对象返回 回写数据 直接返回字符串 返回对象或集合 页面跳转返回字符串形式（应用） 返回ModelAndView形式1(应用)在Controller中方法返回ModelAndView对象，并且设置视图名称 1234567891011121314@RequestMapping(\"/MAV1\") public ModelAndView ModelAndView1()&#123; /* Model:模型 作用封装数据 View：视图 作用展示数据 */ System.out.println(\"ModelAndView1 ...\"); ModelAndView modelAndView=new ModelAndView(); //设置模型数据,可以直接在jsp中用$&#123;username&#125; modelAndView.addObject(\"username\",\"DongHuangZhong\"); //设置视图名称 modelAndView.setViewName(\"mav1\");//也受前缀后缀约束,文件在/jsp/mav1.jsp return modelAndView; &#125; mav1.jsp 12345678910&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;h1&gt;mav1&lt;&#x2F;h1&gt; username:$&#123;username&#125;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 返回ModelAndView形式2(应用)n在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面 1234567@RequestMapping(\"/MAV2\") public ModelAndView ModelAndView2(ModelAndView modelAndView)&#123; System.out.println(\"ModelAndView1 ...\"); modelAndView.addObject(\"username\",\"ManJi\"); modelAndView.setViewName(\"mav1\");//也受前缀后缀约束 return modelAndView; &#125; 返回ModelAndView3(应用)在Controller方法的形参上可以直接使用原生的HttpServeltRequest对象，只需声明即可 123456@RequestMapping(\"/MAV3\") public String ModelAndView2(HttpServletRequest request)&#123; System.out.println(\"ModelAndView3 ...\"); request.setAttribute(\"username\",\"MiLin\"); return \"mav1\"; &#125; 回写数据直接回写字符串(应用)通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”) 回写数据，此时不需要视图跳转，业务方法返回值为void 将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回 123456789101112@RequestMapping(\"/re_str2\") @ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应 public String re_str2()&#123; System.out.println(\"re_str2 ...\"); return \"hello restr2\"; &#125;@RequestMapping(\"/re_str1\") public void re_str1(HttpServletResponse response) throws IOException &#123; System.out.println(\"re_str1 ...\"); response.getWriter().write(\"response return ....\"); &#125; 直接回写json格式字符串(应用)123456@RequestMapping(\"/re_str_json1\") @ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应 public String re_str_json1()&#123; System.out.println(\"re_str_json1 ...\"); return \"&#123;\\\"username\\\":\\\"zhangsan\\\",\\\"age\\\":18&#125;\"; &#125; 手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换,通过jackson转换json格式字符串，回写字符串 添加依赖jar包(不要低于2.6版本) 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 用ObjectMapper得到json 123456789@RequestMapping(&quot;&#x2F;re_str_json2&quot;)@ResponseBody &#x2F;&#x2F;告知SpringMVC框架 不进行视图跳转 直接进行数据响应public String re_str_json2() throws JsonProcessingException &#123; System.out.println(&quot;re_str_json2 ...&quot;); User user&#x3D;new User(&quot;lisi&quot;,22); ObjectMapper mapper &#x3D; new ObjectMapper(); String user_json &#x3D; mapper.writeValueAsString(user); return user_json;&#125; 返回对象或集合(应用)通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置： 1234567&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 1234567@RequestMapping(\"/re_obj_json1\") @ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应 public User re_obj_json1() throws JsonProcessingException &#123; System.out.println(\"re_obj_json1 ...\"); User user=new User(\"lisi\",22); return user; &#125; 09-SpringMVC的数据响应-回写数据-返回对象或集合2(应用)在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置(返回对象自动变成json) 1&lt;mvc:annotation-driven/&gt; 在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 使用&lt;mvc:annotation-driven /&gt;自动加载 RequestMappingHandlerMapping（处理映射器）和 RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用 &lt;mvc:annotation-driven /&gt;替代注解处理器和适配器的配置。 同时使用&lt;mvc:annotation-driven /&gt; 默认底层就会集成jackson进行对象或集合的json格式字符串的转换 10-SpringMVC的数据响应-知识要点小结(理解，记忆)1） 页面跳转 直接返回字符串 通过ModelAndView对象返回 2） 回写数据 直接返回字符串 HttpServletResponse 对象直接写回数据，HttpServletRequest对象带回数据，Model对象带回数据或者@ResponseBody将字符串数据写回 返回对象或集合 @ResponseBody+&lt;mvc:annotation-driven/&gt; SpringMVC的请求请求参数类型(理解)客户端请求参数的格式是：name=value&amp;name=value…… 服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 获得基本类型参数(应用)Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换； 自动的类型转换是指从String向其他类型的转换 http://localhost:8080/user/get_base_para?name=zzz&amp;age=18 12345@RequestMapping(\"/get_base_para\")@ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应public String get_base_para(String name, int age)&#123; return \"paras=&#123;name=\"+name+\";age=\"+age+\"&#125;\";&#125; 获得POJO类型参数(应用)Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。 123456789101112131415161718192021222324252627282930313233343536373839package com.dhz.domain;public class User &#123; private String username; private int age; public User() &#123; &#125; public User(String username, int age) &#123; this.username = username; this.age = age; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"username='\" + username + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; http://localhost:8080/user/get_POPJ_para?username=popj&amp;age=18 123456@RequestMapping(\"/get_POPJ_para\")@ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应public User get_POPJ_para(User user)&#123; System.out.println(user); return user;&#125; 获得数组类型参数(应用)Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。 http://localhost:8080/user/get_arrays_para?name=zhangsan&amp;name=lisi 1234567@RequestMapping(\"/get_arrays_para\")@ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应public List&lt;String&gt; get_arrays_para(String[] name)&#123; List&lt;String&gt; names = Arrays.asList(name); System.out.println(names); return names;&#125; 获得User集合类型参数1(应用)获得集合参数时，要将集合参数包装到一个POJO中才可以。 12345678&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/get_userList\" method=\"post\"&gt; &lt;%--表明是第一个User对象的username age--%&gt; &lt;input type=\"text\" name=\"userList[0].username\"&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"userList[0].age\"&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"userList[1].username\"&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"userList[1].age\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; 1234567891011121314151617181920212223package com.dhz.domain;import java.util.List;public class VO &#123; private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() &#123; return userList; &#125; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; @Override public String toString() &#123; return \"VO&#123;\" + \"userList=\" + userList + '&#125;'; &#125;&#125; 注：public List get_userList2(List userList) 不行 123456@RequestMapping(\"/get_userList\")@ResponseBodypublic VO get_userList(VO vo) throws IOException &#123; System.out.println(vo); return vo;&#125; 获得集合类型参数2(应用)当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装 1234567891011&lt;script src=\"$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.js\"&gt;&lt;/script&gt;&lt;script&gt; var userList = new Array(); userList.push(&#123;username:\"zhangsan\",age:18&#125;); userList.push(&#123;username:\"lisi\",age:28&#125;); $.ajax(&#123; type:\"POST\", url:\"$&#123;pageContext.request.contextPath&#125;/user/get_ajax_userlist\", data:JSON.stringify(userList), contentType:\"application/json;charset=utf-8\" &#125;); 注：需要按照下面的步骤开启静态资源的引用 12345@RequestMapping(\"/get_ajax_userlist\")@ResponseBodypublic void get_ajax_userlist(@RequestBody List&lt;User&gt; userList)&#123; System.out.println(userList);&#125; 静态资源引用的开启(应用)当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源： •在spring-mvc.xml配置文件中指定放行的资源 ​ &lt;mvc:resources mapping=&quot;/js/**&quot;location=&quot;/js/&quot;/&gt; •使用&lt;mvc:default-servlet-handler/&gt;标签 12345&lt;!--开发资源的访问--&gt; &lt;!--&lt;mvc:resources mapping=\"/js/**\" location=\"/js/\"/&gt; &lt;mvc:resources mapping=\"/img/**\" location=\"/img/\"/&gt;--&gt; &lt;mvc:default-servlet-handler/&gt; 配置全局乱码过滤器(应用)当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。在web.xml中 12345678910111213&lt;!--配置全局过滤的filter--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 参数绑定注解@RequestParam(应用)当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定 http://localhost:8080/user/get_para_anno?xingming=lisi 123456@RequestMapping(\"/get_para_anno\")@ResponseBodypublic String get_para_anno(@RequestParam(value = \"xingming\",required = false,defaultValue = \"null\") String name)&#123; System.out.println(name); return name;&#125; Restful风格的参数的获取(应用)Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。 Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下： GET：用于获取资源 POST：用于新建资源 PUT：用于更新资源 DELETE：用于删除资源 例如： /user/1 GET ： 得到 id = 1 的 user /user/1 DELETE： 删除 id = 1 的 user /user/1 PUT： 更新 id = 1 的 user /user POST： 新增 user 上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。 http://localhost:8080/user/request_restful/zhansgan 123456@RequestMapping(\"/request_restful/&#123;name&#125;\")@ResponseBodypublic String request_restful(@PathVariable(value = \"name\") String name)&#123; System.out.println(name); return name;&#125; 自定义类型转换器(应用)SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。默认格式:2020/03/05 编写DateConverter类继承Converter，重写convert方法 12345678910111213public class DateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String dateStr) &#123; SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date &#x3D; null; try &#123; date &#x3D; simpleDateFormat.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125; 声明转换器 1234567&lt;bean id&#x3D;&quot;conversionService&quot; class&#x3D;&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;converters&quot;&gt; &lt;list&gt; &lt;bean class&#x3D;&quot;com.dhz.converter.DateConverter&quot;&#x2F;&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt; 配置到mvc.xml 1&lt;mvc:annotation-driven conversion-service&#x3D;&quot;conversionService&quot;&#x2F;&gt; 测试 123456@RequestMapping(&quot;&#x2F;date&quot;)@ResponseBodypublic String date(Date date)&#123; System.out.println(date); return date.toString();&#125; 获得Servlet相关API(应用)SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下： HttpServletRequest HttpServletResponse HttpSession 1234567@RequestMapping(value=\"/quick19\") @ResponseBody public void save19(HttpServletRequest request, HttpServletResponse response, HttpSession session) throws IOException &#123; System.out.println(request); System.out.println(response); System.out.println(session); &#125; 获得请求头信息(应用)使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name) @RequestHeader注解的属性如下： value：请求头的名称 required：是否必须携带此请求头 12345@RequestMapping(value=\"/quick20\") @ResponseBody public void save20(@RequestHeader(value = \"User-Agent\",required = false) String user_agent) throws IOException &#123; System.out.println(user_agent); &#125; 使用@CookieValue可以获得指定Cookie的值 @CookieValue注解的属性如下： value：指定cookie的名称 required：是否必须携带此cookie 12345@RequestMapping(value=\"/quick21\") @ResponseBody public void save21(@CookieValue(value = \"JSESSIONID\") String jsessionId) throws IOException &#123; System.out.println(jsessionId); &#125;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"}]},{"title":"Spring与Web环境集成","slug":"Spring与Web环境集成","date":"2021-02-18T01:53:16.000Z","updated":"2021-03-05T01:35:47.514Z","comments":true,"path":"2021/02/18/Spring与Web环境集成/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/18/Spring%E4%B8%8EWeb%E7%8E%AF%E5%A2%83%E9%9B%86%E6%88%90/","excerpt":"spring与web环境集成 springmvc简介 spring的执行过程 spring组件解析","text":"spring与web环境集成 springmvc简介 spring的执行过程 spring组件解析 Spring与Web环境集成ApplicationContext应用上下文获取方式弊端应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。 在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。 所以我们需要做的只有两件事： ①在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标） ②使用WebApplicationContextUtils获得应用上下文对象ApplicationContext 获取步骤导入Spring集成web的坐标12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置ContextLoaderListener监听器1234567891011&lt;!--全局参数--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--Spring的监听器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; 通过工具获得应用上下文对象12ApplicationContext app = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext()); UserService userService = app.getBean(UserService.class); SpringMVC的简介SpringMVC概述SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。 SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。 SpringMVC快速入门需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。 开发步骤 ①导入SpringMVC相关坐标 ②配置SpringMVC核心控制器DispathcerServlet ③创建Controller类和视图页面 ④使用注解配置Controller类中业务方法的映射地址 ⑤配置SpringMVC核心文件 spring-mvc.xml ⑥客户端发起请求测试 代码实现 ①导入Spring和SpringMVC的坐标、导入Servlet和Jsp的坐标 123456789101112131415161718192021222324 &lt;!--Spring坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringMVC坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--Servlet坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--Jsp坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; ②创建Controller和业务方法 return “save.jsp” ：从当前请求路径下 return “/save.jsp” 从当前web容器的的路径下，推荐写法 123456public class UserController &#123; public String save()&#123; System.out.println(\"controller save ...\"); return \"save.jsp\"; &#125;&#125; ③配置注解 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;&#x2F;save&quot;) public String save()&#123; System.out.println(&quot;controller save ...&quot;); return &quot;save.jsp&quot;; &#125;&#125; ④创建视图页面save.jsp 12345&lt;html&gt;&lt;body&gt; &lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; ⑤创建spring-mvc.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.dhz.controller\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; ⑥在web.xml配置SpringMVC的核心控制器 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt; ⑦访问测试地址 1http://localhost:8080/save SpringMVC的组件解析SpringMVC的执行流程 ①用户发送请求至前端控制器DispatcherServlet。 ②DispatcherServlet收到请求调用HandlerMapping处理器映射器。 ③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 ④DispatcherServlet调用HandlerAdapter处理器适配器。 ⑤HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 ⑥Controller执行完成返回ModelAndView。 ⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 ⑧DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ⑨ViewReslover解析后返回具体View。 ⑩DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。 SpringMVC组件解析 前端控制器：DispatcherServlet ​ 用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器：HandlerMapping ​ HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器适配器：HandlerAdapter ​ 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 处理器：Handler ​ 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。 视图解析器：View Resolver ​ View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 视图：View ​ SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面 SpringMVC注解解析@RequestMapping作用：用于建立请求 URL 和处理请求方法之间的对应关系 位置： ​ 类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录 ​ 方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径 属性： ​ value：用于指定请求的URL。它和path属性的作用是一样的 ​ method：用于指定请求的方式 ​ params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样 例如： ​ params = {“accountName”}，表示请求参数必须有accountName ​ params = {“moeny!100”}，表示请求参数中money不能是100 1234示例： @RequestMapping(value &#x3D; &quot;&#x2F;save&quot;,method &#x3D; RequestMethod.GET) public String save()&#123; return &quot;save.jsp&quot;; &#125; 1.mvc命名空间引入 123456命名空间：xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"约束地址：http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd 2.组件扫描 SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scan base-package=“com.itheima.controller”/&gt;进行组件扫描。 扫描可以如下配置过滤(或包含)指定的注解，一般只扫描controller 1234&lt;context:component-scan base-package&#x3D;&quot;com.dhz.controller&quot;&gt; &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt; &lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt; &lt;&#x2F;context:component-scan&gt; SpringMVC的XML配置解析SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties(下方external library-&gt;spring_webmvc)，该文件中配置了默认的视图解析器，如下： 1org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver 翻看该解析器源码，可以看到该解析器的默认设置，如下： 1234REDIRECT_URL_PREFIX = \"redirect:\" --重定向前缀FORWARD_URL_PREFIX = \"forward:\" --转发前缀（默认值）在return \"[forword:]/save.jsp\";prefix = \"\"; --视图名称前缀suffix = \"\"; --视图名称后缀 视图解析器 我们可以通过属性注入的方式修改视图的的前后缀，return “save”===访问/jsp/save.jsp 12345&lt;!--配置内部资源视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/jsp/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; 3.5 知识要点SpringMVC的相关组件 前端控制器：DispatcherServlet 处理器映射器：HandlerMapping 处理器适配器：HandlerAdapter 处理器：Handler 视图解析器：View Resolver 视图：View SpringMVC的注解和配置 请求映射注解：@RequestMapping 视图解析器配置： REDIRECT_URL_PREFIX = “redirect:” FORWARD_URL_PREFIX = “forward:” prefix = “”; suffix = “”;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring+web","slug":"spring-web","permalink":"https://donghuangzhong.github.io/tags/spring-web/"}]},{"title":"maven","slug":"maven","date":"2021-02-17T10:33:53.000Z","updated":"2021-07-10T01:12:57.621Z","comments":true,"path":"2021/02/17/maven/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/17/maven/","excerpt":"maven基本jar包、插件、配置","text":"maven基本jar包、插件、配置 安装 下载 进入官网点download https://maven.apache.org/ 下载解压，去掉多余的目录 配置环境变量 新增MAVEN_HOME 测试（cmd） 1mvn -v 改本地仓库 安装配置相关Idea卡在Resolving Maven dependencies 更换阿里云镜像 123456789101112131415161718192021&#x2F;&#x2F;修改apache-maven-3.5.2-bin\\apache-maven-3.5.2\\conf\\settings.xml&#x2F;&#x2F;在镜像位置增加如下内容 &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;&#x2F;id&gt; &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;&#x2F;name&gt; &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&lt;&#x2F;url&gt; &lt;&#x2F;mirror&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;&#x2F;id&gt; &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt; &lt;name&gt;阿里云谷歌仓库&lt;&#x2F;name&gt; &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;google&lt;&#x2F;url&gt; &lt;&#x2F;mirror&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;&#x2F;id&gt; &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt; &lt;name&gt;阿里云阿帕奇仓库&lt;&#x2F;name&gt; &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;apache-snapshots&lt;&#x2F;url&gt; &lt;&#x2F;mirror&gt; 修改maven设置 1修改maven Importing的jvm参数, 默认为700多, 直接修改成 -Xms1024m -Xmx2048m pom.xml相关jar包servlet123456789101112131415&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;7.0.47&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 插件tomcat712345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;&#x2F;port&gt; &lt;path&gt;&#x2F;&lt;&#x2F;path&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"maven","slug":"java/maven","permalink":"https://donghuangzhong.github.io/categories/java/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://donghuangzhong.github.io/tags/maven/"}]},{"title":"spring_problem","slug":"spring-problem","date":"2021-02-17T09:49:52.000Z","updated":"2021-06-25T07:57:50.815Z","comments":true,"path":"2021/02/17/spring-problem/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/17/spring-problem/","excerpt":"摘要","text":"摘要 常见问题类存在，但报找不到的错误 原因：target-&gt;classes目录下没有该文件 解决方法：手动进行maven编译 jsp无法解析EL表达式(${username}) 原因 Application server in question doesn’t support JSP 2.0. （应用服务器不支持JSP2.0) The web.xml is not declared as Servlet 2.4 or higher. (web.xml中servlet版本没有声明在2.4以上） The @page is configured with isELIgnored=true. （页面上配置了&lt;%@ page isELIgnored=”true” %&gt; ) The web.xml is configured with &lt;el-ignored&gt;true&lt;/el-ignored&gt; in &lt;jsp-config&gt;. (web.xml中显式地配置了忽略EL表达式） maven-archetype-webapp创建web.xml默认不支持EL 解决方法：修改web.xml如下，重启tomcat 123&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot; id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;3.0&quot;&gt;...&lt;&#x2F;web-app&gt; spring mvc导入jackson报错 原因：mvc为4.x。需要Jackson为2.6以上 解决方法：修改pom.xml中三个jackson jar包的版本为2.6以上即可 maven项目没有webapp文件夹 没有web.xml也可以部署到tomcat上 依次点击file -&gt; project structure-&gt;module,然后点右上角加号选择web 修改路径后点击o即可 Tomat Deployment 没有Artifact选择 依次点击file -&gt; project structure-&gt;Artifacts,然后点加号，选择如图后一直下一步即可 Eureka：No qualifying bean of type javax.servlet.Filter available 原因：Spring Boot和Spring Cloud版本不相对应导致。需要特别注意的使用Spring Boot和Spring Cloud进行开发时要求Spring Boot 的版本和 Spring Cloud 的版本相对应，如果版本不对应，会遇到很多报错的情况，他们的匹配关系如下： 1234Spring Cloud Hoxton --&gt; Spring Boot 2.2.xSpring Cloud Greenwich --&gt; Spring Boot 2.1.xSpring Cloud Finchley --&gt; Spring Boot 2.0.xSpring Cloud Edgware --&gt; Spring Boot 1.5.x 解决版本后，刷新一下maven依赖","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"}]},{"title":"Spring JdbcTemplate&声明式事务","slug":"Spring-JdbcTemplate-声明式事务","date":"2021-02-17T00:39:55.000Z","updated":"2021-05-20T07:17:06.310Z","comments":true,"path":"2021/02/17/Spring-JdbcTemplate-声明式事务/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/17/Spring-JdbcTemplate-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/","excerpt":"JDBCTemplate声明式事务控制 基于xal 基于注解","text":"JDBCTemplate声明式事务控制 基于xal 基于注解 JdbcTemplate基本使用概述(了解)JdbcTemplate是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。例如：操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。 开发步骤(理解)①导入spring-jdbc和spring-tx坐标 ②创建数据库表和实体 ③创建JdbcTemplate对象 ④执行数据库操作 快速入门代码实现(应用) 导入spring-jdbc、spring-tx、数据库相关坐标 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.3.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.3.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 创建数据库表和实体 123456789101112131415161718192021222324252627282930package com.dhz.domain;public class Account &#123; private String name; private double money; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, money&#x3D;&quot; + money + &#39;&#125;&#39;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money &#x3D; money; &#125;&#125; 创建JdbcTemplate对象，执行数据库操作 123456789101112131415161718@Test //测试JdbcTemplate开发步骤 public void test1() throws PropertyVetoException &#123; //创建数据源对象 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUser(\"root\"); dataSource.setPassword(\"root\"); JdbcTemplate jdbcTemplate = new JdbcTemplate(); //设置数据源对象 知道数据库在哪 jdbcTemplate.setDataSource(dataSource); //执行操作 int row = jdbcTemplate.update(\"insert into account values(?,?)\", \"tom\", 5000); System.out.println(row); &#125; spring产生模板对象分析(理解)我们可以将JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring，在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中,然后通过Spring容器获得JdbcTemplate对象来执行操作。 spring产生模板对象代码实现(应用)配置如下： 123456789101112&lt;!--数据源对象--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///test\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--jdbc模板对象--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; 测试代码 12345678@Test //测试Spring产生jdbcTemplate对象 public void test2() throws PropertyVetoException &#123; ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class); int row = jdbcTemplate.update(\"insert into account values(?,?)\", \"lisi\", 5000); System.out.println(row); &#125; spring产生模板对象代码实现（抽取jdbc.properties）(应用)将数据库的连接信息抽取到外部配置文件中，和spring的配置文件分离开，有利于后期维护 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root 配置文件修改为: 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--加载jdbc.properties--&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt; &lt;!--数据源对象--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt; &lt;!--jdbc模板对象--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 声明式事务控制编程式事务控制相关对象PlatformTransactionManagerPlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。 注意： PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：Dao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager TransactionDefinitionTransactionDefinition 是事务的定义信息对象，里面有如下方法： 事务隔离级别设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE 事务传播行为 REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式运行，如果当前存在事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 是否只读：建议查询时设置为只读 TransactionStatusTransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。 基于 XML 的声明式事务控制什么是声明式事务控制Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。 声明式事务处理的作用 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便 注意：Spring 声明式事务控制底层就是AOP。 声明式事务控制的实现声明式事务控制明确事项： 谁是切点？ 谁是通知？ 配置切面？ ①引入tx命名空间 1234567891011121314&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; ②配置事务增强 1234567891011&lt;!--平台事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--事务增强配置--&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt;//对不同的方法采用不同的事务参数(name是方法名，之后一堆事务参数) &lt;/tx:attributes&gt;&lt;/tx:advice&gt; ③配置事务 AOP 织入 12345&lt;!--事务的aop增强--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"myPointcut\"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; ④测试事务控制转账业务代码 123456@Overridepublic void transfer(String outMan, String inMan, double money) &#123; accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money);&#125; 切点方法的事务参数的配置123456&lt;!--事务增强配置--&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 其中，tx:method 代表切点方法的事务参数的配置，例如： 1&lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" timeout=\"-1\" read-only=\"false\"/&gt; name：切点方法名称 isolation:事务的隔离级别 propogation：事务的传播行为 timeout：超时时间 read-only：是否只读 3 基于注解的声明式事务控制3.1 使用注解配置声明式事务控制 正常注入+方法(或者类)上加@Transactional 编写 AccoutDao 1234567891011@Repository(\"accountDao\")public class AccountDaoImpl implements AccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void out(String outMan, double money) &#123; jdbcTemplate.update(\"update account set money=money-? where name=?\",money,outMan); &#125; public void in(String inMan, double money) &#123; jdbcTemplate.update(\"update account set money=money+? where name=?\",money,inMan); &#125;&#125; 编写 AccoutService 123456789101112@Service(\"accountService\")@Transactional //可以加在类上public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED) //也可以加在方法上,方法的优先级高 public void transfer(String outMan, String inMan, double money) &#123; accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money); &#125;&#125; 编写 applicationContext.xml 配置文件 12345&lt;!—之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt;&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=\"com.itheima\"/&gt;&lt;!--事务的注解驱动--&gt;&lt;tx:annotation-driven/&gt; 3.2 注解配置声明式事务控制解析①使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。 ②注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。 ③使用在方法上，不同的方法可以采用不同的事务参数配置。 ④Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt; 3.3 知识要点注解声明式事务控制的配置要点 平台事务管理器配置（xml方式） 事务通知的配置（@Transactional注解配置） 事务注解驱动的配置 tx:annotation-driven/","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"},{"name":"jdbctemplate","slug":"jdbctemplate","permalink":"https://donghuangzhong.github.io/tags/jdbctemplate/"}]},{"title":"Java_Spring","slug":"Java-Spring","date":"2021-02-14T07:51:11.000Z","updated":"2021-06-06T09:04:15.020Z","comments":true,"path":"2021/02/14/Java-Spring/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/14/Java-Spring/","excerpt":"spring入门环境快速搭建","text":"spring入门环境快速搭建 spring概述Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层 SpringMVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架 自动注入默认使用无参构造方法 spring入门spring无注解快速搭建 新建空的maven项目，在pom.xml中引入spring jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 新建测试的Bean 1234567891011public class TestBean &#123; public void run()&#123; System.out.println(&quot;TestBean Running...&quot;); &#125; public void init()&#123; System.out.println(&quot;init method ...&quot;); &#125; public void destroy()&#123; System.out.println(&quot;destroy method ...&quot;); &#125;&#125; resource目录下新建applicationCOntext.xml，配置bean 1234567&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;com.dhz.bean.TestBean&quot;&gt;&lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; 编写运行类测试 1234567public class Run &#123; public static void main(String[] args) &#123; ApplicationContext app&#x3D;new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); TestBean testBean&#x3D; (TestBean) app.getBean(&quot;testBean&quot;); testBean.run(); &#125;&#125; 配置文件详解 1234567891011121314151617181920212223242526public class Dog &#123; private String name; public Dog() &#123; &#125; public Dog(String name) &#123; this.name &#x3D; name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; void eat()&#123; System.out.println(name+&quot; is eatting...&quot;); &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Zoo &#123; private Dog dog; private int peopleNum; private List&lt;String&gt; peopleNames; private List&lt;Dog&gt; dogs; private Map&lt;String,Dog&gt; dogMap; private Properties properties; public void setDog(Dog dog) &#123; this.dog &#x3D; dog; &#125; public void setPeopleNum(int peopleNum) &#123; this.peopleNum &#x3D; peopleNum; &#125; public void setPeopleNames(List&lt;String&gt; peopleNames) &#123; this.peopleNames &#x3D; peopleNames; &#125; public void setDogs(List&lt;Dog&gt; dogs) &#123; this.dogs &#x3D; dogs; &#125; public void setDogMap(Map&lt;String, Dog&gt; dogMap) &#123; this.dogMap &#x3D; dogMap; &#125; public void setProperties(Properties properties) &#123; this.properties &#x3D; properties; &#125; @Override public String toString() &#123; return &quot;Zoo&#123;&quot; + &quot;dog&#x3D;&quot; + dog + &quot;, peopleNum&#x3D;&quot; + peopleNum + &quot;, peopleNames&#x3D;&quot; + peopleNames + &quot;, dogs&#x3D;&quot; + dogs + &quot;, dogMap&#x3D;&quot; + dogMap + &quot;, properties&#x3D;&quot; + properties + &#39;&#125;&#39;; &#125;&#125; 12345public class NoStaticDogFactory &#123; public Dog creatDog()&#123; return new Dog(&quot;非静态创建的狗&quot;); &#125;&#125; 12345public class StaticDogFactory &#123; public static Dog creatDog()&#123; return new Dog(&quot;静态创建的狗&quot;); &#125;&#125; dog_applicationContext.xml 1234567891011121314151617181920212223242526272829&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;!--默认用无参构造方法生成实例后用set设置参数--&gt; &lt;bean id&#x3D;&quot;dog1&quot; class&#x3D;&quot;com.dhz.bean.Dog&quot;&gt; &lt;!--String等基本数据类型用value--&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;泰迪&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;bean id&#x3D;&quot;dog2&quot; class&#x3D;&quot;com.dhz.bean.Dog&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;金毛&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--使用有参构造生成bean--&gt; &lt;bean id&#x3D;&quot;constructorDog&quot; class&#x3D;&quot;com.dhz.bean.Dog&quot;&gt; &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;有参构造的狗&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--通过静态方法生成bean--&gt; &lt;bean id&#x3D;&quot;staticDog&quot; class&#x3D;&quot;com.dhz.factory.StaticDogFactory&quot; factory-method&#x3D;&quot;creatDog&quot;&#x2F;&gt; &lt;!--通过非静态方法生成bean--&gt; &lt;bean id&#x3D;&quot;factoryBean&quot; class&#x3D;&quot;com.dhz.factory.NoStaticDogFactory&quot;&#x2F;&gt; &lt;bean id&#x3D;&quot;noStaticDog&quot; factory-bean&#x3D;&quot;factoryBean&quot; factory-method&#x3D;&quot;creatDog&quot;&#x2F;&gt;&lt;&#x2F;beans&gt; applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;com.dhz.bean.TestBean&quot;&gt;&lt;&#x2F;bean&gt; &lt;!--读取properties配置文件--&gt; &lt;context:property-placeholder location&#x3D;&quot;classpath:dog.properties&quot;&#x2F;&gt; &lt;bean id&#x3D;&quot;propertyDog&quot; class&#x3D;&quot;com.dhz.bean.Dog&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;$&#123;dogName&#125;&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--分模块配置中导入其他模块的配置--&gt; &lt;import resource&#x3D;&quot;dog_applicationContext.xml&quot;&#x2F;&gt; &lt;!--context命名空间下扫描注解配置--&gt; &lt;context:component-scan base-package&#x3D;&quot;com.dhz&quot;&#x2F;&gt;&lt;!-- 各种数据类型的注入--&gt; &lt;bean id&#x3D;&quot;zoo&quot; class&#x3D;&quot;com.dhz.bean.Zoo&quot;&gt; &lt;!--引用数据类型用ref注入--&gt; &lt;property name&#x3D;&quot;dog&quot; ref&#x3D;&quot;dog1&quot;&#x2F;&gt; &lt;!--基本数据类型用value--&gt; &lt;property name&#x3D;&quot;peopleNum&quot; value&#x3D;&quot;100&quot;&#x2F;&gt; &lt;!--List&lt;String&gt;的注入--&gt; &lt;property name&#x3D;&quot;peopleNames&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;&#x2F;value&gt; &lt;value&gt;李四&lt;&#x2F;value&gt; &lt;value&gt;Tom&lt;&#x2F;value&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt; &lt;!--List&lt;Dog&gt;的注入--&gt; &lt;property name&#x3D;&quot;dogs&quot;&gt; &lt;list&gt; &lt;ref bean&#x3D;&quot;dog1&quot;&#x2F;&gt; &lt;ref bean&#x3D;&quot;dog2&quot;&#x2F;&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt; &lt;!--Map&lt;String,Dog&gt;的注入--&gt; &lt;property name&#x3D;&quot;dogMap&quot;&gt; &lt;map&gt; &lt;entry key&#x3D;&quot;dog1&quot; value-ref&#x3D;&quot;dog1&quot;&#x2F;&gt; &lt;entry key&#x3D;&quot;dog2&quot; value-ref&#x3D;&quot;dog2&quot;&#x2F;&gt; &lt;&#x2F;map&gt; &lt;&#x2F;property&gt; &lt;!--Properties的注入--&gt; &lt;property name&#x3D;&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key&#x3D;&quot;key1&quot;&gt;value1&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;key2&quot;&gt;value2&lt;&#x2F;prop&gt; &lt;&#x2F;props&gt; &lt;&#x2F;property&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; dog.properties 1dogName&#x3D;dog_properties spring+注解 快速搭建 新建空的maven项目，在pom.xml中引入spring jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 新建测试的bean 1234567891011121314151617@Component(&quot;wang_cai&quot;)public class Dog &#123; @Value(&quot;旺财&quot;) private String name; public void eat()&#123; System.out.println(&quot;dog is eatting ...&quot;); &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125;&#125; 编写配置类 1234@Configuration@ComponentScan(&quot;com.dhz&quot;)public class SpringConfiguration &#123;&#125; 测试 12345678public class Run &#123; public static void main(String[] args) &#123; ApplicationContext app&#x3D;new AnnotationConfigApplicationContext(SpringConfiguration.class); Dog d &#x3D; (Dog) app.getBean(&quot;wang_cai&quot;); d.eat(); System.out.println(d); &#125;&#125; 常用注解原始注解 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 @Component(“id名”)1@Component(&quot;userDao&quot;) &#x2F;&#x2F;类注解，配置bean @Resource(name=”xxx”)相当于@Autowired+@Qualifier(“xxx”)，按照id注入 1234&#x2F;&#x2F; @Autowired&#x2F;&#x2F; @Qualifier(&quot;userDao&quot;) @Resource(name&#x3D;&quot;userDao&quot;) private UserDao userDao; @Value(“xxx”)基本数据类型赋值，xxx可为EL表达式 12@Value(&quot;$&#123;jdbc.driver&#125;&quot;)private String driver; @Scope(“xxx”)1234567加在类上scope&#x3D;&quot;singleton&quot; &#x2F;&#x2F;默认，单例，单例模式下，创建spring容器时仅创建一个单例ApplicationContext app&#x3D;new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);此时执行无参构造，仅创建一个实例，只要容器在，对象一直活着，销毁容器时，销毁此实例---------------------------------------------------------------------scope&#x3D;&quot;prototype&quot; &#x2F;&#x2F;多例，每一次getBean都创建一个实例，只要此实例在使用，实例一直活着，长时间不用就会被垃圾回收 @PostConstruct和@PreDestroy加在bean中的方法上 12@PostConstruct &#x2F;&#x2F;init方法@PreDestroy &#x2F;&#x2F;Destroy方法 新注解@Configuration1@Configuration &#x2F;&#x2F;类注解。标志Spring配置类 @ComponentScan(“路径名”)123@ComponentScan(&quot;com.dhz&quot;) &#x2F;&#x2F;类注解，配置注解扫描路径&#x2F;&#x2F;相当于&#x2F;&#x2F;&lt;context:component-scan base-package&#x3D;&quot;com.dhz&quot;&gt;&lt;&#x2F;context:component-scan&gt; @PropertySource(“xxx”)12@PropertySource(&quot;classpath:jdbc.properties&quot;)&#x2F;&#x2F;类注解&#x2F;&#x2F;classpath：表示resources目录下 @Import({xxx.class})1@Import(&#123;DataSourceConfiguration.class&#125;) &#x2F;&#x2F;类注解，引入其他配置类 @Bean 方法中的public DataSource getDataSource(此处可以自动注入参数，和上面的注入方法一样，默认按照类型注入) 用@Resourc等都可以 123456789@Bean(name&#x3D;&quot;dataSource&quot;)public DataSource getDataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource &#x3D; new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource;&#125; 常用标签读取properties+EL表达式(${})12&lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;&#x2F;&#x2F;classpath：表示resources目录下 搭建SpringJunitTestpom.xml 引入jar包12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 编写测试类1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes &#x3D; &#123;SpringConfiguration.class&#125;)&#x2F;&#x2F;@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)&#x2F;&#x2F;或者直接加载配置文件public class SpringJunitTest &#123; @Autowired private UserService userService; @Test public void test()&#123; userService.save(); &#125;&#125; 注：Test方法必须是public AOPAOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 底层实现：通过 Spring 提供的的动态代理技术实现的。 常用的动态代理技术 JDK 代理 : 基于接口的动态代理技术 cglib 代理：基于父类的动态代理技术 自己实现aop目录结构 TargetInterface.java 12345package com.dhz.proxy.jdk;public interface TargetInterface &#123; void save();&#125; Advice.java 12345678910package com.dhz.proxy.cglib;public class Advice &#123; void before()&#123; System.out.println(&quot;before....&quot;); &#125; void after()&#123; System.out.println(&quot;after....&quot;); &#125;&#125; Target.java 12345678package com.dhz.proxy.cglib;public class Target &#123; public void save() &#123; System.out.println(&quot;save....&quot;); &#125;&#125; 基于JDK1234567891011121314151617181920public static void main(String[] args) &#123; final Target target&#x3D;new Target(); final Advice advice&#x3D;new Advice(); TargetInterface targetInterface&#x3D; (TargetInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(),&#x2F;&#x2F;目标对象的类加载器 target.getClass().getInterfaces(),&#x2F;&#x2F;目标对象的接口字节码对象数组 new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; advice.before(); Object invoke &#x3D; method.invoke(target, args); advice.after(); return invoke; &#125; &#125; ); targetInterface.save(); &#125; 基于cglib目录结构中没有TargetInterface.java 1234567891011121314151617181920212223public static void main(String[] args) &#123; final Target target&#x3D;new Target(); final Advice advice&#x3D;new Advice(); &#x2F;&#x2F;1.创建增强器 Enhancer enhancer&#x3D;new Enhancer(); &#x2F;&#x2F;2.设置父类（目标） enhancer.setSuperclass(Target.class); &#x2F;&#x2F;3.设置回调 enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; advice.before(); Object invoke &#x3D; method.invoke(target, args); advice.after(); return invoke; &#125; &#125;); &#x2F;&#x2F;4.创建代理对象 Target target1 &#x3D; (Target) enhancer.create(); target1.save();&#125; sprnig-AOP目录结构 基于xml的AOP快速入门①导入 AOP 相关坐标 ②创建目标接口和目标类（内部有切点） ③创建切面类（内部有增强方法） ④将目标类和切面类的对象创建权交给 spring ⑤在 applicationContext.xml 中配置织入关系 ⑥测试代码 导入 AOP 相关坐标 123456789101112&lt;!--导入spring的context坐标，context依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!-- aspectj的织入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt; &lt;version&gt;1.8.13&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 创建目标接口和目标类（内部有切点） 12345678910public interface TargetInterface &#123; void save();&#125;public class Target implements TargetInterface&#123; public void save() &#123; System.out.println(&quot;save....&quot;); &#125;&#125; 创建切面类（内部有增强方法） 12345678public class Myaspect &#123; public void before()&#123; System.out.println(&quot;before....&quot;); &#125; public void after()&#123; System.out.println(&quot;after....&quot;); &#125;&#125; 将目标类和切面类的对象创建权交给 spring 12&lt;bean id&#x3D;&quot;myaspect&quot; class&#x3D;&quot;com.dhz.aop.Myaspect&quot;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;target&quot; class&#x3D;&quot;com.dhz.aop.Target&quot;&gt;&lt;&#x2F;bean&gt; 在 applicationContext.xml 中配置织入关系 导入aop命名空间 1234567891011&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; 配置切点表达式和前置增强的织入关系 12345&lt;aop:config&gt; &lt;aop:aspect ref&#x3D;&quot;myaspect&quot;&gt; &lt;aop:before method&#x3D;&quot;before&quot; pointcut&#x3D;&quot;execution(public void com.dhz.aop.Target.save())&quot;&gt;&lt;&#x2F;aop:before&gt; &lt;&#x2F;aop:aspect&gt; &lt;&#x2F;aop:config&gt; 测试代码 12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest &#123; @Autowired private TargetInterface target; @Test public void test()&#123; target.save(); &#125;&#125; XML 配置 AOP 详解 切点表达式的写法 表达式语法： 1execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如： 12345execution(public void com.itheima.aop.Target.method()) execution(void com.itheima.aop.Target.*(..))execution(* com.itheima.aop.*.*(..))execution(* com.itheima.aop..*.*(..))execution(* *..*.*(..)) 通知的类型通知的配置语法： 1&lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式\"&gt;&lt;/aop:通知类型&gt; 注意环绕的方法如下： 1234567&#x2F;&#x2F;ProceedingJoinPoint是正在执行的方法public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;前置。。。&quot;); Object proceed &#x3D; pjp.proceed(); System.out.println(&quot;后置。。。&quot;); return proceed;&#125; 切点表达式的抽取 当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。 1234&lt;aop:aspect ref=\"myaspect\"&gt; &lt;aop:pointcut id=\"myPointCut\" expression=\"execution(* com.dhz.aop.*.*(..))\"/&gt; &lt;aop:around method=\"around\" pointcut-ref=\"myPointCut\"&gt;&lt;/aop:around&gt;&lt;/aop:aspect&gt; 基于注解的 AOP 开发快速入门 基于注解的aop开发步骤： ①创建目标接口和目标类（内部有切点） ②创建切面类（内部有增强方法） ③将目标类和切面类的对象创建权交给 spring ④在切面类中使用注解配置织入关系 ⑤在配置文件中开启组件扫描和 AOP 的自动代理 ⑥测试 ①创建目标接口和目标类（内部有切点） 12345678910public interface TargetInterface &#123; void save();&#125;public class Target implements TargetInterface &#123; public void save() &#123; System.out.println(&quot;save....&quot;); &#125;&#125; ②创建切面类（内部有增强方法) 12345public class Myaspect &#123; public void before()&#123; System.out.println(\"before....\"); &#125;&#125; ③将目标类和切面类的对象创建权交给 spring 123456789101112131415@Component(\"target\")public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(\"Target running....\"); &#125;&#125;@Component(\"myAspect\")public class MyAspect &#123; public void before()&#123; System.out.println(\"前置代码增强.....\"); &#125;&#125; ④在切面类中使用注解配置织入关系 12345678@Component(\"myaspect\")@Aspectpublic class Myaspect &#123; @Before(\"execution(* com.dhz.anno.*.*(..))\") public void before()&#123; System.out.println(\"before....\"); &#125;&#125; ⑤在配置文件中开启组件扫描和 AOP 的自动代理 12345&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=\"com.itheima.aop\"/&gt;&lt;!--aop的自动代理--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; ⑥测试代码 12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext_anno.xml\")public class AnnoTest &#123; @Autowired private TargetInterface target; @Test public void test()&#123; target.save(); &#125;&#125; 注解配置 AOP 详解注解通知的类型 通知的配置语法：@通知注解(“切点表达式”) 切点表达式的抽取 同 xml配置 aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下： 1234567891011121314151617181920212223242526@Component(\"myaspect\")@Aspectpublic class Myaspect &#123; @Before(\"execution(* com.dhz.anno.*.*(..))\") public void before()&#123; System.out.println(\"before....\"); &#125; @After(\"pointcut()\") public void after()&#123; System.out.println(\"after....\"); &#125; @Around(\"Myaspect.pointcut()\") public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(\"前置。。。\"); Object proceed = pjp.proceed(); System.out.println(\"后置。。。\"); return proceed; &#125; @Pointcut(\"execution(* com.dhz.anno.*.*(..))\") public void pointcut()&#123; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"}]},{"title":"目标检测","slug":"目标检测","date":"2021-02-08T01:50:49.000Z","updated":"2021-02-09T12:29:38.828Z","comments":true,"path":"2021/02/08/目标检测/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/08/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/","excerpt":"摘要","text":"摘要 R-CNN算法流程 一张图像生成1K~2K个候选区域(使用Selective Search方法) 对每个候选区域，缩放后(277277)使用*AlexNet CNN网络**提取特征向量 (4096维)，最终得到2k * 4096大小矩阵 特征送入每一类(共20类)的SVM 分类器， 判别是否属于该类 ，得到2k * 20矩阵 对每一列进行非极大值抑制 寻找得分最高的目标 计算其他目标与该目标的iou值 删除所有iou值大于给定阈值的目标 使用回归器精细修正候选框位置 算法框架 存在的问题 测试速度慢测试一张图片约53s(CPU)。 用Selective Search算法提取候选框用时约2秒， 一张图像内候选框之间存在大量重叠， 提取特征操作冗余。 训练速度慢 训练所需空间大对于SVM和bbox回归训练， 需要从每个图像中的每个目标候选框提取特征， 并写入磁盘。 对于非常深的网络， 如VGG16， 从VOC07训练集上的5k图像上提取的特征需要数百GB的存储空间。 Fast R-CNN算法流程 一张图像生成1K~2K个候选区域(使用Selective Search方法) 整幅图像输入到网络得到特征图，将筛选后64个候选框投影到特征图后得到64个特征矩阵 特征矩阵通过ROI pooling层缩放到7x7大小的特征图，展平得到特征向量 特征向量并联分类器和边界框回归器 主要组件分类器 N+1个节点(N个类别+1个背景) 经过softmax处理 边界框回归器 (N+1)*4个节点(每个类别对应4个边界框回归参数(dx, dy, dw, dh) ) Px, Py, Pw, Ph 分别为候选框的中心x y坐标，以及宽高 Gˆx,Gˆ y,Gˆw,Gˆh 分别为最终预测的边界框中心x y坐标，以及宽高 损失函数 p : 分类器输出的softmax输出 u : 真实类别标签 算法框架 Faster R-CNN实际就是RPN + Fast R-CNN 算法流程 将图像输入网络得到相应的特征图 使用RPN结构生成候选框， 将RPN生成的候选框投影到特征图上获得相应的特征矩阵 将每个特征矩阵通过ROI pooling层缩放到7x7大小的特征图，接着将特征图展平通过一系列全连接层得到预测结果 RPNRPN在特征图的基础上用3*3的窗口(padding=1,步距为1)进行滑动，将3 * 3窗口的中心通过比例变换得到原图中的像素，以这个像素为中心生成9个anchor。去除跨越边界的anchor，对每一个anchor得到6个输出(2个表示是不是前景，后边四个表示回归参数)，采用非极大值抑制保留少数的候选框 YOLO v1算法思想 将一幅图像分成SxS个网格，如果某个类别真实候选框的中心落在这个网格中， 则这个网格就负责预测这个候选框。 每个网格要预测B个候选框和C个类别，候选框包含预测位置(x,y,w,h)和confidence值。 x,y,w,h都是相对值(相对于原图像)，都在0~1之间 网络结构 损失函数 缺点 群体性小目标检测效果不好(原论文7*7个网格，每个网格预测两个框) 目标出现新的尺寸比例的时候效果差(直接预测位置和宽高，而像R-CNN和SSD系列预测回归参数) YOLO v2算法尝试和创新 每个卷积层后加BN(Batch Normalization)层 更大的输入图片尺寸(更高分辨率) 基于Anchor Boxes，用K-means聚类得到anchor尺寸 用sigmoid函数限制变换后的位置 高层特征和底层特征(包含细节信息，解决v1小目标效果不好)结合 用4x4方格将宽高变为一半，深度变为4倍，与高层特征在深度上拼接 多尺度训练，解决输入图像尺寸固定的弊端，每迭代10个batch，随机选择图片尺寸 网络结构darknet-19 总结构 YOLO v3创新点 在三个尺度对目标进行检测 网络结构DarkNet-53 总结构) 损失函数 目标置信度损失目标置信度损失采用的是二值交叉熵损失(Binary Cross Entropy)，其中,表示预测目标边界框i中是否真实存在目标，0表示不存在，1表示存在。表示预测目标矩形框i内是否存在目标的Sigmoid概率（将预测值通过sigmoid函数得到）。 目标类别损失","categories":[{"name":"目标检测","slug":"目标检测","permalink":"https://donghuangzhong.github.io/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"目标检测","slug":"目标检测","permalink":"https://donghuangzhong.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"test","slug":"test","date":"2021-02-07T09:36:50.486Z","updated":"2021-02-07T09:57:12.775Z","comments":true,"path":"2021/02/07/test/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/07/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux_WSL","slug":"Linux-WSL","date":"2021-02-07T09:01:54.000Z","updated":"2021-06-12T01:16:01.923Z","comments":true,"path":"2021/02/07/Linux-WSL/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/07/Linux-WSL/","excerpt":"摘要","text":"摘要 常用命令版本相关linux查看当前操作系统发行信息12cat &#x2F;etc&#x2F;issuecat &#x2F;etc&#x2F;redhat-release 更新阿里源 备份原先的源 1mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup 下载新的阿里源 1wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-8.repo 运行 yum makecache 生成缓存 1yum makecache 更新 1yum -y update 安装常用软件 软件地址： 安装之前上传到usr/local文件夹 安装JDK 查看jdk版本 1java –version 查看安装的jdk信息 1rpm -qa | grep java 卸载jdk 12rpm -e --nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686rpm -e --nodeps java-1.7.0-openjdk-1.7.0.79-2.5.5.4.el6.i686 进入usr/local解压JDK，通常将软件安装到/usr/local 1tar –xvf jdk.tar.gz -C 目标路径 配置JDK的环境变量 123456789vi &#x2F;etc&#x2F;profile在末尾行添加#set java environmentJAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk&#x2F;jdk1.7.0_71CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib.tools.jarPATH&#x3D;$JAVA_HOME&#x2F;bin:$PATHexport JAVA_HOME CLASSPATH PATH保存退出 安装mysql 上传后解压 将系统自带的mysql卸载 123rpm –qa | grep mysql rpm -e --nodeps 名字 安装MYSQL服务端 会在/root/.mysql_secret中生成root用户的密码 安装MYSQL客户端 查看生成的root密码 开启mysql服务 1service mysql start 设置root用户的密码 1set password&#x3D;password(&#39;root&#39;) 设置mysql远程访问 123grant all privileges on *.* to &#39;root&#39; @&#39;%&#39; identified by &#39;root&#39;;flush privileges; 防火墙设置 1234567在linux中很防火墙打开3306端口&#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 3306 -j ACCEPT&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;iptables save&#x2F;etc&#x2F;init.d&#x2F;iptables status学习阶段我们也可以直接将防火墙关闭service iptables stop;多软件的端口都被”防火墙”限止，我们需要将防火墙关闭 安装tomcat 上传解压至usr/local 在tomcat/bin目录下执行 startup.sh 安装Redisredis是C语言开发，安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境。 安装c语言环境 1yum install gcc-c++ 下载redis 1wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.0.4.tar.gz 解压 1tar -xzvf redis-3.0.4.tar.gz 编译 12cd redis-3.0.4make 安装 1make PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis install 复制配置文件到/usr/local/redis/bin目录 123cd redis-3.0.4cp redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin 启动redis 1234567cd redis&#x2F;bin指定配置文件启动服务端.&#x2F;redis-server redis.conf启动客户端.&#x2F;redis-cli 安装Nginx 安装gcc环境 1yum install gcc-c++ 安装第三方的开发包 123yum install -y pcre pcre-develyum install -y zlib zlib-develyum install -y openssl openssl-devel 上传解压安装包到usr/local 1tar -zxvf nginx-1.8.0.tar.gz 进入解压目录生成makeFile 文件，然后make 1234567891011121314151617181920cd nginx-1.8.0&#x2F;.&#x2F;configure \\--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx \\--pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx&#x2F;nginx.pid \\--lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx.lock \\--error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log \\--http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client \\--http-proxy-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;proxy \\--http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;fastcgi \\--http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;uwsgi \\--http-scgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;scgimakemake install&#x2F;&#x2F;注：四条命令都要执行，最后会生成一个usr&#x2F;local&#x2F;nginx文件夹 安装完成，创建临时目录 1mkdir &#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client -p 启动 123cd sbin&#x2F;.&#x2F;nginx 关闭、刷新命令 123.&#x2F;nginx -s quit &#x2F;&#x2F;正常关闭.&#x2F;nginx -s stop &#x2F;&#x2F;杀进程.&#x2F;nginx -s reload &#x2F;&#x2F;刷新 安装Centos8下载镜像12 用命令行安装123windows命令行(管理员)：wsl --import &lt;分发版&gt; &lt;安装位置&gt; &lt;文件名&gt; [选项]wsl --import CentOS D:\\CentOS D:\\文件路径\\centos8.tar 启动1wsl -d Centos 迁移查看当前用户名12whoami&#x2F;&#x2F;我的用户名是 DongHuangZhong 在迁移目标磁盘创建一个文件夹 ，并设置权限123icacls E:\\bianchenggongju\\Kali.windows &#x2F;grant &quot;DongHuangZhong:(OI)(CI)(F)&quot;.\\lxrunoffline move -n kali-linux -d E:\\bianchenggongju\\Kali.windows 下载解压 LxRunOffline1网址:https:&#x2F;&#x2F;github.com&#x2F;DDoSolitary&#x2F;LxRunOffline&#x2F;releases 解压后，在此目录中按shift+鼠标右键，在此处打开powershell 查看已安装的Linux发行版本1.\\lxrunoffline list 用命令迁移1.\\lxrunoffline move -n kali-linux -d E:\\bianchenggongju\\Kali.windows 确认迁移完成1.&#x2F;LxRunOffline.exe get-dir -n kali-linux","categories":[{"name":"linux","slug":"linux","permalink":"https://donghuangzhong.github.io/categories/linux/"}],"tags":[{"name":"WSL","slug":"WSL","permalink":"https://donghuangzhong.github.io/tags/WSL/"}]},{"title":"python_pandas","slug":"python-pandas","date":"2021-01-28T03:27:31.000Z","updated":"2021-01-28T03:43:08.223Z","comments":true,"path":"2021/01/28/python-pandas/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/28/python-pandas/","excerpt":"摘要","text":"摘要 主体数据类型：DataFrame 名称 功能 参数 返回值 pd.read_csv() 读取csv 路径字符串 DataFrame pd.DataFrame(np.zeros(shape=[1000, 20]), columns=move_class) 创建DataFarame ndarry，列标签 DataFrame DataFrame.sum(axis) 对行或列求和 axis，0列求和，1行求和","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"https://donghuangzhong.github.io/tags/pandas/"}]},{"title":"python_ndarray","slug":"python-ndarray","date":"2021-01-28T03:14:20.000Z","updated":"2021-01-28T04:05:01.935Z","comments":true,"path":"2021/01/28/python-ndarray/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/28/python-ndarray/","excerpt":"摘要","text":"摘要 1.ndarray创建1.通过list创建1a &#x3D; np.array([[1, 2, 3], [4, 5, 6]], dtype &#x3D; np.float32) 2.ndarray的属性 属性 含义 类型 shape 形状 元组 ndim 维度 整数 size 数组中元素个数 整数 itemsize 元素的字节数 整数 dtype 元素类型 “int32” 3.ndarray的方法1.reshape() &amp;&amp; resize()reshape()不改变数据，只改变逻辑上的维数 resize()会改变数据 2.stock_change[stock_change &gt; 0.5] = 1.1将stock_change元素中&gt;0.5的置为1.1 1234567print(score.shape)print(score.ndim)print(score.size)print(score.itemsize)print(score.dtype)score2 &#x3D; score.reshape(6, 5) 4.numpy的方法1.np.random.uniform(low,high,size)均匀分布[low,high)中随机采样size次得到一维数组 2.np.unique(ndarray)返回去重后的数组 3.numpy.random.normal(loc,scale,size)loc：均值 scale：方差 size：个数 4.np.hstack(a,b)在水平方向上连接a数组和b数组 5.np.concatenate((a,b),axis=0)axis=1表示对应行的数组进行拼接 axis=0表示对应列的数组进行拼接 6.np.split()12345678x &#x3D; np.arange(9)print(x)print(np.split(x, 3))print(np.split(x, [3, 5, 7, 8]))[0 1 2 3 4 5 6 7 8][array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])][array([0, 1, 2]), array([3, 4]), array([5, 6]), array([7]), array([8])]","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://donghuangzhong.github.io/tags/numpy/"}]},{"title":"python_pyplot","slug":"python-pyplot","date":"2021-01-28T01:49:00.000Z","updated":"2021-01-28T03:27:06.885Z","comments":true,"path":"2021/01/28/python-pyplot/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/28/python-pyplot/","excerpt":"摘要","text":"摘要 1.图形属性123plt.title(&quot;matplotlib demo&quot;)plt.figure(figsize&#x3D;(20, 8), dpi&#x3D;80) &#x2F;&#x2F;dpi每英寸像素数plt.show()&#x2F;&#x2F;最后都要加才能显示 2.其他图1.二维函数图123plt.xlabel(&quot;x axis&quot;)plt.ylabel(&quot;y axis&quot;)plt.plot(x, y) 2.散点图1plt.scatter(x, y) 3.柱状图1plt.bar(x_lebel, y, color&#x3D;[&#39;b&#39;, &#39;r&#39;, &#39;g&#39;, &#39;y&#39;, &#39;c&#39;, &#39;m&#39;, &#39;y&#39;, &#39;k&#39;, &#39;c&#39;]) 4.饼图1234567plt.pie(tickets, labels&#x3D;movie_names, colors&#x3D;[&#39;b&#39;, &#39;r&#39;, &#39;g&#39;, &#39;y&#39;],autopct&#x3D;&quot;%1.2f&quot;)&#x2F;&#x2F;autopct :控制饼图内百分比设置,可以使用format字符串或者format function &#39;%1.1f&#39;指小数点前后位数(没有用空格补齐) &#x2F;&#x2F;显示图例对应关系plt.legend() 5.直方图12345plt.hist(y, bins&#x3D;10)&#x2F;&#x2F;bins：有几条柱子plt.xticks(range(min(time), max(time), distance))&#x2F;&#x2F;x轴的开始结束和步距 3.中文乱码问题 百度安装simhei.ttf字体 打开python安装目录下python\\Lib\\site-packages\\matplotlib\\mpl-data\\matplotlibrc 搜索font.sans-serif ，去掉注释，在冒号后添加SimHei 搜索axes.unicode_minus，注释去掉，Ture改为False","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"}],"tags":[{"name":"pyplot","slug":"pyplot","permalink":"https://donghuangzhong.github.io/tags/pyplot/"}]},{"title":"JSP&&EL&JSTL","slug":"JSP-EL-JSTL","date":"2021-01-22T04:43:52.000Z","updated":"2021-03-05T00:39:31.497Z","comments":true,"path":"2021/01/22/JSP-EL-JSTL/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/22/JSP-EL-JSTL/","excerpt":"JSP: 指令 注释 内置对象 MVC开发模式 EL表达式 JSTL标签","text":"JSP: 指令 注释 内置对象 MVC开发模式 EL表达式 JSTL标签 JSP 概念：Java Server Pages： java服务器端页面 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写！！！ 原理：JSP本质上就是一个Servlet JSP的脚本：JSP定义Java代码的方式1231. &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。3. &lt;%&#x3D; 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 指令 作用：用于配置JSP页面，导入资源文件 格式 1&lt;%@ 指令名称 属性名1&#x3D;属性值1 属性名2&#x3D;属性值2 ... %&gt; 分类 page contentType：等同于response.setContentType() 设置响应体的mime类型以及字符集2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） import：导包 errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：标识当前也是是否是错误页面。 true：是，可以使用内置对象exception false：否。默认值。不可以使用内置对象exception include 页面包含的。导入页面的资源文件 1&lt;%@include file&#x3D;&quot;top.jsp&quot;%&gt; taglib 导入资源 12&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt; &#x2F;&#x2F;prefix：前缀，自定义的 注释 html注释 1&lt;!-- --&gt; &#x2F;&#x2F;只能注释html代码片段 jsp注释：推荐使用 1&lt;%-- --%&gt; &#x2F;&#x2F;可以注释所有 内置对象在jsp页面中不需要创建，直接使用的对象，一共有如下9个。 变量名 真实类型 作用 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源(转发) session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面(Servlet)的对象this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 * out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 * response.getWriter()和out.write()的区别： * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 * response.getWriter()数据输出永远在out.write()之前MVC：开发模式jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 MVC M：Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V：View，视图。JSP 展示数据 C：Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 优缺点 优点 耦合性低，方便维护，可以利于分工协作 重用性高 缺点：使得项目架构变得复杂，对开发人员要求高 EL表达式不用声明语句，直接在jsp中使用即可 概念Expression Language 表达式语言 作用替换和简化jsp页面中java代码的编写 语法${表达式} 忽略el表达式jsp默认支持el表达式的。如果要忽略el表达式 设置jsp中page指令中：isELIgnored=”true” 忽略当前jsp页面中所有的el表达式 \\${表达式} ：忽略当前这个el表达式 使用运算 算数运算符： + - * /(div) %(mod) 比较运算符： &gt; &lt; &gt;= &lt;= == != 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0 ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0 获取值 el表达式只能从域对象中获取值 语法 ${域名称.键名}：从指定域中获取指定键的值 域名称 12341. pageScope --&gt; pageContext2. requestScope --&gt; request3. sessionScope --&gt; session4. applicationScope --&gt; application（ServletContext） 举例：在request域中存储了name=张三 获取：${requestScope.name} ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 获取对象、List集合、Map集合的值 对象：${域名称.键名.属性名} 本质上会去调用对象的getter方法 List集合：${域名称.键名[索引]} Map集合 ${域名称.键名.key名称} ${域名称.键名[“key名称”]} 隐式对象el表达式中有11个隐式对象 pageContext 获取jsp其他八个内置对象 ${pageContext.request.contextPath}：动态获取虚拟目录 JSTL概念 JavaServer Pages Tag Library JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt; 作用用于简化和替换jsp页面上的java代码 使用步骤 导入jstl相关jar包 引入标签库：taglib指令： &lt;%@ taglib %&gt; 1&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt; 使用标签 常用的JSTL标签if:相当于java代码的if语句 test为必须属性，接受boolean表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合el表达式一起使用 c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 示例 1234567 &lt;% request.setAttribute(&quot;number&quot;,4); %&gt;&lt;c:if test&#x3D;&quot;$&#123;number % 2 !&#x3D; 0&#125;&quot;&gt; $&#123;number&#125;为奇数&lt;&#x2F;c:if&gt; choose:相当于java代码的switch语句 使用choose标签声明 相当于switch声明 使用when标签做判断 相当于case 使用otherwise标签做其他情况的声明 相当于default 示例 123456789101112131415&lt;% request.setAttribute(&quot;number&quot;,51); %&gt; &lt;c:choose&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 1&#125;&quot;&gt;星期一&lt;&#x2F;c:when&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 2&#125;&quot;&gt;星期二&lt;&#x2F;c:when&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 3&#125;&quot;&gt;星期三&lt;&#x2F;c:when&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 4&#125;&quot;&gt;星期四&lt;&#x2F;c:when&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 5&#125;&quot;&gt;星期五&lt;&#x2F;c:when&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 6&#125;&quot;&gt;星期六&lt;&#x2F;c:when&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 7&#125;&quot;&gt;星期天&lt;&#x2F;c:when&gt; &lt;c:otherwise&gt;数字输入有误&lt;&#x2F;c:otherwise&gt; &lt;&#x2F;c:choose&gt; foreach:相当于java代码的for语句属性 begin：开始值 end：结束值 var：临时变量 items:容器对象 普通for循环不用，增强for用 step：步长 varStatus:循环状态对象 index:容器中元素的索引，从0开始 count:循环次数，从1开始 示例 普通for 123&lt;c:forEach begin&#x3D;&quot;1&quot; end&#x3D;&quot;10&quot; var&#x3D;&quot;i&quot; step&#x3D;&quot;2&quot; varStatus&#x3D;&quot;s&quot;&gt; $&#123;i&#125; &lt;h3&gt;$&#123;s.index&#125;&lt;h3&gt; &lt;h4&gt; $&#123;s.count&#125; &lt;&#x2F;h4&gt;&lt;br&gt;&lt;&#x2F;c:forEach&gt; 增强for 1234567891011&lt;c:forEach items&#x3D;&quot;$&#123;requestScope.users&#125;&quot; var&#x3D;&quot;user&quot; varStatus&#x3D;&quot;s&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;s.count&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;user.address&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;user.qq&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;c:forEach&gt;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"web相关","slug":"java/web相关","permalink":"https://donghuangzhong.github.io/categories/java/web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/tags/java/"},{"name":"EL&JSTL","slug":"EL-JSTL","permalink":"https://donghuangzhong.github.io/tags/EL-JSTL/"}]},{"title":"深度学习_keras","slug":"深度学习-keras","date":"2021-01-17T02:37:19.000Z","updated":"2021-01-18T10:22:40.295Z","comments":true,"path":"2021/01/17/深度学习-keras/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-keras/","excerpt":"摘要","text":"摘要 1.函数式编程组件1.keras.layers.Conv2D12345678tf.keras.layers.Conv2D( filters, kernel_size, strides&#x3D;(1, 1), padding&#x3D;&#39;valid&#39;, data_format&#x3D;None, dilation_rate&#x3D;(1, 1), groups&#x3D;1, activation&#x3D;None, use_bias&#x3D;True, kernel_initializer&#x3D;&#39;glorot_uniform&#39;, bias_initializer&#x3D;&#39;zeros&#39;, kernel_regularizer&#x3D;None, bias_regularizer&#x3D;None, activity_regularizer&#x3D;None, kernel_constraint&#x3D;None, bias_constraint&#x3D;None, **kwargs) 函数式编程后边必须是四维的[batch,width,height,chanel] 1.增加维度 后增 1x_train &#x3D; x_train[:, tf.newaxis] 前增 1x_train &#x3D; x_train[tf.newaxis,:] 2.keras.preprocessing.image.ImageDataGenerator123456789tf.keras.preprocessing.image.ImageDataGenerator( featurewise_center&#x3D;False, samplewise_center&#x3D;False, featurewise_std_normalization&#x3D;False, samplewise_std_normalization&#x3D;False, zca_whitening&#x3D;False, zca_epsilon&#x3D;1e-06, rotation_range&#x3D;0, width_shift_range&#x3D;0.0, height_shift_range&#x3D;0.0, brightness_range&#x3D;None, shear_range&#x3D;0.0, zoom_range&#x3D;0.0, channel_shift_range&#x3D;0.0, fill_mode&#x3D;&#39;nearest&#39;, cval&#x3D;0.0, horizontal_flip&#x3D;False, vertical_flip&#x3D;False, rescale&#x3D;None, preprocessing_function&#x3D;None, data_format&#x3D;None, validation_split&#x3D;0.0, dtype&#x3D;None) featurewise_center：布尔值，使输入数据集去中心化（均值为0）, 按feature执行。 samplewise_center：布尔值，使输入数据的每个样本均值为0。 featurewise_std_normalization：布尔值，将输入除以数据集的标准差以完成标准化, 按feature执行。 samplewise_std_normalization：布尔值，将输入的每个样本除以其自身的标准差。 zca_whitening：布尔值，对输入数据施加ZCA白化。 rotation_range：整数，数据提升时图片随机转动的角度。随机选择图片的角度，是一个0180的度数，取值为0180。 width_shift_range：浮点数，图片宽度的某个比例，数据提升时图片随机水平偏移的幅度。 height_shift_range：浮点数，图片高度的某个比例，数据提升时图片随机竖直偏移的幅度。height_shift_range和width_shift_range是用来指定水平和竖直方向随机移动的程度，这是两个0~1之间的比例。 shear_range：浮点数，剪切强度（逆时针方向的剪切变换角度）。是用来进行剪切变换的程度。 zoom_range：浮点数或形如[lower,upper]的列表，随机缩放的幅度，若为浮点数，则相当于[lower,upper] = [1 - zoom_range, 1+zoom_range]。用来进行随机的放大。 channel_shift_range：浮点数，随机通道偏移的幅度。 fill_mode：‘constant’，‘nearest’，‘reflect’或‘wrap’之一，当进行变换时超出边界的点将根据本参数给定的方法进行处理 cval：浮点数或整数，当fill_mode=constant时，指定要向超出边界的点填充的值。 horizontal_flip：布尔值，进行随机水平翻转。随机的对图片进行水平翻转，这个参数适用于水平翻转不影响图片语义的时候。 vertical_flip：布尔值，进行随机竖直翻转。 rescale: 值将在执行其他处理前乘到整个图像上，我们的图像在RGB通道都是0255的整数，这样的操作可能使图像的值过高或过低，所以我们将这个值定为01之间的数。 preprocessing_function: 将被应用于每个输入的函数。该函数将在任何其他修改之前运行。该函数接受一个参数，为一张图片（秩为3的numpy array），并且输出一个具有相同shape的numpy array data_format：字符串，“channel_first”或“channel_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channel_last”对应原本的“tf”，“channel_first”对应原本的“th”。以128x128的RGB图像为例，“channel_first”应将数据组织为（3,128,128），而“channel_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channel_last”。 1.归一化1ImageDataGenerator(rescale&#x3D;1. &#x2F; 255) 2.flow_from_directory123456789101112131415def flow_from_directory(self, directory, target_size&#x3D;(256, 256), color_mode&#x3D;&#39;rgb&#39;, classes&#x3D;None, class_mode&#x3D;&#39;categorical&#39;, batch_size&#x3D;32, shuffle&#x3D;True, seed&#x3D;None, save_to_dir&#x3D;None, save_prefix&#x3D;&#39;&#39;, save_format&#x3D;&#39;png&#39;, follow_links&#x3D;False, subset&#x3D;None, interpolation&#x3D;&#39;nearest&#39;): directory: 目标文件夹路径,此文件夹下包含分类图片的文件夹，然后再是图片，比如此文件夹名为flower,下面含有[daisy,dandelion,roses,sunflowers,tulips]5个文件夹，roses文件夹下是玫瑰花的图片 target_size: 整数tuple,默认为(256, 256). 图像将被resize成该尺寸 batch_size: batch数据的大小,默认32 shuffle: 是否打乱数据,默认为True class_mode: “categorical”, “binary”, “sparse”或None之一. 默认为”categorical. 该参数决定了返回的标签数组的形式, “categorical”会返回2D的one-hot编码标签,”binary”返回1D的二值标签.”sparse”返回1D的整数标签,如果为None则不返回任何标签, 生成器将仅仅生成batch数据, 这种情况在使用model.predict_generator()和model.evaluate_generator()等函数时会用到. color_mode: 颜色模式,为”grayscale”,”rgb”之一,默认为”rgb”.代表这些图片是否会被转换为单通道或三通道的图片. classes: 可选参数,为子文件夹的列表,如[‘dogs’,’cats’]默认为None. 若未提供,则该类别列表将从directory下的子文件夹名称/结构自动推断。每一个子文件夹都会被认为是一个新的类。(类别的顺序将按照字母表顺序映射到标签值)。通过属性class_indices可获得文件夹名与类的序号的对应字典。 seed: 可选参数,打乱数据和进行变换时的随机数种子 save_to_dir: None或字符串，该参数能让你将提升后的图片保存起来，用以可视化 save_prefix：字符串，保存提升后图片时使用的前缀, 仅当设置了save_to_dir时生效 save_format：”png”或”jpeg”之一，指定保存图片的数据格式,默认”jpeg” flollow_links: 是否访问子文件夹中的软链接 .n属性可以获得数量 2.modelloss1.categorical_crossentropy:one-hot2.SparseCategoricalCrossentropy():数字编码1.steps_per_epoch一个step就是一个batch_size 3.搭建网络流程1.列好网络中各层的网络参数2.api编程搭建model3.存在的问题1.jupyter显存占用 每次运行完都重启一下服务","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://donghuangzhong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"_keras","slug":"keras","permalink":"https://donghuangzhong.github.io/tags/keras/"}]},{"title":"深度学习","slug":"深度学习","date":"2021-01-16T10:45:07.000Z","updated":"2021-01-19T04:04:44.510Z","comments":true,"path":"2021/01/16/深度学习/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","excerpt":"摘要","text":"摘要 1.AlexNet概述1.亮点 首次使用GPU加速 使用ReLu激活函数，非传统Sigmoid或Tanh LRN局部响应归一化 全连接层前两层使用Dropout随机失活神经元减少过拟合 2.8层结构卷积层公式12output&#x3D;(W-F+2P)&#x2F;S+1W:输入图片的大小(一般Width&#x3D;Height) F:卷积核大小 S:步长 P:Padding的像素数 层数\\参数 input_size kernels kernel_size padding stride output_size Conv1 [224, 224, 3] 48 * 2 = 96 11 [1, 2] 4 [55, 55, 96] Maxpool1 [55, 55, 96] None 3 0 2 [27, 27, 96] Conv2 [27, 27, 96] 256 5 [2, 2] 1 [27,27, 256] Maxpool2 [27, 27, 256] None 3 0 2 [13, 13, 256] Conv3 [13, 13, 256] 192*2= 384 3 [1, 1] 1 [13, 13, 384] Conv4 [13, 13, 384] 192*2= 384 3 [1, 1] 1 [13, 13, 384] Conv5 [13, 13, 384] 128*2= 256 3 [1, 1] 1 [13, 13, 256] Maxpool3 [13, 13, 256] None 3 0 2 [6, 6, 256] Fc1 2048 None None None None None Fc2 2048 None None None None None Fc3 1000 None None None None None 2.VGG网络1.概述VGG 在2014年由牛津大学著名研究组 VGG（Visual Geometry Group）提出，斩获该年 ImageNet 竞赛中 Localization Task（定位任务）第一名和 Classification Task（分类任务）第二名。 2.亮点 创新点通过堆叠多个小卷积核来替代大尺度卷积核，可以减少训练参数，同时能保证相同的感受野。论文中提到，可以通过堆叠两个3×3的卷积核替代5x5的卷积核，堆叠三个3×3的卷积核替代7x7的卷积核。 1在卷积神经网络中，决定某一层输出结果中一个元素所对应的输入层的区域大小，被称作感受野（receptive field）。 计算公式：F(i)=(F(i+1)−1)×Stride +Ksize F(i) 为第 i 层感受野 Stride为第 i 层的步距 Ksize 为 卷积核 或 池化核 尺寸 3.结构 3.GoogLeNet1.概述GoogLeNet在2014年由Google团队提出（与VGG网络同年，注意GoogLeNet中的L大写是为了致敬LeNet），斩获当年ImageNet竞赛中Classification Task (分类任务) 第一名。 2.亮点创新点 引入了 Inception 结构（融合不同尺度的特征信息） 使用1x1的卷积核进行降维以及映射处理 （虽然VGG网络中也有，但该论文介绍的更详细） 添加两个辅助分类器帮助训练 丢弃全连接层，使用平均池化层（大大减少模型参数，除去两个辅助分类器，网络大小只有vgg的1/20） inception 将特征矩阵同时输入到多个分支进行处理，并将输出的特征矩阵按深度进行拼接，得到最终输出。 作用：增加网络深度和宽度的同时减少参数。 3.结构","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://donghuangzhong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AlexNet","slug":"AlexNet","permalink":"https://donghuangzhong.github.io/tags/AlexNet/"}]},{"title":"jupyter","slug":"jupyter","date":"2021-01-16T01:32:24.000Z","updated":"2021-01-17T05:10:32.032Z","comments":true,"path":"2021/01/16/jupyter/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/16/jupyter/","excerpt":"单独的python安装jupyter","text":"单独的python安装jupyter 1.pip安装最好使用中科大的源 1pip install -i https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple jupyter 2.打开1jupyter notebook 3.可能出现的问题1.kernel error FileNotFoundError: [WinError 2] 系统找不到指定的文件解决方法 查看内核安装位置 1jupyter kernelspec list 在1中的路径打开kernel.jason查看Python编译器的路径是否正确 如果不正确，运行下面这天代码自动修正路径 1python -m ipykernel install --user 4.改默认路径1.生成config文件1jupyter notebook --generate-config 2.打开配置文件，搜索notebook_dir，删去#号修改即可3.重启jupyter5.代码补全1.进入Anaconda Prompt，依次运行以下代码1234567&#x2F;&#x2F;1.安装nbextensions pip install jupyter_contrib_nbextensions -i https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simplejupyter contrib nbextension install --user&#x2F;&#x2F;2.安装nbextensions_configuratorpip install --user jupyter_nbextensions_configurator jupyter nbextensions_configurator enable --user 2.重启jupyter可以看到增加了一个Nbextensions标签页，在这个页面里，勾选Hinterland","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"}],"tags":[{"name":"jupyter","slug":"jupyter","permalink":"https://donghuangzhong.github.io/tags/jupyter/"}]},{"title":"python","slug":"python","date":"2021-01-15T07:59:53.597Z","updated":"2021-01-16T01:34:29.586Z","comments":true,"path":"2021/01/15/python/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/15/python/","excerpt":"","text":"1.设置延时1pip --default-timeout&#x3D;200 install XXX 2.清楚模块(包)缓存1路径：C:\\Users\\用户名\\AppData\\Local\\pip 3.换源123中科大：https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;清华：https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple原始官方源：https:&#x2F;&#x2F;pypi.Python.org&#x2F;simple&#x2F; 1.永久换源1pip config set global.index-url https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 原始的源 1pip config set global.index-url https:&#x2F;&#x2F;pypi.Python.org&#x2F;simple&#x2F; 2.单次换源1pip install -i https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple XXX 4.卸载所有模块12pip freeze &gt; python_modules.txtpip uninstall -r python_modules.txt -y","categories":[],"tags":[]},{"title":"Win10_GeForce940MX_TersorFlow","slug":"Win10-GeForce940MX-TersorFlow","date":"2021-01-15T01:31:12.000Z","updated":"2021-03-01T01:37:18.724Z","comments":true,"path":"2021/01/15/Win10-GeForce940MX-TersorFlow/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/15/Win10-GeForce940MX-TersorFlow/","excerpt":"win10下GeForce940MX显卡安装 概述 安装","text":"win10下GeForce940MX显卡安装 概述 安装 1.安装TensorFlow-GPU1.安装环境 win10 GeForce940MX 自己安装的python3.7.4，非集成环境 2.pip命令安装tersorflow1pip --timeout&#x3D;100 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple tensorflow 必须设置timeout不然稍微网络不好就会报错，然后需要从头开始下载。 如果还是失败，手动去清华源下载whl文件，然后本地pip安装 1https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F; 这里面有版本的问题，不建议安装最新版的tersorflow，我安装的2.x，运行不了，后来重新安装了1.5 3.安装CUDA1https:&#x2F;&#x2F;developer.nvidia.com&#x2F;cuda-toolkit-archive 运行import tersorflow，如果报错cudart64_100.dll找不到，需要将CUDA安装目录下bin添加到系统环境变量path中 4.安装cuDNN1https:&#x2F;&#x2F;developer.nvidia.com&#x2F;cudnn 是一个压缩包，解压放到任何一个目录下就行，然后把其中的bin目录路径添加到Path环境变量里。 最好也将cuDNN安装目录下bin添加到系统环境变量path中 5.测试运行123import tensorflow as tfprint(&#39;Tensorflow Version:&#123;&#125;&#39;.format(tf.__version__))print(tf.test.is_gpu_available()) yolo12python convert.py yolov3.cfg yolov3.weights model_data&#x2F;yolo.h5python convert.py -w yolov3-tiny.cfg yolov3-tiny.weights model_data&#x2F;tiny_yolo_weights.h5","categories":[{"name":"TersorFlow","slug":"TersorFlow","permalink":"https://donghuangzhong.github.io/categories/TersorFlow/"}],"tags":[{"name":"GeForce940MX","slug":"GeForce940MX","permalink":"https://donghuangzhong.github.io/tags/GeForce940MX/"}]},{"title":"hexo便捷图片解决方案","slug":"hexo便捷图片解决方案","date":"2021-01-13T03:58:22.000Z","updated":"2021-02-09T12:32:02.559Z","comments":true,"path":"2021/01/13/hexo便捷图片解决方案/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/13/hexo%E4%BE%BF%E6%8D%B7%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"使图片在本地和网站上都能显示正常 win+s截图，在Typora上粘贴即可，不需要做任何操作","text":"使图片在本地和网站上都能显示正常 win+s截图，在Typora上粘贴即可，不需要做任何操作 1.安装图片插件1npm install hexo-asset-image --save 2.配置文件_config.yml 里post_asset_folder:选项设置为true这样每次hexo n “xxx”时就会一起生成同名文件夹 3.更改Typora设置1.文件-&gt;偏好设置-&gt;图像2.点击下拉框，选择复制到指定路径，如下图设置 3.随便截图，粘贴到Typora中即可","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://donghuangzhong.github.io/categories/Hexo/"}],"tags":[{"name":"图片","slug":"图片","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%BE%E7%89%87/"}]},{"title":"Java_JDBC连接池&JDBCTemplate","slug":"Java-JDBC连接池-JDBCTemplate","date":"2021-01-13T03:41:45.000Z","updated":"2021-03-05T00:09:08.321Z","comments":true,"path":"2021/01/13/Java-JDBC连接池-JDBCTemplate/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/13/Java-JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0-JDBCTemplate/","excerpt":"1.数据库连接池 2.C3p0 3.Druid 4.Spring JDBC : JDBC Template","text":"1.数据库连接池 2.C3p0 3.Druid 4.Spring JDBC : JDBC Template 数据库连接池概述概念其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处 节约资源 用户访问高效 实现标准接口：DataSource javax.sql包下的 获取连接：getConnection() 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 一般我们不去实现它，有数据库厂商来实现 C3P0：数据库连接池技术 Druid：数据库连接池实现技术，由阿里巴巴提供的 C3P0：数据库连接池技术硬编码方式123456ComboPooledDataSource cpds &#x3D; new ComboPooledDataSource();cpds.setDriverClass( &quot;org.postgresql.Driver&quot; ); &#x2F;&#x2F;loads the jdbc driver cpds.setJdbcUrl( &quot;jdbc:postgresql:&#x2F;&#x2F;localhost&#x2F;testdb&quot; );cpds.setUser(&quot;dbuser&quot;); cpds.setPassword(&quot;dbpassword&quot;); conn&#x3D;cpds.getConnection(); 步骤导入jar包 (两个) 和数据库驱动 c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar 不要忘记导入数据库驱动jar包 定义配置文件： 名称： c3p0.properties 或者 c3p0-config.xml 路径：直接将文件放在src目录下即可。 c3p0-config.xml文件内容： 12345678910111213141516171819202122232425262728&lt;c3p0-config&gt; &lt;!-- 使用默认的配置读取连接池对象 --&gt; &lt;default-config&gt; &lt;!-- 连接参数 --&gt; &lt;property name&#x3D;&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;jdbcUrl&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name&#x3D;&quot;initialPoolSize&quot;&gt;5&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;maxPoolSize&quot;&gt;10&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;checkoutTimeout&quot;&gt;3000&lt;&#x2F;property&gt; &lt;&#x2F;default-config&gt; &lt;named-config name&#x3D;&quot;otherc3p0&quot;&gt; &lt;!-- 连接参数 --&gt; &lt;property name&#x3D;&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;jdbcUrl&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;day25&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name&#x3D;&quot;initialPoolSize&quot;&gt;5&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;maxPoolSize&quot;&gt;8&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;checkoutTimeout&quot;&gt;1000&lt;&#x2F;property&gt; &lt;&#x2F;named-config&gt;&lt;&#x2F;c3p0-config&gt; 创建核心对象 数据库连接池对象 ComboPooledDataSource获取连接： getConnection代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class c3p0 &#123; public static void main(String[] args) &#123; Connection conn&#x3D;null; PreparedStatement ps&#x3D;null; ResultSet rs&#x3D;null; try &#123; &#x2F;&#x2F;主要是下面两句 ComboPooledDataSource ds &#x3D; new ComboPooledDataSource(); conn&#x3D;ds.getConnection(); ps&#x3D;conn.prepareStatement(&quot;select * from account where id&#x3D;?&quot;); ps.setInt(1,5); rs &#x3D; ps.executeQuery(); while(rs.next()) &#123; int id &#x3D; rs.getInt(&quot;id&quot;); String name &#x3D; rs.getString(&quot;NAME&quot;); int balance &#x3D; rs.getInt(&quot;balance&quot;); System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+balance); &#125; &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; &#x2F;&#x2F;关闭资源 if(conn!&#x3D;null) &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if(ps!&#x3D;null) &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if(rs!&#x3D;null) &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; &#125;&#125; Druid：数据库连接池实现技术，由阿里巴巴提供的步骤导入jar包 druid-1.0.9.jar在src目录下，定义properties配置文件druid.properties:1234567driverClassName&#x3D;com.mysql.jdbc.Driverurl&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db3username&#x3D;rootpassword&#x3D;rootinitialSize&#x3D;5maxActive&#x3D;10maxWait&#x3D;3000 加载配置文件druid.properties123Properties pro &#x3D; new Properties();InputStream is &#x3D; DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);pro.load(is); 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory1DataSource ds &#x3D; DruidDataSourceFactory.createDataSource(pro); 获取连接：getConnection1Connection conn &#x3D; ds.getConnection(); 代码12345678910111213Properties pro &#x3D; new Properties();pro.load(Druid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));DataSource ds &#x3D; DruidDataSourceFactory.createDataSource(pro);Connection conn &#x3D; ds.getConnection();PreparedStatement pstm &#x3D; conn.prepareStatement(&quot;select * from account where id&#x3D;?;&quot;);pstm.setInt(1,5);ResultSet rs &#x3D; pstm.executeQuery();while(rs.next())&#123; int id &#x3D; rs.getInt(&quot;id&quot;); String name &#x3D; rs.getString(&quot;NAME&quot;); int balance &#x3D; rs.getInt(&quot;balance&quot;); System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+balance);&#125; 编写工具类属性: 1DataSource ds; 方法： 1234静态代码块:用于初始化获得DataSourcegetDataSource()&#x2F;&#x2F;获取连接池getConnection()close(ResultSet resultSet, Statement statement,Connection connection) 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class DruidUtils &#123; private static DataSource ds; static &#123; try &#123; Properties pro &#x3D; new Properties(); pro.load(DruidUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); ds &#x3D; DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static DataSource getDataSource()&#123; return ds; &#125; public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; public static void close(ResultSet resultSet, Statement statement,Connection connection) &#123; if (resultSet!&#x3D;null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (statement!&#x3D;null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (connection!&#x3D;null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; public static void close(Statement statement,Connection connection) &#123; close(null,statement,connection); &#125;&#125; Spring JDBC(配合Druid使用)概念Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 步骤导入jar包（五个） 创建JdbcTemplate对象。依赖于数据源DataSource1JdbcTemplate template &#x3D; new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作update():执行DML语句。增、删、改语句123456@Test public void updateTest() &#123; int count &#x3D; jdbcTemplate.update(&quot;insert into account values(?,?,?)&quot;, 100, &quot;刘能&quot;,2000); System.out.println(count); &#125; 返回主键式insert12345678910111213141516171819202122public Long save(final User user) &#123; &#x2F;&#x2F;创建PreparedStatementCreator PreparedStatementCreator creator &#x3D; new PreparedStatementCreator() &#123; @Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException &#123; &#x2F;&#x2F;使用原始jdbc完成有个PreparedStatement的组建 PreparedStatement preparedStatement &#x3D; connection.prepareStatement(&quot;insert into sys_user values(?,?,?,?,?)&quot;, PreparedStatement.RETURN_GENERATED_KEYS); preparedStatement.setObject(1,null); preparedStatement.setString(2,user.getUsername()); preparedStatement.setString(3,user.getEmail()); preparedStatement.setString(4,user.getPassword()); preparedStatement.setString(5,user.getPhoneNum()); return preparedStatement; &#125; &#125;; &#x2F;&#x2F;创建keyHolder GeneratedKeyHolder keyHolder &#x3D; new GeneratedKeyHolder(); jdbcTemplate.update(creator,keyHolder); &#x2F;&#x2F;获得生成的主键 long userId &#x3D; keyHolder.getKey().longValue(); return userId; &#x2F;&#x2F;返回当前保存用户的id 该id是数据库自动生成的 &#125; query()：查queryForMap()查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 123456@Testpublic void queryForMapTest()&#123; Map&lt;String, Object&gt; rs &#x3D; jdbcTemplate.queryForMap(&quot;select * from account where NAME&#x3D;?&quot;, &quot;刘能&quot;); System.out.println(rs);&#125; 注意：这个方法查询的结果集长度只能是1！！！ queryForList()查询结果将结果集封装为list集合 123456@Testpublic void queryForListTest()&#123; List&lt;Map&lt;String, Object&gt;&gt; maps &#x3D; jdbcTemplate.queryForList(&quot;select * from account where id&#x3D;?&quot;, 5); System.out.println(maps);&#125; 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query() 查询结果，将结果封装为JavaBean对象列表 query的参数：sql，RowMapper，args… 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) 123456@Testpublic void queryTest()&#123; List&lt;Emp&gt; emps &#x3D; jdbcTemplate.query(&quot;select * from account where id&#x3D;?&quot;, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class), 5); System.out.println(emps);&#125; queryForObject() 参数：sql，返回类型的class，args… 查询结果，将结果封装为对象 一般用于聚合函数的查询 123456@Testpublic void queryForObjectTest()&#123; Long count &#x3D; jdbcTemplate.queryForObject(&quot;select count(NAME) from account where id&#x3D;?&quot;, Long.class, 5); System.out.println(count);&#125;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"数据库连接池","slug":"数据库连接池","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"name":"SpringTemplate","slug":"SpringTemplate","permalink":"https://donghuangzhong.github.io/tags/SpringTemplate/"}]},{"title":"VM虚拟机和物理机共享文件夹","slug":"VM虚拟机和物理机共享文件夹","date":"2021-01-12T03:46:55.000Z","updated":"2021-02-09T12:32:37.283Z","comments":true,"path":"2021/01/12/VM虚拟机和物理机共享文件夹/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/12/VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E7%89%A9%E7%90%86%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/","excerpt":"VM虚拟机和实体机共享文件夹","text":"VM虚拟机和实体机共享文件夹 1.在VM中安装VMware Tools 如果没反应，看下面的提示，按win+R,输入D:\\setup.exe手动安装,之后可能需要重启 2.在虚拟机-&gt;设置-&gt;选项-&gt;共享文件夹-&gt;总是启用在下方点添加-&gt;选路径-&gt;勾选映射为驱动器(这一步一定要做！！！)一直下一步，直至完成 3.然后就可以在虚拟机我的电脑里面看到共享的驱动器了","categories":[{"name":"VM","slug":"VM","permalink":"https://donghuangzhong.github.io/categories/VM/"}],"tags":[{"name":"VM","slug":"VM","permalink":"https://donghuangzhong.github.io/tags/VM/"},{"name":"共享文件","slug":"共享文件","permalink":"https://donghuangzhong.github.io/tags/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/"}]},{"title":"Img_test","slug":"Img-test","date":"2021-01-12T02:45:29.000Z","updated":"2021-02-09T12:25:32.761Z","comments":true,"path":"2021/01/12/Img-test/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/12/Img-test/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"Java_idea生成类和方法注释","slug":"Java-idea生成类和方法注释","date":"2021-01-11T09:48:15.000Z","updated":"2021-03-04T02:41:35.998Z","comments":true,"path":"2021/01/11/Java-idea生成类和方法注释/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/11/Java-idea%E7%94%9F%E6%88%90%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A/","excerpt":"自定义Idea类和方法的内容和快捷键","text":"自定义Idea类和方法的内容和快捷键 只演示方法的，类的同样操作即可 1.Ctrl+Alt+S打开Idea设置,找到Editor-&gt;Live Templates2.点右上角加号先添加Template Group(命名为UserDefine)3.选中UserDefine再次点加号选Live Template4.Abbreviation处为快捷键(我设的a),Template Text如下 方法注释 1234567*** @Description: $description$* @Param: $params$* @return: $returns$* @Author: 此处改为你自己的名字* @Date: $date$**&#x2F; 类注释(弄好方法注释之后类的自然也会) 1234567*** @ClassName: $params$* @Description: $description$* @Author: Zhong ZhenJie* @Date: $date$* @Version: 1.0**&#x2F; 5.Template Text下方Define处点开全选6.可以点击右侧Edit Variables点击Expression选择这一项要显示的东西7.最后点OK，最终的快捷键为/+a(Abbreviation处设置的键)+Tab，类注释一样设置","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"tools","slug":"java/tools","permalink":"https://donghuangzhong.github.io/categories/java/tools/"}],"tags":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/tags/java/"},{"name":"idea","slug":"idea","permalink":"https://donghuangzhong.github.io/tags/idea/"}]},{"title":"Java_JDBC","slug":"Java_JDBC","date":"2021-01-11T09:48:15.000Z","updated":"2021-03-05T00:06:03.531Z","comments":true,"path":"2021/01/11/Java_JDBC/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/11/Java_JDBC/","excerpt":"概述 JDBC基本概念 快速入门 对JDBC中各个接口和类详解 JDBCUtils JDBC事务","text":"概述 JDBC基本概念 快速入门 对JDBC中各个接口和类详解 JDBCUtils JDBC事务 1.概念 Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 2. 快速入门1.步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2.右键--&gt;Add As Library 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql，接受返回结果 处理结果 释放资源 2. 代码实现12345678910111213141516&#x2F;&#x2F;1. 导入驱动jar包&#x2F;&#x2F;2.注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;3.获取数据库连接对象Connection conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3&quot;, &quot;root&quot;, &quot;root&quot;);&#x2F;&#x2F;4.定义sql语句String sql &#x3D; &quot;update account set balance &#x3D; 500 where id &#x3D; 1&quot;;&#x2F;&#x2F;5.获取执行sql的对象 StatementStatement stmt &#x3D; conn.createStatement();&#x2F;&#x2F;6.执行sqlint count &#x3D; stmt.executeUpdate(sql);&#x2F;&#x2F;7.处理结果System.out.println(count);&#x2F;&#x2F;8.释放资源stmt.close();conn.close(); 3. 详解各个对象1.DriverManager：驱动管理对象 注册驱动：告诉程序该使用哪一个数据库驱动jar12345678910static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(&quot;Can&#39;t register driver!&quot;); &#125; &#125; 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 获取数据库连接 1static Connection getConnection(String url, String user, String password) url：指定连接的路径 例子：jdbc:mysql://localhost:3306/db3 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 user：用户名 password：密码 2. Statement：执行sql的对象 boolean execute(String sql) 可以执行任意的sql 了解 int executeUpdate(String sql) 执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败， ResultSet executeQuery(String sql) 执行DQL（select)语句 3.PreparedStatement 防SQL注入、执行sql的对象 后期都会使用PreparedStatement来完成增删改查的所有操作 可以防止SQL注入 效率更高 SQL注入输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’ 在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 使用步骤 定义sql，”？”作为占位符 1如：String sql&#x3D;&quot;select * from user where username &#x3D; ? and password &#x3D; ?&quot;; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 1PreparedStatement ps&#x3D;connection.prepareStatement(sql) 给？赋值 12345setXxx(参数1,参数2)参数1：？的位置编号 从1 开始参数2：？的值ps.setString(1,&quot;张三&quot;) 执行sql，接受返回结果，不需要传递sql语句 1ResultSet rs&#x3D;ps.executeQuery(); 4.ResultSet：结果集对象,封装查询结果 boolean next() 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true getXxx(参数):获取数据 Xxx：代表数据类型 如： int getInt() , String getString() 参数： int：代表列的编号,从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 示例123456789while(rs.next())&#123; &#x2F;&#x2F;获取数据 &#x2F;&#x2F;6.2 获取数据 int id &#x3D; rs.getInt(1); String name &#x3D; rs.getString(&quot;name&quot;); double balance &#x3D; rs.getDouble(3); System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance); &#125; 4.抽取JDBC工具类 ： JDBCUtils 目的：简化书写 1.分析 注册驱动也抽取 抽取一个方法获取连接对象 需求：不想传递参数（麻烦），还得保证工具类的通用性。 解决：配置文件jdbc.properties 123url&#x3D;user&#x3D;password&#x3D; 抽取一个方法释放资源 2.代码public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; static { try { ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(&quot;jdbc.properties&quot;); String path = res.getPath(); Properties pro = new Properties(); pro.load(new FileReader(path)); url = pro.getProperty(&quot;url&quot;); user = pro.getProperty(&quot;user&quot;); password = pro.getProperty(&quot;password&quot;); driver = pro.getProperty(&quot;driver&quot;); Class.forName(driver); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } public static Connection getConnection() throws SQLException { Connection connection = DriverManager.getConnection(url, user, password); System.out.println(url+&quot;---数据库连接成功&quot;); return connection; } public static void close(Statement statement,Connection connection) { if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } System.out.println(url+&quot;---数据库关闭成功&quot;); } public static void close(ResultSet resultSet,Statement statement, Connection connection) { if(resultSet!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } System.out.println(url+&quot;---数据库关闭成功&quot;); } }​ 5.JDBC控制事务：事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 1. 开启事务1setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 注意：在执行sql之前开启事务 2.提交事务1commit() &#x2F;&#x2F;当所有sql都执行完提交事务 3.回滚事务1rollback() &#x2F;&#x2F;在catch中回滚事务 4.代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class JDBCDemo10 &#123; public static void main(String[] args) &#123; Connection conn &#x3D; null; PreparedStatement pstmt1 &#x3D; null; PreparedStatement pstmt2 &#x3D; null; try &#123; &#x2F;&#x2F;1.获取连接 conn &#x3D; JDBCUtils.getConnection(); &#x2F;&#x2F;开启事务 conn.setAutoCommit(false); &#x2F;&#x2F;2.定义sql &#x2F;&#x2F;2.1 张三 - 500 String sql1 &#x3D; &quot;update account set balance &#x3D; balance - ? where id &#x3D; ?&quot;; &#x2F;&#x2F;2.2 李四 + 500 String sql2 &#x3D; &quot;update account set balance &#x3D; balance + ? where id &#x3D; ?&quot;; &#x2F;&#x2F;3.获取执行sql对象 pstmt1 &#x3D; conn.prepareStatement(sql1); pstmt2 &#x3D; conn.prepareStatement(sql2); &#x2F;&#x2F;4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); &#x2F;&#x2F;5.执行sql pstmt1.executeUpdate(); &#x2F;&#x2F; 手动制造异常 int i &#x3D; 3&#x2F;0; pstmt2.executeUpdate(); &#x2F;&#x2F;提交事务 conn.commit(); &#125; catch (Exception e) &#123; &#x2F;&#x2F;事务回滚 try &#123; if(conn !&#x3D; null) &#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); &#125; &#125; &#125; ​ ​","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://donghuangzhong.github.io/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://donghuangzhong.github.io/tags/JDBC/"}]},{"title":"MySql","slug":"MySQL基础","date":"2021-01-11T09:48:15.000Z","updated":"2021-03-05T00:01:27.240Z","comments":true,"path":"2021/01/11/MySQL基础/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/11/MySQL%E5%9F%BA%E7%A1%80/","excerpt":"MySQL数据库软件 安装 卸载 配置和操作 SQL(DDL、DML、DQL、DCL) 数据库约束 数据库设计","text":"MySQL数据库软件 安装 卸载 配置和操作 SQL(DDL、DML、DQL、DCL) 数据库约束 数据库设计 MySQL数据库软件安装 进入官网：https://www.mysql.com/ 点击download 点击 MySQL Community (GPL) Downloads 点击MySQL Community Server 点击MSI安装文件下载 选择社区版下载，双击安装 点击自定义安装（Custom） 修改安装路径，然后一直下一步，直到弹出配置界面 自定义最大连接数 选择utf-8字符集 勾选添加到环境变量，然后一直下一步，直至完成 卸载 去mysql的安装目录找到my.ini文件 复制 datadir=”C:/ProgramData/MySQL/MySQL Server 5.5/Data/“ 卸载MySQL 删除C:/ProgramData目录下的MySQL文件夹 配置和操作 启动 手动找服务(service.msc) 命令(cmd管理员) 12net start mysql : 启动mysql的服务net stop mysql:关闭mysql服务 登录 123mysql -uroot -p密码mysql -h(远程主机的ip) -uroot -p连接目标的密码mysql --host&#x3D;ip --user&#x3D;root --password&#x3D;连接目标的密码 退出 12exitquit 备份和恢复 1234567891. 命令行： * 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径2. 图形化工具： SQLStructured Query Language：结构化查询语言 语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 3种注释 12单行注释: -- 注释内容 或 # 注释内容(mysql 特有) 多行注释: &#x2F;* 注释 *&#x2F; 分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表操作数据库：CRUD C(Create):创建 123456* 创建数据库：* create database 数据库名称;* 创建数据库，判断不存在，再创建：* create database if not exists 数据库名称;* 创建数据库，并指定字符集* create database 数据库名称 character set 字符集名; R(Retrieve)：查询 1234* 查询所有数据库的名称:* show databases;* 查询某个数据库的字符集:查询某个数据库的创建语句* show create database 数据库名称; U(Update):修改 12* 修改数据库的字符集* alter database 数据库名称 character set 字符集名称; D(Delete):删除 1234* 删除数据库* drop database 数据库名称;* 判断数据库存在，存在再删除* drop database if exists 数据库名称; 使用数据库 1234* 查询当前正在使用的数据库名称* select database();* 使用数据库* use 数据库名称; 操作表 C(Create):创建 创建 123456789* 创建表create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp); 1 复制表 12* 复制表：* create table 表名 like 被复制的表名; R(Retrieve)：查询 1234* 查询某个数据库中所有的表名称* show tables;* 查询表结构* desc 表名; U(Update):修改 12345678910111. 修改表名 alter table 表名 rename to 新的表名;2. 修改表的字符集 alter table 表名 character set 字符集名称;3. 添加一列 alter table 表名 add 列名 数据类型;4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型;5. 删除列 alter table 表名 drop 列名; D(Delete):删除 12* drop table 表名;* drop table if exists 表名 ; DML：增删改表中数据 添加数据 1234567* 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);* 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 删除数据 1234567* 语法： * delete from 表名 [where 条件]* 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 修改数据 12345* 语法： * update 表名 set 列名1 &#x3D; 值1, 列名2 &#x3D; 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。 DQL：查询表中的记录语法1234567891011121314select 字段列表from 表名列表where 条件列表group by 分组字段having 分组之后的条件order by 排序limit 分页限定 基础查询123456789101112131. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。2. 去除重复： * distinct3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。4. 起别名： * as：as也可以省略 条件查询123456789101112131. where子句后跟条件2. 运算符 * &gt; 、&lt; 、&lt;&#x3D; 、&gt;&#x3D; 、&#x3D; 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! 12345678910111213141516171819202122232425262728293031323334353637383940------------------------------------示例---------------------------------------------- -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;&#x3D; 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age &#x3D; 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age !&#x3D; 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;&#x3D; 20 &amp;&amp; age &lt;&#x3D;30; SELECT * FROM student WHERE age &gt;&#x3D; 20 AND age &lt;&#x3D;30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age &#x3D; 22 OR age &#x3D; 18 OR age &#x3D; 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english &#x3D; NULL; --不对的。null值不能使用&#x3D;（!&#x3D;）判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE &#39;___&#39;; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;; 排序查询123456789* 语法：order by 子句 * order by 排序字段1 排序方式1 ， 排序字段2 排序方式2...* 排序方式： * ASC：升序，默认的。 * DESC：降序。* 注意： * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 聚合函数12345678910111213聚合函数：将一列数据作为一个整体，进行纵向的计算。 1. count：计算个数 1. 一般选择非空的列：主键 2. count(*) 2. max：计算最大值 3. min：计算最小值 4. sum：计算和 5. avg：计算平均值 * 注意：聚合函数的计算，排除null值。 解决方案： 1. 选择不包含非空的列进行计算 2. IFNULL函数 分组查询语法：group by 分组字段； 分组之后查询的字段：分组字段、聚合函数 1234where 和 having 的区别？ where 在分组之前进行限定，如果不满足条件，则不参与分组。 having在分组之后进行限定，如果不满足结果，则不会被查询出来 where 后不可以跟聚合函数，having可以进行聚合函数的判断。 123456789101112131415示例：-- 按照性别分组。分别查询男、女同学的平均分SELECT sex , AVG(math) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 分页查询123456789 1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 &#x3D; （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页3. limit 是一个MySQL&quot;方言&quot; 约束概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 主键约束12345678910111213141516171819202122232425261. 注意： 1. 含义：非空且唯一 2. 一张表只能有一个字段为主键 3. 主键就是表中记录的唯一标识2. 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) );3. 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY;4. 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY;5. 自动增长： 1. 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 2. 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 自动增长12345删除自动增长 ALTER TABLE stu MODIFY id INT; 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 非空约束1234567891011* 非空约束：not null，值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); 唯一约束1234567891011121314* 唯一约束：unique，值不能重复1. 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); * 注意mysql中，唯一约束限定的列的值可以有多个null2. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number;3. 在创建表后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE; 外键约束1234567891011121314* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。 1. 在创建表时，可以添加外键 * 语法： create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 级联操作1234561. 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ;2. 分类： 1. 级联更新：ON UPDATE CASCADE 2. 级联删除：ON DELETE CASCADE 数据库的设计多表之间的关系1234567891011121314151617181920211. 多表之间的关系 1. 分类： 1. 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 数据库设计的范式12345678910111213141516171819202122* 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。分类：1. 第一范式（1NF）：每一列都是不可分割的原子数据项2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） * 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://donghuangzhong.github.io/tags/MySql/"}]},{"title":"Java_propertise传递信息","slug":"Java-propertise传递信息","date":"2021-01-11T07:30:55.000Z","updated":"2021-03-04T02:42:58.808Z","comments":true,"path":"2021/01/11/Java-propertise传递信息/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/11/Java-propertise%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/","excerpt":"用Java中的propertise传递信息(类似键值对)","text":"用Java中的propertise传递信息(类似键值对) 1.在src文件夹下新建xxx.propertise文件文件内容 1234url&#x3D;urltestuser&#x3D;usertestpassword&#x3D;passwordtestdriver&#x3D;drivertest 2.用ClassLoder获取xxx.propertise的路径不要写成绝对路径(没有通用性) 123ClassLoader classLoader &#x3D; JDBCUtils.class.getClassLoader();URL res &#x3D; classLoader.getResource(&quot;xxx.properties&quot;);String path &#x3D; res.getPath(); 3.利用Propertise类获取各个信息123456Properties pro &#x3D; new Properties();pro.load(new FileReader(path));String url &#x3D; pro.getProperty(&quot;url&quot;);String user &#x3D; pro.getProperty(&quot;user&quot;);String password &#x3D; pro.getProperty(&quot;password&quot;);String driver &#x3D; pro.getProperty(&quot;driver&quot;); 4.完整代码12345678910111213141516171819202122232425262728package primary_connect;import java.io.FileReader;import java.io.IOException;import java.net.URL;import java.util.Properties;public class JDBCUtils &#123; public static void main(String[] args) &#123; try &#123; ClassLoader classLoader &#x3D; JDBCUtils.class.getClassLoader(); URL res &#x3D; classLoader.getResource(&quot;jdbc.properties&quot;); String path &#x3D; res.getPath(); Properties pro &#x3D; new Properties(); pro.load(new FileReader(path)); String url &#x3D; pro.getProperty(&quot;url&quot;); String user &#x3D; pro.getProperty(&quot;user&quot;); String password &#x3D; pro.getProperty(&quot;password&quot;); String driver &#x3D; pro.getProperty(&quot;driver&quot;); System.out.println(&quot;url&#x3D;&quot;+url); System.out.println(&quot;user&#x3D;&quot;+user); System.out.println(&quot;password&#x3D;&quot;+password); System.out.println(&quot;driver&#x3D;&quot;+driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5.可能出现的问题1.加载时出现空指针异常1InputStream is &#x3D; JedisUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); 解决办法 在src下新建resourse包，，将jedis.properties放进去，然后点File-&gt;project structure-&gt;mudules 右键resourse文件夹，点resource","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"配置文件","slug":"java/配置文件","permalink":"https://donghuangzhong.github.io/categories/java/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/tags/java/"},{"name":"Properties","slug":"Properties","permalink":"https://donghuangzhong.github.io/tags/Properties/"}]},{"title":"hexo+github_pages+阿里云域名","slug":"hexo-github-pages-阿里云域名","date":"2021-01-02T09:46:19.000Z","updated":"2021-02-09T12:37:20.828Z","comments":true,"path":"2021/01/02/hexo-github-pages-阿里云域名/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/02/hexo-github-pages-%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/","excerpt":"hexo+github_pages+阿里云域名，整理自B站视频:https://www.bilibili.com/video/BV1Yb411a7ty","text":"hexo+github_pages+阿里云域名，整理自B站视频:https://www.bilibili.com/video/BV1Yb411a7ty 1.安装Node.js官网:https://nodejs.org/en/xia安装LTS版本即可 2.安装 Git官网:https://git-scm.com/downloads 2个都安装完成如下： 3.安装hexo1.新建一个文件夹，右键空白处点Git Bash Here 关于博客的所有文件都在这个文件夹下面，我新建的名字是dipamkar。 验证node，npm 是否安装成功，没有成功的就重新安装node。 1键入node -v和npm -v。进行验证 2.安装个cnpm提高速度，以后下载什么东西都用cnpm1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 验证cnpm是否安装成功，键入cnpm -v 3.正式安装hexo1cnpm install -g hexo-cli 验证hexo是否安装成功，键入hexo -v 4.初始化hexo1.本地初始化1hexo init 在此文件夹就会出现一堆文件 2.运行测试常用命令： 1234hexo clean #用来清理缓存文件hexo g #生成文件hexo s #运行本地服务器hexo d #上传到服务器 先运行hexo s。在浏览器中打开网址localhost:4000即可，得到下图表示成功 5.部署到github1.注册登录github网址：github.com 2.点击your repositories然后点new,新建仓库 3.Repository name必须写github账号名+github.io 填成上图即可点击create完成仓库创建 4.安装部署插件1cnpm install --save hexo-deployer-git 5.修改配置文件_config.yml 右键这个文件-&gt;编辑 或者用记事本打开 到此文件最后的位置，只改Deployment，改成下图 注意：repo按照下图从仓库中复制过来，改完不要忘了保存 6.绑定邮箱和账号名键入以下命令，引号中的信息换成你自己的 12git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 7.用hexo d正式部署到github 键入hexo d，然后会让你输入github账号密码，最后出现Deploy done表示成功 然后就可以用github账号名.github.io访问了 8.常用流程和命令1234567891011121314151617181920&#x2F;&#x2F;新建文章(默认md文件)hexo n &quot;文章名称&quot;&#x2F;&#x2F;本地调试hexo s&#x2F;&#x2F;清理文件夹hexo clean&#x2F;&#x2F;生成静态网页hexo g&#x2F;&#x2F;部署到githubhexo d&#x2F;&#x2F;必须先生成然后再部署，生成+部署可以简写成一条命令hexo g -d&#x2F;&#x2F;一般先用hexo n “”生成md文件-&gt;写文章-&gt;hexo g -d","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://donghuangzhong.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"博客搭建","slug":"个人博客/博客搭建","permalink":"https://donghuangzhong.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/tags/hexo/"},{"name":"github_pages","slug":"github-pages","permalink":"https://donghuangzhong.github.io/tags/github-pages/"}]},{"title":"计算机图形学 MFC 鼠标绘制多边形并用指定数字填充","slug":"计算机图形学-MFC-鼠标绘制多边形并用指定数字填充","date":"2020-12-31T02:37:39.000Z","updated":"2021-02-09T12:34:55.568Z","comments":true,"path":"2020/12/31/计算机图形学-MFC-鼠标绘制多边形并用指定数字填充/","link":"","permalink":"https://donghuangzhong.github.io/2020/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-MFC-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%B9%B6%E7%94%A8%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97%E5%A1%AB%E5%85%85/","excerpt":"边标志算法的实现 ，用鼠标左键单击绘制顶点最后一个顶点用双击输入，然后用任意的数字填充，用vc6.0软件做的","text":"边标志算法的实现 ，用鼠标左键单击绘制顶点最后一个顶点用双击输入，然后用任意的数字填充，用vc6.0软件做的 1.新建MFC项目 然后点finish就行 2.添加鼠标左键单击和双击的响应事件 Class name必须选View结尾的，选择WM_LBUTTONDOWN，然后必须先点Add Function，然后再点OK 这样就可以在目录结构中看到添加的事件了 同样可以添加双击的事件 3.首先实现用鼠标绘制多边形的代码首先分析一个我们要干的事，用鼠标单击事件获取到点的坐标后需要，moveto和lineto来划线，但是第一个点的时候不用划线，只有第二个点的时候才需要和上一个点划线，之后我们还需要每一个边的起点终点的位置，所以必须把所有点保存下来，同时需要记录这个多边形对应的矩形区域 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int max_x,max_y,min_x,min_y;&#x2F;&#x2F;多边形的矩形区域bool flag1&#x3D;0,flag&#x3D;0;&#x2F;&#x2F;flag1控制只进行一次画多边形，flag控制存放起点CPoint p[100];&#x2F;&#x2F;保存顶点数组，填充需要int n&#x3D;0;&#x2F;&#x2F;表示多边形顶点的的个数void CShiyan2View::OnLButtonDown(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;如果多边形已经绘制完成，再次点击则不会响应 &#123; if(!flag)&#123; max_x&#x3D;min_x&#x3D;point.x;&#x2F;&#x2F;初始化最开始的矩形区域为第一个点的横纵坐标 max_y&#x3D;min_y&#x3D;point.y; flag&#x3D;1; p[n++]&#x3D;point; &#125; else &#123; if(point.x&gt;max_x)&#x2F;&#x2F;更新矩形区域的坐标 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); p[n++]&#x3D;point; &#125; &#125; ReleaseDC(pDC); CView::OnLButtonDown(nFlags, point);&#125;void CShiyan2View::OnLButtonDblClk(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;只有没有绘制完成才会对双击进行响应 &#123; if(point.x&gt;max_x)&#x2F;&#x2F;此为最后一个顶点，同样需要更新矩形区域 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); pDC-&gt;MoveTo(point); pDC-&gt;LineTo(p[0]); flag1&#x3D;1;&#x2F;&#x2F;表示多边形已经绘制完成 p[n++]&#x3D;point; p[n]&#x3D;p[0]; &#125; ReleaseDC(pDC); CView::OnLButtonDblClk(nFlags, point);&#125; 4.用边标志法实现多边形填充(先用纯色填充)需要一个bool数组mask，初始全0，遍历每一条边上的点，将这个点右边的msak取反，最后得到的mask中为1的区域就是需要填充的区域。 从顶点数组p中获取每一条边的顶点信息，然后根据y计算x，对mask进行取反即可 要注意两点： 注意遍历点的时候要纵坐标优先，也就是纵坐标每次变化1，用纵坐标去计算横坐标 在顶点数组中，有可能出现起点的y比终点的y大的情况，这样就需要手动转换了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void CShiyan2View::OnLButtonDblClk(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;只有没有绘制完成才会对双击进行响应 &#123; if(point.x&gt;max_x)&#x2F;&#x2F;此为最后一个顶点，同样需要更新矩形区域 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); pDC-&gt;MoveTo(point); pDC-&gt;LineTo(p[0]); flag1&#x3D;1;&#x2F;&#x2F;表示多边形已经绘制完成 p[n++]&#x3D;point; p[n]&#x3D;p[0]; &#125; &#x2F;&#x2F;填充部分 for(int i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) mask[i][j]&#x3D;0;&#x2F;&#x2F;将数组全置0 for(i&#x3D;0;i&lt;n;i++)&#x2F;&#x2F;处理每一条边 &#123; int s&#x3D;p[i].y&lt;p[i+1].y?i:i+1;&#x2F;&#x2F;s保存的是较小y点的下标，e保存y较大的点的下标 int e&#x3D;2*i+1-s;&#x2F;&#x2F;由于起点终点的下标一个是i,一个是i+1，和为2*i+1，所以可以通过s计算e double dx&#x3D;(p[e].x-p[s].x)&#x2F;double(p[e].y-p[s].y);&#x2F;&#x2F;保存dx&#x2F;dy。也就是y每变化1，x的变化值 for(int y&#x3D;p[s].y;y&lt;p[e].y;y++) &#123; int x&#x3D;(y-p[s].y)*dx+p[s].x;&#x2F;&#x2F;通过y计算x。简单的直线方程 for(int t&#x3D;x;t&lt;&#x3D;max_x;t++) mask[t][y]&#x3D;!mask[t][y]; &#x2F;&#x2F;将此点右边的全取反 &#125; &#125; for(i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) if(mask[i][j]) pDC-&gt;SetPixel(i,j,RGB(100,100,100));&#x2F;&#x2F;将数组中为1的区域涂色 ReleaseDC(pDC); CView::OnLButtonDblClk(nFlags, point);&#125; 5.用任意数字填充首先要生成数字的点阵数组。然后就可以通过区域的周期性来画图。 生成指定数字的点阵数组，利用0~9镜像对称的数组来实现 1234567891011121314151617181920212223242526char a[10][8]&#x3D;&#123; &#123;0x00,0x18,0x24,0x24,0x24,0x24,0x24,0x18&#125;, &#x2F;&#x2F;0 &#123;0x00,0x18,0x1c,0x18,0x18,0x18,0x18,0x18&#125;, &#x2F;&#x2F;1 &#123;0x00,0x1e,0x30,0x30,0x1c,0x06,0x06,0x3e&#125;, &#x2F;&#x2F;2 &#123;0x00,0x1e,0x30,0x30,0x1c,0x30,0x30,0x1e&#125;, &#x2F;&#x2F;3 &#123;0x00,0x30,0x38,0x34,0x32,0x3e,0x30,0x30&#125;, &#x2F;&#x2F;4 &#123;0x00,0x1e,0x02,0x1e,0x30,0x30,0x30,0x1e&#125;, &#x2F;&#x2F;5 &#123;0x00,0x1c,0x06,0x1e,0x36,0x36,0x36,0x1c&#125;, &#x2F;&#x2F;6 &#123;0x00,0x3f,0x30,0x18,0x18,0x0c,0x0c,0x0c&#125;, &#x2F;&#x2F;7 &#123;0x00,0x1c,0x36,0x36,0x1c,0x36,0x36,0x1c&#125;, &#x2F;&#x2F;8 &#123;0x00,0x1c,0x36,0x36,0x36,0x3c,0x30,0x1c&#125;, &#x2F;&#x2F;9&#125;;&#x2F;&#x2F;数字的镜像对称数组，每个数字用8行8列的01表示，每一行看做一个8位二进制void Creat_array(int n,bool dianzhen[8][32])&#x2F;&#x2F;得到要显示四个数字的点阵数组&#123; int num[4]; for(int i&#x3D;3;i&gt;&#x3D;0;i--,n&#x2F;&#x3D;10)&#x2F;&#x2F;将这四位数放到数组中 num[i]&#x3D;n%10; for(i&#x3D;0;i&lt;8;i++)&#x2F;&#x2F;一共8行，每行显示4*8&#x3D;32个0或1 for(int j&#x3D;0;j&lt;4;j++) &#123; int x&#x3D;a[num[j]][i];&#x2F;&#x2F;得到num[j]对应的数字点阵的第i行二进制串 for(int k&#x3D;0;k&lt;8;k++,x&#x2F;&#x3D;2)&#x2F;&#x2F;依次得到二进制串的每一位 dianzhen[i][j*8+k]&#x3D;x%2?1:0;&#x2F;&#x2F;组合成指定数字的点阵数组 &#125; &#125; 利用区域的周期性填充区域 12345for(i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) if(mask[i][j]) pDC-&gt;SetPixel(i,j,(dianzhen[j%8][i%32])?RGB(230,0,0):RGB(255,255,255)); &#x2F;&#x2F;将数组中为1的区域打印成点阵数字 6.最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114int number&#x3D;1357;&#x2F;&#x2F;要显示的数字，必须填四位int max_x,max_y,min_x,min_y;&#x2F;&#x2F;多边形的矩形区域bool flag1&#x3D;0,flag&#x3D;0;&#x2F;&#x2F;flag1控制只进行一次画多边形，flag控制存放起点CPoint p[100];&#x2F;&#x2F;保存顶点数组，填充需要int n&#x3D;0;&#x2F;&#x2F;表示多边形顶点的的个数bool mask[1000][1000],dianzhen[8][32];char a[10][8]&#x3D;&#123; &#123;0x00,0x18,0x24,0x24,0x24,0x24,0x24,0x18&#125;, &#x2F;&#x2F;0 &#123;0x00,0x18,0x1c,0x18,0x18,0x18,0x18,0x18&#125;, &#x2F;&#x2F;1 &#123;0x00,0x1e,0x30,0x30,0x1c,0x06,0x06,0x3e&#125;, &#x2F;&#x2F;2 &#123;0x00,0x1e,0x30,0x30,0x1c,0x30,0x30,0x1e&#125;, &#x2F;&#x2F;3 &#123;0x00,0x30,0x38,0x34,0x32,0x3e,0x30,0x30&#125;, &#x2F;&#x2F;4 &#123;0x00,0x1e,0x02,0x1e,0x30,0x30,0x30,0x1e&#125;, &#x2F;&#x2F;5 &#123;0x00,0x1c,0x06,0x1e,0x36,0x36,0x36,0x1c&#125;, &#x2F;&#x2F;6 &#123;0x00,0x3f,0x30,0x18,0x18,0x0c,0x0c,0x0c&#125;, &#x2F;&#x2F;7 &#123;0x00,0x1c,0x36,0x36,0x1c,0x36,0x36,0x1c&#125;, &#x2F;&#x2F;8 &#123;0x00,0x1c,0x36,0x36,0x36,0x3c,0x30,0x1c&#125;, &#x2F;&#x2F;9&#125;;&#x2F;&#x2F;数字的镜像对称数组，每个数字用8行8列的01表示，每一行看做一个8位二进制void CShiyan2View::OnLButtonDown(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;如果多边形已经绘制完成，再次点击则不会响应 &#123; if(!flag)&#123; max_x&#x3D;min_x&#x3D;point.x;&#x2F;&#x2F;初始化最开始的矩形区域为第一个点的横纵坐标 max_y&#x3D;min_y&#x3D;point.y; flag&#x3D;1; p[n++]&#x3D;point; &#125; else &#123; if(point.x&gt;max_x)&#x2F;&#x2F;更新矩形区域的坐标 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); p[n++]&#x3D;point; &#125; &#125; ReleaseDC(pDC); CView::OnLButtonDown(nFlags, point);&#125;void Creat_array(int n,bool dianzhen[8][32])&#x2F;&#x2F;得到要显示四个数字的点阵数组&#123; int num[4]; for(int i&#x3D;3;i&gt;&#x3D;0;i--,n&#x2F;&#x3D;10)&#x2F;&#x2F;将这四位数放到数组中 num[i]&#x3D;n%10; for(i&#x3D;0;i&lt;8;i++)&#x2F;&#x2F;一共8行，每行显示4*8&#x3D;32个0或1 for(int j&#x3D;0;j&lt;4;j++) &#123; int x&#x3D;a[num[j]][i];&#x2F;&#x2F;得到num[j]对应的数字点阵的第i行二进制串 for(int k&#x3D;0;k&lt;8;k++,x&#x2F;&#x3D;2)&#x2F;&#x2F;依次得到二进制串的每一位 dianzhen[i][j*8+k]&#x3D;x%2?1:0;&#x2F;&#x2F;组合成指定数字的点阵数组 &#125; &#125;void CShiyan2View::OnLButtonDblClk(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;只有没有绘制完成才会对双击进行响应 &#123; if(point.x&gt;max_x)&#x2F;&#x2F;此为最后一个顶点，同样需要更新矩形区域 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); pDC-&gt;MoveTo(point); pDC-&gt;LineTo(p[0]); flag1&#x3D;1;&#x2F;&#x2F;表示多边形已经绘制完成 p[n++]&#x3D;point; p[n]&#x3D;p[0];&#x2F;&#x2F;此处将首尾相连，方便得到边的信息 &#125; &#x2F;&#x2F;填充部分 for(int i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) mask[i][j]&#x3D;0;&#x2F;&#x2F;将数组全置0 for(i&#x3D;0;i&lt;n;i++)&#x2F;&#x2F;处理每一条边 &#123; int s&#x3D;p[i].y&lt;p[i+1].y?i:i+1;&#x2F;&#x2F;s保存的是较小y点的下标，e保存y较大的点的下标 int e&#x3D;2*i+1-s;&#x2F;&#x2F;由于起点终点的下标一个是i,一个是i+1，和为2*i+1，所以可以通过s计算e double dx&#x3D;(p[e].x-p[s].x)&#x2F;double(p[e].y-p[s].y);&#x2F;&#x2F;保存dx&#x2F;dy。也就是y每变化1，x的变化值 for(int y&#x3D;p[s].y;y&lt;p[e].y;y++) &#123; int x&#x3D;(y-p[s].y)*dx+p[s].x;&#x2F;&#x2F;通过y计算x。简单的直线方程 for(int t&#x3D;x+1;t&lt;&#x3D;max_x;t++) mask[t][y]&#x3D;!mask[t][y]; &#x2F;&#x2F;将此点右边的全取反 &#125; &#125; Creat_array(number,dianzhen); for(i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) if(mask[i][j]) pDC-&gt;SetPixel(i,j,(dianzhen[j%8][i%32])?RGB(230,0,0):RGB(255,255,255)); &#x2F;&#x2F;将数组中为1的区域打印成点阵数字 ReleaseDC(pDC); CView::OnLButtonDblClk(nFlags, point);&#125;","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://donghuangzhong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"多边形填充","slug":"计算机图形学/多边形填充","permalink":"https://donghuangzhong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%A1%AB%E5%85%85/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"MFC","slug":"MFC","permalink":"https://donghuangzhong.github.io/tags/MFC/"}]},{"title":"蓝桥杯2018第九届省赛解题报告","slug":"蓝桥杯2018第九届省赛解题报告","date":"2020-04-14T00:39:21.000Z","updated":"2020-04-14T01:23:57.177Z","comments":true,"path":"2020/04/14/蓝桥杯2018第九届省赛解题报告/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/14/%E8%93%9D%E6%A1%A5%E6%9D%AF2018%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%9C%81%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"摘要","text":"摘要 第一题 标题：分数1/1 + 1/2 + 1/4 + 1/8 + 1/16 + …. 每项是前一项的一半，如果一共有20项,求这个和是多少，结果用分数表示出来。分子分母要求互质。 解题思路求和找最大公约数 答案：1048575/524288 （选中或复制后查看，下同） 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int gcd(int a,int b)&#123; return b&#x3D;&#x3D;0?a:gcd(b,a%b); &#125;int main()&#123;&#x2F;&#x2F; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int factor&#x3D;gcd((1&lt;&lt;20)-1,1&lt;&lt;19); cout&lt;&lt;(((1&lt;&lt;20)-1)&#x2F;factor)&lt;&lt;&quot;&#x2F;&quot;&lt;&lt;(1&lt;&lt;19)&#x2F;factor&lt;&lt;endl; return 0;&#125; 第二题 标题：星期一整个20世纪（1901年1月1日至2000年12月31日之间），一共有多少个星期一？ 解题思路找最后一个周一(可以查日历也可以算)，剩余天数除以7。但是因为最后一天是周日，所以可以直接除以7，有几个完整的星期就有几个周一。 答案5217 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int count_day(int year,int month,int day)&#123; int day_sum&#x3D;0; _for(i,1,month-1) &#123; if(i&#x3D;&#x3D;2) &#123; if((year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0)||year%400&#x3D;&#x3D;0) day_sum+&#x3D;29; else day_sum+&#x3D;28; &#125; else if(i&#x3D;&#x3D;4||i&#x3D;&#x3D;6||i&#x3D;&#x3D;9||i&#x3D;&#x3D;11) day_sum+&#x3D;30; else day_sum+&#x3D;31; &#125; return day_sum+day;&#125;int main()&#123; int y,m,d; &#x2F;&#x2F;while(cin&gt;&gt;y&gt;&gt;m&gt;&gt;d&amp;&amp;y) &#x2F;&#x2F; cout&lt;&lt;count_day(y,m,d); int sum_2001&#x3D;count_day(2020,4,5); _for(i,2001,2019) sum_2001+&#x3D;count_day(i,12,31); sum_2001%&#x3D;7; int zhou&#x3D;(0-sum_2001)%7+1; cout&lt;&lt;&quot;2001&#x2F;01&#x2F;01:&quot;&lt;&lt;zhou&lt;&lt;endl; int sum_21&#x3D;0; _for(i,1901,2000) sum_21+&#x3D;count_day(i,12,31); cout&lt;&lt;&quot;21 century:&quot;&lt;&lt;sum_21&lt;&lt;endl; cout&lt;&lt;&quot;answer:&quot;&lt;&lt;sum_21&#x2F;7&lt;&lt;endl; return 0;&#125; 第三题 标题：乘积尾零如下的10行数据，每行有10个整数，请你求出它们的乘积的末尾有多少个零？ 5650 4542 3554 473 946 4114 3871 9073 90 4329 2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 1486 5722 3135 1170 4014 5510 5120 729 2880 9019 2049 698 4582 4346 4427 646 9742 7340 1230 7683 5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 6701 6645 1671 5978 2704 9926 295 3125 3878 6785 2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 689 5510 8243 6114 337 4096 8199 7313 3685 211 注意：需要提交的是一个整数，表示末尾零的个数。不要填写任何多余内容。 解题思路求因数中2和5的总数的最小值 答案31 12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,factor_2&#x3D;0,factor_5&#x3D;0; while(cin&gt;&gt;n) &#123; while(n%2&#x3D;&#x3D;0) n&#x2F;&#x3D;2,factor_2++; while(n%5&#x3D;&#x3D;0) n&#x2F;&#x3D;5,factor_5++; &#125; cout&lt;&lt;min(factor_2,factor_5); return 0;&#125; 第四题 标题：第几个幸运数到x星球旅行的游客都被发给一个整数，作为游客编号。x星的国王有个怪癖，他只喜欢数字3,5和7。国王规定，游客的编号如果只含有因子：3,5,7,就可以获得一份奖品。 我们来看前10个幸运数字是：3 5 7 9 15 21 25 27 35 45。 因而第11个幸运数字是：49 小明领到了一个幸运数字 59084709587505，他去领奖的时候，人家要求他准确地说出这是第几个幸运数字，否则领不到奖品。 请你帮小明计算一下，59084709587505是第几个幸运数字。需要提交的是一个整数，请不要填写任何多余内容。 解题思路三种思路， 答案1905","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"category2","slug":"ACM/category2","permalink":"https://donghuangzhong.github.io/categories/ACM/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"洛谷_P1233 木棍加工","slug":"洛谷-P1233-木棍加工","date":"2020-04-07T04:03:48.000Z","updated":"2020-04-07T04:03:48.289Z","comments":true,"path":"2020/04/07/洛谷-P1233-木棍加工/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/07/%E6%B4%9B%E8%B0%B7-P1233-%E6%9C%A8%E6%A3%8D%E5%8A%A0%E5%B7%A5/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"洛谷_P4933 大师","slug":"洛谷-P4933-大师","date":"2020-04-06T10:11:06.000Z","updated":"2020-04-06T10:23:40.706Z","comments":true,"path":"2020/04/06/洛谷-P4933-大师/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P4933-%E5%A4%A7%E5%B8%88/","excerpt":"DP关键的是设状态。","text":"DP关键的是设状态。 题目题目背景建筑大师最近在跟着数学大师ljt12138学数学，今天他学了等差数列，ljt12138决定给他留一道练习题。 题目描述ljt12138首先建了n个特斯拉电磁塔，这些电塔排成一排，从左到右依次标号为1到n，第i个电塔的高度为h[i]。 建筑大师需要从中选出一些电塔，然后这些电塔就会缩到地下去。这时候，如果留在地上的电塔的高度，从左向右构成了一个等差数列，那么这个选择方案就会被认为是美观的。 建筑大师需要求出，一共有多少种美观的选择方案，答案模998244353。 注意，如果地上只留了一个或者两个电塔，那么这种方案也是美观的。地上没有电塔的方案被认为是不美观的。 输入格式第一行一个正整数n。 第二行n个非负整数，第i个整数是第i个电塔的高度h[i]。 输出格式输出一个整数，表示美观的方案数模998244353的值。 输入输出样例输入 #1复制 12813 14 6 20 27 34 34 41 输出 #1复制 150 输入 #2复制 1210090 1004 171 99 1835 108 81 117 141 126 135 144 81 153 193 81 962 162 1493 171 1780 864 297 180 532 1781 189 1059 198 333 1593 824 207 1877 216 270 225 1131 336 1875 362 234 81 288 1550 243 463 1755 252 406 261 270 279 288 1393 261 1263 297 135 333 872 234 881 180 198 81 225 306 180 90 315 81 81 198 252 81 297 1336 1140 1238 81 198 297 661 81 1372 469 1132 81 126 324 333 342 81 351 481 279 1770 1225 549 输出 #2复制 111153 说明/提示我们用v表示最高的电塔高度。 对于前30%的数据，n&lt;=20。 对于前60%的数据，n&lt;=100，v&lt;=2000。 对于另外20%的数据，所有电塔的高度构成一个等差数列。 对于100%的数据，n&lt;=1000，v&lt;=20000。 算法用dp[i][a[i]-a[j]+20002]表示以i点为结束公差为a[i]-a[j]的数列，加上20002是因为a[i]-a[j]最小为0-20000,为了避免出现负数，注意ans不可以加上dp[i][a[i]-a[j]+20002]，因为会出现相同塔高的塔，会重复加这些塔 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int dp[1001][40002];int a[1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; long long ans&#x3D;0; _for(i,1,n)cin&gt;&gt;a[i]; _for(i,2,n) for(int j&#x3D;i-1;j&gt;&#x3D;1;j--) &#123; dp[i][a[i]-a[j]+20002]&#x3D;(dp[i][a[i]-a[j]+20002]+dp[j][a[i]-a[j]+20002]+1)%998244353; ans&#x3D;(ans+dp[j][a[i]-a[j]+20002]+1)%998244353; &#125; ans&#x3D;(ans+n)%998244353; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"W","slug":"W","permalink":"https://donghuangzhong.github.io/tags/W/"},{"name":"设状态","slug":"设状态","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%BE%E7%8A%B6%E6%80%81/"}]},{"title":"洛谷_P1040 加分二叉树","slug":"洛谷-P1040-加分二叉树","date":"2020-04-06T08:02:34.000Z","updated":"2020-04-06T08:06:20.849Z","comments":true,"path":"2020/04/06/洛谷-P1040-加分二叉树/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P1040-%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"设计好状态就行，可以用dp也可以用记忆dfs","text":"设计好状态就行，可以用dp也可以用记忆dfs 题目题目描述设一个nn个节点的二叉树tree的中序遍历为（1,2,3,…,n1,2,3,…,n），其中数字1,2,3,…,n1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第ii个节点的分数为di,treed**i,t*ree及它的每个子树都有一个加分，任一棵子树subtreesubtree（也包含treetre*e本身）的加分计算方法如下： subtrees*ubtree的左子树的加分× subtreesubtree的右子树的加分＋subtreesubtre*e的根的分数。 若某个子树为空，规定其加分为11，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n1,2,3,…,n）且加分最高的二叉树treet*ree*。要求输出； （1）treet*ree*的最高加分 （2）treet*ree*的前序遍历 输入格式第11行：11个整数n(n&lt;30)n(n&lt;30)，为节点个数。 第22行：nn个用空格隔开的整数，为每个节点的分数（分数&lt;100&lt;100）。 输出格式第11行：11个整数，为最高加分（Ans \\le 4,000,000,000≤4,000,000,000）。 第22行：nn个用空格隔开的整数，为该树的前序遍历。 输入输出样例输入 #1复制 1255 7 1 2 10 输出 #1复制 121453 1 2 4 5 算法记忆dfs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,a[31],root[31][31],mem[31][31];int dfs(int s,int e)&#123; if(mem[s][e]) return mem[s][e]; if(s&gt;e) return 1; if(s&#x3D;&#x3D;e) return a[s]; int maxx&#x3D;-1; _for(i,s,e) &#123; int t&#x3D;(dfs(s,i-1)*dfs(i+1,e)+a[i]); if(t&gt;maxx) &#123; maxx&#x3D;t; root[s][e]&#x3D;i; &#125; &#125; return mem[s][e]&#x3D;maxx;&#125; void p(int s,int e)&#123; if(s&gt;e) return ; if(s&#x3D;&#x3D;e) &#123; cout&lt;&lt;e&lt;&lt;&quot; &quot;; return ; &#125; cout&lt;&lt;root[s][e]&lt;&lt;&quot; &quot;; p(s,root[s][e]-1); p(root[s][e]+1,e);&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) cin&gt;&gt;a[i]; cout&lt;&lt;dfs(1,n)&lt;&lt;endl; p(1,n); return 0;&#125; DP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,a[31],root[31][31],dp[31][31];void p(int s,int e)&#123; if(s&gt;e) return ; if(s&#x3D;&#x3D;e) &#123; cout&lt;&lt;e&lt;&lt;&quot; &quot;; return ; &#125; cout&lt;&lt;root[s][e]&lt;&lt;&quot; &quot;; p(s,root[s][e]-1); p(root[s][e]+1,e);&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) cin&gt;&gt;a[i];&#x2F;&#x2F; dp[i][j]&#x3D;max(dp[i][k-1]*dp[k+1][j]+a[i]); _for(i,1,n)&#123;dp[i][i]&#x3D;a[i];dp[i][i-1]&#x3D;1;&#125; for(int i&#x3D;n;i&gt;&#x3D;1;i--) &#123; for(int j&#x3D;i+1;j&lt;&#x3D;n;j++) &#123; for(int k&#x3D;i;k&lt;&#x3D;j;k++) &#123; if(dp[i][j]&lt;dp[i][k-1]*dp[k+1][j]+a[k]) &#123; dp[i][j]&#x3D;dp[i][k-1]*dp[k+1][j]+a[k]; root[i][j]&#x3D;k; &#125; &#125; &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; p(1,n); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"记忆化dfs","slug":"记忆化dfs","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96dfs/"}]},{"title":"洛谷_P2758 编辑距离","slug":"洛谷-P2758-编辑距离","date":"2020-04-06T02:48:15.000Z","updated":"2020-04-06T03:15:15.039Z","comments":true,"path":"2020/04/06/洛谷-P2758-编辑距离/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P2758-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","excerpt":"DP精髓：不确定性就是DP范围。其实DP就是记忆化递归。","text":"DP精髓：不确定性就是DP范围。其实DP就是记忆化递归。 题目题目描述设A和B是两个字符串。我们要用最少的字符操作次数，将字符串A转换为字符串B。这里所说的字符操作共有三种： 1、删除一个字符； 2、插入一个字符； 3、将一个字符改为另一个字符； ！皆为小写字母！ 输入格式第一行为字符串A；第二行为字符串B；字符串A和B的长度均小于2000。 输出格式只有一个正整数，为最少字符操作次数。 输入输出样例输入 #1复制 12sfdqxbwgfdgw 输出 #1复制 14 算法普通二维数组dp[i][j]表示的是将第一个串s1前i个字符变为第二个串s2的前j个字符的最少操作次数，那么如果s1[i]==s2[j]，那么无需对s1[i]操作，将s1前i字符转换为s2前j字符的操作次数就是将s1前i-1字符转换为s2前j-1字符的操作次数，即dp[i][j]=dp[i-1][j-1]。如果s1[i]!=s2[j]那么就需要对s1[i]进行操作，操作的目的是将第一个串s1前i个字符变为第二个串s2的前j个字符，操作有三种 1.删去s1[i]，将s1前i-1字符变为s2前j字符，dp[i][j]=dp[i-1][j]+1 2.插入，将s1前i字符变为s2前j-1字符dp[i][j]=dp[i][j-1]+1 3.替换，将s1前i-1字符变为s2前j-1字符 dp[i][j]=dp[i-1][j]+1 取最小值 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int dp[2001][2001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; for(int i&#x3D;0;i&lt;&#x3D;s1.length();i++) dp[i][0]&#x3D;i; for(int j&#x3D;0;j&lt;&#x3D;s2.length();j++) dp[0][j]&#x3D;j; _for(i,1,s1.length()) _for(j,1,s2.length()) &#123; if(s1[i-1]&#x3D;&#x3D;s2[j-1]) dp[i][j]&#x3D;dp[i-1][j-1]; else dp[i][j]&#x3D;min(min(dp[i-1][j]+1,dp[i][j-1]+1),dp[i-1][j-1]+1); &#125; cout&lt;&lt;dp[s1.length()][s2.length()]&lt;&lt;endl; _for(i,0,s1.length()) &#123; _for(j,0,s2.length()) &#123; cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 滚动数组观察到计算i行只需要i、i-1行，所以可以改造成滚动数组 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int dp[2][2001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; for(int i&#x3D;0;i&lt;&#x3D;s2.length();i++) dp[0][i]&#x3D;i; bool index; _for(i,1,s1.length()) &#123; index&#x3D;i&amp;1; dp[index][0]&#x3D;i; _for(j,1,s2.length()) &#123; if(s1[i-1]&#x3D;&#x3D;s2[j-1]) dp[index][j]&#x3D;dp[1-index][j-1]; else dp[index][j]&#x3D;min(min(dp[1-index][j]+1,dp[index][j-1]+1),dp[1-index][j-1]+1); &#125; &#125; cout&lt;&lt;dp[index][s2.length()]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"滚动数组","slug":"滚动数组","permalink":"https://donghuangzhong.github.io/tags/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"}]},{"title":"洛谷_P1280 尼克的任务","slug":"洛谷-P1280-尼克的任务","date":"2020-04-06T00:03:27.000Z","updated":"2020-04-06T00:24:51.737Z","comments":true,"path":"2020/04/06/洛谷-P1280-尼克的任务/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P1280-%E5%B0%BC%E5%85%8B%E7%9A%84%E4%BB%BB%E5%8A%A1/","excerpt":"当前时间点只有一个任务时，必须选择这个任务。当前时间点有多个任务时，选择哪个任务取决于哪个任务结束的时候有更多的空闲时间。假设当前有多个任务，开始的时间是s，结束的时间是e1,e2,e3。选择哪一个任务取决于开始时间是e1,e2,e3的时候一直到最后哪个剩余的空闲时间多。以所有的起点为基准，dp[i]表示以i为起点的时候剩余的空闲时间。那么dp[i]=max(end-start+dp[strat])，i是当前的起点，end是当前的终点，start是终点后面第一个起点。从后向前算，起点和终点好说，怎么找终点后面的第一个起点，遍历的话是k,二分查找的话是logn","text":"当前时间点只有一个任务时，必须选择这个任务。当前时间点有多个任务时，选择哪个任务取决于哪个任务结束的时候有更多的空闲时间。假设当前有多个任务，开始的时间是s，结束的时间是e1,e2,e3。选择哪一个任务取决于开始时间是e1,e2,e3的时候一直到最后哪个剩余的空闲时间多。以所有的起点为基准，dp[i]表示以i为起点的时候剩余的空闲时间。那么dp[i]=max(end-start+dp[strat])，i是当前的起点，end是当前的终点，start是终点后面第一个起点。从后向前算，起点和终点好说，怎么找终点后面的第一个起点，遍历的话是k,二分查找的话是logn 题目题目描述尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 尼克的一个工作日为 nn 分钟，从第 11 分钟开始到第 nn 分钟结束。当尼克到达单位后他就开始干活，公司一共有 kk 个任务需要完成。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第 pp 分钟开始，持续时间为 tt 分钟，则该任务将在第 (p+t-1)(p+t−1) 分钟结束。 写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。 输入格式输入数据第一行含两个用空格隔开的整数 nn 和 kk。 接下来共有 kk 行，每一行有两个用空格隔开的整数 pp 和 tt，表示该任务从第 pp 分钟开始，持续时间为 tt 分钟。 输出格式输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。 输入输出样例输入 #1复制 123456715 61 21 64 118 58 111 5 输出 #1复制 14 说明/提示数据规模与约定 对于 100%100% 的数据，保证 1 \\leq n \\leq 10^4,1 \\leq k \\leq 10^4,1 \\leq p \\leq n,1 \\leq p+t-1 \\leq n1≤n≤104,1≤k≤104,1≤p≤n,1≤p+t−1≤n。 算法为了方便把1看成一个起点为1终点为1的时间段 vector(k*n)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct Time&#123; int s,e;&#125;;vector&lt;Time&gt; v;int dp[10001];int n,k,end;int get(int e)&#123; _for(j,1,v.size()-1) &#123; if(v[j].s&gt;&#x3D;e) return v[j].s; &#125; return n;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;k; n++; v.push_back(&#123;1,1&#125;); _for(i,1,k) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; v.push_back(&#123;s,e+s&#125;); &#125; for(int i&#x3D;v.size()-1;i&gt;&#x3D;0;i--) &#123; int j&#x3D;i,maxx&#x3D;-1; while(v[j].s&#x3D;&#x3D;v[i].s) &#123; int start&#x3D;get(v[j].e); maxx&#x3D;max(maxx,start-v[j].e+dp[start]); j--; &#125; dp[v[i].s]&#x3D;maxx; i&#x3D;j+1; &#125; cout&lt;&lt;dp[1]; return 0;&#125; 结构体+二分查找(k*lgn)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct Time&#123; int s,e;&#125; v[10005];int dp[10005];int a[10005];int n,k,end;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;k; n++; int len&#x3D;0; v[0].s&#x3D;1; v[0].e&#x3D;1; _for(i,1,k) &#123; int s,t; cin&gt;&gt;s&gt;&gt;t; v[i].s&#x3D;s; v[i].e&#x3D;s+t; if(s!&#x3D;a[len]) &#123; a[++len]&#x3D;s; &#125; &#125; a[++len]&#x3D;n; for(int i&#x3D;k;i&gt;&#x3D;0;i--) &#123; int j&#x3D;i,maxx&#x3D;-1; while(v[j].s&#x3D;&#x3D;v[i].s) &#123; int start&#x3D;*lower_bound(a+1,a+len+1,v[j].e); maxx&#x3D;max(maxx,start-v[j].e+dp[start]); j--; &#125; dp[v[i].s]&#x3D;maxx; i&#x3D;j+1; &#125; cout&lt;&lt;dp[1]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"二分查找(大小于)","slug":"二分查找-大小于","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%A4%A7%E5%B0%8F%E4%BA%8E/"}]},{"title":"洛谷_P1439 【模板】最长公共子序列","slug":"洛谷-P1439-【模板】最长公共子序列","date":"2020-04-05T23:50:50.000Z","updated":"2020-04-06T00:04:23.449Z","comments":true,"path":"2020/04/06/洛谷-P1439-【模板】最长公共子序列/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P1439-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"可以用通用m*n算法。由于这两个序列都是全排列的一种，假设这两串数字分别是s1,s2。将s1的元素从第一个开始全部表示为a,b,c……。将s2中对应的数字也变为字母。比如s1:3,2,1，s2:2,3,1。将3替换为a，2替换为b，1替换为c。s1变为a,b,c。s2变为b,a,c。最长公共子序列的长度不变，现在的问题就变成了求a,b,c和b,c,a中的最长公共子序列。于是就可以转换为求最长递增子序列的长度。","text":"可以用通用m*n算法。由于这两个序列都是全排列的一种，假设这两串数字分别是s1,s2。将s1的元素从第一个开始全部表示为a,b,c……。将s2中对应的数字也变为字母。比如s1:3,2,1，s2:2,3,1。将3替换为a，2替换为b，1替换为c。s1变为a,b,c。s2变为b,a,c。最长公共子序列的长度不变，现在的问题就变成了求a,b,c和b,c,a中的最长公共子序列。于是就可以转换为求最长递增子序列的长度。 题目题目描述给出 1,2,\\ldots,n1,2,…,n 的两个排列 P_1P1 和 P_2P2 ，求它们的最长公共子序列。 输入格式第一行是一个数 nn。 接下来两行，每行为 nn 个数，为自然数 1,2,\\ldots,n1,2,…,n 的一个排列。 输出格式一个数，即最长公共子序列的长度。 输入输出样例输入 #1复制 1235 3 2 1 4 51 2 3 4 5 输出 #1复制 13 说明/提示 对于 50%50% 的数据， n \\le 10^3n≤103； 对于 100%100% 的数据， n \\le 10^5n≤105。 算法通用算法m*n123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)#define N 10001using namespace std;int lcs[N][N];int a[N];int b[N];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); &#x2F;&#x2F;lcs[i][j]&#x3D;lcs[i-1][j-1]+1; a[i]&#x3D;&#x3D;b[i] &#x2F;&#x2F;lcs[i][j]&#x3D;max(lcs[i][j-1],lcs[i-1][j]); int n; cin&gt;&gt;n; _for(i,1,n) cin&gt;&gt;a[i]; _for(i,1,n) cin&gt;&gt;b[i]; _for(i,1,n) _for(j,1,n) &#123; if(a[i]&#x3D;&#x3D;b[i]) lcs[i][j]&#x3D;lcs[i-1][j-1]+1; else lcs[i][j]&#x3D;max(lcs[i][j-1],lcs[i-1][j]); &#125; cout&lt;&lt;lcs[n][n]; return 0;&#125; 最长上升子序列nlogn123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)#define N 100001int a[N],b[N],c[N];using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) &#123; cin&gt;&gt;a[i]; c[a[i]]&#x3D;i; &#125; _for(i,1,n) cin&gt;&gt;a[i]; int len&#x3D;0; _for(i,1,n) &#123; if(c[a[i]]&gt;b[len]) b[++len]&#x3D;c[a[i]]; else *upper_bound(b+1,b+len+1,c[a[i]])&#x3D;c[a[i]]; &#125; cout&lt;&lt;len; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"最长公共子序列","slug":"最长公共子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"最长上升子序列","slug":"最长上升子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"}]},{"title":"洛谷_P1020 导弹拦截","slug":"洛谷-P1020-导弹拦截","date":"2020-04-04T07:12:04.000Z","updated":"2020-04-04T08:34:20.073Z","comments":true,"path":"2020/04/04/洛谷-P1020-导弹拦截/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/04/%E6%B4%9B%E8%B0%B7-P1020-%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/","excerpt":"第一问一眼能看出是求最大单调非递增序列；第二问可以用Dilworth定理：最长x的子序列链的个数等于最长!X链的长度。或者这么考虑，问的是最少的导弹系统的个数，所以如果用x1,x2,……xn表示导弹系统1，2，……n现在可以到达的高度，其中x1,x2……xn互不相同，假设x1=1,x2=2,现在来了一个高度为1的导弹，肯定用x1来击落它，不会浪费高的导弹系统。所以它们互不相同。对于每一个新导弹系统击落的第一个导弹来说，x1,x2,……xn都比这个导弹的高度低(如果高的话就不会动用新的导弹系统)，所以最少导弹系统的个数一定是一个上升子序列的长度。考虑到如果存在一个最长的单调递增子序列，每个元素都需要一个新的导弹系统，所以新的导弹系统的个数最少是最长上升子序列的长度，又因为最少导弹系统的个数一定是一个上升子序列的长度，所以新的导弹系统的个数就是最长上升子序列的长度。","text":"第一问一眼能看出是求最大单调非递增序列；第二问可以用Dilworth定理：最长x的子序列链的个数等于最长!X链的长度。或者这么考虑，问的是最少的导弹系统的个数，所以如果用x1,x2,……xn表示导弹系统1，2，……n现在可以到达的高度，其中x1,x2……xn互不相同，假设x1=1,x2=2,现在来了一个高度为1的导弹，肯定用x1来击落它，不会浪费高的导弹系统。所以它们互不相同。对于每一个新导弹系统击落的第一个导弹来说，x1,x2,……xn都比这个导弹的高度低(如果高的话就不会动用新的导弹系统)，所以最少导弹系统的个数一定是一个上升子序列的长度。考虑到如果存在一个最长的单调递增子序列，每个元素都需要一个新的导弹系统，所以新的导弹系统的个数最少是最长上升子序列的长度，又因为最少导弹系统的个数一定是一个上升子序列的长度，所以新的导弹系统的个数就是最长上升子序列的长度。 题目题目描述 某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度（雷达给出的高度数据是\\le 50000≤50000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入格式11行，若干个整数（个数\\le 100000≤100000） 输出格式22行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出样例输入 #1复制 1389 207 155 300 299 170 158 65 输出 #1复制 1262 说明/提示为了让大家更好地测试n方算法，本题开启spj，n方100分，nlogn200分 每点两问，按问给分 算法DP（n2）a数组存数据，b[i]/r[i]表示以a[i]结尾(包括a[i])的最大非上升/上升子序列的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int a[100001];int b[100001];int r[100001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int c&#x3D;0,ans&#x3D;0,rans&#x3D;0; while(cin&gt;&gt;a[c++]) &#123; int he&#x3D;0; for(int i&#x3D;c-1;i&gt;&#x3D;0;i--) &#123; if(a[i]&gt;a[c-1]) &#123; he&#x3D;max(he,b[i]); &#125; &#125; b[c-1]&#x3D;he+1; ans&#x3D;max(ans,b[c-1]); he&#x3D;0; for(int i&#x3D;c-1;i&gt;&#x3D;0;i--) &#123; if(a[i]&lt;a[c-1]) &#123; he&#x3D;max(he,r[i]); &#125; &#125; r[c-1]&#x3D;he+1; rans&#x3D;max(rans,r[c-1]); &#125;cout&lt;&lt;ans&lt;&lt;endl;cout&lt;&lt;rans; return 0;&#125; DP+二分查找a数组存数据，b[i]/r[i]表示长度为i的最大非上升/上升序列的最后一个元素的最大/小值。bs函数可以当做模板，参数（待查找的数组，起点，终点，要比较的数字，op）,op为1/-1表示找小/大于num的第一个数的下标。当然二分查找的前提是数组已经排好序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int a[100001];int b[100001];int r[100001];int bs(int s[],int start,int end,int num,int op)&#123; while(start&lt;&#x3D;end) &#123; int mid&#x3D;(start+end)&#x2F;2; if(op*num&lt;&#x3D;op*s[mid]) start&#x3D;mid+1; else end&#x3D;mid-1; &#125; while(op&#x3D;&#x3D;-1&amp;&amp;s[start-1]&#x3D;&#x3D;num) start--; return start;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int c&#x3D;0,len_b&#x3D;0,len_r&#x3D;0; memset(b,0x3f,sizeof(b)); while(cin&gt;&gt;a[c++]) &#123; int b_index&#x3D;bs(b,0,len_b,a[c-1],1); b[b_index]&#x3D;a[c-1]; if(b_index&gt;len_b) len_b&#x3D;b_index; int r_index&#x3D;bs(r,0,len_r,a[c-1],-1); r[r_index]&#x3D;a[c-1]; if(r_index&gt;len_r) len_r&#x3D;r_index; &#125; cout&lt;&lt;len_b&lt;&lt;endl&lt;&lt;len_r; return 0;&#125; 用STL里面的二分查找1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int a[100001];int b[100001];int r[100001];bool cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int c&#x3D;0,len_b&#x3D;0,len_r&#x3D;0; b[0]&#x3D;0x3f3f3f3f; while(cin&gt;&gt;a[c++]) &#123; if(a[c-1]&lt;&#x3D;b[len_b]) b[++len_b]&#x3D;a[c-1]; else *upper_bound(b+1,b+len_b+1,a[c-1],cmp)&#x3D;a[c-1]; if(a[c-1]&gt;r[len_r]) r[++len_r]&#x3D;a[c-1]; else *lower_bound(r+1,r+1+len_r,a[c-1])&#x3D;a[c-1]; &#125; cout&lt;&lt;len_b&lt;&lt;endl&lt;&lt;len_r; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"二分查找(大小于)","slug":"二分查找-大小于","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%A4%A7%E5%B0%8F%E4%BA%8E/"},{"name":"最长(非)单调子序列","slug":"最长-非-单调子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF-%E9%9D%9E-%E5%8D%95%E8%B0%83%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"Dilworth定理","slug":"Dilworth定理","permalink":"https://donghuangzhong.github.io/tags/Dilworth%E5%AE%9A%E7%90%86/"}]},{"title":"洛谷_P1002 过河卒","slug":"洛谷-P1002-过河卒","date":"2020-04-03T04:22:21.000Z","updated":"2020-04-03T04:25:31.362Z","comments":true,"path":"2020/04/03/洛谷-P1002-过河卒/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/03/%E6%B4%9B%E8%B0%B7-P1002-%E8%BF%87%E6%B2%B3%E5%8D%92/","excerpt":"注意初始化不能直接对起点操作，因为这样就不能判断起点是不是马的控制点。","text":"注意初始化不能直接对起点操作，因为这样就不能判断起点是不是马的控制点。 题目题目描述棋盘上 AA 点有一个过河卒，需要走到目标 BB 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 CC 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。 棋盘用坐标表示，AA 点 (0, 0)(0,0)、BB 点 (n, m)(n,m)，同样马的位置坐标是需要给出的。 现在要求你计算出卒从 AA 点能够到达 BB 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。 输入格式一行四个正整数，分别表示 BB 点坐标和马的坐标。 输出格式一个整数，表示所有的路径条数。 输入输出样例输入 #1复制 16 6 3 3 输出 #1复制 16 说明/提示对于 100 %100% 的数据，1 \\le n, m \\le 201≤n,m≤20，0 \\le0≤ 马的坐标 \\le 20≤20。 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m,horse_x,horse_y;long long map[22][22];int dir[8][2]&#x3D;&#123;1,2,1,-2,-1,2,-1,-2,2,1,2,-1,-2,1,-2,-1&#125;;bool judge(int x,int y)&#123; if(x&#x3D;&#x3D;horse_x&amp;&amp;y&#x3D;&#x3D;horse_y) return 0; _for(i,0,7) &#123; int xx&#x3D;horse_x+dir[i][0]; int yy&#x3D;horse_y+dir[i][1]; if(x&#x3D;&#x3D;xx&amp;&amp;y&#x3D;&#x3D;yy) return 0; &#125; return 1;&#125; int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input1.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m&gt;&gt;horse_x&gt;&gt;horse_y; n++;m++;horse_x++;horse_y++; map[1][0]&#x3D;1; _for(i,1,n) _for(j,1,m) if(judge(i,j)) map[i][j]&#x3D;map[i-1][j]+map[i][j-1]; cout&lt;&lt;map[n][m]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"简单DP","slug":"简单DP","permalink":"https://donghuangzhong.github.io/tags/%E7%AE%80%E5%8D%95DP/"}]},{"title":"洛谷_P1802 5倍经验日","slug":"洛谷-P1802-5倍经验日","date":"2020-04-03T01:31:44.000Z","updated":"2020-04-03T01:36:30.509Z","comments":true,"path":"2020/04/03/洛谷-P1802-5倍经验日/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/03/%E6%B4%9B%E8%B0%B7-P1802-5%E5%80%8D%E7%BB%8F%E9%AA%8C%E6%97%A5/","excerpt":"一个01可不装满背包的变形，注意循环必须[x,cost],然后[0,cost-1]，不然会重复！","text":"一个01可不装满背包的变形，注意循环必须[x,cost],然后[0,cost-1]，不然会重复！ 题目题目背景现在乐斗有活动了！每打一个人可以获得5倍经验！absi2011却无奈的看着那一些比他等级高的好友，想着能否把他们干掉。干掉能拿不少经验的。 题目描述现在absi2011拿出了x个迷你装药物(嗑药打人可耻….)，准备开始与那些人打了 由于迷你装一个只能管一次，所以absi2011要谨慎的使用这些药，悲剧的是，没到达最少打败该人所用的属性药了他打人必输&gt;.&lt;所以他用2个药去打别人，别人却表明3个药才能打过，那么相当于你输了并且这两个属性药浪费了。 现在有n个好友，有输掉拿的经验、赢了拿的经验、要嗑几个药才能打过。求出最大经验（注意，最后要乘以5） 输入格式第一行两个数，n和x 后面n行每行三个数，分别表示输了拿到的经验(lose[i])、赢了拿到的经验(win[i])、打过要至少使用的药数量(use[i])。 输出格式一个整数，最多获得的经验 输入输出样例输入 #1复制 12345676 821 52 121 70 521 48 214 38 314 36 114 36 2 输出 #1复制 11060 说明/提示【Hint】 五倍经验活动的时候，absi2011总是吃体力药水而不是这种属性药&gt;.&lt; 【数据范围】 对于10%的数据，保证x=0 对于30%的数据，保证n&lt;=10,x&lt;=20 对于60%的数据，保证n&lt;=100,x&lt;=100, 10&lt;=lose[i], win[i]&lt;=100,use[i]&lt;=5 对于100%的数据，保证n&lt;=1000,x&lt;=1000,0&lt;lose[i]&lt;=win[i]&lt;=1000000,0&lt;=use[i]&lt;=1000 【题目来源】 fight.pet.qq.com absi2011授权题目 算法12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;long long bag[1001]; int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,x; cin&gt;&gt;n&gt;&gt;x; _for(i,1,n) &#123; long long lose,win,cost; cin&gt;&gt;lose&gt;&gt;win&gt;&gt;cost; for(int j&#x3D;x;j&gt;&#x3D;cost;j--) bag[j]&#x3D;max(bag[j-cost]+win,bag[j]+lose); _for(j,0,cost-1) bag[j]+&#x3D;lose; &#125; cout&lt;&lt;bag[x]*5; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"高阶01背包","slug":"高阶01背包","permalink":"https://donghuangzhong.github.io/tags/%E9%AB%98%E9%98%B601%E8%83%8C%E5%8C%85/"}]},{"title":"洛谷_P1616 疯狂的采药","slug":"洛谷-P1616-疯狂的采药","date":"2020-04-02T10:06:29.000Z","updated":"2020-04-02T11:26:44.831Z","comments":true,"path":"2020/04/02/洛谷-P1616-疯狂的采药/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P1616-%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF/","excerpt":"无限物品的可不满背包","text":"无限物品的可不满背包 题目题目背景此题为NOIP2005普及组第三题的疯狂版。 此题为纪念LiYuxiang而生。 题目描述LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是LiYuxiang，你能完成这个任务吗？ 此题和原题的不同点： 1.每种草药可以无限制地疯狂采摘。 2.药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 输入格式输入第一行有两个整数T（1 &lt;= T &lt;= 100000）和M（1 &lt;= M &lt;= 10000），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到10000之间（包括1和10000）的整数，分别表示采摘某种草药的时间和这种草药的价值。 输出格式输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。 输入输出样例输入 #1复制 123470 371 10069 11 2 输出 #1复制 1140 说明/提示对于30%的数据，M &lt;= 1000； 对于全部的数据，M &lt;= 10000，且M*T&lt;10000000(别数了，7个0)。 加油LiYuxiang，第一个AC留给你！ 算法1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;long long bag[100001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int t,m; cin&gt;&gt;t&gt;&gt;m; _for(i,1,m) &#123; int herb_t,herb_v; cin&gt;&gt;herb_t&gt;&gt;herb_v; for(int j&#x3D;herb_t;j&lt;&#x3D;t;j++) &#123; if(bag[j-herb_t]+herb_v&gt;bag[j]) bag[j]&#x3D;bag[j-herb_t]+herb_v; &#125; &#125; cout&lt;&lt;bag[t]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"无限背包","slug":"无限背包","permalink":"https://donghuangzhong.github.io/tags/%E6%97%A0%E9%99%90%E8%83%8C%E5%8C%85/"}]},{"title":"洛谷_P1048 采药","slug":"洛谷-P1048-采药","date":"2020-04-02T07:21:21.000Z","updated":"2020-04-02T07:24:41.229Z","comments":true,"path":"2020/04/02/洛谷-P1048-采药/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P1048-%E9%87%87%E8%8D%AF/","excerpt":"简单可不装满的01背包，数组初始化全为0","text":"简单可不装满的01背包，数组初始化全为0 题目题目描述辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？ 输入格式第一行有 22 个整数 TT（1 \\le T \\le 10001≤T≤1000）和 MM（1 \\le M \\le 1001≤M≤100），用一个空格隔开，TT 代表总共能够用来采药的时间，MM 代表山洞里的草药的数目。 接下来的 MM 行每行包括两个在 11 到 100100 之间（包括 11 和 100100）的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出格式输出在规定的时间内可以采到的草药的最大总价值。 输入输出样例输入 #1复制 123470 371 10069 11 2 输出 #1复制 13 说明/提示 对于 30%30% 的数据，M \\le 10M≤10； 对于全部的数据，M \\le 100M≤100。 算法1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int bag[1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int t,m; cin&gt;&gt;t&gt;&gt;m; _for(i,1,m) &#123; int herb_t,herb_v; cin&gt;&gt;herb_t&gt;&gt;herb_v; for(int j&#x3D;t;j&gt;&#x3D;herb_t;j--) &#123; if(bag[j-herb_t]+herb_v&gt;bag[j]) bag[j]&#x3D;bag[j-herb_t]+herb_v; &#125; &#125; cout&lt;&lt;bag[t]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"01可不满背包","slug":"01可不满背包","permalink":"https://donghuangzhong.github.io/tags/01%E5%8F%AF%E4%B8%8D%E6%BB%A1%E8%83%8C%E5%8C%85/"}]},{"title":"洛谷_P4017 最大食物链计数","slug":"洛谷-P4017-最大食物链计数","date":"2020-04-02T05:50:09.000Z","updated":"2020-04-02T06:22:52.073Z","comments":true,"path":"2020/04/02/洛谷-P4017-最大食物链计数/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P4017-%E6%9C%80%E5%A4%A7%E9%A3%9F%E7%89%A9%E9%93%BE%E8%AE%A1%E6%95%B0/","excerpt":"本文用了三类方法，加上邻接表和vector的转换，一共写了五个方法，分别是优先队列，记忆dfs+vector，记忆dfs+邻接表，拓扑排序+二维数组，拓扑排序+邻接表","text":"本文用了三类方法，加上邻接表和vector的转换，一共写了五个方法，分别是优先队列，记忆dfs+vector，记忆dfs+邻接表，拓扑排序+二维数组，拓扑排序+邻接表 题目题目背景你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。 题目描述给你一个食物网，你要求出这个食物网中最大食物链的数量。 （这里的“最大食物链”，指的是生物学意义上的食物链，即最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者。） Delia 非常急，所以你只有 11 秒的时间。 由于这个结果可能过大，你只需要输出总数模上 8011200280112002 的结果。 输入格式第一行，两个正整数 n、mn、m，表示生物种类 nn 和吃与被吃的关系数 mm。 接下来 mm 行，每行两个正整数，表示被吃的生物A和吃A的生物B。 输出格式一行一个整数，为最大食物链数量模上 8011200280112002 的结果。 输入输出样例输入 #1复制 123456785 71 21 32 33 52 54 53 4 输出 #1复制 15 说明/提示各测试点满足以下约定： 【补充说明】 数据中不会出现环，满足生物学的要求。（感谢 @AKEE ） 算法优先队列这是我第一个想到的方法，因为这个题目的分类在DP中，想到把边用优先队列按照起点从小到大排序，这样就能满足这样一个转移方程 1sum[a.e]+&#x3D;(v[a.s]&#x3D;&#x3D;0)?1:sum[a.s]; 其中，v[i]=0表示纯起点，因为把边按照起点排序了，所以当前边终点的出度一定为0，起点又分为两种情况，一个是没有入度的(纯起点)，如果这样，sum[终点]应该加1。如果起点是既有入度又有出度的，sum[终点]+=sum[起点]。这个过程中还要改变点的状态，例如1-&gt;2,2标记为终点，然后1-&gt;3,3标记为终点，然后2-&gt;3,2标记为中转点，这样统计所有终点的sum值就可以得到结果。但是现实是残酷的，有500000个边，我估计队列都满了，并且时间效率也不好，失败的算法 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int sum[5001];int v[5001];&#x2F;&#x2F;0新起点，1终点，-1中转点 struct edge&#123; int s,e;&#125;;struct cmp&#123; bool operator()(edge a,edge b) &#123; return a.s&gt;b.s; &#125;&#125;;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,m; priority_queue&lt;edge ,vector&lt;edge&gt;, cmp&gt; q; cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; q.push(&#123;s,e&#125;); &#125; while(!q.empty()) &#123; edge a&#x3D;q.top(); q.pop();&#x2F;&#x2F; sum[a.e]&#x3D;(v[a.s]&#x3D;&#x3D;0)?(sum[a.e]+1):sum[a.s]; if(v[a.s]&#x3D;&#x3D;0) &#123; sum[a.e]++; &#125; else &#123; sum[a.e]+&#x3D;sum[a.s]; if(v[a.s]&#x3D;&#x3D;1) v[a.s]&#x3D;-1; &#125; v[a.e]&#x3D;1; &#125; int ans&#x3D;0; _for(i,1,n) &#123; if(v[i]&#x3D;&#x3D;1) ans+&#x3D;sum[i]; &#125; cout&lt;&lt;ans; return 0;&#125; 记忆dfs如果我们能知道以终点上一个点为终点的食物链数，那么终点的食物链数就是这些点食物链数的和。例如，知道5是其中一个终点，并且已知只有2-&gt;5,4-&gt;5，那么以5位终点的食物链数等于以2为终点的食物链数+以4为终点的食物链数。怎么知道以5为终点的边的起点呢？需要邻接表或者vector，怎么知道5是不是终点呢？需要一个数组标记一下和邻接表或者vector联合判断 记忆dfs+邻接表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct Edge&#123; int start,next;&#125; edge[5000005];int pre[5005];int num[5005];bool des[5005];int dfs(int e)&#123; if(!pre[e]) return 1; if(num[e]) return num[e]; int summ&#x3D;0; for(int i&#x3D;pre[e];i;i&#x3D;edge[i].next) &#123; summ+&#x3D;dfs(edge[i].start); summ%&#x3D;80112002; &#125; return num[e]&#x3D;summ;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,m; cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; edge[i].start&#x3D;s; edge[i].next&#x3D;pre[e]; pre[e]&#x3D;i; des[s]&#x3D;1; &#125; int ans&#x3D;0; _for(i,1,n) &#123; if(!des[i]&amp;&amp;pre[i]) &#123; ans+&#x3D;dfs(i); ans%&#x3D;80112002; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; 记忆dfs+vector12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int num[5005];bool des[5005];vector&lt;int&gt; v[5005];int dfs(int e)&#123; if(!v[e].size()) return 1; if(num[e]) return num[e]; int summ&#x3D;0; for(int i&#x3D;0;i&lt;v[e].size();i++) &#123; summ+&#x3D;dfs(v[e][i]); summ%&#x3D;80112002; &#125; return num[e]&#x3D;summ;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,m; cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; v[e].push_back(s); des[s]&#x3D;1; &#125; int ans&#x3D;0; _for(i,1,n) &#123; if(!des[i]&amp;&amp;v[i].size()) &#123; ans+&#x3D;dfs(i); ans%&#x3D;80112002; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; 拓扑排序每次取入度为0的点，也就是起点，然后把这个这个起点能到达的终点+当前食物链数目，再找入度为0的点，继续。直到只剩下终点统计一下就可以，这个需要已知起点找终点，可以用二维数组或者邻接表或者vector 拓扑+二维数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m;int map[5005][5005];int in[5005],out[5005];int sum[5005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; map[s][e]&#x3D;1; out[s]++; in[e]++; &#125; queue&lt;int&gt; q; _for(i,1,n) &#123; if(!in[i]) &#123; sum[i]&#x3D;1; q.push(i); &#125; &#125; int summ&#x3D;0; while(!q.empty()) &#123; int s&#x3D;q.front(); q.pop(); _for(i,1,n) &#123; if(map[s][i]) &#123; sum[i]+&#x3D;sum[s]; sum[i]%&#x3D;80112002; in[i]--; if(!in[i]) &#123; if(!out[i]) &#123; summ+&#x3D;sum[i]; summ%&#x3D;80112002; continue; &#125; q.push(i); &#125; &#125; &#125; &#125; cout&lt;&lt;summ; return 0;&#125; 拓扑+邻接表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct Edge&#123; int end,next;&#125; edge[5000005];int n,m;int pre[5005];int in[5005],out[5005];int sum[5005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; edge[i].end&#x3D;e; edge[i].next&#x3D;pre[s]; pre[s]&#x3D;i; out[s]++; in[e]++; &#125; queue&lt;int&gt; q; _for(i,1,n) &#123; if(!in[i]) &#123; sum[i]&#x3D;1; q.push(i); &#125; &#125; int summ&#x3D;0; while(!q.empty()) &#123; int s&#x3D;q.front(); q.pop(); for(int i&#x3D;pre[s];i;i&#x3D;edge[i].next) &#123; sum[edge[i].end]+&#x3D;sum[s]; sum[edge[i].end]%&#x3D;80112002; in[edge[i].end]--; if(!in[edge[i].end]) &#123; if(!out[edge[i].end]) &#123; summ+&#x3D;sum[edge[i].end]; summ%&#x3D;80112002; continue; &#125; q.push(edge[i].end); &#125; &#125; &#125; cout&lt;&lt;summ; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"食物链","slug":"食物链","permalink":"https://donghuangzhong.github.io/tags/%E9%A3%9F%E7%89%A9%E9%93%BE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://donghuangzhong.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"记忆化递归","slug":"记忆化递归","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92/"},{"name":"邻接表","slug":"邻接表","permalink":"https://donghuangzhong.github.io/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"},{"name":"优先队列","slug":"优先队列","permalink":"https://donghuangzhong.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"vector","slug":"vector","permalink":"https://donghuangzhong.github.io/tags/vector/"}]},{"title":"洛谷_P2196 挖地雷","slug":"洛谷-P2196-挖地雷","date":"2020-04-02T01:30:59.000Z","updated":"2020-04-02T01:36:37.696Z","comments":true,"path":"2020/04/02/洛谷-P2196-挖地雷/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P2196-%E6%8C%96%E5%9C%B0%E9%9B%B7/","excerpt":"摘要","text":"摘要 题目题目描述在一个地图上有NN个地窖(N \\le 20)(N≤20)，每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。当地窖及其连接的数据给出之后，某人可以从任一处开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。 输入格式有若干行。 第11行只有一个数字，表示地窖的个数NN。 第22行有NN个数，分别表示每个地窖中的地雷个数。 第33行至第N+1N+1行表示地窖之间的连接情况： 第33行有n-1n−1个数（00或11），表示第一个地窖至第22个、第33个、…、第nn个地窖有否路径连接。如第33行为1 1 0 0 0 … 011000…0，则表示第11个地窖至第22个地窖有路径，至第33个地窖有路径，至第44个地窖、第55个、…、第nn个地窖没有路径。 第44行有n-2n−2个数，表示第二个地窖至第33个、第44个、…、第nn个地窖有否路径连接。 … … 第n+1n+1行有11个数，表示第n-1n−1个地窖至第nn个地窖有否路径连接。（为00表示没有路径，为11表示有路径）。 输出格式有两行 第一行表示挖得最多地雷时的挖地雷的顺序，各地窖序号间以一个空格分隔，不得有多余的空格。 第二行只有一个数，表示能挖到的最多地雷数。 输入输出样例输入 #1复制 123456510 8 4 7 61 1 1 00 0 01 11 输出 #1复制 121 3 4 52 算法如果我们知道i点可以到达j点，并且知道到达i点时的最大值sum[i],那么我们就可以计算经过i点到达j点的最大值，与当前j点的最大值sum[j]做比较，取较大者。转移方程为 1sum[j]&#x3D;max(sum[i]+mines[j],sum[j]) 可行性分析：sum[i]必须是最优解，稍微分析一下能证明可行 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int mines[21]; int sum[21];int path[21];void print_path(int x)&#123; if(x&#x3D;&#x3D;0) return ; print_path(path[x]); cout&lt;&lt;x&lt;&lt;&quot; &quot;;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) &#123; cin&gt;&gt;mines[i]; sum[i]&#x3D;mines[i]; &#125; int ans&#x3D;-1; int index; _for(i,1,n-1) &#123; _for(j,i+1,n) &#123; bool connect; if(cin&gt;&gt;connect&amp;&amp;connect&amp;&amp;sum[i]+mines[j]&gt;sum[j]) &#123; sum[j]&#x3D;sum[i]+mines[j]; path[j]&#x3D;i; &#125; &#125; if(sum[i]&gt;ans) &#123; ans&#x3D;sum[i]; index&#x3D;i; &#125; &#125; if(sum[n]&gt;ans) &#123; ans&#x3D;sum[n]; index&#x3D;n; &#125; print_path(index); cout&lt;&lt;endl&lt;&lt;ans; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"正向DP","slug":"正向DP","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E5%90%91DP/"}]},{"title":"洛谷_P1434_[SHOI2002]滑雪","slug":"洛谷-P1434-SHOI2002-滑雪","date":"2020-04-01T23:45:26.000Z","updated":"2020-04-01T23:49:53.647Z","comments":true,"path":"2020/04/02/洛谷-P1434-SHOI2002-滑雪/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P1434-SHOI2002-%E6%BB%91%E9%9B%AA/","excerpt":"摘要","text":"摘要 题目题目描述Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子： 123451 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 2424－1717－1616－11（从 2424 开始，在 11 结束）。当然 2525－2424－2323－\\ldots…－33－22－11 更长。事实上，这是最长的一条。 输入格式输入的第一行为表示区域的二维数组的行数 RR 和列数 CC。下面是 RR 行，每行有 CC 个数，代表高度(两个数字之间用 11 个空格间隔)。 输出格式输出区域中最长滑坡的长度。 输入输出样例输入 #1复制 1234565 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 输出 #1复制 125 说明/提示对于 100%100% 的数据，1\\leq R,C\\leq 1001≤R,C≤100。 算法记忆化递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int map[101][101];int mem[101][101];int r,c;int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;int dfs(int x,int y)&#123; if(mem[x][y]) return mem[x][y]; int maxx&#x3D;0; _for(i,0,3) &#123; int xx&#x3D;x+dir[i][0]; int yy&#x3D;y+dir[i][1]; if(xx&gt;&#x3D;0&amp;&amp;xx&lt;r&amp;&amp;yy&gt;&#x3D;0&amp;&amp;yy&lt;c&amp;&amp;map[xx][yy]&lt;map[x][y]) &#123; maxx&#x3D;max(maxx,dfs(xx,yy)); &#125; &#125; return mem[x][y]&#x3D;maxx+1;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;r&gt;&gt;c; _for(i,0,r-1) _for(j,0,c-1) cin&gt;&gt;map[i][j]; int ans&#x3D;-1; _for(i,0,r-1) _for(j,0,c-1) ans&#x3D;max(ans,dfs(i,j)); cout&lt;&lt;ans; return 0;&#125; 优先队列DP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct node&#123; int x,y,num;&#125;;struct cmp&#123; bool operator()(node a,node b) &#123; return a.num&gt;b.num; &#125;&#125;;int r,c,map[101][101],step[101][101];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;r&gt;&gt;c; priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; q; _for(i,1,r) _for(j,1,c) &#123; step[i][j]&#x3D;1; cin&gt;&gt;map[i][j]; q.push(&#123;i,j,map[i][j]&#125;); &#125; int ans&#x3D;0; while(!q.empty()) &#123; node t&#x3D;q.top(); q.pop(); if(t.num&gt;map[t.x+1][t.y]) step[t.x][t.y]&#x3D;max(step[t.x][t.y],step[t.x+1][t.y]+1); if(t.num&gt;map[t.x-1][t.y]) step[t.x][t.y]&#x3D;max(step[t.x][t.y],step[t.x-1][t.y]+1); if(t.num&gt;map[t.x][t.y+1]) step[t.x][t.y]&#x3D;max(step[t.x][t.y],step[t.x][t.y+1]+1); if(t.num&gt;map[t.x][t.y-1]) step[t.x][t.y]&#x3D;max(step[t.x][t.y],step[t.x][t.y-1]+1); ans&#x3D;max(ans,step[t.x][t.y]); &#125; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"洛谷_P1216_数字三角形","slug":"洛谷-P1216-数字三角形","date":"2020-04-01T09:40:22.000Z","updated":"2020-04-01T10:08:26.881Z","comments":true,"path":"2020/04/01/洛谷-P1216-数字三角形/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/01/%E6%B4%9B%E8%B0%B7-P1216-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2/","excerpt":"摘要","text":"摘要 题目题目描述观察下面的数字金字塔。 写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。 12345 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 在上面的样例中,从 7 \\to 3 \\to 8 \\to 7 \\to 57→3→8→7→5 的路径产生了最大 输入格式第一个行一个正整数 rr ,表示行的数目。 后面每行为这个数字金字塔特定行包含的整数。 输出格式单独的一行,包含那个可能得到的最大的和。 输入输出样例输入 #1复制 123456573 88 1 02 7 4 44 5 2 6 5 输出 #1复制 130 说明/提示【数据范围】对于 100%100% 的数据，1\\le r \\le 10001≤r≤1000，所有输入在 [0,100][0,100] 范围内。 算法正向:计算起点到每个点的最大值从上向下走，找正向的来源，注意不能影响下一个点的来源 轴对称翻转代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int num[1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,number; cin&gt;&gt;n; _for(i,1,n) for(int j&#x3D;i;j&gt;&#x3D;1;j--) cin&gt;&gt;number,num[j]&#x3D;max(num[j],num[j-1])+number; int ans&#x3D;num[1]; _for(i,2,n) ans&#x3D;max(ans,num[i]); cout&lt;&lt;ans; return 0;&#125; 右对齐代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int num[1002];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,number; cin&gt;&gt;n; _for(i,1,n) for(int j&#x3D;n-i+1;j&lt;&#x3D;n;j++) cin&gt;&gt;number,num[j]&#x3D;max(num[j],num[j+1])+number; int ans&#x3D;num[1]; _for(i,2,n) ans&#x3D;max(ans,num[i]); cout&lt;&lt;ans; return 0;&#125; 反向：计算终点到每一个起点的最大值代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int map[1001][1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,0,n-1) _for(j,0,i) cin&gt;&gt;map[i][j]; for(int i&#x3D;n-2;i&gt;&#x3D;0;i--) for(int j&#x3D;0;j&lt;&#x3D;i;j++) map[i][j]+&#x3D;max(map[i+1][j],map[i+1][j+1]); cout&lt;&lt;map[0][0]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"数塔","slug":"数塔","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E5%A1%94/"},{"name":"正反向思考","slug":"正反向思考","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E5%8F%8D%E5%90%91%E6%80%9D%E8%80%83/"}]},{"title":"HDU_1024_Max Sum Plus Plus","slug":"HDU-1024-Max-Sum-Plus-Plus","date":"2020-04-01T07:04:24.000Z","updated":"2020-04-01T07:51:43.084Z","comments":true,"path":"2020/04/01/HDU-1024-Max-Sum-Plus-Plus/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/01/HDU-1024-Max-Sum-Plus-Plus/","excerpt":"DP最重要的是找状态转移方程，也就是怎么通过已有的状态求未知的状态","text":"DP最重要的是找状态转移方程，也就是怎么通过已有的状态求未知的状态 题目Max Sum Plus Plus\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 48103 Accepted Submission(s): 17534** Problem DescriptionNow I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem. Given a consecutive number sequence S1, S2, S3, S4 … Sx, … Sn (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ Sx ≤ 32767). We define a function sum(i, j) = Si + … + Sj (1 ≤ i ≤ j ≤ n). Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i1, j1) + sum(i2, j2) + sum(i3, j3) + … + sum(im, jm) maximal (ix ≤ iy ≤ jx or ix ≤ jy ≤ jx is not allowed). But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(ix, jx)(1 ≤ x ≤ m) instead. ^_^ InputEach test case will begin with two integers m and n, followed by n integers S1, S2, S3 … Sn.Process to the end of file. OutputOutput the maximal summation described above in one line. Sample Input121 3 1 2 32 6 -1 4 -2 3 -2 3 Sample Output1268 题目大意输入m,n,然后输入n个数。求在这n个数中，分为m个区间，区间互不重叠，对每个区间求和得到sum1~m，再对这m个sum求和，求这个和的最大值 算法先从未优化的版本开始，max_sum[i][j]表示的是将[0,j]区间分为i个互不重叠子区间得到的最优解，那么状态转移方程就可以表示为 1max_sum[i][j]&#x3D;max(max_sum[i][j-1],max_sum[i-1][k]) k属于[i-1,j-1] 然后就可以发现，求解的时候只涉及max_sum数组的两行，第i行和第i-1行，因此可以用一个两行的滚动的数组表示DP数组。也就是用其中一行计算另一行，当另一行计算好了之后，转换角色。即 1max_sum[t][j]&#x3D;max(max_sum[t][j-1],max_sum[1-t][k]) k属于[i-1,j-1] 然后就会发现，时间复杂度太高，主要是max_sum[1-t][k]耗时，于是将后面的max_sum[1-t][k]用单独一个数组max_pre[j-1]代替，并且这样做也可以舍弃max_sum的第一维了。于是就简化转移方程为 1max_sum[j]&#x3D;max(max_sum[j-1],max_pre[j-1])+num[j]; 其中max_sum[j]表示的是[0,j]区间分为i个互不重叠小区间的最优解；max_pre[j-1]表示的是终点在[i,j-1]，并且分为i-1个区间的和的最大值，其实就是刚开始的max_sum[i-1][k] k属于[i-1,j-1]的最大值，即 1max(max_sum[i-1][i-1],max_sum[i-1][i],max_sum[i-1][i+1],…………,max_sum[i-1][j-1]) 舍弃掉第一维，可以用循环次数决定max_sum数组表示的是分为几个小区间的状态，比如循环一次就表示分为1个小区间的各种状态，循环m次就表示循环m次的状态，并且当每次循环的时候需要更新max_pre，当第i次循环的时候计算max_sum[j]的时候，需要用到max_pre[j-1]，并且在第i次循环中只使用这一次，以后就用不到了，并且此时的max_pre需要更新的值已经出来了，就是max_sum[x] x属于[0,j-1]的最大值，所以我们只需要维护一个max_summ表示第i次max_sum[x] x属于[0,j-1]的最大值就能够实现这两个数组的同步更新。、 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)#define MAX 0x3f3f3f3fusing namespace std;int num[1000001];int max_sum[1000001];int max_pre[1000001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int m,n,max_summ; while(cin&gt;&gt;m&gt;&gt;n) &#123; memset(max_sum,0,sizeof(max_sum)); memset(max_pre,0,sizeof(max_pre)); _for(i,1,n) cin&gt;&gt;num[i]; _for(i,1,m) &#123; max_summ&#x3D;-MAX; _for(j,i,n) &#123; max_sum[j]&#x3D;max(max_sum[j-1],max_pre[j-1])+num[j]; max_pre[j-1]&#x3D;max_summ; if(max_sum[j]&gt;max_summ) max_summ&#x3D;max_sum[j]; &#125; &#125; cout&lt;&lt;max_summ&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"转移方程的构造","slug":"转移方程的构造","permalink":"https://donghuangzhong.github.io/tags/%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E7%9A%84%E6%9E%84%E9%80%A0/"},{"name":"极度优化","slug":"极度优化","permalink":"https://donghuangzhong.github.io/tags/%E6%9E%81%E5%BA%A6%E4%BC%98%E5%8C%96/"}]},{"title":"算法提高 秘密行动","slug":"算法提高-秘密行动","date":"2020-04-01T01:21:03.000Z","updated":"2020-04-01T01:58:28.976Z","comments":true,"path":"2020/04/01/算法提高-秘密行动/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/01/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98-%E7%A7%98%E5%AF%86%E8%A1%8C%E5%8A%A8/","excerpt":"双数组DP","text":"双数组DP 题目算法提高 秘密行动提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 小D接到一项任务，要求他爬到一座n层大厦的顶端与神秘人物会面。这座大厦有一个神奇的特点，每层的高度都不一样，同时，小D也拥有一项特殊能力，可以一次向上跳跃一层或两层，但是这项能力无法连续使用。已知向上1高度消耗的时间为1，跳跃不消耗时间。由于事态紧急，小D想知道他最少需要多少时间到达顶层。 输入格式 第一行包含一个整数n，代表楼的高度。 接下来n行每行一个整数ai，代表i层的楼层高度（ai &lt;= 100）。 输出格式 输出1行，包含一个整数，表示所需的最短时间。 样例输入535184 样例输出1 数据规模和约定 对20%的数据,n&lt;=10 对40%的数据,n&lt;=100 对60%的数据,n&lt;=5000 对100%的数据,n&lt;=10000 算法通用做法(三个数组)三个数组，height[i]表示第i层楼的高度，climb[i]表示爬上第i层楼的最短时间，jump[i]表示跳到第i层楼的时间。显然，如果是爬到第i层楼，那它的起点只能是从第i-1层楼，所以如果知道到i-1层的最短时间就能知道爬到第i层楼的最短时间，到第i-1层楼的方式可能是爬，也可能是跳跃。所以就有了爬楼的转移方程 1climb[i]&#x3D;min(climb[i-1],jump[i-1])+height[i] 同理，跳跃的上一步只能是爬，因为题目说了不能连续跳跃，但是跳跃的起点有两个，所以转移方程为 1jump[i]&#x3D;min(climb[i-1],climb[i-2]) 所以i要从2开始，同时要初始化好climb[0],climb[1]和jump[1] 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int jump[10001];int climb[10001];int height[10001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) cin&gt;&gt;height[i]; climb[0]&#x3D;jump[0]&#x3D;0; climb[1]&#x3D;height[1]; _for(i,2,n) &#123; climb[i]&#x3D;min(climb[i-1],jump[i-1])+height[i]; jump[i]&#x3D;min(climb[i-1],climb[i-2]); &#125; cout&lt;&lt;min(climb[n],jump[n]); return 0;&#125; 两个数组的做法观察转移方程，hight[i]可以直接输入，不用保存。也就是说输入第i层楼的高度的时候，climb[i]和jump[i]已经可以算出来了 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int jump[10001];int climb[10001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; climb[0]&#x3D;jump[0]&#x3D;0; cin&gt;&gt;climb[1]; _for(i,2,n) &#123; int height; cin&gt;&gt;height; climb[i]&#x3D;min(climb[i-1],jump[i-1])+height; jump[i]&#x3D;min(climb[i-1],climb[i-2]); &#125; cout&lt;&lt;min(climb[n],jump[n]); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"多数组DP","slug":"多数组DP","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%9A%E6%95%B0%E7%BB%84DP/"}]},{"title":"HDU-1114_Piggy-Bank","slug":"HDU-1114-Piggy-Bank","date":"2020-04-01T01:01:31.000Z","updated":"2020-04-01T01:07:13.004Z","comments":true,"path":"2020/04/01/HDU-1114-Piggy-Bank/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/01/HDU-1114-Piggy-Bank/","excerpt":"简单背包","text":"简单背包 题目Piggy-Bank\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 46180 Accepted Submission(s): 22736** Problem DescriptionBefore ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid. But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs! InputThe input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams. OutputPrint exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”. Sample Input12345678910111213310 11021 130 5010 11021 150 301 6210 320 4 Sample Output123The minimum amount of money in the piggy-bank is 60.The minimum amount of money in the piggy-bank is 100.This is impossible. 题目大意输入空的存钱罐的重量和装满钱的存钱罐的重量，然后再输入硬币的面值和重量，要求输出这个存钱罐恰好能够装的最小金钱的值 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int dp[10001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int t; cin&gt;&gt;t; while(t--) &#123; memset(dp,0x3f,sizeof(dp)); dp[0]&#x3D;0; int empty_w,full_w; cin&gt;&gt;empty_w&gt;&gt;full_w; int w&#x3D;full_w-empty_w; int coin_n; cin&gt;&gt;coin_n; while(coin_n--) &#123; int v,coin_w; cin&gt;&gt;v&gt;&gt;coin_w; for(int i&#x3D;coin_w;i&lt;&#x3D;w;i++) &#123; if(dp[i]&gt;dp[i-coin_w]+v) dp[i]&#x3D;dp[i-coin_w]+v; &#125; &#125; if(dp[w]&#x3D;&#x3D;0x3f3f3f3f) &#123; cout&lt;&lt;&quot;This is impossible.&quot;&lt;&lt;endl; continue; &#125; cout&lt;&lt;&quot;The minimum amount of money in the piggy-bank is &quot;&lt;&lt;dp[w]&lt;&lt;&quot;.&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"},{"name":"背包","slug":"背包","permalink":"https://donghuangzhong.github.io/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"算法训练 小生物的逃逸","slug":"算法训练-小生物的逃逸","date":"2020-03-31T09:09:29.000Z","updated":"2020-03-31T09:11:59.153Z","comments":true,"path":"2020/03/31/算法训练-小生物的逃逸/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/31/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%B0%8F%E7%94%9F%E7%89%A9%E7%9A%84%E9%80%83%E9%80%B8/","excerpt":"水","text":"水 题目算法训练 小生物的逃逸提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 空间中有n个球，这些球不相交也不相切。有m个可以视为质点的小生物，可能在某些球内，也可能在所有球之外，但不会在球面上。问这些生物从原来的地方逃逸到所有球外面的空间，至少要经过多少层球面。 输入格式 第一行两个数n、m：表示球的数量和小生物的数量； 接下来n行每行四个整数Xi、Yi、Zi和Ri：表示一个球的三维坐标和半径； 接下来m行每行三个整数Xi、Yi、Zi：表示一个生物的坐标。 输出格式 一行m个数：表示每个小生物逃逸时至少经过的球面数。 样例输入2 20 0 0 20 0 0 40 0 10 0 3 样例输出2 1 算法12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m;struct aa&#123; int x,y,z,r;&#125;;aa a[101];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input10.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m; _for(i,0,n-1) cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].z&gt;&gt;a[i].r; _for(i,1,m) &#123; int sum&#x3D;0; long long x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; _for(j,0,n-1) if((x-a[j].x)*(x-a[j].x)+(y-a[j].y)*(y-a[j].y)+(z-a[j].z)*(z-a[j].z)&lt;a[j].r*a[j].r) sum++; cout&lt;&lt;sum&lt;&lt;&quot; &quot;; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[]},{"title":"算法训练 相邻字母","slug":"算法训练-相邻字母","date":"2020-03-31T00:22:47.000Z","updated":"2020-03-31T00:24:38.853Z","comments":true,"path":"2020/03/31/算法训练-相邻字母/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/31/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E7%9B%B8%E9%82%BB%E5%AD%97%E6%AF%8D/","excerpt":"简单水题","text":"简单水题 题目算法训练 相邻字母提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 【问题描述】 从键盘输入一个英文字母，要求按字母的顺序打印出3个相邻的字母，指定的字母在中间。若指定的字母为Z，则打印YZA，若为A则打印ZAB。注意：需要区分大小写。 【输入格式】 一行，仅包含一个英文字母。 【输出格式】 一行，包含三个字母。 【样例输入**1****】 a 【样例输出**1****】 zab 【样例输入**2****】 B 【样例输出**2****】 ABC 算法12345678910111213141516171819202122#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int main()&#123; char c; cin&gt;&gt;c; if(c&#x3D;&#x3D;&#39;a&#39;||c&#x3D;&#x3D;&#39;A&#39;) printf(&quot;%c&quot;,c+25); else printf(&quot;%c&quot;,c-1); cout&lt;&lt;c; if(c&#x3D;&#x3D;&#39;z&#39;||c&#x3D;&#x3D;&#39;Z&#39;) printf(&quot;%c&quot;,c-25); else printf(&quot;%c&quot;,c+1); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"},{"name":"字母","slug":"字母","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E6%AF%8D/"}]},{"title":"算法训练 奇变的字符串","slug":"算法训练-奇变的字符串","date":"2020-03-31T00:06:56.000Z","updated":"2020-03-31T00:08:43.521Z","comments":true,"path":"2020/03/31/算法训练-奇变的字符串/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/31/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%A5%87%E5%8F%98%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"摘要","text":"摘要 题目算法训练 奇变的字符串提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 将一个字符串的奇数位（首位为第0位）取出，将其顺序弄反，再放回原字符串的原位置上。 如字符串”abcdefg”，奇数位为”bdf”，顺序弄反后为”fdb”，最后得到字符串”afcdebg”。 输入格式 输入共一行，为一个字符串，字符串中无空格。 输出格式 输出共一行，为一个字符串，即最后得到的字符串。 样例输入abcdefg 样例输出afcdebg 数据规模和约定 字符串长度不超过255. 算法1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); string a; cin&gt;&gt;a; int l&#x3D;0,r&#x3D;a.length()-1; while(r&gt;l) &#123; if((l&amp;1)&#x3D;&#x3D;0) l++; if((r&amp;1)&#x3D;&#x3D;0) r--; swap(a[l],a[r]); l+&#x3D;2; r-&#x3D;2; &#125; cout&lt;&lt;a; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"字符串","slug":"ACM/字符串","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"算法训练 自行车停放","slug":"算法训练-自行车停放","date":"2020-03-30T11:00:24.000Z","updated":"2020-03-30T11:11:58.852Z","comments":true,"path":"2020/03/30/算法训练-自行车停放/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E8%87%AA%E8%A1%8C%E8%BD%A6%E5%81%9C%E6%94%BE/","excerpt":"看数据规模，10的5次方，用数组的话大于是(n(n+1)/2)n^2级别的，实测12秒。只能转向双向链表！","text":"看数据规模，10的5次方，用数组的话大于是(n(n+1)/2)n^2级别的，实测12秒。只能转向双向链表！ 题目算法训练 自行车停放提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 有n辆自行车依次来到停车棚，除了第一辆自行车外，每辆自行车都会恰好停放在已经在停车棚里的某辆自行车的左边或右边。(e.g.停车棚里已经有3辆自行车，从左到右编号为：3,5,1。现在编号为2的第4辆自行车要停在5号自行车的左边，所以现在停车棚里的自行车编号是：3,2,5,1)。给定n辆自行车的停放情况，按顺序输出最后停车棚里的自行车编号。 输入格式 第一行一个整数n。 第二行一个整数x。表示第一辆自行车的编号。 以下n-1行，每行3个整数x,y,z。 z=0时，表示编号为x的自行车恰停放在编号为y的自行车的左边 z=1时，表示编号为x的自行车恰停放在编号为y的自行车的右边 输出格式 从左到右输出停车棚里的自行车编号 样例输入431 3 12 1 05 2 1 样例输出3 2 5 1 数据规模和约定 n&lt;=100000 自行车编号为不超过100000的正整数。 算法数组版(12秒)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int a[100001],b[100001];void insert(int n,int num,int sum)&#123; &#x2F;&#x2F;memcpy(a+n+1,a+n,4*(sum-n)); for(int i&#x3D;sum-1;i&gt;&#x3D;n;i--) &#123; a[i+1]&#x3D;a[i]; b[a[i]]++; &#125; a[n]&#x3D;num; b[num]&#x3D;n;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int n; int cc&#x3D;clock(); cin&gt;&gt;n&gt;&gt;a[0]; b[a[0]]&#x3D;0; int now_sum&#x3D;1; int t&#x3D;n-1; while(t--) &#123; int x,y,z,i; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; i&#x3D;b[y]; int index_move&#x3D;z?i+1:i; insert(index_move,x,now_sum++); &#125; _for(i,0,now_sum-1) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; PP(&quot;time&#x3D;&quot;,clock()-cc); return 0;&#125; 双向链表版用的是带头结点和尾结点的双向链表，单纯是为了方便插入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct L&#123; L * pre; int n; L *next;&#125;;L* d[100001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); L *head&#x3D;(L *)malloc(sizeof(L)); L *t1&#x3D;(L *)malloc(sizeof(L)); L * wei&#x3D;(L *)malloc(sizeof(L)); head-&gt;next&#x3D;t1; t1-&gt;pre&#x3D;head; t1-&gt;next&#x3D;wei; wei-&gt;pre&#x3D;t1; wei-&gt;next&#x3D;NULL; int n; cin&gt;&gt;n&gt;&gt;t1-&gt;n; d[t1-&gt;n]&#x3D;t1; int t&#x3D;n-1; while(t--) &#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; L* node&#x3D;(L *)malloc(sizeof(L)); node-&gt;n&#x3D;x; d[x]&#x3D;node; L* temp&#x3D;d[y]; if(z) &#123; node-&gt;pre&#x3D;temp; node-&gt;next&#x3D;temp-&gt;next; temp-&gt;next-&gt;pre&#x3D;node; temp-&gt;next&#x3D;node; &#125; else &#123; node-&gt;next&#x3D;temp; node-&gt;pre&#x3D;temp-&gt;pre; temp-&gt;pre-&gt;next&#x3D;node; temp-&gt;pre&#x3D;node; &#125; &#125; t1&#x3D;head-&gt;next; while(t1-&gt;next!&#x3D;NULL) &#123; cout&lt;&lt;t1-&gt;n&lt;&lt;&quot; &quot;; t1&#x3D;t1-&gt;next; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"双向链表","slug":"ACM/双向链表","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"双向链表","slug":"双向链表","permalink":"https://donghuangzhong.github.io/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"索引表","slug":"索引表","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A2%E5%BC%95%E8%A1%A8/"}]},{"title":"算法训练 数组逆序排列","slug":"算法训练-数组逆序排列","date":"2020-03-30T09:18:16.000Z","updated":"2020-03-30T09:19:37.871Z","comments":true,"path":"2020/03/30/算法训练-数组逆序排列/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E6%95%B0%E7%BB%84%E9%80%86%E5%BA%8F%E6%8E%92%E5%88%97/","excerpt":"摘要","text":"摘要 题目算法训练 数组逆序排列提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 编写一个程序，读入一组整数（不超过20个），并把它们保存在一个整型数组中。当用户输入0时，表示输入结束。然后程序将把这个数组中的值按逆序重新存放，并打印出来。要求：(1)只能定义一个数组；(2)在交换两个数组元素的值时，必须使用单独定义的一个函数swap。例如：假设用户输入了一组数据：7 19 -5 6 2 0，那么程序将会把前五个有效数据保存在一个数组中，即7 19 -5 6 2，然后把这个数组中的值按逆序重新存放，即变成了2 6 -5 19 7，然后把它们打印出来。 输入格式：输入只有一行，包括若干个整数，最后一个整数是0。 输出格式：输出只有一行，包括若干个整数，即逆序排列后的结果。 输入输出样例样例输入7 19 -5 6 2 0 样例输出2 6 -5 19 7 算法123456789101112131415161718192021222324#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int a[21]; int index&#x3D;1; while(cin&gt;&gt;a[index++]&amp;&amp;a[index-1]); index-&#x3D;2; _for(i,1,index&#x2F;2) swap(a[i],a[index+1-i]); _for(i,1,index) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"整除2","slug":"整除2","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B4%E9%99%A42/"}]},{"title":"算法训练 字符串比较","slug":"算法训练-字符串比较","date":"2020-03-30T08:50:22.000Z","updated":"2020-03-30T09:07:55.217Z","comments":true,"path":"2020/03/30/算法训练-字符串比较/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/","excerpt":"我也不知道怎么错的，测试用例都对了，但就是通不过！最后附上官方的代码！！","text":"我也不知道怎么错的，测试用例都对了，但就是通不过！最后附上官方的代码！！ 题目算法训练 字符串比较提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 strncmp函数的原型为：int strncmp(char *s, char *t, int n);，其功能是比较字符串s和t的前n个字符。如果s&lt;t，返回-1；如果s=t，返回0；如果s&gt;t，返回1。请自己编程实现该函数，并编写一个程序来测试其正确性。 输入格式：输入有三行，第一行为字符串s，第二行为字符串t，第三行为整数n。 输出格式：输出只有一个整数，即比较结果。 输入输出样例样例输入worldword4 样例输出1 代码测试用例在win10 下都能通过，但在蓝桥就是错误 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int cmp(string a,string b,int n)&#123; for(int i&#x3D;0;i&lt;&#x3D;n-1;i++) &#123; if(i&#x3D;&#x3D;a.length()||i&#x3D;&#x3D;b.length()) &#123; if(i!&#x3D;a.length()) return -1; else if(i!&#x3D;b.length()) return 1; else return 0; &#125; if(a[i]&gt;b[i]) return 1; if(a[i]&lt;b[i]) return -1; &#125; &#125;int main()&#123;&#x2F;&#x2F; ios::sync_with_stdio(0);&#x2F;&#x2F; cin.tie(0);&#x2F;&#x2F; cout.tie(0); freopen(&quot;input6.txt&quot;,&quot;r&quot;,stdin); string a,b; int n; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n;&#x2F;&#x2F; cout&lt;&lt;cmp(a,b,n)&lt;&lt;endl;&#x2F;&#x2F; printf(&quot;%d&quot;,cmp(a,b,n)); int c&#x3D;cmp(a,b,n); if(c&#x3D;&#x3D;0) cout&lt;&lt;&quot;0&quot;; else cout&lt;&lt;c; return 0;&#125; 这个是官方版，但是我觉得错误太明显了，应该是题目叙述错了，有改动，比如a,b的大小关系和az和ba的关系应该是一样的，但是官方给的程序测试结果不一样 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[10000],t[10000]; int i,n,a&#x3D;0,k&#x3D;1; scanf(&quot;%s&quot;,&amp;s); scanf(&quot;%s&quot;,&amp;t); scanf(&quot;%d&quot;,&amp;n); for(i&#x3D;n-1;i&gt;&#x3D;0;i--)&#123; a&#x3D;a+s[i]*k-t[i]*k; k&#x3D;k*10; &#125; if(a&gt;0)&#123; printf(&quot;1&quot;); &#125; else if(a&lt;0)&#123; printf(&quot;-1&quot;); &#125; else&#123; printf(&quot;0&quot;); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"字符串","slug":"ACM/字符串","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串比较","slug":"字符串比较","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"}]},{"title":"算法训练 石子游戏","slug":"算法训练-石子游戏","date":"2020-03-30T04:21:07.000Z","updated":"2020-03-30T04:29:41.805Z","comments":true,"path":"2020/03/30/算法训练-石子游戏/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/","excerpt":"分析时间复杂度n^2=10^6,一秒不会超时。这个题的样例还好，给出了要用long long的暗示，并且给出这个测试用例摆明给你降低难度。这个题应该数组合sum全部用long long，因为a=b+c，先是计算b+c存到一个和b一样的数据类型中，如果a是long long，b,c是int，先计算b+c存到一个int的数据类型里，然后再赋值给c，如果溢出的话，b+c已经溢出了，此时在赋值给c还是溢出。所以需要全部置为long long!","text":"分析时间复杂度n^2=10^6,一秒不会超时。这个题的样例还好，给出了要用long long的暗示，并且给出这个测试用例摆明给你降低难度。这个题应该数组合sum全部用long long，因为a=b+c，先是计算b+c存到一个和b一样的数据类型中，如果a是long long，b,c是int，先计算b+c存到一个int的数据类型里，然后再赋值给c，如果溢出的话，b+c已经溢出了，此时在赋值给c还是溢出。所以需要全部置为long long! 题目算法训练 石子游戏提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 石子游戏的规则如下： 地上有n堆石子，每次操作可选取两堆石子（石子个数分别为x和y）并将它们合并，操作的得分记为(x+1)×(y+1)，对地上的石子堆进行操作直到只剩下一堆石子时停止游戏。 请问在整个游戏过程中操作的总得分的最大值是多少？ 输入格式 输入数据的第一行为整数n，表示地上的石子堆数；第二行至第n+1行是每堆石子的个数。 输出格式 程序输出一行，为游戏总得分的最大值。 样例输入10510519400273091989227814251291927212517254194053 样例输出15212676150 数据规模和约定 1≤n≤1000，1≤一堆中石子数≤50000 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;long long a[1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,0,n-1) cin&gt;&gt;a[i]; long long sum&#x3D;0; _for(i,1,n-1) &#123; int index1&#x3D;a[0]&gt;a[1]?0:1; int index2&#x3D;1-index1; _for(j,2,n-1) &#123; if(a[j]&gt;a[index2]) &#123; if(a[j]&gt;a[index1]) &#123; index2&#x3D;index1; index1&#x3D;j; &#125; else index2&#x3D;j; &#125; &#125; sum+&#x3D;(a[index1]+1)*(a[index2]+1); a[index1]+&#x3D;a[index2]; a[index2]&#x3D;-1; &#125; cout&lt;&lt;sum; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"贪心","slug":"ACM/贪心","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%B4%AA%E5%BF%83/"}],"tags":[{"name":"大数陷阱","slug":"大数陷阱","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%99%B7%E9%98%B1/"},{"name":"溢出陷阱","slug":"溢出陷阱","permalink":"https://donghuangzhong.github.io/tags/%E6%BA%A2%E5%87%BA%E9%99%B7%E9%98%B1/"}]},{"title":"算法训练 最大获利","slug":"算法训练-最大获利","date":"2020-03-30T03:52:59.000Z","updated":"2020-03-30T03:58:28.610Z","comments":true,"path":"2020/03/30/算法训练-最大获利/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E6%9C%80%E5%A4%A7%E8%8E%B7%E5%88%A9/","excerpt":"看数据规模，计算中会超过10的9次方，所以应该选择long long。","text":"看数据规模，计算中会超过10的9次方，所以应该选择long long。 题目算法训练 最大获利提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 Chakra是一位年轻有为的企业家，最近他在进军餐饮行业。他在各地开拓市场，共买下了N个饭店。在初期的市场调研中，他将一天划分为M个时间段，并且知道第i个饭店在第j个时间段内，会有Aij位服务员当值和Bij位客户光临。他还分析了不同饭店不同时间段客户的需求，得到第i个饭店在第j个时间段内，平均每位客户消费Cij元。为了创设品牌形象，Chakra决定每个饭店每天只选择一个时间段营业，每个服务员至多接待一位顾客（若顾客数多于服务员数，超过部分的顾客当天就无法在该店消费了）。 企业家的目的终究还是获利。请你安排营业时间，并告诉Chakra每天消费总额最多为多少。 输入格式 第一行两个整数，N、M。 第二行开始依次给出三个矩阵A(NM)、B(NM)、C(N*M)。 输出格式 一行一个整数，最大消费总额。 样例输入2 31 2 33 2 13 2 11 2 34 5 23 1 6 样例输出16 数据规模和约定 1 &lt;= M,N &lt;= 100 1 &lt;= Aij, Bij &lt;= 5000 0 &lt;= Cij &lt;= 10^9 算法根据一位服务员只能服务一名顾客可以计算出，顾客人数矩阵，然后在根据顾客平均消费矩阵计算出总额矩阵，每行选一个求和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;long long st[3][101][101];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input3.txt&quot;,&quot;r&quot;,stdin); int n,m; cin&gt;&gt;n&gt;&gt;m; _for(j,0,2) _for(i,1,n) _for(k,1,m) cin&gt;&gt;st[j][i][k]; _for(i,1,n) _for(k,1,m) if(st[0][i][k]&lt;st[1][i][k]) st[1][i][k]&#x3D;st[0][i][k]; _for(i,1,n) _for(k,1,m) st[2][i][k]*&#x3D;st[1][i][k]; long long sum&#x3D;0; _for(i,1,n) &#123; long long max&#x3D;-1; _for(j,1,m) &#123; if(st[2][i][j]&gt;max) max&#x3D;st[2][i][j]; &#125; sum+&#x3D;max; &#125; cout&lt;&lt;sum; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://donghuangzhong.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数据规模","slug":"数据规模","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1/"}]},{"title":"算法训练 乘法次数","slug":"算法训练-乘法次数","date":"2020-03-30T03:19:42.000Z","updated":"2020-03-30T03:30:49.993Z","comments":true,"path":"2020/03/30/算法训练-乘法次数/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E4%B9%98%E6%B3%95%E6%AC%A1%E6%95%B0/","excerpt":"已知x^n次方的情况下获取x^(2n)的最少途径就是x^n*x^n。要求x^n的最小乘法次数，就是不断的求x^2,x^4,x^8……，找到小于x^n的那个x^y次方(y是2的幂），这样就解决了大头，至于剩下的小头，在重复上述操作。其实就是基于二进制优化的快速幂！！","text":"已知x^n次方的情况下获取x^(2n)的最少途径就是x^n*x^n。要求x^n的最小乘法次数，就是不断的求x^2,x^4,x^8……，找到小于x^n的那个x^y次方(y是2的幂），这样就解决了大头，至于剩下的小头，在重复上述操作。其实就是基于二进制优化的快速幂！！ 题目算法训练 乘法次数提交此题 资源限制 时间限制：1.0s 内存限制：999.4MB 问题描述 给你一个非零整数，让你求这个数的n次方，每次相乘的结果可以在后面使用，求至少需要多少次乘。如24：22=22（第一次乘），2222=24（第二次乘），所以最少共2次； 输入格式 第一行m表示有m(1&lt;=m&lt;=100)组测试数据； 每一组测试数据有一整数n（0&lt;n&lt;=100000000）; 输出格式 输出每组测试数据所需次数s; 样例输入3234 样例输出122 题目大意在已知有一个数x的情况下，求x^n需要经过的最少的乘法次数。 算法123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,c; cin&gt;&gt;c; while(c--) &#123; cin&gt;&gt;n; int t&#x3D;n; int count_1&#x3D;0; while(t) &#123; bool wei&#x3D;t&amp;1; if(wei) count_1++; t&gt;&gt;&#x3D;1; &#125; int high_wei&#x3D;log(n)&#x2F;log(2); cout&lt;&lt;high_wei+count_1-1&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"快速幂","slug":"ACM/快速幂","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"tags":[{"name":"二进制优化","slug":"二进制优化","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"}]},{"title":"C++坑点","slug":"C-坑点","date":"2020-03-29T08:22:05.000Z","updated":"2020-03-29T08:22:05.302Z","comments":true,"path":"2020/03/29/C-坑点/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/29/C-%E5%9D%91%E7%82%B9/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"python爬虫爬取wallpapers壁纸","slug":"python爬虫爬取wallpapers壁纸","date":"2020-03-28T11:55:30.000Z","updated":"2020-03-28T11:58:01.004Z","comments":true,"path":"2020/03/28/python爬虫爬取wallpapers壁纸/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/28/python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96wallpapers%E5%A3%81%E7%BA%B8/","excerpt":"python爬虫爬取wallpapers最新壁纸","text":"python爬虫爬取wallpapers最新壁纸 详细教程请访问：https://www.bilibili.com/video/av58978561/详细教程请访问：https://www.bilibili.com/video/av58978561/123456789101112131415161718192021222324252627import requests #这个包里有打开网页的包from bs4 import BeautifulSoup #这个包里有html解析器def getimg(url,path,name):#将步骤3封装成函数 参数（图片网址，路径，名字） with requests.get(url) as resp:#打开图片 with open(path+'/'+name+'.jpg','wb') as f:#打开路径，准备写入图片 f.write(resp.content)#将图片以传进来的名字以wb(w:写入 b:二进制方式)写入路径def getdurl(url,l,w):#步骤2 参数（每一页的网址，图片长度，图片宽度） with requests.get(url) as resp:#打开网址 html=resp.text#获取html代码 soup=BeautifulSoup(html,'html.parser')#将代码用bs4进行解析 h1=soup.select('h1')#找到html代码中标签为h1（html中h1代表标题）的赋值给变量h1 这样我们就找到了所有图片的名字，但是还有一个网页的标题Latest Wallpapers for i in h1:#for循环 if i.text=='Latest Wallpapers': continue#去掉网页标题 n=i.text imgurl='http://wallpaperswide.com/download/'+n.replace(' ','_').lower()+'-'+str(l)+'x'+str(w) #拼接网址，将名字中空格换成下划线，所有字母换小写 # print(imgurl) print('正在下载'+n+'。。。')#提示信息 getimg(imgurl,'D:\\编程\\python\\wallpapers',n)#调用步骤三函数循环下载 print(n+'下载完成。。。')#提示信息 # url='http://wallpaperswide.com/download/Cyberpunk2077-800x480'if __name__=='__main__':#此程序作为主程序运行 for i in range(2):#外循环，从第一页循环至第十页，这里的10可以改成别的 getdurl('http://wallpaperswide.com/latest_wallpapers/page/'+str(i+1)+'.html',1366,768)#拼接网址调用步骤二函数","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"},{"name":"爬虫","slug":"python/爬虫","permalink":"https://donghuangzhong.github.io/categories/python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"wallpapers","slug":"wallpapers","permalink":"https://donghuangzhong.github.io/tags/wallpapers/"},{"name":"壁纸","slug":"壁纸","permalink":"https://donghuangzhong.github.io/tags/%E5%A3%81%E7%BA%B8/"}]},{"title":"蓝桥模拟_第十题_晚会节目单","slug":"蓝桥模拟-第十题-晚会节目单","date":"2020-03-27T10:20:44.000Z","updated":"2020-03-29T08:16:40.829Z","comments":true,"path":"2020/03/27/蓝桥模拟-第十题-晚会节目单/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/27/%E8%93%9D%E6%A1%A5%E6%A8%A1%E6%8B%9F-%E7%AC%AC%E5%8D%81%E9%A2%98-%E6%99%9A%E4%BC%9A%E8%8A%82%E7%9B%AE%E5%8D%95/","excerpt":"频繁的查询区间最值对于遍历来说开销非常大，所以产生了一种区间最值查询这种算法，本文只讲ST+RMQ，ST是稀疏矩阵的意思，这种方法要求数据必须是静态的不能变化的。","text":"频繁的查询区间最值对于遍历来说开销非常大，所以产生了一种区间最值查询这种算法，本文只讲ST+RMQ，ST是稀疏矩阵的意思，这种方法要求数据必须是静态的不能变化的。 问题引入有一个一位数组(长度为n)，频繁的查询[s,e]区间的最值。 算法详解定义一个二维数组ST(大小[n,lgn])。ST[i][j]表示的是从i开始(包括i)向后2^j个元素区间的最值，即区间[i,i+2^j-1]的最值，那么很明显ST[i][0]=a[i](因为[i,i]只有一个值)。现在我们开始推导递推式,[i,i+2^j-1]可以按照中间分为两个大小为2^(j-1)的区间[i,i+2^(j-1)-1]和[i+2^(j-1),i+2^j-1]，那么[i,i+2^j-1]的最值为这两个区间再求最值，即[i,i+2^j-1]=min/max([i,i+2^(j-1)-1],[i+2^(j-1),i+2^j-1])也就是： 1ST[i][j]&#x3D;min&#x2F;max(ST[i][j-1],ST[i+2^j][j-1]) 那么就可以发现第j列某个元素值的计算只跟它前一列的某两个值有关，并且刚刚我们已经算好了第一列，由第一列可以计算第二列，由第二列可以计算第三列……那么要算到哪一列呢？ST[i][j]表示的区间是[i,i+2^j-1]很明显i+2^j-1&lt;=n-1(n个元素，下标0~n-1)所以就有了建ST的模板： 123456789101112void cal(int a[],int n)&#123; for(int i&#x3D;0;i&lt;&#x3D;n-1;i++) ST[i][0]&#x3D;a[i]; for(int j&#x3D;1;(1&lt;&lt;(j))&lt;&#x3D;n;j++) &#123; for(int i&#x3D;0;i+(1&lt;&lt;j)-1&lt;&#x3D;n-1;i++) &#123; st[i][j]&#x3D;max&#x2F;min(st[i][j-1],st[i+1&lt;&lt;(j-1)][j-1]); &#125; &#125; &#125; 说了半天有了这个表该怎么用呢？假如我们要计算区间[s,e]的最值该怎么算呢？我们能够利用的是ST[此处可为任意数][此处必须为2的幂]如果我们能够找到一个k，使得区间[s,e]变成[s,s+2^k-1]和[s+2^k][e]，我们就可以利用表了，但是你会发现第二个区间没法表示，我们只能表示长度为2的幂的区间。于是聪明人就会发现用e减去2的幂不就行了！于是将[s,e]变成[s,s+2^k-1]和[e-2^k+1,e]，这样区间[s][e]的最值就可以变为min/max(ST[s][k],ST[e-2^K+1][e])但是可能有人又会提出疑问了，如果这两个集合没有交集怎么办？比如[2,6]分为[2,3]和[5,6] (k=1)，这样得到话明显不对啊！所以我们需要找一个比较大的k值，[s,s+2^k-1]必须包含在[s][e]里面,也就是s+2^k-1&lt;=e 解得$$k&lt;=log_2(e-s+1),令k=log_2(e-s+1)$$并且(int)k去除了k的小数部分，也就是说0&lt;=k-(int)k&lt;1，所以k-1&lt;(int)k&lt;=k，代入原式：$$2^{k-1}-1&lt;2^{(int)k}-1&lt;=2^k-1将k=log_2(e-s+1)代入得$$ $$(e-s)/2-1/2&lt;2^{(int)k}-1，此处2^{(int)k}-1是整数，所以(e-s)/2=&lt;2^{(int)k}-1$$ $$所以s+2^{(int)k}-1&gt;=s+(e-s)/2=(e+s)/2(中点)且e-2^k+1&lt;=e-(e+s)/2=(e+s)/2(中点)$$ 所以当k=(int)(log2(e-s+1))时，ST[s][k],ST[e-2^K+1][e]表示的区间一定有交集。所以要求[s,e]区间最值只需要计算min/max(ST[s][k],ST[e-2^K+1][e]),k=(int)(log2(e-s+1)) 例题第十题 晚会节目单题目【问题描述】小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。小明发现，观众对于晚会的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。 【输入格式】输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。第二行包含 n 个整数，依次为每个节目的好看值。 【输出格式】输出一行包含 m 个整数，为选出的节目的好看值。 【样例输入】5 33 1 2 5 4 【样例输出】3 5 4 【样例说明】选择了第1, 4, 5个节目。 【评测用例规模与约定】对于 30% 的评测用例，1 &lt;= n &lt;= 20；对于 60% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。 思路 O(N^2)ST+RMQ 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m;int a[100001];int tree[400001];int st[100001][20];int pow_2(int p) &#123; return 1 &lt;&lt; p;&#125;void cal(int a[],int n)&#123; for(int j&#x3D;1;(1&lt;&lt;(j-1))&lt;&#x3D;n;j++) &#123; for(int i&#x3D;0;i+(1&lt;&lt;j)-1&lt;&#x3D;n-1;i++) &#123; st[i][j]&#x3D;a[st[i][j-1]]&gt;a[st[i+pow_2(j-1)][j-1]]?st[i][j-1]:st[i+pow_2(j-1)][j-1]; &#125; &#125; &#125;int query(int s,int e)&#123; int t&#x3D;(int)(log(e-s+1)&#x2F;log(2)); return a[st[s][t]]&gt;a[st[e-(1&lt;&lt;t)+1][t]]?st[s][t]:st[e-(1&lt;&lt;t)+1][t];&#125; void build_tree(int s,int e,int node)&#123; if(s&#x3D;&#x3D;e) &#123; tree[node]&#x3D;s; return ; &#125; int mid&#x3D;(s+e)&#x2F;2; build_tree(s,mid,2*node+1); build_tree(mid+1,e,2*node+2); tree[node]&#x3D;a[tree[2*node+1]]&gt;a[tree[2*node+2]]?tree[2*node+1]:tree[2*node+2];&#125;int query_tree(int s,int e,int node,int l,int r)&#123; if(e&lt;l||s&gt;r) return 0; if(s&gt;&#x3D;l&amp;&amp;e&lt;&#x3D;r) return tree[node]; int mid&#x3D;(s+e)&#x2F;2; int ln&#x3D;query_tree(s,mid,2*node+1,l,r); int rn&#x3D;query_tree(mid+1,e,2*node+2,l,r); return a[ln]&gt;a[rn]?ln:rn;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; _for(i,0,n-1) &#123; cin&gt;&gt;a[i]; st[i][0]&#x3D;i; &#125; int c&#x3D;clock(); cal(a,n); int s&#x3D;0,k&#x3D;m; while(k!&#x3D;0) &#123; int z&#x3D;query(s,n-1-k+1); cout&lt;&lt;a[z]&lt;&lt;&quot; &quot;; s&#x3D;z+1; k--; &#125; P(&quot;&quot;); PP(&quot;time&#x3D;&quot;,clock()-c); c&#x3D;clock(); build_tree(0,n-1,0); cout&lt;&lt;&quot;tree:&quot;; s&#x3D;0;k&#x3D;m; while(k!&#x3D;0) &#123; int z&#x3D;query_tree(0,n-1,0,s,n-1-k+1); cout&lt;&lt;a[z]&lt;&lt;&quot; &quot;; s&#x3D;z+1; k--; &#125; cout&lt;&lt;endl&lt;&lt;&quot;time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"RMQ","slug":"ACM/RMQ","permalink":"https://donghuangzhong.github.io/categories/ACM/RMQ/"}],"tags":[{"name":"ST","slug":"ST","permalink":"https://donghuangzhong.github.io/tags/ST/"}]},{"title":"C++_string","slug":"C-STL","date":"2020-03-26T02:54:47.000Z","updated":"2020-04-04T08:40:41.759Z","comments":true,"path":"2020/03/26/C-STL/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/26/C-STL/","excerpt":"简要记录C家族有效方法","text":"简要记录C家族有效方法 字符串strlen()返回的是’\\0’的位置加1 sprintfsprintf(char a[],”%d”,10) 各种形式转换成字符数组，可以string str(a)转换成string,然后用string的方法 123char s[5];sprintf(s, &quot;%d&quot;, i);string str(s); stringstr.find()找字符参数:(字符，起点下标(缺省0)) 找字符串参数：(字符串，起点坐标(缺省0)，找字符串的前n个字符串(缺省)) 12345string s&#x3D;&quot;helollo&quot;;cout&lt;&lt;s.find(&#39;l&#39;,3)&lt;&lt;endl;cout&lt;&lt;s.find(&quot;ll&quot;,0,1)&lt;&lt;endl;&#x2F;&#x2F;4&#x2F;&#x2F;2 str.find_first_of宏定义#的用法有时候我们想在打印变量前标明一下变量名字，如果一个一个手打非常的不方便，于是我们可以用宏定义中的#代表加引号的变量 123#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endlprint(s.find(&#39;l&#39;,3));&#x2F;&#x2F;s.find(&#39;l&#39;,3)&#x3D;4 二分查找upper_bound lower_bound123456bool cmp(int a,int b) &#123;return a&gt;b&#125;;int a[];查找区间[a,a+len+1)upper_bound(a,a+len+1,x) &#x2F;&#x2F;默认升序 第一个大于x的地址lower_bound(a,a+len+1,x) &#x2F;&#x2F;默认升序 第一个大于等于x的地址upper_bound(a,a+len+1,x,cmp) &#x2F;&#x2F;降序 第一个小于x的地址lower_bound(a,a+len+1,x,cmp) &#x2F;&#x2F;降序 第一个小于等于x的地址","categories":[{"name":"tools","slug":"tools","permalink":"https://donghuangzhong.github.io/categories/tools/"},{"name":"C++","slug":"tools/C","permalink":"https://donghuangzhong.github.io/categories/tools/C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://donghuangzhong.github.io/tags/STL/"}]},{"title":"蓝桥杯2020三月模拟赛解题报告","slug":"蓝桥杯2020三月模拟赛解题报告","date":"2020-03-26T02:33:02.000Z","updated":"2020-03-29T08:16:50.738Z","comments":true,"path":"2020/03/26/蓝桥杯2020三月模拟赛解题报告/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/26/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E4%B8%89%E6%9C%88%E6%A8%A1%E6%8B%9F%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"摘要","text":"摘要 第一题 单位变换题目【问题描述】在计算机存储中，15.125GB是多少MB？ 【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 思路1G=1024M 答案15488 第二题 约数个数题目【问题描述】1200000有多少个约数（只计算正约数）。 【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 思路枚举+检查 参考代码123456789101112131415161718#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input2.txt&quot;,&quot;r&quot;,stdin); int i&#x3D;1200000,sum&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;i;j++) &#123; if(i%j&#x3D;&#x3D;0) sum++; &#125; cout&lt;&lt;sum; return 0;&#125; 答案96 第三题 叶结点数题目【问题描述】一棵包含有2019个结点的二叉树，最多包含多少个叶结点？ 【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 思路ni为出度为i的节点，二叉树只有三种节点，出度为0,1,2的三种。并且有下面的关系 n=n0+n1+n2 n0=n2+1 证明法1：n个节点的二叉树共有n-1条边，n-1=2*n2+n1,带入1式得：n0=n2+1 证明法2:n0为叶子节点的个数，每两个叶子节点经过一次合并产生一个n2，得到一个新的叶子节点，也就是说每两个叶子节点经过一次合并减少一个叶子节点，产生一个n2。所以需要n-1次合并产生n-1个n2得到根节点，所以n0=n2+1 为使叶子节点数（n0）最多，必须n1最小，设为0，而n0=n2+1，得n2=(2019-1)/2=1009所以n0=1010 答案1010 第四题 数字9题目【问题描述】在1至2019中，有多少个数的数位中包含数字9？注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算时只是算一个数。 【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 思路两个方法 (1)分别计算各个位上的数字然后判断 (2)字符串 伪代码123for i from 9 to 2019 if str(i).contains(&#39;9&#39;) ans++ 参考代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;time.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;bool check(int i) &#123; char s[5]; sprintf(s, &quot;%d&quot;, i); string str(s); return str.find(&#39;9&#39;) !&#x3D; string::npos;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input2.txt&quot;,&quot;r&quot;,stdin); int n&#x3D;2019,sum&#x3D;0; int a&#x3D;clock(); for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; int g&#x3D;j%10; int s&#x3D;(j&#x2F;10)%10; int b&#x3D;(j&#x2F;100)%10; int q&#x3D;(j&#x2F;1000)%10; if(g&#x3D;&#x3D;9||s&#x3D;&#x3D;9||b&#x3D;&#x3D;9||q&#x3D;&#x3D;9) sum++; &#x2F;&#x2F;cout&lt;&lt;q&lt;&lt;b&lt;&lt;s&lt;&lt;g&lt;&lt;endl; &#125; cout&lt;&lt;sum&lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-a&lt;&lt;endl; a&#x3D;clock(); sum&#x3D;0;char s[10]; for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123; sprintf(s,&quot;%d&quot;,i); string str(s);; if(str.find(&#39;9&#39;)!&#x3D;string::npos) sum++; &#125; cout &lt;&lt; sum &lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-a&lt;&lt;endl; return 0; &#125; 答案544 第五题 数位递增的数题目【问题描述】一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？ 【输入格式】输入的第一行包含一个整数 n。 【输出格式】输出一行包含一个整数，表示答案。 【样例输入】30 【样例输出】26【评测用例规模与约定】对于 40% 的评测用例，1 &lt;= n &lt;= 1000。对于 80% 的评测用例，1 &lt;= n &lt;= 100000。对于所有评测用例，1 &lt;= n &lt;= 1000000。 思路 O(kN)两个方法 (1)计算每一位，判断 (2)迭代1~n 转换为字符串 迭代字符串的每一位，判断是否满足要求 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;time.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input2.txt&quot;,&quot;r&quot;,stdin); int n,sum&#x3D;0; cin&gt;&gt;n; int c&#x3D;clock(); for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int t&#x3D;i,lwei&#x3D;10,j; for(j&#x3D;1;j&lt;&#x3D;7;j++) &#123; int wei&#x3D;t%10; t&#x2F;&#x3D;10; if(wei&gt;lwei) break; lwei&#x3D;wei; &#125; if(j&gt;7) sum++; &#125; cout&lt;&lt;sum&lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-c&lt;&lt;endl; sum&#x3D;0; c&#x3D;clock(); char a[7]; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int j; sprintf(a,&quot;%d&quot;,i); for(j&#x3D;1;j&lt;strlen(a);j++) if(a[j-1]&gt;a[j]) break; if(j&#x3D;&#x3D;strlen(a)) sum++; &#125; cout&lt;&lt;sum&lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0; &#125; 第六题 递增三元组题目【问题描述】在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。 【输入格式】输入的第一行包含一个整数 n。第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。 【输出格式】输出一行包含一个整数，表示答案。 【样例输入】51 2 5 3 5 【样例输出】2 【样例说明】a[2] 和 a[4] 可能是三元组的中心。 【评测用例规模与约定】对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。 思路 O(N^2)枚举每个元素 该元素与前面的元素比较，找到小的即可 该元素与后面的元素比较，找到大的即可 上面两项为真，即说明当前元素可以作为三元组的中心O(N^2)，因为N最大为1000，所以1秒内可以解决战斗。 参考代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;time.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,sum&#x3D;0,a[10000],j,k; cin&gt;&gt;n; for(int i&#x3D;0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; int c&#x3D;clock(); for(int i&#x3D;1;i&lt;&#x3D;n-2;i++) &#123; for(j&#x3D;0;j&lt;i;j++) &#123; if(a[j]&lt;a[i]) break; &#125; if(j&#x3D;&#x3D;i) continue; for(k&#x3D;i+1;k&lt;n;k++) &#123; if(a[i]&lt;a[k]) break; &#125; if(k&#x3D;&#x3D;n) continue; sum++; &#125; cout&lt;&lt;sum&lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-c; return 0;&#125; 第七题 音节判断题目【问题描述】小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。 【输入格式】输入一行，包含一个单词，单词中只包含小写英文字母。 【输出格式】输出答案，或者为yes，或者为no。 【样例输入】lanqiao 【样例输出】yes 【样例输入】world 【样例输出】no 【评测用例规模与约定】对于所有评测用例，单词中的字母个数不超过100。 思路三个方法 (1)遍历字符串，如果是辅音就设y(bool)为0，直到找到元音，记录下标，继续遍历，找到第二个元音，然后判断第一个元音的下标是不是0，必须非0并且第二个元音之后的都是辅音 (2)逻辑和:遍历字符串，计算(judge(s[i])+judge(s[i+1]))==1的次数，如果最后次数==3，说明合题意 (3)字符串现成的方法 找到第一个元音的下标index1，必须大于0，且能找到沿着index1继续找下一个非元音得到index2，必须能找到沿着index2继续找下一个元音得到index3，必须能找到最后判断index3-1位置的字符应该是从后往前第一个非元音（因为index3及以后的字符都必须是元音了） 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&#x2F;&#x2F;qwrtypsdfghjklzxcvbnmaeiouuoieamnbvcxzlkjhgfdspytrwqaaeeiioouu&#x2F;&#x2F;yes time&#x3D;0&#x2F;&#x2F;yes time&#x3D;0&#x2F;&#x2F;yes time&#x3D;0#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;time.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;bool judge(char c)&#123; if(c&#x3D;&#x3D;&#39;a&#39;||c&#x3D;&#x3D;&#39;e&#39;||c&#x3D;&#x3D;&#39;i&#39;||c&#x3D;&#x3D;&#39;o&#39;||c&#x3D;&#x3D;&#39;u&#39;) return 1; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); string s; int index[2]; int in&#x3D;0,sum&#x3D;0,k; bool y&#x3D;0,flag&#x3D;0; cin&gt;&gt;s; int c&#x3D;clock(); for(int i&#x3D;0;i&lt;s.length();i++) &#123; if(judge(s[i])) &#123; if(y&#x3D;&#x3D;0) &#123; y&#x3D;1; index[in++]&#x3D;i; if(in&#x3D;&#x3D;2) &#123; if(index[0]&#x3D;&#x3D;0) &#123; flag&#x3D;0; break; &#125; for(k&#x3D;index[1];k&lt;s.length();k++) &#123; if(!judge(s[k])) &#123; flag&#x3D;0; break; &#125; &#125; if(k&#x3D;&#x3D;s.length()) flag&#x3D;1; else break; &#125; &#125; else continue; &#125; else y&#x3D;0; &#125; if(flag) cout&lt;&lt;&quot;yes&quot;; else cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; c&#x3D;clock(); int jiao&#x3D;0; for(int i&#x3D;0;i&lt;s.length()-1;i++) &#123; if((judge(s[i])+judge(s[i+1]))&#x3D;&#x3D;1) jiao++; &#125; if(jiao&#x3D;&#x3D;3) cout&lt;&lt;&quot;yes&quot;; else cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; c&#x3D;clock(); int index1&#x3D;s.find_first_of(&quot;aeiou&quot;); if(!index1||index1&#x3D;&#x3D;string::npos) &#123; cout&lt;&lt;&quot;no&quot;; return 0; &#125; int index2&#x3D;s.find_first_not_of(&quot;aeiou&quot;,index1+1); if(index2&#x3D;&#x3D;string::npos) &#123; cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0; &#125; int index3&#x3D;s.find_first_of(&quot;aeiou&quot;,index2+1); if(index3&#x3D;&#x3D;string::npos) &#123; cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0; &#125; int index4&#x3D;s.find_last_not_of(&quot;aeiou&quot;); if(index4!&#x3D;index3-1) &#123; cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0; &#125; cout&lt;&lt;&quot;yes&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0;&#125; 第八题 长草题目【问题描述】小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。请告诉小明，k 个月后空地上哪些地方有草。 【输入格式】输入的第一行包含两个整数 n, m。接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。接下来包含一个整数 k。 【输出格式】输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。 【样例输入】4 5.g……....g..…..2 【样例输出】gggg.gggg.ggggg.ggg. 【评测用例规模与约定】对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= k &lt;= 1000。 思路 O(N*M)(1)dfs有可能会超时 (2)典型的多入口bfs，基本是个模板题。时间复杂度最多为O(N*M)。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;cstdio&gt;#include&lt;time.h&gt;#include&lt;memory&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;struct Point&#123; int x,y,kk;&#125;;char map[1010][1010],save[1010][1010];int m,n,k;queue&lt;Point&gt; q; int dir[4][2]&#x3D;&#123;0,1,0,-1,1,0,-1,0&#125;;void manyan(int x,int y)&#123; for(int i&#x3D;0;i&lt;4;i++) &#123; int xx&#x3D;x+dir[i][0]; int yy&#x3D;y+dir[i][1]; if(xx&gt;&#x3D;0&amp;&amp;xx&lt;m&amp;&amp;yy&gt;&#x3D;0&amp;&amp;yy&lt;n) &#123; if(map[xx][yy]&#x3D;&#x3D;&#39;.&#39;) map[xx][yy]&#x3D;&#39;d&#39;; &#125; &#125;&#125;void bfs()&#123; Point a,b; while(!q.empty()) &#123; a&#x3D;q.front(); if(a.kk&#x3D;&#x3D;k) return ; q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(b.x&gt;&#x3D;0&amp;&amp;b.x&lt;m&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;n&amp;&amp;map[b.x][b.y]&#x3D;&#x3D;&#39;.&#39;) &#123; b.kk&#x3D;a.kk+1; map[b.x][b.y]&#x3D;&#39;g&#39;; q.push(b); &#125; &#125; &#125;&#125;void show(char map[1010][1010])&#123; for(int i&#x3D;0;i&lt;m;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; cout&lt;&lt;map[i][j]; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;m&gt;&gt;n; for(int i&#x3D;0;i&lt;m;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]&#x3D;&#x3D;&#39;g&#39;) q.push(&#123;i,j,0&#125;); &#125; &#125; memcpy(save,map,sizeof(map)); cin&gt;&gt;k; int c&#x3D;clock(); bfs(); cout&lt;&lt;&quot;time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; show(map); memcpy(map,save,sizeof(map)); c&#x3D;clock(); for(int i&#x3D;0;i&lt;k;i++) &#123; for(int ii&#x3D;0;ii&lt;m;ii++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; if(map[ii][j]&#x3D;&#x3D;&#39;g&#39;) manyan(ii,j); &#125; &#125; for(int ii&#x3D;0;ii&lt;m;ii++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; if(map[ii][j]&#x3D;&#x3D;&#39;d&#39;) map[ii][j]&#x3D;&#39;g&#39;; &#125; &#125; &#125; cout&lt;&lt;&quot;time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; show(map); return 0;&#125; 第九题 序列计数题目【问题描述】小明想知道，满足以下条件的正整数序列的数量： 第一项为 n； 第二项不超过 n； 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。 【输入格式】输入一行包含一个整数 n。 【输出格式】输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。 【样例输入】4 【样例输出】7 【样例说明】以下是满足条件的序列：4 14 1 14 1 24 24 2 14 34 4 【评测用例规模与约定】对于 20% 的评测用例，1 &lt;= n &lt;= 5；对于 50% 的评测用例，1 &lt;= n &lt;= 10；对于 80% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 1000。 思路：void dfs1(当前选择的点，下一次选择的范围)正向思维，注意这里每次都可以选择不向下找了，将后面补0，直接递归看做结束的条件(严重超时) int dfs2(上上一个选择的数字,上一个选择的数据)逆向思维，和第一个半斤八两，初始化为1是因为本身就是一种情况 记忆性递归(O(n^3)) 参数和第二个相同从第一、二种中可以看出有可能重复，所以加上一个矩阵记录 递归优化dfs4(i,j) 表示前一个点是i,后一个点是[1,j]这些可能性的总和，显然dfs4(i,j)=dfs4(i,j-1)+1+dfs4(j,|i-j|)，为什么要加1？问的好，因为1表示的是(i,j(后面没有了))这一种情况 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int mem[1001][1001],sum;void dfs1(int aa,int jue)&#123; if(aa&#x3D;&#x3D;0) &#123; sum++; return ; &#125; dfs1(0,aa); _for(i,1,jue-1) &#123; int t&#x3D;(aa&gt;&#x3D;i)?(aa-i):(i-aa); dfs1(i,t); &#125;&#125;int dfs2(int a,int b)&#123; int t&#x3D;(a&gt;&#x3D;b?(a-b):(b-a)); int ans&#x3D;1; _for(i,1,t-1) ans+&#x3D;dfs2(b,i); return ans%10000; &#125;int dfs3(int a,int b)&#123; if(mem[a][b]) return mem[a][b]; int cha&#x3D;a&gt;&#x3D;b?(a-b):(b-a); int ans&#x3D;1; _for(i,1,cha-1) ans+&#x3D;dfs3(b,i); ans%&#x3D;10000; mem[a][b]&#x3D;ans; return ans;&#125; int dfs4(int a,int b)&#123; if(b&lt;&#x3D;0) return 0; if(mem[a][b]) return mem[a][b]; int t&#x3D;(a&gt;&#x3D;b?(a-b):(b-a)); return mem[a][b]&#x3D;(dfs4(a,b-1)+1+dfs4(b,t-1))%10000;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; int c&#x3D;clock(); sum&#x3D;0; _for(j,1,n) dfs1(j,n-j); P(sum%10000); PP(&quot;time&quot;,clock()-c); c&#x3D;clock(); sum&#x3D;0; _for(i,1,n) sum+&#x3D;dfs2(n,i); P(sum%10000); PP(&quot;time&quot;,clock()-c); c&#x3D;clock(); sum&#x3D;0; _for(i,1,n) sum+&#x3D;dfs3(n,i); P(sum%10000); PP(&quot;time&quot;,clock()-c); memset(mem,0,sizeof(mem)); c&#x3D;clock(); P(dfs4(n,n)); PP(&quot;time&quot;,clock()-c); return 0;&#125; 第十题 晚会节目单题目【问题描述】小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。小明发现，观众对于晚会的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。 【输入格式】输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。第二行包含 n 个整数，依次为每个节目的好看值。 【输出格式】输出一行包含 m 个整数，为选出的节目的好看值。 【样例输入】5 33 1 2 5 4 【样例输出】3 5 4 【样例说明】选择了第1, 4, 5个节目。 【评测用例规模与约定】对于 30% 的评测用例，1 &lt;= n &lt;= 20；对于 60% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。 错误思路如果用两次排序求解，那就错了。因为并不是要选出的方案的好看值总和最大，而是要从前往后尽量好看。即选出的M个数字典序最大 思路 O(N^2)ST+RMQ 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m;int a[100001];int tree[400001];int st[100001][20];int pow_2(int p) &#123; return 1 &lt;&lt; p;&#125;void cal(int a[],int n)&#123; for(int j&#x3D;1;(1&lt;&lt;(j-1))&lt;&#x3D;n;j++) &#123; for(int i&#x3D;0;i+(1&lt;&lt;j)-1&lt;&#x3D;n-1;i++) &#123; st[i][j]&#x3D;a[st[i][j-1]]&gt;a[st[i+pow_2(j-1)][j-1]]?st[i][j-1]:st[i+pow_2(j-1)][j-1]; &#125; &#125; &#125;int query(int s,int e)&#123; int t&#x3D;(int)(log(e-s+1)&#x2F;log(2)); return a[st[s][t]]&gt;a[st[e-(1&lt;&lt;t)+1][t]]?st[s][t]:st[e-(1&lt;&lt;t)+1][t];&#125; void build_tree(int s,int e,int node)&#123; if(s&#x3D;&#x3D;e) &#123; tree[node]&#x3D;s; return ; &#125; int mid&#x3D;(s+e)&#x2F;2; build_tree(s,mid,2*node+1); build_tree(mid+1,e,2*node+2); tree[node]&#x3D;a[tree[2*node+1]]&gt;a[tree[2*node+2]]?tree[2*node+1]:tree[2*node+2];&#125;int query_tree(int s,int e,int node,int l,int r)&#123; if(e&lt;l||s&gt;r) return 0; if(s&gt;&#x3D;l&amp;&amp;e&lt;&#x3D;r) return tree[node]; int mid&#x3D;(s+e)&#x2F;2; int ln&#x3D;query_tree(s,mid,2*node+1,l,r); int rn&#x3D;query_tree(mid+1,e,2*node+2,l,r); return a[ln]&gt;a[rn]?ln:rn;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; _for(i,0,n-1) &#123; cin&gt;&gt;a[i]; st[i][0]&#x3D;i; &#125; int c&#x3D;clock(); cal(a,n); int s&#x3D;0,k&#x3D;m; while(k!&#x3D;0) &#123; int z&#x3D;query(s,n-1-k+1); cout&lt;&lt;a[z]&lt;&lt;&quot; &quot;; s&#x3D;z+1; k--; &#125; P(&quot;&quot;); PP(&quot;time&#x3D;&quot;,clock()-c); c&#x3D;clock(); build_tree(0,n-1,0); cout&lt;&lt;&quot;tree:&quot;; s&#x3D;0;k&#x3D;m; while(k!&#x3D;0) &#123; int z&#x3D;query_tree(0,n-1,0,s,n-1-k+1); cout&lt;&lt;a[z]&lt;&lt;&quot; &quot;; s&#x3D;z+1; k--; &#125; cout&lt;&lt;endl&lt;&lt;&quot;time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"解题报告","slug":"ACM/解题报告","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"蓝桥杯2020模拟赛","slug":"蓝桥杯2020模拟赛","permalink":"https://donghuangzhong.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}]},{"title":"UVA-1052-算法训练-Bit Compressor","slug":"UVA-1052-算法训练-Bit-Compressor","date":"2020-03-25T08:23:34.000Z","updated":"2020-03-26T02:19:58.169Z","comments":true,"path":"2020/03/25/UVA-1052-算法训练-Bit-Compressor/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/25/UVA-1052-%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-Bit-Compressor/","excerpt":"dfs奥义:不确定性即可能性！并且有时候可能性可以没有顺序！本文的不确定性在于对于前面有1的0，不确定是分隔符还是二进制中的一部分。这就是不确定性，也就是可能性。本程序还利用了二进制的动态计算。","text":"dfs奥义:不确定性即可能性！并且有时候可能性可以没有顺序！本文的不确定性在于对于前面有1的0，不确定是分隔符还是二进制中的一部分。这就是不确定性，也就是可能性。本程序还利用了二进制的动态计算。 试题 算法训练 Bit Compressor提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 数据压缩的目的是为了减少存储和交换数据时出现的冗余。这增加了有效数据的比重并提高了传输速率。有一种压缩二进制串的方法是这样的： 将连续的n个1替换为n的二进制表示（注：替换发生当且仅当这种替换减少了二进制串的总长度） （译者注：连续的n个1的左右必须是0或者是串的开头、结尾） 比如：11111111001001111111111111110011会被压缩成10000010011110011。原串长为32,被压缩后串长为17. 这种方法的弊端在于，有时候解压缩算法会得到不止一个可能的原串，使得我们无法确定原串究竟是什么。请你写一个程序来判定我们能否利用压缩后的信息来确定原串。给出原串长L，原串中1的个数N，以及压缩后的串。 L&lt;=16 Kbytes，压缩后的串长度&lt;=40 bits。 输入格式 第一行两个整数L,N，含义同问题描述 第二行一个二进制串，表示压缩后的串 输出格式 输出”YES”或”NO”或”NOT UNIQUE”（不包含引号） 分别表示： YES：原串唯一 NO：原串不存在 NOT UNIQUE：原串存在但不唯一 样例输入样例1：32 2610000010011110011样例2：9 71010101样例3：14 14111111 样例输出样例1：YES样例2：NOT UNIQUE样例3：NO 算法先说二进制的动态计算，你可能会说我还不会二进制转十进制吗？例如1101，分别计算1,11,110,1101。每一个的前面都是重复的，我们可以用到前面的计算结果，这样可以避免重复计算，提高效率。 dfs参数(要处理的位置下标，已经处理的原串中的字符个数，已经处理的原串中的1的个数)。后两个参数是为了剪枝的。如果碰到前面没有1的0直接跳过，因为肯定是原串中的0，对于每个前面有1的0我们提供两种选择，一是作为原串中的0(把前面的反编码成二进制个1)，二是作为二进制中的0。但是这样会出现一个棘手的问题，一是10不能反编码回去，因为反编码得到11，长度都是2，不合题意，你可能说1也不能反编码回去，但是1无论是反编码还是不反编码得到的都是一样的结果，既然这样为什么还认为1不能反编码增加额外代码量呢？也就是说原串中的11是不能编码成10的，所以编码后的串中如果出现11不能确定是原串中的是11还是111，也就是说按照碰到前面有1的0就提供两种可能性的策略，对于10不能进去，对于11少算了一个。对于少算的可以额外增加，因为可能性的顺序没关系。但是对于多算的我们要加条件过滤。于是代码就产生了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;#define maxn 50int n,m; string s;int answer&#x3D;0; void dfs(int pos,int len,int len_1)&#123; if(pos&#x3D;&#x3D;s.length()&amp;&amp;len&#x3D;&#x3D;n&amp;&amp;len_1&#x3D;&#x3D;m) &#123; answer++; return ; &#125; if(pos&gt;&#x3D;s.length()||len&gt;n||len_1&gt;m) return ; if(s[pos]&#x3D;&#x3D;&#39;0&#39;) &#123; dfs(pos+1,len+1,len_1); return ; &#125; int t&#x3D;0; for(int i&#x3D;pos;i&lt;s.length();i++) &#123; t*&#x3D;2; t+&#x3D;s[i]-&#39;0&#39;; if(len_1+t&gt;m||len+t&gt;n) break; if(s[i+1]!&#x3D;&#39;1&#39;&amp;&amp;(t!&#x3D;2)) dfs(i+1,len+t,len_1+t); &#125; if(s[pos+1]&#x3D;&#x3D;&#39;1&#39;&amp;&amp;s[pos+2]!&#x3D;&#39;1&#39;) dfs(pos+2,len+2,len_1+2);&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int e&#x3D;1; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n)&#123; answer&#x3D;0; cin&gt;&gt;s; dfs(0,0,0); printf(&quot;Case #%d: &quot;,e++); if(answer&#x3D;&#x3D;0) printf(&quot;NO\\n&quot;); else if(answer&#x3D;&#x3D;1) printf(&quot;YES\\n&quot;); else printf(&quot;NOT UNIQUE\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"高级dfs","slug":"ACM/高级dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%AB%98%E7%BA%A7dfs/"}],"tags":[{"name":"编码","slug":"编码","permalink":"https://donghuangzhong.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"动态二进制","slug":"动态二进制","permalink":"https://donghuangzhong.github.io/tags/%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"算法训练 cNteSahruPfefrlefe","slug":"算法训练-cNteSahruPfefrlefe","date":"2020-03-20T09:09:31.000Z","updated":"2020-03-20T09:09:31.642Z","comments":true,"path":"2020/03/20/算法训练-cNteSahruPfefrlefe/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/20/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-cNteSahruPfefrlefe/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"算法训练 Sticks","slug":"算法训练-Sticks","date":"2020-03-18T11:08:24.000Z","updated":"2020-03-18T11:38:23.496Z","comments":true,"path":"2020/03/18/算法训练-Sticks/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/18/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-Sticks/","excerpt":"还记得dfs的入门题吗？输入n个数和一个结果m,问这n个数能不能组合成m。这个题就是在能凑成m的基础上再从头开始搜索，注意不能运行多次dfs，而是要递归调用，因为不能确定找到一个m就是其中的一个m，有可能不合法。dfs的代码风格有两种，一种是正序，一种是倒序","text":"还记得dfs的入门题吗？输入n个数和一个结果m,问这n个数能不能组合成m。这个题就是在能凑成m的基础上再从头开始搜索，注意不能运行多次dfs，而是要递归调用，因为不能确定找到一个m就是其中的一个m，有可能不合法。dfs的代码风格有两种，一种是正序，一种是倒序 问题试题 算法训练 Sticks提交此题 资源限制 时间限制：1.0s 内存限制：999.4MB Sticks Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 113547 Accepted: 26078 问题描述 George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero. 输入格式 The input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the file contains zero. 输出格式 The output should contains the smallest possible length of original sticks, one per line. 样例输入95 2 1 5 2 1 5 2 141 2 3 40 样例输出56 题目大意多个测试用例，第一行输入木棒的个数n，下一行输入n个数代表不同木棒的长度，这些木棒可以组成m个长度为k的长木棒，输出k的最小值","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dfs","slug":"ACM/dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/dfs/"}],"tags":[{"name":"高级dfs","slug":"高级dfs","permalink":"https://donghuangzhong.github.io/tags/%E9%AB%98%E7%BA%A7dfs/"}]},{"title":"基础练习 字符串对比","slug":"基础练习-字符串对比","date":"2020-03-14T10:12:05.000Z","updated":"2020-03-14T10:18:28.577Z","comments":true,"path":"2020/03/14/基础练习-字符串对比/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E6%AF%94/","excerpt":"首先1很好判断，并且1和234对立(一组if else)，再看2，需要全部对比完才能；而34只要一个不满足就可以输出，所以34的判断在2的前面，根据题目逻辑，4要在三的前面。于是逻辑就清楚了。","text":"首先1很好判断，并且1和234对立(一组if else)，再看2，需要全部对比完才能；而34只要一个不满足就可以输出，所以34的判断在2的前面，根据题目逻辑，4要在三的前面。于是逻辑就清楚了。 问题试题 基础练习 字符串对比提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4中情况之一： 1：两个字符串长度不等。比如 Beijing 和 Hebei 2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如 Beijing 和 Beijing 3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如 beijing 和 BEIjing 4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing 编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。 输入格式 包括两行，每行都是一个字符串 输出格式 仅有一个数字，表明这两个字符串的关系编号 样例输入BEIjing 1beiJing 样例输出3 算法12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); char a[10],b[10]; cin&gt;&gt;a&gt;&gt;b; if(strlen(a)!&#x3D;strlen(b)) cout&lt;&lt;&quot;1&quot;; else&#123; for(int i&#x3D;0;i&lt;strlen(a);i++) &#123; int t&#x3D;a[i]-b[i]; if(!(t&#x3D;&#x3D;32||t&#x3D;&#x3D;-32||t&#x3D;&#x3D;0)) &#123;cout&lt;&lt;&quot;4&quot;;return 0; &#125; else if(t!&#x3D;0) &#123; cout&lt;&lt;&quot;3&quot;; return 0; &#125; &#125; cout&lt;&lt;&quot;2&quot;; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"判断条件的先后","slug":"判断条件的先后","permalink":"https://donghuangzhong.github.io/tags/%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%88%E5%90%8E/"}]},{"title":"基础练习 完美的代价","slug":"基础练习-完美的代价","date":"2020-03-14T09:59:56.000Z","updated":"2020-03-14T10:11:24.635Z","comments":true,"path":"2020/03/14/基础练习-完美的代价/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7/","excerpt":"注意交换方式是相邻互换，每次处理的范围都是[i,j]，k=j,k&gt;=i,k–。从j往前找和i一样的字符，找到了就k,j交换，记录交换次数，j–,i++；找不到则判断总数奇偶，偶则直接输出不可能，奇则做一个标记(因为总数是奇数可以允许一个字符不成对，但这个字符必须在中间)，然后记录将i移动到中间的步数(注意只是记录而不移动，因为移动了也会被再次打乱)，i++，继续从下一个找,如果有遇到一个找不到的，直接输出不可能","text":"注意交换方式是相邻互换，每次处理的范围都是[i,j]，k=j,k&gt;=i,k–。从j往前找和i一样的字符，找到了就k,j交换，记录交换次数，j–,i++；找不到则判断总数奇偶，偶则直接输出不可能，奇则做一个标记(因为总数是奇数可以允许一个字符不成对，但这个字符必须在中间)，然后记录将i移动到中间的步数(注意只是记录而不移动，因为移动了也会被再次打乱)，i++，继续从下一个找,如果有遇到一个找不到的，直接输出不可能 问题试题 基础练习 完美的代价提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。 交换的定义是：交换两个相邻的字符 例如mamad 第一次交换 ad : mamda 第二次交换 md : madma 第三次交换 ma : madam (回文！完美！) 输入格式 第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000) 第二行是一个字符串，长度为N.只包含小写字母 输出格式 如果可能，输出最少的交换次数。 否则输出Impossible 样例输入5mamad 样例输出3 算法1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n; char s[8001]; cin&gt;&gt;n&gt;&gt;s; int j&#x3D;n-1,sum&#x3D;0; bool flag&#x3D;0; for(int i&#x3D;0;i&lt;&#x3D;j;i++) &#123; for(int k&#x3D;j;k&gt;&#x3D;i;k--) &#123; if(i&#x3D;&#x3D;k) &#123; if(flag||(n&amp;1)&#x3D;&#x3D;0) &#123; cout &lt;&lt; &quot;Impossible&quot;; return 0; &#125; flag&#x3D;1; sum+&#x3D;n&#x2F;2-i; &#125; else if(s[i]&#x3D;&#x3D;s[k]) &#123; for(int i&#x3D;k;i&lt;&#x3D;j-1;i++) &#123; swap(s[i],s[i+1]); sum++; &#125; j--; break; &#125; &#125; &#125; cout&lt;&lt;sum;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"回文","slug":"ACM/回文","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%9B%9E%E6%96%87/"}],"tags":[{"name":"移动成回文最短","slug":"移动成回文最短","permalink":"https://donghuangzhong.github.io/tags/%E7%A7%BB%E5%8A%A8%E6%88%90%E5%9B%9E%E6%96%87%E6%9C%80%E7%9F%AD/"}]},{"title":"基础练习 数的读法","slug":"基础练习-数的读法","date":"2020-03-14T09:21:46.000Z","updated":"2020-03-14T09:59:32.837Z","comments":true,"path":"2020/03/14/基础练习-数的读法/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E6%95%B0%E7%9A%84%E8%AF%BB%E6%B3%95/","excerpt":"先看题目的规模，最大到十亿的单位。中文的数字单位有个特点，个十百千一组，万一组，亿一组。也就是读一个数先读亿前面的个十百千读法，然后加上亿，然后再读亿到万的个十百千读法，然后再读万，然后再读个十百千。比如12 3456 7890，先读亿前面的数字，十二，然后加上亿，在读亿和万之间的数字，三千四百五十六，然后加上万，然后读七千八百九十，最终读十二亿三千四百五十六万七千八百九十。还有一些其他的一些细节。","text":"先看题目的规模，最大到十亿的单位。中文的数字单位有个特点，个十百千一组，万一组，亿一组。也就是读一个数先读亿前面的个十百千读法，然后加上亿，然后再读亿到万的个十百千读法，然后再读万，然后再读个十百千。比如12 3456 7890，先读亿前面的数字，十二，然后加上亿，在读亿和万之间的数字，三千四百五十六，然后加上万，然后读七千八百九十，最终读十二亿三千四百五十六万七千八百九十。还有一些其他的一些细节。 问题试题 基础练习 数的读法提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 Tom教授正在给研究生讲授一门关于基因的课程，有一件事情让他颇为头疼：一条染色体上有成千上万个碱基对，它们从0开始编号，到几百万，几千万，甚至上亿。 比如说，在对学生讲解第1234567009号位置上的碱基时，光看着数字是很难准确的念出来的。 所以，他迫切地需要一个系统，然后当他输入12 3456 7009时，会给出相应的念法： 十二亿三千四百五十六万七千零九 用汉语拼音表示为 shi er yi san qian si bai wu shi liu wan qi qian ling jiu 这样他只需要照着念就可以了。 你的任务是帮他设计这样一个系统：给定一个阿拉伯数字串，你帮他按照中文读写的规范转为汉语拼音字串，相邻的两个音节用一个空格符格开。 注意必须严格按照规范，比如说“10010”读作“yi wan ling yi shi”而不是“yi wan ling shi”，“100000”读作“shi wan”而不是“yi shi wan”，“2000”读作“er qian”而不是“liang qian”。 输入格式 有一个数字串，数值大小不超过2,000,000,000。 输出格式 是一个由小写英文字母，逗号和空格组成的字符串，表示该数的英文读法。 样例输入1234567009 样例输出shi er yi san qian si bai wu shi liu wan qi qian ling jiu 算法知道了大概的读法之后就可以写了，于是就需要一个数组存数字的读法，一个数组存单位的读法，这里不需要个位，将个位置空就行，因为我们平时也不读个位。然后判断输入的规模到亿了吗？如果到亿(倒数第九位)了就将单位数组和亿对齐，并将个位置“yi”,到万(倒数第五位)则跟万对齐，个位置“wan”，否则对齐最后一位,个位置空。例如 12 3456 7890 10 ​ 3210 ​ 3210 第二三四行代表数组单位的下标，此时的对齐的标准是亿，个位置“yi”,然后读一个数字读一个单位，读出&quot;yi shi er yi&quot;，注意此时的个位置&quot;yi&quot;，所以读出&quot;yi&quot;。这样就可以读出数来了，然而还是存在一些问题，比如，12(仅限开头，412中的1还是要读的)应读作”shi er”而不是“yi shi er”,这个问题很好解决，加一个判断的条件，开头为1单位是“shi”的时候不读yi”。102应读作“yi bai ling er”而不是“yi bai ling shi er”,这个问题也很好解决，零的时候数字和单位都不读，如果遇到非零数字的上一个数字是零就多读一个“ling ”。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; char s[11]; cin&gt;&gt;s; string shu[10]&#x3D;&#123;&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;&#125;; string d[6]&#x3D;&#123;&quot;&quot;,&quot;shi&quot;,&quot;bai&quot;,&quot;qian&quot;,&quot;wan&quot;,&quot;yi&quot;&#125;; int len&#x3D;strlen(s); int p; for(int i&#x3D;0;i&lt;strlen(s);i++) &#123; if(strlen(s)-i&gt;&#x3D;9) p&#x3D;9; else if(strlen(s)-i&gt;&#x3D;5) p&#x3D;5; else p&#x3D;1; int j&#x3D;strlen(s)-p-i; if(s[i]!&#x3D;&#39;0&#39;) &#123; if(p&#x3D;&#x3D;9) d[0]&#x3D;&quot;yi &quot;; else if(p&#x3D;&#x3D;5) d[0]&#x3D;&quot;wan &quot;; else d[0]&#x3D;&quot;&quot;; if(i&gt;&#x3D;1&amp;&amp;s[i-1]&#x3D;&#x3D;&#39;0&#39;) cout&lt;&lt;&quot;ling&quot;&lt;&lt;&quot; &quot;; if(!(i&#x3D;&#x3D;0&amp;&amp;s[i]&#x3D;&#x3D;&#39;1&#39;&amp;&amp;j&#x3D;&#x3D;1)) cout&lt;&lt;shu[s[i]-&#39;0&#39;]&lt;&lt;&quot; &quot;; if(j!&#x3D;0) cout&lt;&lt;d[j]&lt;&lt;&quot; &quot;; &#125; if(j&#x3D;&#x3D;0) &#123; cout&lt;&lt;d[0]; d[0]&#x3D;&quot;&quot;; &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"读数字","slug":"读数字","permalink":"https://donghuangzhong.github.io/tags/%E8%AF%BB%E6%95%B0%E5%AD%97/"}]},{"title":"基础练习 时间转换","slug":"基础练习-时间转换","date":"2020-03-14T09:10:50.000Z","updated":"2020-03-14T09:21:25.741Z","comments":true,"path":"2020/03/14/基础练习-时间转换/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/","excerpt":"十进制转六十进制的倒数第三位","text":"十进制转六十进制的倒数第三位 题目试题 基础练习 时间转换提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 给定一个以秒为单位的时间t，要求用“::”的格式来表示这个时间。表示时间，表示分钟，而表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。 输入格式 输入只有一行，是一个整数t（0&lt;=t&lt;=86399）。 输出格式 输出只有一行，是以“::”的格式所表示的时间，不包括引号。 样例输入0 样例输出0:0:0 样例输入5436 样例输出1:30:36 算法1234567891011121314#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int t; cin&gt;&gt;t; int h&#x3D;t&#x2F;(60*60); t-&#x3D;h*(60*60); int m&#x3D;t&#x2F;60; t-&#x3D;m*60; cout&lt;&lt;h&lt;&lt;&quot;:&quot;&lt;&lt;m&lt;&lt;&quot;:&quot;&lt;&lt;t;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"进制","slug":"ACM/进制","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%BF%9B%E5%88%B6/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"基础练习 矩阵乘法","slug":"基础练习-矩阵乘法","date":"2020-03-14T08:27:26.000Z","updated":"2020-03-14T09:10:18.994Z","comments":true,"path":"2020/03/14/基础练习-矩阵乘法/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/","excerpt":"整数的乘法初始化为1，矩阵的乘法初始化为大小相同单位矩阵(只有对角线全是1)。必须由第三个变量保存结果。for循环不仅控制次数还控制积和被乘数每次的变换。","text":"整数的乘法初始化为1，矩阵的乘法初始化为大小相同单位矩阵(只有对角线全是1)。必须由第三个变量保存结果。for循环不仅控制次数还控制积和被乘数每次的变换。 问题试题 基础练习 矩阵乘法提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 给定一个N阶矩阵A，输出A的M次幂（M是非负整数） 例如： A = 1 2 3 4 A的2次幂 7 10 15 22 输入格式 第一行是一个正整数N、M（1&lt;=N&lt;=30, 0&lt;=M&lt;=5），表示矩阵A的阶数和要求的幂数 接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值 输出格式 输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开 样例输入2 21 23 4 样例输出7 1015 22 算法1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int juzhen[30][30],jieguo[2][30][30],nn&#x3D;0; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i&#x3D;0;i&lt;n;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; cin&gt;&gt;juzhen[i][j]; jieguo[0][i][j]&#x3D;i&#x3D;&#x3D;j?1:0; &#125; &#125; for(int i&#x3D;0;i&lt;m;i++) &#123; nn&#x3D;i&amp;1?0:1; for(int j&#x3D;0;j&lt;n;j++) &#123; for(int k&#x3D;0;k&lt;n;k++) &#123; int sum&#x3D;0; for(int l&#x3D;0;l&lt;n;l++) &#123; sum+&#x3D;jieguo[1-nn][j][l]*juzhen[l][k]; &#125; jieguo[nn][j][k]&#x3D;sum; &#125; &#125; &#125; for(int j&#x3D;0;j&lt;n;j++) &#123; for(int k&#x3D;0;k&lt;n;k++) cout&lt;&lt;jieguo[nn][j][k]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"矩阵乘法","slug":"ACM/矩阵乘法","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"}],"tags":[{"name":"妙用下标和","slug":"妙用下标和","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E4%B8%8B%E6%A0%87%E5%92%8C/"}]},{"title":"基础练习 矩形面积交","slug":"基础练习-矩形面积交","date":"2020-03-14T08:16:17.000Z","updated":"2020-03-14T08:26:58.826Z","comments":true,"path":"2020/03/14/基础练习-矩形面积交/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E4%BA%A4/","excerpt":"如果判断一个线段跟另一个线段相交的长度的话，起点就是两个线段起点的最大值，终点就是两个线段的终点的最小值。然后判断一下终点是不是比起点大，如果终点比起点小的话就不相交。但因为我们通常不知道线段的起点和终点，所以要进行比较。所以这个方法也可以推广到n维。","text":"如果判断一个线段跟另一个线段相交的长度的话，起点就是两个线段起点的最大值，终点就是两个线段的终点的最小值。然后判断一下终点是不是比起点大，如果终点比起点小的话就不相交。但因为我们通常不知道线段的起点和终点，所以要进行比较。所以这个方法也可以推广到n维。 问题试题 基础练习 矩形面积交提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。 输入格式 输入仅包含两行，每行描述一个矩形。 在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。 输出格式 输出仅包含一个实数，为交的面积，保留到小数后两位。 样例输入1 1 3 32 2 4 4 样例输出1.00 算法1234567891011121314151617#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; double a[8]; for(int i&#x3D;0;i&lt;8;i++) cin&gt;&gt;a[i]; double xmin&#x3D;max(min(a[0],a[2]),min(a[4],a[6])); double xmax&#x3D;min(max(a[0],a[2]),max(a[4],a[6])); double ymin&#x3D;max(min(a[1],a[3]),min(a[5],a[7])); double ymax&#x3D;min(max(a[1],a[3]),max(a[5],a[7])); if(xmin&lt;xmax&amp;&amp;ymin&lt;ymax) printf(&quot;%.2f&quot;,(xmax-xmin)*(ymax-ymin)); else cout&lt;&lt;&quot;0.00&quot;;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"线段交","slug":"ACM/线段交","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%BA%BF%E6%AE%B5%E4%BA%A4/"}],"tags":[{"name":"n维交","slug":"n维交","permalink":"https://donghuangzhong.github.io/tags/n%E7%BB%B4%E4%BA%A4/"}]},{"title":"基础练习 分解质因数","slug":"基础练习-分解质因数","date":"2020-03-14T08:11:19.000Z","updated":"2020-03-14T08:14:48.337Z","comments":true,"path":"2020/03/14/基础练习-分解质因数/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/","excerpt":"有好多种做法，最快的应该是从小到大打印素数表，然后挨个除。但是我觉得打印素数表太麻烦，于是就从2开始挨个除然后输出。","text":"有好多种做法，最快的应该是从小到大打印素数表，然后挨个除。但是我觉得打印素数表太麻烦，于是就从2开始挨个除然后输出。 题目试题 基础练习 分解质因数提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 求出区间[a,b]中所有整数的质因数分解。 输入格式 输入两个整数a，b。 输出格式 每行输出一个数的分解，形如k=a1a2a3…(a1&lt;=a2&lt;=a3…，k也是从小到大的)(具体可看样例) 样例输入3 10 样例输出3=34=225=56=237=78=2229=3310=25 提示 先筛出所有素数，然后再分解。 数据规模和约定 2&lt;=a&lt;=b&lt;=10000 算法1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;void zhiyinshu(int n)&#123; for(int i&#x3D;2;i&lt;&#x3D;n;i++) &#123; if(n%i&#x3D;&#x3D;0) &#123; n&#x2F;&#x3D;i; if(n&#x3D;&#x3D;1) cout&lt;&lt;i&lt;&lt;endl; else cout&lt;&lt;i&lt;&lt;&quot;*&quot;; i--; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int m,n; cin&gt;&gt;m&gt;&gt;n; for(int i&#x3D;m;i&lt;&#x3D;n;i++) &#123; cout&lt;&lt;i&lt;&lt;&quot;&#x3D;&quot;; zhiyinshu(i); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"质因数","slug":"ACM/质因数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%B4%A8%E5%9B%A0%E6%95%B0/"}],"tags":[{"name":"分解质因数","slug":"分解质因数","permalink":"https://donghuangzhong.github.io/tags/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/"}]},{"title":"基础练习 Sine之舞","slug":"基础练习-Sine之舞","date":"2020-03-14T08:08:27.000Z","updated":"2020-03-14T08:10:50.527Z","comments":true,"path":"2020/03/14/基础练习-Sine之舞/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-Sine%E4%B9%8B%E8%88%9E/","excerpt":"仔细观察，嵌套方式，然后写出来就行","text":"仔细观察，嵌套方式，然后写出来就行 问题试题 基础练习 Sine之舞提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 最近FJ为他的奶牛们开设了数学分析课，FJ知道若要学好这门课，必须有一个好的三角函数基本功。所以他准备和奶牛们做一个“Sine之舞”的游戏，寓教于乐，提高奶牛们的计算能力。 不妨设 An=sin(1–sin(2+sin(3–sin(4+…sin(n))…) Sn=(…(A1+n)A2+n-1)A3+…+2)An+1 FJ想让奶牛们计算Sn的值，请你帮助FJ打印出Sn的完整表达式，以方便奶牛们做题。 输入格式 仅有一个数：N&lt;201。 输出格式 请输出相应的表达式Sn，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。 样例输入3 样例输出((sin(1)+3)sin(1–sin(2))+2)sin(1–sin(2+sin(3)))+1 算法12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;void p(int s,int e)&#123; if(s&#x3D;&#x3D;e) &#123; printf(&quot;sin(%d)&quot;,e); return ; &#125; char c&#x3D;s&amp;1?&#39;-&#39;:&#39;+&#39;; printf(&quot;sin(%d%c&quot;,s,c); p(s+1,e); cout&lt;&lt;&quot;)&quot;;&#125;void pp(int an,int nn)&#123; if(an&#x3D;&#x3D;1) &#123; p(1,an); cout&lt;&lt;&quot;+&quot;&lt;&lt;nn; return ; &#125; cout&lt;&lt;&quot;(&quot;; pp(an-1,nn+1); cout&lt;&lt;&quot;)&quot;; p(1,an); cout&lt;&lt;&quot;+&quot;&lt;&lt;nn;&#125;int main()&#123; int n; cin&gt;&gt;n; pp(n,1);&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"递归","slug":"ACM/递归","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%92%E5%BD%92/"}],"tags":[{"name":"逻辑","slug":"逻辑","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91/"}]},{"title":"基础练习 FJ的字符串","slug":"基础练习-FJ的字符串","date":"2020-03-14T08:05:02.000Z","updated":"2020-03-14T08:07:29.021Z","comments":true,"path":"2020/03/14/基础练习-FJ的字符串/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-FJ%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"仔细观察就是二叉树的中序遍历","text":"仔细观察就是二叉树的中序遍历 题目试题 基础练习 FJ的字符串提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 FJ在沙盘上写了这样一些字符串： A1 = “A” A2 = “ABA” A3 = “ABACABA” A4 = “ABACABADABACABA” … … 你能找出其中的规律并写所有的数列AN吗？ 输入格式 仅有一个数：N ≤ 26。 输出格式 请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。 样例输入3 样例输出ABACABA 算法123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;void p(char c)&#123; if(c&#x3D;&#x3D;&#39;A&#39;) &#123; cout&lt;&lt;c; return ; &#125; p(c-1); cout&lt;&lt;c; p(c-1);&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; p(&#39;A&#39;-1+n); cout&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"递归","slug":"ACM/递归","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%92%E5%BD%92/"}],"tags":[{"name":"逻辑","slug":"逻辑","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"}]},{"title":"C++ to_string编写","slug":"C-to-string编写","date":"2020-03-13T01:38:31.000Z","updated":"2020-03-13T01:43:24.525Z","comments":true,"path":"2020/03/13/C-to-string编写/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/13/C-to-string%E7%BC%96%E5%86%99/","excerpt":"dev c++ 中不能用to_string函数，于是就自己用泛型写了一个。函数模板是函数的模板，需要经过编译两次，第一次检查错误，第二次生成具体的函数。","text":"dev c++ 中不能用to_string函数，于是就自己用泛型写了一个。函数模板是函数的模板，需要经过编译两次，第一次检查错误，第二次生成具体的函数。 1234567891011#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;template &lt;typename T &gt;string to_string(T i)&#123; stringstream s; s&lt;&lt;i; return s.str();&#125;","categories":[{"name":"tools","slug":"tools","permalink":"https://donghuangzhong.github.io/categories/tools/"},{"name":"C++","slug":"tools/C","permalink":"https://donghuangzhong.github.io/categories/tools/C/"}],"tags":[{"name":"泛型编程","slug":"泛型编程","permalink":"https://donghuangzhong.github.io/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"},{"name":"函数模板","slug":"函数模板","permalink":"https://donghuangzhong.github.io/tags/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"}]},{"title":"基础练习 芯片测试","slug":"基础练习-芯片测试","date":"2020-03-12T05:50:39.000Z","updated":"2020-03-12T05:50:39.301Z","comments":true,"path":"2020/03/12/基础练习-芯片测试/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E8%8A%AF%E7%89%87%E6%B5%8B%E8%AF%95/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"基础练习 龟兔赛跑预测","slug":"基础练习-龟兔赛跑预测","date":"2020-03-12T04:15:22.000Z","updated":"2020-03-12T04:27:38.052Z","comments":true,"path":"2020/03/12/基础练习-龟兔赛跑预测/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E9%A2%84%E6%B5%8B/","excerpt":"结果一定是一个整数，题中说是两个速度的公倍数。必须一秒一秒的走，当兔子领先t米时，后退v1*s米就行，这样再经过s秒之后回到后退前的位置","text":"结果一定是一个整数，题中说是两个速度的公倍数。必须一秒一秒的走，当兔子领先t米时，后退v1*s米就行，这样再经过s秒之后回到后退前的位置 题目试题 基础练习 龟兔赛跑预测提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 话说这个世界上有各种各样的兔子和乌龟，但是研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。 然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。 输入格式 输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt;=100;t&lt;=300;s&lt;=10;l&lt;=10000且为v1,v2的公倍数) 输出格式 输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。 第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。 样例输入10 5 5 2 20 样例输出D4 样例输入10 5 5 1 20 样例输出R3 样例输入10 5 5 3 20 样例输出T4 算法12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;void shuchu(int , int , int , int , int );int main(void)&#123; int v1,v2,t,s,l; scanf(&quot;%d%d%d%d%d&quot;, &amp;v1 , &amp;v2 , &amp;t , &amp;s , &amp;l ); shuchu( v1 , v2 , t , s , l ); return 0;&#125;void shuchu(int v1 , int v2 , int t , int s , int l )&#123; int s1&#x3D; 0 , s2 &#x3D; 0 ,i &#x3D; 0; while(s1 &lt; l &amp;&amp; s2 &lt; l) &#123; s1 +&#x3D;v1 ; s2 +&#x3D;v2 ; i ++ ; if( s1 &#x3D;&#x3D; l || s2 &#x3D;&#x3D; l) &#123; break; &#125; if(s1-s2 &gt;&#x3D; t) &#123; s1-&#x3D; v1 * s; &#125; &#x2F;&#x2F;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s1&lt;&lt;&quot; &quot;&lt;&lt;s2&lt;&lt;endl; &#125; if(s1 &gt; s2 ) &#123; printf(&quot;R\\n&quot;); &#125; if( s2 &gt; s1) &#123; printf(&quot;T\\n&quot;); &#125; if(s1 &#x3D;&#x3D; s2) &#123; printf(&quot;D\\n&quot;); &#125; printf(&quot;%d&quot;, i );&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"龟兔赛跑","slug":"龟兔赛跑","permalink":"https://donghuangzhong.github.io/tags/%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91/"}]},{"title":"基础练习 回形取数","slug":"基础练习-回形取数","date":"2020-03-12T02:17:09.000Z","updated":"2020-03-12T02:21:41.638Z","comments":true,"path":"2020/03/12/基础练习-回形取数/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/","excerpt":"将一个方向的点遍历并输出，直到碰壁，然后改变方向，然后再输出……。不能用dfs因为需要的是碰壁再换方向，而不是每次都改变方向。","text":"将一个方向的点遍历并输出，直到碰壁，然后改变方向，然后再输出……。不能用dfs因为需要的是碰壁再换方向，而不是每次都改变方向。 问题试题 基础练习 回形取数提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 回形取数就是沿矩阵的边取数，若当前方向上无数可取或已经取过，则左转90度。一开始位于矩阵左上角，方向向下。 输入格式 输入第一行是两个不超过200的正整数m, n，表示矩阵的行和列。接下来m行每行n个整数，表示这个矩阵。 输出格式 输出只有一行，共mn个数，为输入矩阵回形取数得到的结果。数之间用一个空格分隔，行末不要有多余的空格。 样例输入3 31 2 34 5 67 8 9 样例输出1 4 7 8 9 6 3 2 5 样例输入3 21 23 45 6 样例输出1 3 5 6 4 2 算法12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;&#x2F;&#x2F;#include&lt;map&gt;#define PI 3.14159265358979323#define MAX 0x3f3f3f3fusing namespace std;int map[210][210],m,n,sum&#x3D;1,x,y;int dir[4][2]&#x3D;&#123;1,0,0,1,-1,0,0,-1&#125;;int main()&#123; &#x2F;&#x2F;freopen(&quot;input2.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;m&gt;&gt;n; for(int i&#x3D;0;i&lt;m;i++) for(int j&#x3D;0;j&lt;n;j++) cin&gt;&gt;map[i][j]; x&#x3D;y&#x3D;0; cout&lt;&lt;map[0][0]; map[x][y]&#x3D;-1; while(sum!&#x3D;m*n) &#123; for(int i&#x3D;0;i&lt;4;i++) &#123; int xx&#x3D;x+dir[i][0]; int yy&#x3D;y+dir[i][1]; while(xx&gt;&#x3D;0&amp;&amp;xx&lt;m&amp;&amp;yy&gt;&#x3D;0&amp;&amp;yy&lt;n&amp;&amp;map[xx][yy]!&#x3D;-1) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;map[xx][yy]; map[xx][yy]&#x3D;-1; x&#x3D;xx; y&#x3D;yy; sum++; xx&#x3D;x+dir[i][0]; yy&#x3D;y+dir[i][1]; &#125; &#125; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"回形取数","slug":"回形取数","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/"}]},{"title":"基础练习 报时助手","slug":"基础练习-报时助手","date":"2020-03-12T02:12:49.000Z","updated":"2020-03-12T02:16:36.655Z","comments":true,"path":"2020/03/12/基础练习-报时助手/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E6%8A%A5%E6%97%B6%E5%8A%A9%E6%89%8B/","excerpt":"由于0~23都有完整的字符串，所以20,30,40,50要连续存储，求他们的十位数加上一个偏移量","text":"由于0~23都有完整的字符串，所以20,30,40,50要连续存储，求他们的十位数加上一个偏移量 问题试题 基础练习 报时助手提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 给定当前的时间，请用英文的读法将它读出来。 时间用时h和分m表示，在英文的读法中，读一个时间的方法是： 如果m为0，则将时读出来，然后加上“o’clock”，如3:00读作“three o’clock”。 如果m不为0，则将时读出来，然后将分读出来，如5:30读作“five thirty”。 时和分的读法使用的是英文数字的读法，其中0~20读作： 0:zero, 1: one, 2:two, 3:three, 4:four, 5:five, 6:six, 7:seven, 8:eight, 9:nine, 10:ten, 11:eleven, 12:twelve, 13:thirteen, 14:fourteen, 15:fifteen, 16:sixteen, 17:seventeen, 18:eighteen, 19:nineteen, 20:twenty。 30读作thirty，40读作forty，50读作fifty。 对于大于20小于60的数字，首先读整十的数，然后再加上个位数。如31首先读30再加1的读法，读作“thirty one”。 按上面的规则21:54读作“twenty one fifty four”，9:07读作“nine seven”，0:15读作“zero fifteen”。 输入格式 输入包含两个非负整数h和m，表示时间的时和分。非零的数字前没有前导0。h小于24，m小于60。 输出格式 输出时间时刻的英文。 样例输入0 15 样例输出zero fifteen 算法123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;map&gt;#define PI 3.14159265358979323#define MAX 0x3f3f3f3fusing namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); string yingshe[]&#x3D;&#123;&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;,&quot;ten&quot;,&quot;eleven&quot;,&quot;twelve&quot;,&quot;thirteen&quot;,&quot;fourteen&quot;,&quot;fifteen&quot;,&quot;sixteen&quot;,&quot;seventeen&quot;,&quot;eighteen&quot;,&quot;nineteen&quot;,&quot;twenty&quot;,&quot;twenty one&quot;,&quot;twenty two&quot;,&quot;twenty three&quot;,&quot;twenty&quot;,&quot;thirty&quot;,&quot;forty&quot;,&quot;fifty&quot;&#125;; int h,m; cin&gt;&gt;h&gt;&gt;m; cout&lt;&lt;yingshe[h]&lt;&lt;&quot; &quot;; if(m&#x3D;&#x3D;0) &#123; cout&lt;&lt;&quot;o&#39;clock&quot;; &#125; else if(m&gt;0&amp;&amp;m&lt;&#x3D;23) cout&lt;&lt;yingshe[m]; else &#123; int s&#x3D;m&#x2F;10+2; int g&#x3D;m%10; cout&lt;&lt;yingshe[20+s]&lt;&lt;&quot; &quot;&lt;&lt;yingshe[g]; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"字符串数组","slug":"字符串数组","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84/"}]},{"title":"基础练习 2n皇后问题","slug":"基础练习-2n皇后问题","date":"2020-03-12T02:01:47.000Z","updated":"2020-03-12T02:12:26.853Z","comments":true,"path":"2020/03/12/基础练习-2n皇后问题/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-2n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/","excerpt":"不能用dfs并行运算，会重复，可以举例2*2的棋盘，必须分开算","text":"不能用dfs并行运算，会重复，可以举例2*2的棋盘，必须分开算 问题试题 基础练习 Huffuman树提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。 给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下： 1. 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa + pb。 2. 重复步骤1，直到{pi}中只剩下一个数。 在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。 本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。 例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下： 1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。 2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。 3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。 4. 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。 5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。 输入格式 输入的第一行包含一个正整数n（n&lt;=100）。 接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。 输出格式 输出用这些数构造Huffman树的总费用。 样例输入55 3 8 2 9 样例输出59 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#define PI 3.14159265358979323#define MAX 0x3f3f3f3fusing namespace std;int lieh[9],lieb[9];int map[9][9],n,sum&#x3D;0;bool judgeh(int x,int y)&#123; if(map[x][y]&#x3D;&#x3D;0) return 0; if(lieh[y]!&#x3D;0) return 0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(lieh[i]!&#x3D;0) &#123; double t&#x3D;(i-y)&#x2F;double(lieh[i]-x); if(t&#x3D;&#x3D;1||t&#x3D;&#x3D;-1) &#123; return 0; &#125; &#125; &#125; return 1;&#125;bool judgeb(int x,int y)&#123; if(map[x][y]&#x3D;&#x3D;0) return 0; if(lieb[y]!&#x3D;0||lieh[y]&#x3D;&#x3D;x) return 0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(lieb[i]!&#x3D;0) &#123; double t&#x3D;(i-y)&#x2F;double(lieb[i]-x); if(t&#x3D;&#x3D;1||t&#x3D;&#x3D;-1) &#123; return 0; &#125; &#125; &#125; return 1; &#125;void dfsb(int h)&#123; if(h&#x3D;&#x3D;n+1) &#123; sum++; return ; &#125; for(int i&#x3D;0;i&lt;&#x3D;n;i++) &#123; if(judgeb(h,i)) &#123; lieb[i]&#x3D;h; dfsb(h+1); lieb[i]&#x3D;0; &#125; &#125;&#125;void dfsh(int h)&#123; if(h&#x3D;&#x3D;n+1) &#123; dfsb(1); return ; &#125; for(int i&#x3D;0;i&lt;&#x3D;n;i++) &#123; if(judgeh(h,i)) &#123; lieh[i]&#x3D;h; dfsh(h+1); lieh[i]&#x3D;0; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; cin&gt;&gt;map[i][j]; &#125; &#125; memset(lieh,0,sizeof(lieh)); memset(lieb,0,sizeof(lieb)); dfsh(1); cout&lt;&lt;sum&lt;&lt;endl; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dfs","slug":"ACM/dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/dfs/"}],"tags":[{"name":"八皇后问题","slug":"八皇后问题","permalink":"https://donghuangzhong.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"name":"黑白子","slug":"黑白子","permalink":"https://donghuangzhong.github.io/tags/%E9%BB%91%E7%99%BD%E5%AD%90/"}]},{"title":"基础练习 Huffuman树","slug":"基础练习-Huffuman树","date":"2020-03-12T01:55:32.000Z","updated":"2020-03-12T02:01:13.715Z","comments":true,"path":"2020/03/12/基础练习-Huffuman树/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-Huffuman%E6%A0%91/","excerpt":"用两个变量保存最小值，用两个变量保存两个最小值的下标，然后相加放入其中一个变量，另一个变量置无穷大，n个变量需要n-1步操作变成最后的一个变量，记录他们的和","text":"用两个变量保存最小值，用两个变量保存两个最小值的下标，然后相加放入其中一个变量，另一个变量置无穷大，n个变量需要n-1步操作变成最后的一个变量，记录他们的和 问题试题 基础练习 Huffuman树提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。 给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下： 1. 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa + pb。 2. 重复步骤1，直到{pi}中只剩下一个数。 在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。 本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。 例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下： 1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。 2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。 3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。 4. 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。 5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。 输入格式 输入的第一行包含一个正整数n（n&lt;=100）。 接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。 输出格式 输出用这些数构造Huffman树的总费用。 样例输入55 3 8 2 9 样例输出59 算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;#include&lt;queue&gt;#define PI 3.14159265358979323#define MAX 0x3f3f3f3fusing namespace std;int main()&#123; int hf[100]; int n,minn1,minn2,index1,index2,sum&#x3D;0; cin&gt;&gt;n; for(int i&#x3D;0;i&lt;n;i++) &#123; cin&gt;&gt;hf[i]; &#125; for(int i&#x3D;0;i&lt;n-1;i++) &#123; minn1&#x3D;MAX; minn2&#x3D;MAX; for(int j&#x3D;0;j&lt;n;j++) &#123; if(hf[j]&lt;minn2) &#123; if(hf[j]&lt;minn1) &#123; minn2&#x3D;minn1; index2&#x3D;index1; minn1&#x3D;hf[j]; index1&#x3D;j; &#125; else &#123;minn2&#x3D;hf[j]; index2&#x3D;j; &#125; &#125; &#125; hf[index1]&#x3D;minn1+minn2; sum+&#x3D;hf[index1]; hf[index2]&#x3D;MAX; &#125; cout&lt;&lt;sum; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Huffuman","slug":"ACM/Huffuman","permalink":"https://donghuangzhong.github.io/categories/ACM/Huffuman/"}],"tags":[{"name":"两个最小值","slug":"两个最小值","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%A4%E4%B8%AA%E6%9C%80%E5%B0%8F%E5%80%BC/"}]},{"title":"基础练习 阶乘计算","slug":"基础练习-阶乘计算","date":"2020-03-12T01:46:49.000Z","updated":"2020-03-12T01:54:44.453Z","comments":true,"path":"2020/03/12/基础练习-阶乘计算/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97/","excerpt":"m位数乘以n位数的最大位数是（m+1）*n（n&lt;m）","text":"m位数乘以n位数的最大位数是（m+1）*n（n&lt;m） 问题试题 基础练习 阶乘计算提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 输入一个正整数n，输出n!的值。 其中n!=123…*n*。 算法描述 n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。 将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。 首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。 输入格式 输入包含一个正整数n，n&lt;=1000。 输出格式 输出n!的准确值。 样例输入10 样例输出3628800 算法累乘，每次除10，求出i的位数，用len保存当前结果的位数，(len+1)*i的位数就是新结果的最大范围，依次更新并记录结果的实际位数 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;#include&lt;queue&gt;#define PI 3.14159265358979323using namespace std;int a[2600];int main()&#123; int n; cin&gt;&gt;n; memset(a,0,sizeof(a)); a[1]&#x3D;1; int jinwei&#x3D;0; int len&#x3D;1; for(int i&#x3D;2;i&lt;&#x3D;n;i++) &#123; int tlen&#x3D;len,t&#x3D;i; int wei&#x3D;0; while(t!&#x3D;0) &#123; t&#x2F;&#x3D;10; wei++; &#125; for(int j&#x3D;1;j&lt;&#x3D;(len+1)+wei;j++) &#123; a[j]&#x3D;i*a[j]+jinwei; if(a[j]&gt;&#x3D;10) &#123; jinwei&#x3D;a[j]&#x2F;10; a[j]&#x3D;a[j]%10; &#125; else jinwei&#x3D;0; if(j&gt;tlen&amp;&amp;a[j]) tlen&#x3D;j; &#125; len&#x3D;tlen; &#125; while(len) cout&lt;&lt;a[len--]; cout&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"大数","slug":"ACM/大数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0/"}],"tags":[{"name":"大数阶乘","slug":"大数阶乘","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/"}]},{"title":"POJ-1511-Invitation Cards","slug":"POJ-1511-Invitation-Cards","date":"2020-03-10T07:40:31.000Z","updated":"2020-03-10T07:52:08.464Z","comments":true,"path":"2020/03/10/POJ-1511-Invitation-Cards/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/10/POJ-1511-Invitation-Cards/","excerpt":"这个用Bellman一直超时，后来用了spfa，邻接表简直就是为spfa量身打造的，不过此题中的指针换成了变得索引，此题中由于要翻转边，所以需要把边的信息全部记下来，spfa开始的时候翻转，然后交换边的起点和终点，然后再调用一次spfa","text":"这个用Bellman一直超时，后来用了spfa，邻接表简直就是为spfa量身打造的，不过此题中的指针换成了变得索引，此题中由于要翻转边，所以需要把边的信息全部记下来，spfa开始的时候翻转，然后交换边的起点和终点，然后再调用一次spfa 题目邀请卡 时限： 8000MS 内存限制： 262144K 提交总数： 39132 接受的： 12664 描述在电视时代，很少有人参加戏剧表演。Malidinesia的古董喜剧演员知道这一事实。他们想传播戏剧，最重要的是传播古董喜剧。他们印有所有必要信息和计划的邀请卡。雇用了许多学生在人们中间分发这些邀请。每个学生志愿者都恰好分配了一个公交车站，他或她整天都呆在那里，并向乘公共汽车旅行的人发出邀请。开设了一门特殊的课程，让学生学习如何影响人以及影响力和抢劫之间的区别。 运输系统非常特殊：所有线路都是单向的，并且恰好连接两个站。公交车每半小时便有客流驶离始发站。到达目的地站后，他们返回到出发站为空，直到下一个完整的半小时，例如X：00或X：30，其中“ X”表示小时。两站之间的运输费用由特别表提供，应当场支付。线路的规划方式是，每次往返（即在同一站开始和结束的旅程）都要经过中央检查站（CCS），每位乘客都必须通过包括身体扫描在内的全面检查。 所有ACM学生成员每天早晨都离开CCS。每个志愿者将移动到一个预定的站点以邀请乘客。志愿人员的数量与站点的数量一样多。最终，所有学生都返回了CCS。您要编写一个计算机程序，以帮助ACM最大限度地减少每天支付给其员工的运输费用。 输入值输入包含N个案例。输入的第一行仅包含正整数N。然后遵循这些情况。每种情况均始于一条直线，该直线恰好包含两个整数P和Q，1 &lt;= P，Q &lt;=1000000。P是包含CCS的站点数，而Q是总线的数量。然后有Q条线，每条线描述一条总线。每行均包含三个数字-起始止损，目的地止损和价格。CCS由数字1表示。价格是正整数，其总和小于1000000000。您还可以假设始终可以从任何停靠点到达任何其他停靠点。 输出量对于每种情况，请打印一行，其中包含ACM每天为其志愿者支付的差旅费用的最低金额。 样本输入123456789101122 21 2 132 1 334 61 2 102 1 601 3 203 4 102 4 54 1 50 样本输出1246210 题目大意第一行输入测试用例，第二行分别输入顶点的个数和边的个数，剩下的行输入边的信息，起点终点费用 求来回的最小距离 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;#include&lt;queue&gt;#define N 1000005using namespace std;struct Point&#123; int start,end,price;&#125; route[N];int s,n,m,p[N],v[N],d[N],nextt[N];long long sum;void spfa()&#123; memset(p,0,(n+1)*sizeof(int)); memset(v,0,(n+1)*sizeof(int)); memset(d,0x3f,(n+1)*sizeof(int)); for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; nextt[i]&#x3D;p[route[i].start]; p[route[i].start]&#x3D;i; &#125; d[1]&#x3D;0; queue&lt;int&gt; q; q.push(1); v[1]&#x3D;1; while(!q.empty()) &#123; int a&#x3D;q.front(); q.pop(); v[a]&#x3D;0; int next&#x3D;p[a]; while(next!&#x3D;0) &#123; if(d[route[next].end]&gt;d[a]+route[next].price) &#123; d[route[next].end]&#x3D;d[a]+route[next].price; if(v[route[next].end]&#x3D;&#x3D;0) &#123; v[route[next].end]&#x3D;1; q.push(route[next].end); &#125; &#125; next&#x3D;nextt[next]; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; &#x2F;&#x2F;cout&lt;&lt;d[i]&lt;&lt;&quot; &quot;; sum+&#x3D;d[i]; &#125; &#x2F;&#x2F;cout&lt;&lt;endl;&#125;void turn()&#123; for (int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int temp&#x3D;route[i].start; route[i].start&#x3D;route[i].end; route[i].end&#x3D;temp; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int t; &#x2F;&#x2F;cin&gt;&gt;t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; sum&#x3D;0; &#x2F;&#x2F;cin&gt;&gt;n&gt;&gt;m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; &#x2F;&#x2F;cin&gt;&gt;route[i].start&gt;&gt;route[i].end&gt;&gt;route[i].price; scanf(&quot;%d%d%d&quot;,&amp;route[i].start,&amp;route[i].end,&amp;route[i].price); &#125; spfa(); turn(); spfa(); cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"SPFA","slug":"ACM/SPFA","permalink":"https://donghuangzhong.github.io/categories/ACM/SPFA/"}],"tags":[{"name":"翻转边","slug":"翻转边","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E8%BE%B9/"},{"name":"来回总和最短","slug":"来回总和最短","permalink":"https://donghuangzhong.github.io/tags/%E6%9D%A5%E5%9B%9E%E6%80%BB%E5%92%8C%E6%9C%80%E7%9F%AD/"}]},{"title":"HDU-1217-POJ-2240-Arbitrage","slug":"HDU-1217-POJ-2240-Arbitrage","date":"2020-03-09T01:58:42.000Z","updated":"2020-03-11T03:51:17.321Z","comments":true,"path":"2020/03/09/HDU-1217-POJ-2240-Arbitrage/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/09/HDU-1217-POJ-2240-Arbitrage/","excerpt":"HDU和POJ的数据都很水，这个题没说第一个货币一定在环中，但以第一种货币一定在环中的算法却都能AC，不信试试我给的测试数据，不得不说Bellman真的强，本文给出这个题的严谨证明和算法！！！不可转载谢谢！","text":"HDU和POJ的数据都很水，这个题没说第一个货币一定在环中，但以第一种货币一定在环中的算法却都能AC，不信试试我给的测试数据，不得不说Bellman真的强，本文给出这个题的严谨证明和算法！！！不可转载谢谢！ 题目套利\\时间限制：2000/1000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）提交总数：12754接受提交：5785** 问题描述套利是利用货币汇率差异将一种货币单位转换成一种以上相同货币单位。例如，假设1美元买入0.5英镑，1英镑买入10.0法国法郎，而1法国法郎买入0.21美元。然后，通过转换货币，一个聪明的交易者可以从1美元开始，买入0.5 * 10.0 * 0.21 = 1.05美元，获利5％。 您的工作是编写一个程序，该程序将货币汇率列表作为输入，然后确定是否可以进行套利。 输入值输入文件将包含一个或多个测试用例。在每个测试用例的第一行中，有一个整数n（1 &lt;= n &lt;= 30），代表不同货币的数量。接下来的n行分别包含一种货币的名称。名称中不会出现空格。下一行包含一个整数m，代表要跟随的表的长度。最后的m行分别包含源货币的名称ci，代表从ci到cj的汇率的实数rij和目标货币的名称cj。没有出现在表中的交换是不可能的。测试用例之间用空白行隔开。输入以n的零（0）值终止。 输出量对于每个测试用例，分别以“案例：是”和“案例：否”的格式打印一行，说明是否可以套利。 Sample Input123456789101112131415161718192021223USDollarBritishPoundFrenchFranc3USDollar 0.5 BritishPoundBritishPound 10.0 FrenchFrancFrenchFranc 0.21 USDollar3USDollarBritishPoundFrenchFranc6USDollar 0.5 BritishPoundUSDollar 4.9 FrenchFrancBritishPound 10.0 FrenchFrancBritishPound 1.99 USDollarFrenchFranc 0.09 BritishPoundFrenchFranc 0.19 USDollar0 Sample Output12Case 1: YesCase 2: No 算法先给出不严谨的算法(第一种货币一定在环中)，这个就不用证明了吧，这个在HDU、POJ都能AC！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;int n,m; map&lt;string,int&gt; y;struct &#123; int x,y; double h;&#125; bian[5000];double d[5000];int c&#x3D;1;bool Bellman()&#123; d[1]&#x3D;1; bool flag; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; flag&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(d[bian[j].y]&lt;d[bian[j].x]*bian[j].h) &#123; d[bian[j].y]&#x3D;d[bian[j].x]*bian[j].h; flag&#x3D;1; &#125; &#125; if(flag&#x3D;&#x3D;0) return 0; &#125; for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(d[bian[j].y]&lt;d[bian[j].x]*bian[j].h) &#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n) &#123; char a[100]; double hui; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; &#x2F;&#x2F;d[i]&#x3D;1; d[i]&#x3D;0; scanf(&quot;%s&quot;,a); y[a]&#x3D;i; &#125; cin&gt;&gt;m; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; scanf(&quot;%s%lf&quot;,a,&amp;hui); bian[i].x&#x3D;y[a]; bian[i].h&#x3D;hui; scanf(&quot;%s&quot;,a); bian[i].y&#x3D;y[a]; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;c++&lt;&lt;&quot;: &quot;; if(Bellman()) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125; 测试数据123456789104abcd3b 0.5 cc 1 dd 10 b0 这个数据将第一个点孤立了，b-&gt;c-&gt;d-&gt;b为正环，按照题目逻辑应该输出Yes,但是上述不严谨算法输出No，可见HDU、POJ数据太水了，上述不严谨算法都AC了 再给出严谨的算法，有人说遍历所有起点，多次调用Bellman，NoNoNo！还是太小看Bellman的算法，本题中如果指定第一种货币为起点则应该d[1]=1,其余全为0。严谨的做法应该是d全为1即可，但也不要生搬硬套，此题为乘法类，所以为1,如果是加法类就应该为0。如果d全为0，则起点在正负边(比如b-&gt;c为0.5倍，这是负边；d-&gt;b为10倍，为正边)交界的顶点，有人说正正边交界的顶点也是起点，那只能说你不明白Bellman算法。将正负交界的顶点放在一个集合S中，下面我来证明，一定有一个顶点q属于S,这个点到所有点都为正边(为什么要证明这个，因为碰到负边会走不下去)，现在的问题就变成了： 已知一个正环，S为正负边交界的顶点的集合，证明：一定存在点q属于S，q到此正环所有顶点的的边都为正边 将此正环相邻的相同符号的边看做一条边，即相邻的正边看做一条正边，相邻的负边看做一条负边，如下 这个是个有向图，顺时针，忘了画方向。相邻的正负(先正后负)边看做一个整体，比如上图有两部分，ad和da。这个图就有两组这样的正负边，一个正环可能有n组正负边，当n==2时，由于是一个正环，则这两组边有两种情况 1.都是正边，则结论得证 2.一正一负，那么从正的那组正负边的起点作为起点，结论得证 现在我要用数学归纳法，k==2时结论成立(k为正负边的组数，就是上面的n)，当k==k+1时,又有两种情况 1.都是正边，结论得证 2.存在负边，则将负边中任意一组去掉，变成k-1组正负边组合+一个负的正负边组合。因为整个环为正环，所以这k-1组也可以组成一个正环，k-1组正负边组成的正环符合结论，结论得证 所以可以证明，Bellman选择的起点集合中一定有一个点可以走遍整个环，附上代码，就改了d的初值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;int n,m; map&lt;string,int&gt; y;struct &#123; int x,y; double h;&#125; bian[5000];double d[5000];int c&#x3D;1;bool Bellman()&#123; &#x2F;&#x2F;d[1]&#x3D;1; bool flag; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; flag&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(d[bian[j].y]&lt;d[bian[j].x]*bian[j].h) &#123; d[bian[j].y]&#x3D;d[bian[j].x]*bian[j].h; flag&#x3D;1; &#125; &#125; if(flag&#x3D;&#x3D;0) return 0; &#125; for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(d[bian[j].y]&lt;d[bian[j].x]*bian[j].h) &#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n) &#123; char a[100]; double hui; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; d[i]&#x3D;1; &#x2F;&#x2F;d[i]&#x3D;0; scanf(&quot;%s&quot;,a); y[a]&#x3D;i; &#125; cin&gt;&gt;m; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; scanf(&quot;%s%lf&quot;,a,&amp;hui); bian[i].x&#x3D;y[a]; bian[i].h&#x3D;hui; scanf(&quot;%s&quot;,a); bian[i].y&#x3D;y[a]; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;c++&lt;&lt;&quot;: &quot;; if(Bellman()) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Bellman","slug":"ACM/Bellman","permalink":"https://donghuangzhong.github.io/categories/ACM/Bellman/"}],"tags":[{"name":"正环","slug":"正环","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E7%8E%AF/"}]},{"title":"POJ-3660-Cow Contest","slug":"POJ-3660-Cow-Contest","date":"2020-03-07T09:41:21.000Z","updated":"2020-03-07T09:59:15.242Z","comments":true,"path":"2020/03/07/POJ-3660-Cow-Contest/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/07/POJ-3660-Cow-Contest/","excerpt":"技巧：map[i][j]=map[i][j]||(map[i][k]&amp;&amp;map[k][j]);利用逻辑短路，如果map[i][i]==1说明i到j已经存在通路，直接返回1,否则判断map[i][k]&amp;&amp;map[k][j]==1，可达为1,不可达为0。","text":"技巧：map[i][j]=map[i][j]||(map[i][k]&amp;&amp;map[k][j]);利用逻辑短路，如果map[i][i]==1说明i到j已经存在通路，直接返回1,否则判断map[i][k]&amp;&amp;map[k][j]==1，可达为1,不可达为0。 题目牛比赛 时限： 1000MS 内存限制： 65536K 提交总数： 20550 接受的： 11394 描述Ñ（1≤ ñ ≤100）牛，方便地编号为1 .. Ñ，正在参与编程竞赛。众所周知，有些母牛的编码要好于其他母牛。每头母牛都有一定的恒定技能等级，这在竞争者中是独一无二的。 比赛分几个头对头进行，每回合在两头母牛之间进行。如果牛阿具有更大的技能水平比牛乙（1≤ 甲 ≤ Ñ ; 1≤ 乙 ≤ Ñ ; 甲 ≠ 乙），然后牛甲总是打牛乙。 农夫约翰试图按技能水平对母牛进行排名。给定一个列表的结果中号*（1≤ *中号 ≤4500）二牛回合，确定奶牛他们的职级从结果可以精确地确定的数量。可以保证回合的结果不会矛盾。 输入值第1行：两个以空格分隔的整数：N和*M第2行*。M +1：每行包含两个以空格分隔的整数，这些整数描述单个选手的竞争者和结果（第一个整数A是获胜者）一轮比赛：A和B 输出量*第1行：一个整数，代表可以确定其等级的母牛的数量 样本输入1234565 54 34 23 21 22 5 样本输出12 题目大意给出m个胜负关系对n个点进行排名，第一行输入n,m。剩下m行输入a,b。表示a胜过b。求通过胜负关系能确定几个点的名次。 算法用图(bool型，1表示可达，0表示不可达)的知识，Floyd算法，得到全图的可达关系，要判断第i个点能不能判断名次，去决议该点的入度和出度和是否为n-1。由于题目的输入必须有逻辑，即不能2胜1同时1胜2,所以map[i][j]与map[j][i]不能同时为1，并且不存在环(1-&gt;2-&gt;3-&gt;1)，所以map[i][i]必为0，所以可以用if(map[j][i]||map[i][j]) z++;统计次数 优化后bool图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;#define N 101int n,m;bool map[N][N];void floyd()&#123; for(int k&#x3D;1;k&lt;&#x3D;n;k++) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; map[i][j]&#x3D;map[i][j]||(map[i][k]&amp;&amp;map[k][j]); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n&gt;&gt;m; memset(map,0,sizeof(0)); for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; map[a][b]&#x3D;1; &#125; floyd(); int s&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int z&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(map[j][i]||map[i][j]) &#123; z++; &#125; &#125; if(z&#x3D;&#x3D;n-1) s++; &#125; cout&lt;&lt;s&lt;&lt;endl; return 0;&#125; 传统Floyd12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;#define N 101#define MAX 0x3f3f3f3fint map[N][N],n,m;void floyd()&#123; for(int k&#x3D;1;k&lt;&#x3D;n;k++) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(map[i][k]+map[k][j]&lt;map[i][j]) &#123; map[i][j]&#x3D;map[i][k]+map[k][j]; &#125; &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n&gt;&gt;m; for(int i&#x3D;0;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) map[i][j]&#x3D;MAX; &#125; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; map[a][b]&#x3D;1; &#125; floyd(); int z&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int l&#x3D;0; int q&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(map[j][i]!&#x3D;MAX) &#123; l++; &#125; if(map[i][j]!&#x3D;MAX) q++; &#125; if(l+q&#x3D;&#x3D;n-1) z++; &#125; cout&lt;&lt;z&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Floyd","slug":"ACM/Floyd","permalink":"https://donghuangzhong.github.io/categories/ACM/Floyd/"}],"tags":[{"name":"排名","slug":"排名","permalink":"https://donghuangzhong.github.io/tags/%E6%8E%92%E5%90%8D/"},{"name":"逻辑路径","slug":"逻辑路径","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E8%B7%AF%E5%BE%84/"}]},{"title":"POJ-1502-MPI Maelstrom","slug":"POJ-1502-MPI-Maelstrom","date":"2020-03-07T04:24:19.000Z","updated":"2020-03-07T04:36:35.248Z","comments":true,"path":"2020/03/07/POJ-1502-MPI-Maelstrom/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/07/POJ-1502-MPI-Maelstrom/","excerpt":"atoi(char *)把字符串转换成整形，还有一个string参数的方法是stoi但是在帮助文档里搜不到，但可以用s.c_str()将string转换成char *,当然也可用字符数组，但是我觉得字符数组有长度限制不大好。dij算法中邻接矩阵map[i][i]不用管，只需d[起点]=0，因为不可能访问到d[i][i]。","text":"atoi(char *)把字符串转换成整形，还有一个string参数的方法是stoi但是在帮助文档里搜不到，但可以用s.c_str()将string转换成char *,当然也可用字符数组，但是我觉得字符数组有长度限制不大好。dij算法中邻接矩阵map[i][i]不用管，只需d[起点]=0，因为不可能访问到d[i][i]。 题目MPI大漩涡 时限： 1000MS 内存限制： 10000K 提交总数： 15467 接受： 9422 描述BIT最近接受了他们的新超级计算机的交付，该超级计算机是具有分层通信子系统的32处理器Apollo Odyssey分布式共享内存计算机。Valentine McKee的研究顾问Jack Swigert要求她对新系统进行基准测试。瓦伦丁对斯维格特说：由于阿波罗是一台分布式共享存储机器，因此存储访问和通信时间并不统一。&#39;&#39;共享同一内存子系统的处理器之间的通信速度很快，但是不在同一子系统上的处理器之间的通信速度却较慢。阿波罗与我们实验室中的机器之间的通讯速度还慢一些。”“ 阿波罗的消息传递接口（MPI）的端口如何工作？”斯维格特问。 不太好，&#39;&#39;瓦伦丁回答。要将消息从一个处理器广播到所有其他n-1个处理器，它们只是执行一系列n-1发送。这确实使事情序列化并破坏了性能 .````有什么可以解决的吗？’’ 是的，&#39;&#39;情人微笑。有。一旦第一个处理器将消息发送到另一个，这两个处理器就可以同时将消息发送到另外两个主机。然后将有四个可以发送的主机，以此类推 .````啊，所以您可以像二叉树一样进行广播！’’ ``不是真正的二叉树-我们应该利用我们网络的某些特殊功能。我们拥有的接口卡允许每个处理器同时将消息发送到与其连接的任意数量的其他处理器。但是，消息不一定要同时到达目的地-涉及通信成本。总的来说，我们需要考虑网络拓扑中每个链接的通信成本，并做出相应的计划以最大程度地减少广播所需的总时间。’’ 输入值输入将描述连接n个处理器的网络的拓扑。输入的第一行将是n，即处理器的数量，因此1 &lt;= n &lt;=100 。其余的输入定义邻接矩阵A。邻接矩阵是正方形，大小为nx n。它的每个条目都是整数或字符x。A（i，j）的值表示直接从节点i向节点j发送消息的开销。A（i，j）的x值表示无法将消息直接从节点i发送到节点j。 请注意，对于节点向其自身发送消息的不需要网络通信，因此对于1 &lt;= i &lt;= n，A（i，i）= 0。另外，您可能会假定网络是无向的（消息可以以相同的开销在任一方向上传播），因此A（i，j）= A（j，i）。因此，将仅提供A的（严格）下部三角形部分上的条目。 程序的输入将是A的下部三角形部分。也就是说，输入的第二行将包含一个条目A（2,1）。下一行将包含两个条目A（3,1）和A（3,2），依此类推。 输出量您的程序应输出从第一个处理器向所有其他处理器广播消息所需的最短通信时间。 样本输入1234555030 5100 20 5010 xx 10 样本输出135 题目大意第一行输入点的数量，剩下输入邻接矩阵(双向边)的下三角，x表示不可达 算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAX 0x3f3f3f3fusing namespace std;int d[101],n;int map[101][101];bool v[101];void dij()&#123; int index; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; v[i]&#x3D;0; d[i]&#x3D;map[1][i]; &#125; v[1]&#x3D;1; d[1]&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; int minn&#x3D;MAX; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(v[j]&#x3D;&#x3D;0&amp;&amp;d[j]&lt;minn) &#123; minn&#x3D;d[j]; index&#x3D;j; &#125; &#125; v[index]&#x3D;1; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(v[j]&#x3D;&#x3D;0&amp;&amp;(d[j]&gt;d[index]+map[index][j])) &#123; d[j]&#x3D;d[index]+map[index][j]; &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; &#x2F;&#x2F;map[i][i]&#x3D;0; for(int j&#x3D;1;j&lt;i;j++) &#123; string s; cin&gt;&gt;s; if(s&#x3D;&#x3D;&quot;x&quot;) map[i][j]&#x3D;map[j][i]&#x3D;MAX; else map[i][j]&#x3D;map[j][i]&#x3D;atoi(s.c_str()); &#125; &#125; dij(); int maxx&#x3D;-1; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(d[i]&gt;maxx) &#123; maxx&#x3D;d[i]; &#125; &#125; cout&lt;&lt;maxx&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"最短路径","slug":"最短路径","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"POJ-3259-Wormholes","slug":"POJ-3259-Wormholes","date":"2020-03-07T01:17:58.264Z","updated":"2020-03-07T01:25:28.982Z","comments":true,"path":"2020/03/07/POJ-3259-Wormholes/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/07/POJ-3259-Wormholes/","excerpt":"负环，注意输入时输入的是正数，要变成负数存起来。这样可能两点之间存在三条边，但bellman对边没有要求，也可以只留两条边，但我觉得没有必要，还得搜索更改。","text":"负环，注意输入时输入的是正数，要变成负数存起来。这样可能两点之间存在三条边，但bellman对边没有要求，也可以只留两条边，但我觉得没有必要，还得搜索更改。 题目虫洞 时限： 2000MS 内存限制： 65536K 提交总数： 79083 接受： 29365 描述在探索他的许多农场时，农夫约翰发现了许多惊人的虫洞。虫洞非常特殊，因为它是一条单向路径，可在您进入虫洞之前将您送至目的地！每个FJ的农场包括Ñ（1≤ ñ ≤500）字段方便地编号为1 .. Ñ，中号*（1≤ *中号 ≤2500）的路径，和w ^*（1≤ *w ^ ≤200）虫洞。 由于FJ是一位狂热的时空旅行爱好者，因此他希望做到以下几点：从某个领域开始，经过一些路径和虫洞，并在他初次离开之前的某个时间返回开始领域。也许他将能够见到自己：）。 为了帮助FJ找出这是否可行与否，他将与完整的地图供你˚F*（1≤ *˚F ≤5）他的农场。路径行驶时间不会超过10,000秒，虫洞也不会使FJ的返回时间超过10,000秒。 输入值第1行：一个整数，˚F。F服务器场说明如下。每个服务器场的第1行：三个空格分隔的整数：N，M和W第2行。每个服务器场的M +1：三个以空格分隔的数字（S，E，T），分别描述：双向路径在S和E之间需要经过T秒。两个字段可能通过一条以上的路径连接。线中号 2 .. 中号 + w ^每个场的1：三个空间分隔的数字（S，E，T）分别描述：从S到E的单向路径，也将旅行者向后移动T秒。 输出量第1行。F：对于每个农场，如果FJ可以实现其目标，则输出“ YES”，否则输出“ NO”（不包括引号）。 样本输入1234567891023 3 11 2 21 3 42 3 13 1 33 2 11 2 32 3 43 1 8 样本输出12没有是 题目大意第一行输入三个正整数，代表点的个数，双向正边数，单向负边数。下面每行输入三个数，起点，终点，花费的时间(注意输入负边时也是正数，需要变成负数存起来)。 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;struct R&#123; int start,end,time;&#125; r[5201];int d[501];int n,m,w;bool bellman()&#123; memset(d,0x3f,sizeof(d)); d[1]&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;2*m+w;j++) &#123; if(d[r[j].end]&gt;d[r[j].start]+r[j].time) &#123; d[r[j].end]&#x3D;d[r[j].start]+r[j].time; &#125; &#125; &#125; for(int j&#x3D;1;j&lt;&#x3D;2*m+w;j++) &#123; if(d[r[j].end]&gt;d[r[j].start]+r[j].time) &#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;w; for(int i&#x3D;1;i&lt;&#x3D;2*m;i+&#x3D;2) &#123; cin&gt;&gt;r[i].start&gt;&gt;r[i].end&gt;&gt;r[i].time; r[i+1].start&#x3D;r[i].end; r[i+1].end&#x3D;r[i].start; r[i+1].time&#x3D;r[i].time; &#125; for(int i&#x3D;2*m+1;i&lt;&#x3D;2*m+w;i++) &#123; int tt; cin&gt;&gt;r[i].start&gt;&gt;r[i].end&gt;&gt;tt; r[i].time&#x3D;-tt; &#125; if(bellman()) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Bellman","slug":"ACM/Bellman","permalink":"https://donghuangzhong.github.io/categories/ACM/Bellman/"}],"tags":[{"name":"负环","slug":"负环","permalink":"https://donghuangzhong.github.io/tags/%E8%B4%9F%E7%8E%AF/"}]},{"title":"POJ-1860-Currency Exchange","slug":"POJ-1860-Currency-Exchange","date":"2020-03-07T00:24:06.000Z","updated":"2020-03-07T01:25:15.626Z","comments":true,"path":"2020/03/07/POJ-1860-Currency-Exchange/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/07/POJ-1860-Currency-Exchange/","excerpt":"dij算法不能处理负边，因为如果有负边就不能确定最小的那个是最优解了。Bellman-Ford可以处理负边，但在结束之前都不是最优解，并且可以处理闭环，因为i次循环可以算出走i步的最优解，所以必须循环n-1次，才能得到最优解，如果要判断是不是有环，需要再循环一次，如果最终的结果有被更改，则代表有环。正负环的初始化不同。","text":"dij算法不能处理负边，因为如果有负边就不能确定最小的那个是最优解了。Bellman-Ford可以处理负边，但在结束之前都不是最优解，并且可以处理闭环，因为i次循环可以算出走i步的最优解，所以必须循环n-1次，才能得到最优解，如果要判断是不是有环，需要再循环一次，如果最终的结果有被更改，则代表有环。正负环的初始化不同。 题目货币兑换 时限： 1000MS 内存限制： 30000K 提交总数： 44848 接受： 17312 描述我们城市有几个货币兑换点。让我们假设每个点专门研究两种特定货币，并且仅使用这些货币执行兑换操作。同一对货币可能有多个要点。每个点都有自己的汇率，A到B的汇率是您获得1A时B的数量。此外，每个兑换点都有一定的佣金，您必须为兑换操作支付的总金额。佣金始终以原始货币收取。例如，如果您想在兑换点将100美元兑换成俄罗斯卢布，汇率为29.75，佣金为0.39，您将获得（100-0.39）* 29.75 = 2963.3975RUR。您肯定知道我们城市可以处理N种不同的货币。让我们为每种货币分配从1到N的唯一整数。然后可以用6个数字描述每个兑换点：整数A和B-​​兑换的货币数量，以及实际R AB，C AB，R BA和C BA-分别将A兑换为B和B兑换为A时的汇率和佣金。尼克拥有货币S的钱，并且想知道在进行一些兑换操作后，他是否可以以某种方式增加其资本。当然，他希望最后用S货币来存钱。帮助他回答这个难题。尼克在进行操作时必须始终拥有非负数的资金。 输入值输入的第一行包含四个数字：N-货币数量，M-兑换点数量，S-Nick拥有的货币数量，V-他拥有的货币单位数量。接下来的M行每行包含6个数字-相应交换点的描述-按上面指定的顺序进行。数字用一个或多个空格分隔。1 &lt;= S &lt;= N &lt;= 100，1 &lt;= M &lt;= 100，V是实数，0 &lt;= V &lt;= 10 3。对于每个点的汇率和佣金是真实的，与小数点后至多两个数字，10给出-2 &lt;=速率&lt;= 10 2，0 &lt;=佣金&lt;= 10 2。如果在此序列中不使用任何交换点以上，则将交换操作的某些序列称为简单序列。您可以假定在任何简单的交换操作序列的末尾和开始处，总和的数值之比小于10 4。 输出量如果Nick可以增加他的财富，则输出YES，否则输出NO到输出文件。 样本输入1233 2 1 20.01 2 1.00 1.00 1.00 1.002 3 1.10 1.00 1.10 1.00 样本输出1是 题目描述第一行输入n,m,s,v分别表示货币的种数，货币转换的方式数，自己拥有的货币的种类，自己拥有货币的数量；接下来m行输入a,b,c,d,e,f表示a向b转换的汇率是c,手续费是d,b向a转换的汇率e,手续费是f.计算方式:（a-d）*c 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int n,m,t;double s,d[101];struct &#123; int a,b; double huilv,tax;&#125; bian[201];bool bellman_ford()&#123; memset(d,0,sizeof(d)); d[t]&#x3D;s; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;2*m;j++) &#123; if(d[bian[j].b]&lt;(d[bian[j].a]-bian[j].tax)*bian[j].huilv) &#123; d[bian[j].b]&#x3D;(d[bian[j].a]-bian[j].tax)*bian[j].huilv; &#125; &#125; &#125; for(int j&#x3D;1;j&lt;&#x3D;2*m;j++) &#123; if(d[bian[j].b]&lt;(d[bian[j].a]-bian[j].tax)*bian[j].huilv) &#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;s; for(int i&#x3D;1;i&lt;&#x3D;2*m;i+&#x3D;2) &#123; cin&gt;&gt;bian[i].a&gt;&gt;bian[i].b&gt;&gt;bian[i].huilv&gt;&gt;bian[i].tax&gt;&gt;bian[i+1].huilv&gt;&gt;bian[i+1].tax; bian[i+1].a&#x3D;bian[i].b; bian[i+1].b&#x3D;bian[i].a; &#125; if(bellman_ford()) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Bellman","slug":"ACM/Bellman","permalink":"https://donghuangzhong.github.io/categories/ACM/Bellman/"}],"tags":[{"name":"正环","slug":"正环","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E7%8E%AF/"}]},{"title":"POJ-3268-Silver Cow Party","slug":"POJ-3268-Silver-Cow-Party","date":"2020-03-06T03:44:08.000Z","updated":"2020-03-06T03:56:45.407Z","comments":true,"path":"2020/03/06/POJ-3268-Silver-Cow-Party/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/06/POJ-3268-Silver-Cow-Party/","excerpt":"上来一看觉得这个题很简单，写出来测试结果也对，一提交，超时。于是我又把cin改成scanf,cin比scanf慢太多了，结果还是超时。这就不是细节问题了，是算法本身的问题，后来把矩阵翻转了一下就可以解决，复杂度从n^3变成n^2，这样一想刚开始的算法太愚蠢了！","text":"上来一看觉得这个题很简单，写出来测试结果也对，一提交，超时。于是我又把cin改成scanf,cin比scanf慢太多了，结果还是超时。这就不是细节问题了，是算法本身的问题，后来把矩阵翻转了一下就可以解决，复杂度从n^3变成n^2，这样一想刚开始的算法太愚蠢了！ 题目银牛党 时限： 2000MS 内存限制： 65536K 提交总数： 38727 接受： 17305 描述从每一个牛ñ农场（1≤ ñ ≤1000）方便地编号为1 .. ñ是要参加大牛党在农场＃举行X（1≤ X ≤ ñ）。共中号*（1≤ *中号 ≤100,000）农场单向（单向道路所连接对;道路我需要Ť 我*（1≤ *Ť 我 ≤100）的时间到横动单元。 每头母牛都必须走到聚会上，聚会结束后，要回到自己的农场。每头母牛都是懒惰的，因此选择了最短时间的最佳路线。由于道路是单向的，所以母牛的回程路线可能与原先到达聚会的路线有所不同。 在所有奶牛中，奶牛步行去聚会和返回所花费的最长时间是多少？ 输入值分别三空格隔开的整数，：1线Ñ，中号，和X线2 .. 中号 1：线我 1描述了道路我有三个空格隔开的整数：甲我，乙我和Ť 我。所描述的道路从农场A i到农场B i延伸，需要经过T i个时间单位。 输出量第1行：一个整数：任何一头母牛必须行走的最长时间。 样本输入1234567894 8 21 2 41 3 21 4 72 1 12 3 53 1 23 4 44 2 3 样本输出110 题目大意输出三个数，n,m,x。n代表点的个数，m代表有向边的个数，x代表集会地点，下面m行:x,y,s。表示x点到y点的有向边的长度是s。要求输出某个点到x,再从x回家的最长距离 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 1001#define MAX 0x3f3f3f3fusing namespace std;int n,m,x,map[N][N],d[N],v[N],bd[N];void dij(int start)&#123; int index,minn; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; v[i]&#x3D;0; d[i]&#x3D;map[start][i]; &#125; v[start]&#x3D;1; for(int k&#x3D;2;k&lt;&#x3D;n;k++) &#123; minn&#x3D;MAX; for(int i&#x3D;1;i&lt;&#x3D;n;i++) if(v[i]&#x3D;&#x3D;0&amp;&amp;d[i]&lt;minn) &#123; minn&#x3D;d[i]; index&#x3D;i; &#125; v[index]&#x3D;1; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(v[i]&#x3D;&#x3D;0&amp;&amp;d[i]&gt;d[index]+map[index][i]) &#123; d[i]&#x3D;d[index]+map[index][i]; &#125; &#125; &#125; &#x2F;&#x2F;cout&lt;&lt;d[end]&lt;&lt;endl;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n&gt;&gt;m&gt;&gt;x; &#x2F;&#x2F;memset(map,0x3f,sizeof(map)); for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;n;j++) map[i][j]&#x3D;MAX; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; cin&gt;&gt;map[x][y]; &#125; dij(x); for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; bd[i]&#x3D;d[i]; for(int j&#x3D;i+1;j&lt;&#x3D;n;j++) &#123; int t&#x3D;map[i][j]; map[i][j]&#x3D;map[j][i]; map[j][i]&#x3D;t; &#125; &#125; dij(x); int jieguo&#x3D;-1; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(i!&#x3D;x&amp;&amp;d[i]!&#x3D;MAX&amp;&amp;bd[i]!&#x3D;MAX&amp;&amp;d[i]+bd[i]&gt;jieguo) jieguo&#x3D;d[i]+bd[i]; &#125; cout&lt;&lt;jieguo&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"有向图绕圈","slug":"有向图绕圈","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%89%E5%90%91%E5%9B%BE%E7%BB%95%E5%9C%88/"},{"name":"翻转矩阵","slug":"翻转矩阵","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5/"}]},{"title":"POJ-1797-Heavy Transportation","slug":"POJ-1797-Heavy-Transportation","date":"2020-03-06T00:57:10.000Z","updated":"2020-03-06T01:17:59.272Z","comments":true,"path":"2020/03/06/POJ-1797-Heavy-Transportation/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/06/POJ-1797-Heavy-Transportation/","excerpt":"dij用途还是很广的，稍微分析一下可行性就可以。可行性主要表现在两部分，第一部分筛选最优解，第二部分更新当前状态。只要这两点可行就可以。注意不能图省事两个循环同时计算和求最优解。","text":"dij用途还是很广的，稍微分析一下可行性就可以。可行性主要表现在两部分，第一部分筛选最优解，第二部分更新当前状态。只要这两点可行就可以。注意不能图省事两个循环同时计算和求最优解。 题目重型运输 时限： 3000MS 内存限制： 30000K 提交总数： 66100 接受： 16246 描述背景雨果重工很高兴。Cargolifter项目崩溃后，他现在可以扩展业务。但是他需要一个聪明的人，告诉他从客户建造巨型钢起重机的地方到所有街道都可以承载重量的地方是否真的有办法。幸运的是，他已经制定了一个计划，包括所有街道，桥梁和所有允许的重量。不幸的是，他不知道如何找到最大重量来告诉客户起重机的重量。但是你当然知道。 问题系统会为您提供城市规划，由交叉口之间的街道（权重限制）描述，该街道编号为1到n。您的任务是找到从1号交叉口（Hugo的位置）到n号交叉口（客户的位置）可以运输的最大重量。您可以假设至少有一条路径。所有街道均可双向行驶。 输入值第一行包含方案（城市计划）的数量。对于每个城市，第一行给出的是路口交叉口数量n（1 &lt;= n &lt;= 1000）和街道数量m。接下来的m行包含整数的三元组，这些整数指定了道路的起点和终点交叉点以及允许的最大权重，该权重为正且不大于1000000。每对交叉点之间最多有一条街道。 输出量每个方案的输出都以包含“方案#i：”的行开头，其中i是从1开始的方案编号。然后打印一行，其中包含Hugo可以运输给客户的最大允许重量。用空白行终止方案的输出。 样本输入123451个3 31 2 31 3 42 3 5 样本输出12方案1：4 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int map[1001][1001];int d[1001];bool v[1001];int q&#x3D;1;int n,index,m,maxx;void dij()&#123; int i,j; for(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; v[i]&#x3D;0; d[i]&#x3D;map[1][i]; &#125; v[1]&#x3D;1; while(v[n]!&#x3D;1) &#123; maxx&#x3D;-1; for(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(v[i]&#x3D;&#x3D;0&amp;&amp;d[i]&gt;maxx) &#123; maxx&#x3D;d[i]; index&#x3D;i; &#125; &#125; v[index]&#x3D;1; for(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int tt&#x3D;map[index][i]&lt;d[index]?map[index][i]:d[index]; if(v[i]&#x3D;&#x3D;0&amp;&amp;(d[i]&lt;tt)) &#123; d[i]&#x3D;tt; &#125; &#125; &#125; printf(&quot;Scenario #%d:\\n%d\\n\\n&quot;,q++,d[n]);&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; map[i][j]&#x3D;0; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int a,b,w; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w); map[a][b]&#x3D;map[b][a]&#x3D;w; &#125; dij(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"最大最小距离","slug":"最大最小距离","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"}]},{"title":"POJ-2253-Frogger","slug":"POJ-2253-Frogger","date":"2020-03-05T07:16:38.000Z","updated":"2020-03-05T07:49:10.697Z","comments":true,"path":"2020/03/05/POJ-2253-Frogger/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/05/POJ-2253-Frogger/","excerpt":"跟dij算法的可行性一样，分为两个集合，一个是处理完的集合a(a中存在起点s),一个是待处理的集合b，取b中所求量(一般为最短型，可以是总路径，也可以是组内路径)最小的那个点c，那么s到c的最优解就能够确定下来，c的上一个点p，要么在a中，要么在b中，在b中不可能，因为b中除了c点别的点都要比c大(我们之前的取得C是最小的)，所以p点只能在a中。如果a中只有起点s，那么s到c的最小值就是s到c的距离，把c加入a集合，同时更新b集合中的点到s的距离，这样就能保证每次保留的都是b集合中每一个点到a集合的距离，再取最小值……","text":"跟dij算法的可行性一样，分为两个集合，一个是处理完的集合a(a中存在起点s),一个是待处理的集合b，取b中所求量(一般为最短型，可以是总路径，也可以是组内路径)最小的那个点c，那么s到c的最优解就能够确定下来，c的上一个点p，要么在a中，要么在b中，在b中不可能，因为b中除了c点别的点都要比c大(我们之前的取得C是最小的)，所以p点只能在a中。如果a中只有起点s，那么s到c的最小值就是s到c的距离，把c加入a集合，同时更新b集合中的点到s的距离，这样就能保证每次保留的都是b集合中每一个点到a集合的距离，再取最小值…… 题目蛙人 时限： 1000MS 内存限制： 65536K 提交总数： 77942 接受： 23692 描述弗雷迪·青蛙坐在湖中间的一块石头上。突然，他注意到坐在另一块石头上的菲奥娜·青蛙。他计划去探望她，但由于水很脏，到处都是游客的防晒霜，他想避免游泳，而是跳跳来到达她。不幸的是，菲奥娜的石头不在他的跳跃范围内。因此，弗雷迪（Freddy）考虑使用其他石头作为中间停靠点，并通过几次小跳的顺序到达她。为了执行给定的跳跃序列，青蛙的跳跃范围显然必须至少与序列中发生的最长跳跃一样长。因此，将两块石头之间的青蛙距离（人类也称为最小最大距离）定义为两块石头之间所有可能路径上的最小必要跳跃范围。 您将获得弗雷迪石头，菲奥娜石头和湖中所有其他石头的坐标。您的工作是计算Freddy和Fiona的石头之间的青蛙距离。 输入值输入将包含一个或多个测试用例。每个测试用例的第一行将包含结石数量n（2 &lt;= n &lt;= 200）。接下来的n条线分别包含两个整数xi，yi（0 &lt;= xi，yi &lt;= 1000），它们表示石头#i的坐标。第1块石头是弗雷迪的石头，第2块石头是菲奥娜的石头，其他n-2块石头未被占用。每个测试用例后面都有一个空白行。输入以n的零（0）值终止。 输出量对于每个测试用例，打印一行“ Scenario #x”和一行“ Frog Distance = y”，其中x替换为测试用例编号（从1开始编号），y替换为适当的实数，打印到三位小数。在每个测试用例之后，甚至在最后一个测试用例之后，都应留一个空白行。 样本输入123456789102 0 0 3 4 3 17 4 19 4 18 5 0 样本输出12345方案＃1 青蛙距离&#x3D; 5.000 方案＃2 青蛙距离&#x3D; 1.414 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int n,MAX&#x3D;0x3f3f3f3f;int x[201];int y[201];double d[201];bool v[201];double map[201][201];int index;int q&#x3D;1;double minn;void dij()&#123; memset(v,0,sizeof(v)); d[1]&#x3D;0; v[1]&#x3D;1; int mubiao&#x3D;1; while(v[2]!&#x3D;1) &#123; minn&#x3D;MAX; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(v[i]&#x3D;&#x3D;0) &#123; if(max(d[mubiao],map[mubiao][i])&lt;d[i]) &#123; d[i]&#x3D;max(d[mubiao],map[mubiao][i]); &#125; if(d[i]&lt;minn) &#123; minn&#x3D;d[i]; index&#x3D;i; &#125; &#125; &#125; v[index]&#x3D;1; mubiao&#x3D;index; &#125; printf(&quot;Scenario #%d\\nFrog Distance &#x3D; %.3f\\n\\n&quot;,q++,d[2]); &#x2F;&#x2F;printf(&quot;%.3f\\n&quot;,d[2]);&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;n&amp;&amp;n) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; cin&gt;&gt;x[i]&gt;&gt;y[i]; &#125; &#x2F;&#x2F;memset(map,0,sizeof(map)); for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; map[i][i]&#x3D;0; d[i]&#x3D;MAX; for(int j&#x3D;1;j&lt;&#x3D;i-1;j++) &#123; map[i][j]&#x3D;map[j][i]&#x3D;sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])); &#125; &#125; dij(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"组内最短路径","slug":"组内最短路径","permalink":"https://donghuangzhong.github.io/tags/%E7%BB%84%E5%86%85%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"POJ-2387-Til the Cows Come Home","slug":"POJ-2387-Til-the-Cows-Come-Home","date":"2020-03-05T00:46:24.000Z","updated":"2020-03-05T08:51:12.523Z","comments":true,"path":"2020/03/05/POJ-2387-Til-the-Cows-Come-Home/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/05/POJ-2387-Til-the-Cows-Come-Home/","excerpt":"dijkstra算法，非简单可达路径不要用DFS；如果要输出路径保存在标志数组中，递归输出；变与不变的情况最好不用三目运算符","text":"dijkstra算法，非简单可达路径不要用DFS；如果要输出路径保存在标志数组中，递归输出；变与不变的情况最好不用三目运算符 题目http://poj.org/problem?id=2387 直到母牛回家 时限： 1000MS 内存限制： 65536K 提交总数： 100676 接受的： 32539 描述贝西（Bessie）在野外，想回到谷仓，以便在农夫约翰（Johner John）叫醒她早晨挤奶之前尽可能多地入睡。贝西需要美睡，所以她想尽快回来。 农夫约翰的田地中有N（2 &lt;= N &lt;= 1000）个地标，唯一编号为1..N。地标1是谷仓；Bessie整日站立的苹果树丛是地标N。奶牛使用地标之间长度各不相同的T（1 &lt;= T &lt;= 2000）双向奶牛场在田间旅行。贝西对自己的导航能力不抱有信心，因此，从开始到结束，她始终处在步道上。 给定地标之间的路径，确定Bessie返回谷仓必须行走的最小距离。可以保证存在这样的路由。 输入值*第1行：两个整数：T和N *第2..T + 1行：每行将一个轨迹描述为三个以空格分隔的整数。前两个整数是小径在其间行进的地标。第三个整数是路径的长度，范围为1..100。 输出量*第1行：一个整数，Bessie从地标N到地标1所必须经过的最小距离。 样本输入1234565 51 2 202 3 303 4 204 5 201 5 100 样本输出190 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int N[1001];bool v[1001];int map[1001][1001];int n,x,index,mubiao; int MAX&#x3D;0x3f3f3f3f;void dij()&#123; N[x]&#x3D;0; v[x]&#x3D;1; int mubiao&#x3D;x; while(v[1]!&#x3D;1) &#123; int min&#x3D;MAX; for(int i&#x3D;1;i&lt;&#x3D;x;i++) &#123; if(v[i]&#x3D;&#x3D;0) &#123; int t&#x3D;N[mubiao]+map[mubiao][i]; if(N[i]&gt;t) N[i]&#x3D;t; if(N[i]&lt;min)&#123; min&#x3D;N[i]; index&#x3D;i; &#125; &#125; &#125; v[index]&#x3D;1; mubiao&#x3D;index; &#125; cout&lt;&lt;N[1]&lt;&lt;endl;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;n&gt;&gt;x) &#123; &#x2F;&#x2F;memset(map,0x3f,sizeof(map)); &#x2F;&#x2F;memset(v,0,sizeof(v)); &#x2F;&#x2F;memset(N,0x3f,sizeof(N)); for(int i&#x3D;1;i&lt;&#x3D;x;i++) &#123; N[i]&#x3D;MAX; v[i]&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;x;j++) &#123; map[i][j]&#x3D;MAX; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int j,k,dd; cin&gt;&gt;j&gt;&gt;k; cin&gt;&gt;dd; if(dd&lt;map[j][k]) &#123; map[j][k]&#x3D;dd; map[k][j]&#x3D;dd; &#125; &#125; dij(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"最短路径","slug":"最短路径","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"HDU-2102-A计划","slug":"HDU-2102-A计划","date":"2020-03-03T02:39:56.000Z","updated":"2020-03-03T02:49:20.495Z","comments":true,"path":"2020/03/03/HDU-2102-A计划/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/03/HDU-2102-A%E8%AE%A1%E5%88%92/","excerpt":"两层迷宫，‘#’代表瞬时传送装置，如果传送后是墙则撞死，如果传送后是‘#’，则一直在传送，必须考虑这两种情况。","text":"两层迷宫，‘#’代表瞬时传送装置，如果传送后是墙则撞死，如果传送后是‘#’，则一直在传送，必须考虑这两种情况。 题目A计划\\Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 38233 Accepted Submission(s): 9470** Problem Description 可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用*表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。 Input 输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小NM（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前NM表示迷宫的第一层的布置情况，后N*M表示迷宫第二层的布置情况。 Output 如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。 Sample Input 1234567891011121315 5 14S*#*..#........****....#...*.P#.*..***.....*.*.#.. Sample Output 1YES 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;struct Point&#123; int x,y,z;&#125; a,b;int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;int m,n,t,zx,zy,zz;char map[2][10][10];int v[2][10][10];void bfs()&#123; memset(v,0,sizeof(v)); v[0][0][0]&#x3D;1; a.x&#x3D;0;a.y&#x3D;0;a.z&#x3D;0; queue&lt;Point&gt; q; q.push(a); while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x; b.y&#x3D;a.y+dir[i][0]; b.z&#x3D;a.z+dir[i][1]; if(b.y&gt;&#x3D;0&amp;&amp;b.y&lt;m&amp;&amp;b.z&gt;&#x3D;0&amp;&amp;b.z&lt;n&amp;&amp;map[b.x][b.y][b.z]!&#x3D;&#39;*&#39;&amp;&amp;v[b.x][b.y][b.z]&#x3D;&#x3D;0) &#123; v[b.x][b.y][b.z]&#x3D;v[a.x][a.y][a.z]+1; if(map[b.x][b.y][b.z]&#x3D;&#x3D;&#39;#&#39;) &#123; int tt&#x3D;v[b.x][b.y][b.z]; b.x&#x3D;(b.x&#x3D;&#x3D;1?0:1); if(map[b.x][b.y][b.z]&#x3D;&#x3D;&#39;*&#39;||map[b.x][b.y][b.z]&#x3D;&#x3D;&#39;#&#39;) continue; v[b.x][b.y][b.z]&#x3D;tt; &#125; if(v[b.x][b.y][b.z]-1&gt;t)&#123;cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;return;&#125; if(map[b.x][b.y][b.z]&#x3D;&#x3D;&#39;P&#39;) &#123;cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; return;&#125; q.push(b); &#125; &#125; &#125; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int c; cin&gt;&gt;c; while(c--)&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;t; for(int k&#x3D;0;k&lt;2;k++) for(int i&#x3D;0;i&lt;m;i++) for(int j&#x3D;0;j&lt;n;j++) cin&gt;&gt;map[k][i][j]; bfs(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"易错题","slug":"易错题","permalink":"https://donghuangzhong.github.io/tags/%E6%98%93%E9%94%99%E9%A2%98/"},{"name":"标志数组做记录","slug":"标志数组做记录","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%81%9A%E8%AE%B0%E5%BD%95/"}]},{"title":"HDU-2181-哈密顿绕行问题","slug":"HDU-2181-哈密顿绕行问题","date":"2020-03-03T00:35:19.000Z","updated":"2020-03-03T00:42:31.992Z","comments":true,"path":"2020/03/03/HDU-2181-哈密顿绕行问题/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/03/HDU-2181-%E5%93%88%E5%AF%86%E9%A1%BF%E7%BB%95%E8%A1%8C%E9%97%AE%E9%A2%98/","excerpt":"DFS遍历所有可能性","text":"DFS遍历所有可能性 题目哈密顿绕行世界问题\\Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 10731 Accepted Submission(s): 6191** Problem Description 一个规则的实心十二面体，它的 20个顶点标出世界著名的20个城市，你从一个城市出发经过每个城市刚好一次后回到出发的城市。 Input 前20行的第i行有3个数,表示与第i个城市相邻的3个城市.第20行以后每行有1个数m,m&lt;=20,m&gt;=1.m=0退出. Output 输出从第m个城市出发经过每个城市1次又回到m的所有路线,如有多条路线,按字典序输出,每行1条路线.每行首先输出是第几条路线.然后个一个: 后列出经过的城市.参看Sample output Sample Input 123456789101112131415161718192021222 5 201 3 122 4 103 5 81 4 65 7 196 8 174 7 98 10 163 9 1110 12 152 11 1312 14 2013 15 1811 14 169 15 177 16 1814 17 196 18 201 13 1950 Sample Output 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601: 5 1 2 3 4 8 7 17 18 14 15 16 9 10 11 12 13 20 19 6 52: 5 1 2 3 4 8 9 10 11 12 13 20 19 18 14 15 16 17 7 6 53: 5 1 2 3 10 9 16 17 18 14 15 11 12 13 20 19 6 7 8 4 54: 5 1 2 3 10 11 12 13 20 19 6 7 17 18 14 15 16 9 8 4 55: 5 1 2 12 11 10 3 4 8 9 16 15 14 13 20 19 18 17 7 6 56: 5 1 2 12 11 15 14 13 20 19 18 17 16 9 10 3 4 8 7 6 57: 5 1 2 12 11 15 16 9 10 3 4 8 7 17 18 14 13 20 19 6 58: 5 1 2 12 11 15 16 17 18 14 13 20 19 6 7 8 9 10 3 4 59: 5 1 2 12 13 20 19 6 7 8 9 16 17 18 14 15 11 10 3 4 510: 5 1 2 12 13 20 19 18 14 15 11 10 3 4 8 9 16 17 7 6 511: 5 1 20 13 12 2 3 4 8 7 17 16 9 10 11 15 14 18 19 6 512: 5 1 20 13 12 2 3 10 11 15 14 18 19 6 7 17 16 9 8 4 513: 5 1 20 13 14 15 11 12 2 3 10 9 16 17 18 19 6 7 8 4 514: 5 1 20 13 14 15 16 9 10 11 12 2 3 4 8 7 17 18 19 6 515: 5 1 20 13 14 15 16 17 18 19 6 7 8 9 10 11 12 2 3 4 516: 5 1 20 13 14 18 19 6 7 17 16 15 11 12 2 3 10 9 8 4 517: 5 1 20 19 6 7 8 9 10 11 15 16 17 18 14 13 12 2 3 4 518: 5 1 20 19 6 7 17 18 14 13 12 2 3 10 11 15 16 9 8 4 519: 5 1 20 19 18 14 13 12 2 3 4 8 9 10 11 15 16 17 7 6 520: 5 1 20 19 18 17 16 9 10 11 15 14 13 12 2 3 4 8 7 6 521: 5 4 3 2 1 20 13 12 11 10 9 8 7 17 16 15 14 18 19 6 522: 5 4 3 2 1 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 523: 5 4 3 2 12 11 10 9 8 7 6 19 18 17 16 15 14 13 20 1 524: 5 4 3 2 12 13 14 18 17 16 15 11 10 9 8 7 6 19 20 1 525: 5 4 3 10 9 8 7 6 19 20 13 14 18 17 16 15 11 12 2 1 526: 5 4 3 10 9 8 7 17 16 15 11 12 2 1 20 13 14 18 19 6 527: 5 4 3 10 11 12 2 1 20 13 14 15 16 9 8 7 17 18 19 6 528: 5 4 3 10 11 15 14 13 12 2 1 20 19 18 17 16 9 8 7 6 529: 5 4 3 10 11 15 14 18 17 16 9 8 7 6 19 20 13 12 2 1 530: 5 4 3 10 11 15 16 9 8 7 17 18 14 13 12 2 1 20 19 6 531: 5 4 8 7 6 19 18 17 16 9 10 3 2 12 11 15 14 13 20 1 532: 5 4 8 7 6 19 20 13 12 11 15 14 18 17 16 9 10 3 2 1 533: 5 4 8 7 17 16 9 10 3 2 1 20 13 12 11 15 14 18 19 6 534: 5 4 8 7 17 18 14 13 12 11 15 16 9 10 3 2 1 20 19 6 535: 5 4 8 9 10 3 2 1 20 19 18 14 13 12 11 15 16 17 7 6 536: 5 4 8 9 10 3 2 12 11 15 16 17 7 6 19 18 14 13 20 1 537: 5 4 8 9 16 15 11 10 3 2 12 13 14 18 17 7 6 19 20 1 538: 5 4 8 9 16 15 14 13 12 11 10 3 2 1 20 19 18 17 7 6 539: 5 4 8 9 16 15 14 18 17 7 6 19 20 13 12 11 10 3 2 1 540: 5 4 8 9 16 17 7 6 19 18 14 15 11 10 3 2 12 13 20 1 541: 5 6 7 8 4 3 2 12 13 14 15 11 10 9 16 17 18 19 20 1 542: 5 6 7 8 4 3 10 9 16 17 18 19 20 13 14 15 11 12 2 1 543: 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 544: 5 6 7 8 9 16 17 18 19 20 1 2 12 13 14 15 11 10 3 4 545: 5 6 7 17 16 9 8 4 3 10 11 15 14 18 19 20 13 12 2 1 546: 5 6 7 17 16 15 11 10 9 8 4 3 2 12 13 14 18 19 20 1 547: 5 6 7 17 16 15 11 12 13 14 18 19 20 1 2 3 10 9 8 4 548: 5 6 7 17 16 15 14 18 19 20 13 12 11 10 9 8 4 3 2 1 549: 5 6 7 17 18 19 20 1 2 3 10 11 12 13 14 15 16 9 8 4 550: 5 6 7 17 18 19 20 13 14 15 16 9 8 4 3 10 11 12 2 1 551: 5 6 19 18 14 13 20 1 2 12 11 15 16 17 7 8 9 10 3 4 552: 5 6 19 18 14 15 11 10 9 16 17 7 8 4 3 2 12 13 20 1 553: 5 6 19 18 14 15 11 12 13 20 1 2 3 10 9 16 17 7 8 4 554: 5 6 19 18 14 15 16 17 7 8 9 10 11 12 13 20 1 2 3 4 555: 5 6 19 18 17 7 8 4 3 2 12 11 10 9 16 15 14 13 20 1 556: 5 6 19 18 17 7 8 9 16 15 14 13 20 1 2 12 11 10 3 4 557: 5 6 19 20 1 2 3 10 9 16 15 11 12 13 14 18 17 7 8 4 558: 5 6 19 20 1 2 12 13 14 18 17 7 8 9 16 15 11 10 3 4 559: 5 6 19 20 13 12 11 10 9 16 15 14 18 17 7 8 4 3 2 1 560: 5 6 19 20 13 14 18 17 7 8 4 3 10 9 16 15 11 12 2 1 5 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int nn,Case;bool v[21];int l[21];struct Point&#123; int xianglin[3];&#125; map[21];void dfs(int n)&#123; if(n&#x3D;&#x3D;21)&#123; for(int i&#x3D;0;i&lt;3;i++) &#123; if(map[l[n-1]].xianglin[i]&#x3D;&#x3D;nn) &#123; cout&lt;&lt;Case++&lt;&lt;&quot;: &quot;; for(int j&#x3D;1;j&lt;21;j++) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;l[j]; &#125; cout&lt;&lt;&quot; &quot;&lt;&lt;l[1]; cout&lt;&lt;endl; &#125; &#125; return; &#125; for(int i&#x3D;0;i&lt;3;i++) &#123; if(v[map[l[n-1]].xianglin[i]]&#x3D;&#x3D;0) &#123; v[map[l[n-1]].xianglin[i]]&#x3D;1; l[n]&#x3D;map[l[n-1]].xianglin[i]; dfs(n+1); v[map[l[n-1]].xianglin[i]]&#x3D;0; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); for(int i &#x3D; 1; i &lt; 21; i++) &#123; cin&gt;&gt;map[i].xianglin[0]&gt;&gt;map[i].xianglin[1]&gt;&gt;map[i].xianglin[2]; &#125; while(cin&gt;&gt;nn&amp;&amp;nn)&#123; Case&#x3D;1; memset(v,0,sizeof(v)); v[nn]&#x3D;1; l[1]&#x3D;nn; dfs(2); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DFS","slug":"ACM/DFS","permalink":"https://donghuangzhong.github.io/categories/ACM/DFS/"}],"tags":[{"name":"遍历所有可能性","slug":"遍历所有可能性","permalink":"https://donghuangzhong.github.io/tags/%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E6%80%A7/"}]},{"title":"HDU-2612","slug":"HDU-2612","date":"2020-03-02T01:47:16.000Z","updated":"2020-03-02T01:58:36.944Z","comments":true,"path":"2020/03/02/HDU-2612/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/02/HDU-2612/","excerpt":"两个标志数组，两次BFS，不是双BFS，双BFS应该是双入口BFS，是一次BFS，两个入口而已，UVA-11624这才是双入口BFS。二维数组对应的函数形参必须声明第二维，并且不能对传进函数的形参用memset,因为sizeof(数组)不对，这样只能自行指定memset的大小了。","text":"两个标志数组，两次BFS，不是双BFS，双BFS应该是双入口BFS，是一次BFS，两个入口而已，UVA-11624这才是双入口BFS。二维数组对应的函数形参必须声明第二维，并且不能对传进函数的形参用memset,因为sizeof(数组)不对，这样只能自行指定memset的大小了。 问题想办法\\时间限制：3000/1000 MS（Java /其他）内存限制：32768/32768 K（Java /其他）总提交数量：35622接受提交数量：11329** 问题描述 终于在杭州经过一年的学习，一分飞终于到了宁波。离开宁波一年后，一分飞有很多人见面。特别是好朋友Merceki。Yifenfei的家在乡下，而Merceki的家在城市中心。因此，易芬菲与Merceki安排了在肯德基会面。宁波有很多肯德基，他们想选择一种让总时间最短的肯德基。现在给您一张宁波地图，yifenfei和Merceki都可以通过成本11分钟左右上下移动到相邻的道路。 输入值 输入包含多个测试用例。每个测试用例包括前两个整数n，m。（2 &lt;= n，m &lt;= 200）。接下来的n行，每行包含m个字符。“ Y”表示一分钱的初始职位。“ M”表示Merceki的初始位置。‘＃’禁止道路；‘。’ 路。‘@’KCF 输出量 对于每个测试用例输出，yifenfei和Merceki到达肯德基之一的最短总时间。您可以肯定总是有一个肯德基可以让他们见面。 样本输入 123456789101112131415164 4Y。＃@....。＃..@ .. M4 4Y。＃@....。＃..@＃。M5 5Y .. @。。＃...。＃...@ .. M。＃...＃ 样本输出 123668866 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;char map[201][201];int v1[201][201];int v2[201][201];int m,n,minn;int dir[4][2]&#x3D;&#123;0,1,1,0,0,-1,-1,0&#125;;struct Point&#123; int x,y;&#125; a,b,y,M;void bfs(int x,int y,int v[201][201])&#123; memset(v,0,4*201*201); a.x&#x3D;x;a.y&#x3D;y; queue&lt;Point&gt; q; q.push(a); v[x][y]&#x3D;1; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(b.x&gt;&#x3D;0&amp;&amp;b.x&lt;m&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;n&amp;&amp;map[b.x][b.y]!&#x3D;&#39;#&#39;&amp;&amp;v[b.x][b.y]&#x3D;&#x3D;0) &#123; v[b.x][b.y]&#x3D;v[a.x][a.y]+1; q.push(b); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;m&gt;&gt;n) &#123; for(int i&#x3D;0;i&lt;m;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]&#x3D;&#x3D;&#39;Y&#39;) &#123; y.x&#x3D;i;y.y&#x3D;j; &#125; if(map[i][j]&#x3D;&#x3D;&#39;M&#39;) &#123; M.x&#x3D;i;M.y&#x3D;j; &#125; &#125; &#125; bfs(y.x,y.y,v1); bfs(M.x,M.y,v2); minn&#x3D;1000000; for(int i&#x3D;0;i&lt;m;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; if(map[i][j]&#x3D;&#x3D;&#39;@&#39;&amp;&amp;v1[i][j]&amp;&amp;v2[i][j]) &#123; v2[i][j]+&#x3D;v1[i][j]-2; if(v2[i][j]&lt;minn) &#123; minn&#x3D;v2[i][j]; &#125; &#125; &#125;&#125; cout&lt;&lt;minn*11&lt;&lt;endl; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"两次BFS","slug":"两次BFS","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%A4%E6%AC%A1BFS/"},{"name":"函数数组形参","slug":"函数数组形参","permalink":"https://donghuangzhong.github.io/tags/%E5%87%BD%E6%95%B0%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82/"}]},{"title":"HDU-1495","slug":"HDU-1495","date":"2020-02-29T09:43:05.000Z","updated":"2020-03-02T01:41:23.273Z","comments":true,"path":"2020/02/29/HDU-1495/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/29/HDU-1495/","excerpt":"搜索所有的状态，标志数组同时用于记录次数，最后减一，用i!=j的方式遍历倒法，用3-i-j得到剩余的被子杯子的可乐。网上有一份数论的做法，极为精简，以后再研究吧。路漫漫其修远兮！","text":"搜索所有的状态，标志数组同时用于记录次数，最后减一，用i!=j的方式遍历倒法，用3-i-j得到剩余的被子杯子的可乐。网上有一份数论的做法，极为精简，以后再研究吧。路漫漫其修远兮！ 题目非常可乐\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 36161 Accepted Submission(s): 14072** Problem Description 大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 Input 三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。 Output 如果能平分的话请输出最少要倒的次数，否则输出”NO”。 Sample Input 1237 4 34 1 30 0 0 Sample Output 12NO3 算法刚开始状态为0,0,s。之后模拟所有倒法共有6种，能倒的前提是本瓶子有水，被倒的瓶子有空闲容量。根据这两个的大小倒之后可能有两个状态，本瓶子空，被倒瓶子水增加；本瓶子非空，被盗瓶子满。得到倒之后的状态，判断是否到达过这个状态，没有则步数加一…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int m,n,s;int v[101][101][101];int r[3];struct S&#123; int c[3];&#125; a,b;void bfs()&#123; a.c[0]&#x3D;0; a.c[1]&#x3D;0; a.c[2]&#x3D;s; v[0][0][s]&#x3D;1; queue&lt;S&gt; q; q.push(a); while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;3;i++) &#123; for(int j&#x3D;0;j&lt;3;j++) &#123; if(i!&#x3D;j) &#123; if(a.c[i]&gt;0&amp;&amp;r[j]-a.c[j]&gt;0) &#123; if(a.c[i]&gt;&#x3D;r[j]-a.c[j]) &#123;b.c[j]&#x3D;r[j]; b.c[i]&#x3D;a.c[i]-r[j]+a.c[j]; b.c[3-i-j]&#x3D;a.c[3-i-j]; &#125; else &#123; b.c[i]&#x3D;0; b.c[j]&#x3D;a.c[j]+a.c[i]; b.c[3-i-j]&#x3D;a.c[3-i-j]; &#125; if(v[b.c[0]][b.c[1]][b.c[2]]&#x3D;&#x3D;0) &#123; v[b.c[0]][b.c[1]][b.c[2]]&#x3D;v[a.c[0]][a.c[1]][a.c[2]]+1; if((b.c[0]&#x3D;&#x3D;s&#x2F;2&amp;&amp;b.c[1]&#x3D;&#x3D;s&#x2F;2)||(b.c[1]&#x3D;&#x3D;s&#x2F;2&amp;&amp;b.c[2]&#x3D;&#x3D;s&#x2F;2)||(b.c[0]&#x3D;&#x3D;s&#x2F;2&amp;&amp;b.c[2]&#x3D;&#x3D;s&#x2F;2)) &#123;cout&lt;&lt;v[b.c[0]][b.c[1]][b.c[2]]-1&lt;&lt;endl; return; &#125; q.push(b); &#125; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;s&gt;&gt;n&gt;&gt;m&amp;&amp;m&amp;&amp;n&amp;&amp;s) &#123; if(s%2 &#x3D;&#x3D; 1)&#123; printf(&quot;NO\\n&quot;); continue; &#125; memset(v,0,sizeof(v)); r[0]&#x3D;m; r[1]&#x3D;n; r[2]&#x3D;s; bfs(); &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"倒水","slug":"倒水","permalink":"https://donghuangzhong.github.io/tags/%E5%80%92%E6%B0%B4/"},{"name":"数论","slug":"数论","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"HDU-1241","slug":"HDU-1241","date":"2020-02-23T11:57:05.000Z","updated":"2020-02-23T11:59:40.268Z","comments":true,"path":"2020/02/23/HDU-1241/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/23/HDU-1241/","excerpt":"简单BFS，找到一个入队点将所有可达的区域置为不可达","text":"简单BFS，找到一个入队点将所有可达的区域置为不可达 题目油藏\\时间限制：2000/1000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）提交总数：58896接受提交：33745** 问题描述 GeoSurvComp地质勘测公司负责检测地下油藏。GeoSurvComp一次处理一个大矩形区域的土地，并创建一个将土地划分为多个正方形图的网格。然后，它使用传感设备分别分析每个地块，以确定该地块是否包含油。包含油的地块称为矿穴。如果两个凹坑相邻，则它们是同一油藏的一部分。积油可能很大，可能包含许多凹穴。您的工作是确定网格中包含多少种不同的油藏。 输入值 输入文件包含一个或多个网格。每个网格均以包含m和n的行开始，网格中的行和列数为m和n，并用单个空格分隔。如果m = 0，则表示输入结束；否则，输入0。否则为1 &lt;= m &lt;= 100和1 &lt;= n &lt;=100。紧随其后的是m行，每行n个字符（不计算行尾字符）。每个字符对应一个地块，要么是代表无油的“ *”，要么是代表油囊的“ @”。 输出量 对于每个网格，输出不同的油藏数量。如果两个不同的油藏在水平，垂直或对角线上相邻，则它们是同一油藏的一部分。积油最多可容纳100个口袋。 样本输入 1234567891011121314151 1 * 3 5 * @ * @ * ** @ ** * @ * @ * 1 8 @@ **** @ * 5 5 **** @ * @@ * @ * @ ** @ @@@ * @ @@ ** @ 0 0 样本输出 12340 1 2 2 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int dir[8][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1,1,1,-1,-1,1,-1,-1,1&#125;;char map[101][101]; struct Point&#123; int x,y;&#125; a,b;int h,l;void bfs(int x,int y)&#123; queue&lt;Point&gt; q; a.x&#x3D;x; a.y&#x3D;y; q.push(a); map[x][y]&#x3D;&#39;*&#39;; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;8;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(b.x&gt;&#x3D;0&amp;&amp;b.x&lt;h&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;l&amp;&amp;map[b.x][b.y]&#x3D;&#x3D;&#39;@&#39;) &#123; map[b.x][b.y]&#x3D;&#39;*&#39;; q.push(b); &#125; &#125; &#125; &#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;h&gt;&gt;l&amp;&amp;h&amp;&amp;l) &#123; int sum&#x3D;0; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; cin&gt;&gt;map[i][j]; &#125; &#125; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; if(map[i][j]&#x3D;&#x3D;&#39;@&#39;) &#123; bfs(i,j); sum++; &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"图的连通区域","slug":"图的连通区域","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%8C%BA%E5%9F%9F/"},{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"迷宫问题","slug":"迷宫问题","date":"2020-02-23T10:16:02.000Z","updated":"2020-02-23T10:20:59.846Z","comments":true,"path":"2020/02/23/迷宫问题/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/23/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/","excerpt":"每个节点的去向有很多，不变保存，每个点的来源只有一个，方便保存，但是是逆序的，最后要递归输出","text":"每个节点的去向有很多，不变保存，每个点的来源只有一个，方便保存，但是是逆序的，最后要递归输出 题目迷宫问题定义一个二维数组： 1234567int maze[5][5] &#x3D; &#123; 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,&#125;; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 Input 一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。 Output 左上角到右下角的最短路径，格式如样例所示。 Sample Input123450 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0 Sample Output123456789(0, 0)(1, 0)(2, 0)(2, 1)(2, 2)(2, 3)(2, 4)(3, 4)(4, 4) 算法用另外一个和map一样大小的数组保存该点的上一个点的坐标，然后递归输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std; int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;struct Point&#123; int x; int y;&#125; a,b,point[5][5];int map[5][5];void printxy(int x,int y)&#123; if(x&#x3D;&#x3D;-1&amp;&amp;y&#x3D;&#x3D;-1) return ; printxy(point[x][y].x,point[x][y].y); cout&lt;&lt;&quot;(&quot;&lt;&lt;x&lt;&lt;&quot;, &quot;&lt;&lt;y&lt;&lt;&quot;)&quot;&lt;&lt;endl;&#125;void bfs()&#123; queue&lt;Point&gt; q; a.x&#x3D;0; a.y&#x3D;0; q.push(a); map[0][0]&#x3D;1; point[0][0].x&#x3D;-1; point[0][0].y&#x3D;-1; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(b.x&gt;&#x3D;0&amp;&amp;b.x&lt;5&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;5&amp;&amp;map[b.x][b.y]&#x3D;&#x3D;0) &#123; map[b.x][b.y]&#x3D;1; point[b.x][b.y].x&#x3D;a.x; point[b.x][b.y].y&#x3D;a.y; if(b.x&#x3D;&#x3D;4&amp;&amp;b.y&#x3D;&#x3D;4) &#123; printxy(4,4); &#125; q.push(b); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); for(int i&#x3D;0;i&lt;5;i++) &#123; for(int j&#x3D;0;j&lt;5;j++) &#123; cin&gt;&gt;map[i][j]; &#125; &#125; bfs(); return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"输出路径","slug":"输出路径","permalink":"https://donghuangzhong.github.io/tags/%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84/"}]},{"title":"UVA-11624","slug":"UVA-11624","date":"2020-02-23T04:24:43.000Z","updated":"2020-02-23T06:09:58.176Z","comments":true,"path":"2020/02/23/UVA-11624/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/23/UVA-11624/","excerpt":"一个BFS，多个入口，char的表示范围[0,127]，本来可以不用标志数组的，节省空间，但奈何char表示不了比较大的数","text":"一个BFS，多个入口，char的表示范围[0,127]，本来可以不用标志数组的，节省空间，但奈何char表示不了比较大的数 题目火场逃生一个矩阵中有一个人，用J表示，可以向上下左右走。有多个起火点，用F表示。#表示墙，.表示人可以行走的地方。要求是逃出这个矩阵即可，输出逃出这个矩阵的最短时间，如果不能逃出这个矩阵输出IMPOSSIBEL Sample Input1234567891024 4#### #JF# #..# #..# 3 3 ### #J. #.F Sample Output123 IMPOSSIBLE 算法单个BFS火场逃生是一个连续的过程，同时有火的蔓延和人的移动。但可以将这个连续的过程分割，比如人先走一步，火再蔓延一步，人再走一步，火再蔓延一步······。可是既然是同时发生的，谁先谁后呢？肯定是人先火后了，因为这样不会改变的火场逃生的结果。不然火先的话，假设火和人差一步，火先的话人就死了，火场逃生的结果就不符合事实。人先火后的话问题就变得简单起来了，因为人要先行，所以人必须先入队(同时将该点的J，改变为K)，然后才是各个火种的入队。进入循环，取队首，队首出队，判断这个队首是火(火的话就是’F‘)还是人(&gt;=’K’)，如果是人，判断走完下一步是否走出矩阵，如果走出，则直接保存一下时间(这个时间的基数为’K‘，最后要减去’K‘)然后return，否则将这个点可达的’.’置为队首加一(没错，这是一个字符数组，但char和int在[0,127]互通,这也是为什么失败的原因)，可达点入队；如果是火，则将火的可达点(不是火并且不是墙)置为F，可达点入队……循环往复 失败原因：char能表示的int为[0,127]，再加上基数为’K‘，能表示的时间就更短了，无奈溢出。。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;int h,l,startx,starty,firex,firey,mintime;int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;char map[1001][1001];using namespace std;struct Point&#123; int x; int y;&#125; a,b;queue&lt;Point&gt; q;void bfs()&#123; mintime&#x3D;0; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(map[a.x][a.y]&gt;&#x3D;&#39;K&#39;) &#123; if(b.x&lt;0||b.x&gt;&#x3D;h||b.y&lt;0||b.y&gt;&#x3D;l) &#123; mintime&#x3D;map[a.x][a.y]+1-&#39;K&#39;; return ; &#125; else if(map[b.x][b.y]&#x3D;&#x3D;&#39;.&#39;) &#123; map[b.x][b.y]&#x3D;map[a.x][a.y]+1; q.push(b); &#125; &#125; if(map[a.x][a.y]&#x3D;&#x3D;&#39;F&#39;&amp;&amp;b.x&gt;&#x3D;0&amp;&amp;b.x&lt;h&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;l&amp;&amp;map[b.x][b.y]!&#x3D;&#39;F&#39;&amp;&amp;map[b.x][b.y]!&#x3D;&#39;#&#39;) &#123; map[b.x][b.y]&#x3D;&#39;F&#39;; q.push(b); &#125; &#125; &#125; &#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; while(n--) &#123; while(!q.empty()) q.pop(); cin&gt;&gt;h&gt;&gt;l; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]&#x3D;&#x3D;&#39;J&#39;) &#123; startx&#x3D;i; starty&#x3D;j; a.x&#x3D;startx; a.y&#x3D;starty; map[a.x][a.y]&#x3D;&#39;K&#39;; q.push(a); &#125; &#125; &#125; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; if(map[i][j]&#x3D;&#x3D;&#39;F&#39;) &#123; firex&#x3D;i; firey&#x3D;j; a.x&#x3D;firex; a.y&#x3D;firey; q.push(a); &#125; &#125; &#125; bfs(); if(mintime&#x3D;&#x3D;0) cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl; else cout&lt;&lt;mintime&lt;&lt;endl; &#125; return 0; &#125; 这个在UVA上有debug功能，这个算法通过了所有的测试，但还是WA了，追求完美是每个人的向往，我看到这个题发现地图，标志数组，记录时间的数组可以共用一个，所以写出了上面的代码。知道失败的原因就好改了，记录时间的数组少不了。同时我也将标志数组和记录时间的数组共用一个(这是我的习惯，可以去看看我其他的BFS，其实大部分都是可以共用的)，于是有了下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;int h,l,mintime;int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;char map[1001][1001];int v[1001][1001];using namespace std;struct Point&#123; int x; int y;&#125; a,b;queue&lt;Point&gt; q;void bfs()&#123; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(map[a.x][a.y]&#x3D;&#x3D;&#39;.&#39;) &#123; if(b.x&lt;0||b.x&gt;&#x3D;h||b.y&lt;0||b.y&gt;&#x3D;l) &#123; mintime&#x3D;v[a.x][a.y]+1-1; return ; &#125; else if(map[b.x][b.y]&#x3D;&#x3D;&#39;.&#39;&amp;&amp;v[b.x][b.y]&#x3D;&#x3D;0) &#123; v[b.x][b.y]&#x3D;v[a.x][a.y]+1; q.push(b); &#125; &#125; if(map[a.x][a.y]&#x3D;&#x3D;&#39;F&#39;&amp;&amp;b.x&gt;&#x3D;0&amp;&amp;b.x&lt;h&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;l&amp;&amp;map[b.x][b.y]!&#x3D;&#39;F&#39;&amp;&amp;map[b.x][b.y]!&#x3D;&#39;#&#39;) &#123; map[b.x][b.y]&#x3D;&#39;F&#39;; q.push(b); &#125; &#125; &#125; &#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; while(n--) &#123; mintime&#x3D;0; memset(v,0,sizeof(v)); while(!q.empty()) q.pop(); cin&gt;&gt;h&gt;&gt;l; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]&#x3D;&#x3D;&#39;J&#39;) &#123; a.x&#x3D;i; a.y&#x3D;j; v[a.x][a.y]&#x3D;1; map[a.x][a.y]&#x3D;&#39;.&#39;; q.push(a); &#125; &#125; &#125; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; if(map[i][j]&#x3D;&#x3D;&#39;F&#39;) &#123; a.x&#x3D;i; a.y&#x3D;j; q.push(a); &#125; &#125; &#125; bfs(); if(mintime&#x3D;&#x3D;0) cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl; else cout&lt;&lt;mintime&lt;&lt;endl; &#125; return 0; &#125; 双BFS这也是一个方法，分为火的BFS和人的BFS，先算火的BFS，记录火到达每一个点的时间，然后再算人的BFS，加一个条件，人必须要比火先到才能走下一步，不过我没写代码","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"妙用标志数组","slug":"妙用标志数组","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"},{"name":"多入口BFS","slug":"多入口BFS","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%9A%E5%85%A5%E5%8F%A3BFS/"},{"name":"火场逃生","slug":"火场逃生","permalink":"https://donghuangzhong.github.io/tags/%E7%81%AB%E5%9C%BA%E9%80%83%E7%94%9F/"}]},{"title":"POJ-3126","slug":"POJ-3126","date":"2020-02-22T08:07:26.000Z","updated":"2020-02-22T08:30:17.283Z","comments":true,"path":"2020/02/22/POJ-3126/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/22/POJ-3126/","excerpt":"4位数素数共1061个，如果m个条件，其中固定a个条件成立，b个条件不成立，a+b=m，则可以列出这些条件，令它们的和为a","text":"4位数素数共1061个，如果m个条件，其中固定a个条件成立，b个条件不成立，a+b=m，则可以列出这些条件，令它们的和为a 题目主要路径 时限： 1000MS 内存限制： 65536K 提交总数： 37988 接受： 20286 就是给两个四位数素数a,b，每次只能变化a中个位十位百位千位其中的一位，问经过多少次变化可以a可以变成b 1033173337333739377987798179 该解决方案的成本为6磅。请注意，在步骤2中粘贴的数字1不能在最后一步中重复使用-必须购买新的1。 输入值 一行带有正数：测试用例的数量（最多100个）。然后，对于每个测试用例，用两个数字用空格分隔的一行。这两个数字都是四位数的质数（无前导零）。 输出量 每种情况下一行，或者用数字表示最低费用，或者包含“不可能”一词。 样本输入 123431033 81791373 80171033 1033 样本输出 123670 算法对素数进行打表，利用标志数组记录步数(基数为1，最终结果-1)，利用逻辑相加保证只有一位变化，比如找相比于a只有一位变化的数字，遍历素数数组p，(p[i]%10==g)+(p[i]/10%10==s)+(p[i]/100%10==ba)+(p[i]/1000==qi))==3就能保证只有一位发生变化，其中g,s,ba,qi分别为a的个，十，百，千位。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int a,b,minn&#x3D;1000000;int p[1062];int pp[1062];void bfs(int k)&#123; pp[k]&#x3D;1; queue&lt;int&gt; q; q.push(k); while(!q.empty()) &#123; int w&#x3D;q.front(); q.pop(); int g,s,ba,qi; g&#x3D;p[w]%10; s&#x3D;p[w]&#x2F;10%10; ba&#x3D;p[w]&#x2F;100%10; qi&#x3D;p[w]&#x2F;1000; for(int i&#x3D;1;i&lt;1062;i++) &#123; if(((p[i]%10&#x3D;&#x3D;g)+(p[i]&#x2F;10%10&#x3D;&#x3D;s)+(p[i]&#x2F;100%10&#x3D;&#x3D;ba)+(p[i]&#x2F;1000&#x3D;&#x3D;qi))&#x3D;&#x3D;3&amp;&amp;pp[i]&#x3D;&#x3D;0) &#123; pp[i]&#x3D;pp[w]+1; if(p[i]&#x3D;&#x3D;b) &#123; cout&lt;&lt;pp[i]-1&lt;&lt;endl; return; &#125; q.push(i); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int qq&#x3D;0,j; for(int i&#x3D;1000;i&lt;&#x3D;9999;i++) &#123; int sq&#x3D;sqrt(i); for(j&#x3D;2;j&lt;&#x3D;sq;j++) &#123; if(i%j&#x3D;&#x3D;0) break; &#125; if(j&lt;&#x3D;sq) continue; qq++; &#x2F;&#x2F;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl; p[qq]&#x3D;i; &#125; int n; cin&gt;&gt;n; while(n--) &#123; int r; cin&gt;&gt;a&gt;&gt;b; if(a&#x3D;&#x3D;b) &#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; memset(pp,0,sizeof(pp)); for(r&#x3D;1;r&lt;1062;r++) if(p[r]&#x3D;&#x3D;a) &#123; break; &#125; pp[r]&#x3D;1; bfs(r); &#x2F;&#x2F; cout&lt;&lt;minn-1&lt;&lt;endl; &#x2F;&#x2F;cout&lt;&lt;1&#x3D;&#x3D;1+ &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"标志数组妙用","slug":"标志数组妙用","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/"},{"name":"素数打表","slug":"素数打表","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A0%E6%95%B0%E6%89%93%E8%A1%A8/"},{"name":"逻辑相加妙用","slug":"逻辑相加妙用","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E7%9B%B8%E5%8A%A0%E5%A6%99%E7%94%A8/"}]},{"title":"POJ-1426","slug":"POJ-1426","date":"2020-02-21T10:20:08.000Z","updated":"2020-02-21T11:38:04.800Z","comments":true,"path":"2020/02/21/POJ-1426/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/21/POJ-1426/","excerpt":"代码是从网上抄下来的，我之前想过这个思路，但是被我否决了，否决的原因有两点，1.无法判断从小到大的每一种01组合对n取余是不是0？2.题目中说解的长度不超过100位，我无法判断解的最短长度的最大值。虽然AC了，但是网上的答案还是没有解决第二个问题，不知道他们是怎么确定答案在32位数以内","text":"代码是从网上抄下来的，我之前想过这个思路，但是被我否决了，否决的原因有两点，1.无法判断从小到大的每一种01组合对n取余是不是0？2.题目中说解的长度不超过100位，我无法判断解的最短长度的最大值。虽然AC了，但是网上的答案还是没有解决第二个问题，不知道他们是怎么确定答案在32位数以内 题目寻找多重 时限： 1000MS 内存限制： 10000K 提交总数： 56332 接受： 23292 特别法官 描述 给定正整数n，编写一个程序以找出n的非零倍数m，其十进制表示形式仅包含数字0和1。您可以假定n不大于200，并且对应的m包含不超过100十进制数字。 输入值 输入文件可能包含多个测试用例。每行包含一个值n（1 &lt;= n &lt;= 200）。包含零的行将终止输入。 输出量 对于输入中n的每个值，打印一行包含m的对应值。m的十进制表示形式不能超过100个数字。如果给定值n有多个解，则其中任何一个都是可接受的。 样本输入 123426190 样本输出 12310100100100100100100111111111111111111 算法具体步骤就是二进制枚举，将一个整形的二进制表示十进制,注意是表示不是转换，例如11(二进制)=3(十进制)，这是转换，3(十进制)=11(二进制)表示为11(十进制)，这是表示。一个整形表示的范围为0(2^31-1)，也就是二进制000,001,010,011,100111(这只是3位，应该是31位)，这些01串正是从小到大的遍历。","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"二进制","slug":"ACM/二进制","permalink":"https://donghuangzhong.github.io/categories/ACM/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}],"tags":[{"name":"同余定理","slug":"同余定理","permalink":"https://donghuangzhong.github.io/tags/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/"},{"name":"二进制表示十进制","slug":"二进制表示十进制","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%8D%81%E8%BF%9B%E5%88%B6/"}]},{"title":"POJ-3279","slug":"POJ-3279","date":"2020-02-20T10:30:53.000Z","updated":"2020-02-20T11:00:47.764Z","comments":true,"path":"2020/02/20/POJ-3279/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/20/POJ-3279/","excerpt":"本来想DFS的，但是复杂度太高了。第一次遇到这种开关类问题，关键就是要找唯一点，比如本题，要翻转一个色块有5种选择，砍掉四个，只留下最下面的一个选择。这样如果此色块为黑色，则下面的色块必须翻转；为白则必须不翻转","text":"本来想DFS的，但是复杂度太高了。第一次遇到这种开关类问题，关键就是要找唯一点，比如本题，要翻转一个色块有5种选择，砍掉四个，只留下最下面的一个选择。这样如果此色块为黑色，则下面的色块必须翻转；为白则必须不翻转 题目翻板 时限： 2000MS 内存限制： 65536K 提交总数： 25631 接受的： 9075 描述 农夫约翰知道，一头知识上满意的母牛是一头快乐的母牛，它将提供更多的牛奶。他已安排一个聪明的活动中，他们操纵奶牛中号 × Ñ栅格（1≤ 中号 ≤15; 1≤ ñ ≤15）正方形瓷砖，其中的每一个着色为黑色的一侧和白色的另一侧。 就像人们猜测的那样，当翻转单个白色图块时，它会变为黑色。翻转单个黑色图块时，它将变为白色。母牛在翻转砖块时会得到奖励，因此每块砖块的白色侧面都朝上。但是，母牛的蹄子相当大，当他们尝试翻转特定的瓷砖时，它们也会翻转所有相邻的瓷砖（与翻转的瓷砖共享完整边缘的瓷砖）。由于翻转很累，奶牛希望尽量减少翻转次数。 帮助奶牛确定所需的最小翻转次数，以及达到该最小翻转的位置。如果有多种方法可以以最小的翻转次数来完成任务，则当将其视为字符串时，以输出中词典顺序最少的方式返回。如果无法完成任务，请用“ IMPOSSIBLE”一词打印一行。 输入值 第1行：两个以空格分隔的整数：M和N第2行。M +1：第i +1行描述了网格第i行的颜色（从左到右），其中N个以空格分隔的整数，黑色和1为黑色。 0代表白色 输出量 第1 .. M行：每行包含N个以空格分隔的整数，每个整数指定翻转该特定位置的次数。 样本输入 123454 41 0 0 10 1 1 00 1 1 01 0 0 1 样本输出 12340 0 0 01 0 0 11 0 0 10 0 0 0 算法该游戏不受步骤的影响，没有翻转的先后顺序，因为某一个色块被翻转的总和跟翻转的顺序没有关系，总和不变，颜色就不变，所以对于一个色块翻转两次没有意义。假设现在已经知道最优解的第一行要翻转哪几个色块(指的是中心色块，不是周围被翻转的四个)，那么将这几个色块根据规则翻转后，对于第一行的黑色块，它下面的色块(第二行)必须被翻转，因为对于这个黑色块而言，能够改变它颜色的邻居四个中只有下面的能翻转(上面没有色块，左右色块不能翻转，因为你已经将最优解中第一行的的翻转色块翻转完了)；同理第一行白色块下面必须不能翻转，这样就能确定第二行色块的翻转情况，将第二行翻转后，又回到第一行最优解翻转后的情况….。重复这个过程。所以如果知道第一行的翻转情况，就能知道整体的翻转情况。现在的问题是我们不知道最优解第一行的翻转情况，那么就需要枚举了，枚举第一行的翻转情况(最多2^n)，取最优即可，需要注意的是如果最后一行翻转后还有黑色，则此种第一行的分布不能得出解，因为最后一行没有能改变的选择了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;using namespace std;int c,k,sum,minn;bool qipan[16][16],zturn[16][16],turn[16][16]; int lujing[5][2]&#x3D;&#123;0,0,0,1,0,-1,1,0,-1,0&#125;;bool getcolor(int a,int b)&#123; int turn_sum&#x3D;qipan[a][b]; for(int i&#x3D;0;i&lt;5;i++) &#123; int x&#x3D;a+lujing[i][0]; int y&#x3D;b+lujing[i][1]; if(x&gt;&#x3D;0&amp;&amp;x&lt;c&amp;&amp;y&gt;&#x3D;0&amp;&amp;y&lt;k) turn_sum+&#x3D;turn[x][y]; &#125; return turn_sum%2;&#125;void cal()&#123; for(int q&#x3D;1;q&lt;c;q++) for(int w&#x3D;0;w&lt;k;w++) &#123; if(getcolor(q-1,w)) &#123; turn[q][w]&#x3D;1; sum++; if(sum&gt;&#x3D;minn) return; &#125; &#125; for(int e&#x3D;0;e&lt;k;e++) if(getcolor(c-1,e)) return ; if(sum&lt;minn) &#123; minn&#x3D;sum; memcpy(zturn,turn,sizeof(turn)); &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;c&gt;&gt;k) &#123; for(int i&#x3D;0;i&lt;c;i++) for(int j&#x3D;0;j&lt;k;j++) cin&gt;&gt;qipan[i][j]; minn&#x3D;0x3f3f3f3f; for(int i&#x3D;0;i&lt;1&lt;&lt;k;i++) &#123; sum&#x3D;0; memset(turn,0,sizeof(turn)); for(int j&#x3D;0;j&lt;k;j++) &#123; turn[0][k-1-j]&#x3D;(i&gt;&gt;j)&amp;1; if(turn[0][k-1-j]&#x3D;&#x3D;1) sum++; &#125; cal(); &#125; if(minn&#x3D;&#x3D;0x3f3f3f3f) cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl; else &#123; for(int i&#x3D;0;i&lt;c;i++) &#123; for(int j&#x3D;0;j&lt;k;j++) cout&lt;&lt;zturn[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; &#125; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"开关","slug":"ACM/开关","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%BC%80%E5%85%B3/"}],"tags":[{"name":"翻转游戏","slug":"翻转游戏","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E6%B8%B8%E6%88%8F/"}]},{"title":"HDU-2717 POJ-3278","slug":"HDU-2717-POJ-3278","date":"2020-02-19T10:36:00.000Z","updated":"2020-02-20T01:23:37.830Z","comments":true,"path":"2020/02/19/HDU-2717-POJ-3278/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/19/HDU-2717-POJ-3278/","excerpt":"太坑了，题中没有标明有多个测试用例，如果只输入一次，POJ可以通过，HDU必需用while(cin&gt;&gt;n&gt;&gt;k),并且POJ有一个测试用例是起点和终点一起，所以bfs的开始就要判断起点和终点是否相同，每一次入队前都要判断起点和终点是否相同，如果为了省代码出队判断是否为终点，牺牲了太多时间(多处理了太多点)，我非常不推荐","text":"太坑了，题中没有标明有多个测试用例，如果只输入一次，POJ可以通过，HDU必需用while(cin&gt;&gt;n&gt;&gt;k),并且POJ有一个测试用例是起点和终点一起，所以bfs的开始就要判断起点和终点是否相同，每一次入队前都要判断起点和终点是否相同，如果为了省代码出队判断是否为终点，牺牲了太多时间(多处理了太多点)，我非常不推荐 题目赶上那头牛\\时间限制：5000/2000 MS（Java /其他）内存限制：32768/32768 K（Java /其他）总计提交：28511已接受提交：7809** 问题描述 农夫约翰已被告知一头逃犯的位置，并希望立即抓住她。他从数字线上的点N（0≤N≤100,000）开始，而母牛在同一数字线上的点K（0≤K≤100,000）。农夫约翰有两种运输方式：步行和传送。 *行走：FJ可以在一分钟内从任意点X移至点X-1或X + 1。*传送：FJ可以在一分钟内从任意点X移至点2×X。 如果没有意识到它的追捕能力的母牛完全没有动弹，那么农夫约翰要花多长时间？ 输入值 第1行：两个以空格分隔的整数：N和K 输出量 第1行：最短的时间（以分钟为单位），农夫John赶上了逃亡的母牛。 样本输入 15 17 样本输出 1234暗示农夫约翰到达逃亡者牛的最快方法是沿着以下路径移动：5-10-9-18-17，这需要4分钟。 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;using namespace std;int n,k;int zhou[100001];int a,b;bool judge(int w)&#123; if(w&gt;&#x3D;0&amp;&amp;w&lt;&#x3D;100000&amp;&amp;zhou[w]&#x3D;&#x3D;0) return 1; return 0;&#125;void bfs()&#123; if(n&#x3D;&#x3D;k)&#123; cout&lt;&lt;0&lt;&lt;endl; return ; &#125; memset(zhou,0,sizeof(zhou)); zhou[n]&#x3D;1; queue&lt;int&gt; q; q.push(n); while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;3;i++) &#123; if(i&#x3D;&#x3D;0) b&#x3D;a-1; else if(i&#x3D;&#x3D;1) b&#x3D;a+1; else b&#x3D;2*a; &#x2F;&#x2F;if(b&lt;0||b&gt;100000) continue; &#x2F;&#x2F; if(zhou[b]&#x3D;&#x3D;0) if(judge(b)) &#123; zhou[b]&#x3D;zhou[a]+1; if(b&#x3D;&#x3D;k) &#123; cout&lt;&lt;zhou[b]-1&lt;&lt;endl; return ; &#125; q.push(b); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;n&gt;&gt;k) &#123; if(k&lt;&#x3D;n) cout&lt;&lt;n-k&lt;&lt;endl; else bfs(); &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"标志数组妙用","slug":"标志数组妙用","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/"}]},{"title":"POJ-2251","slug":"POJ-2251","date":"2020-02-19T04:08:39.000Z","updated":"2020-02-19T04:24:48.079Z","comments":true,"path":"2020/02/19/POJ-2251/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/19/POJ-2251/","excerpt":"无论是BFS还是DFS都需要一个标志数组来防止无意义的重复路径访问，并不是只能访问一次，有些迷宫会有加血或者加时间的设定。但有些仅仅是简单的只能访问一次，这样只能用到数组的01两个状态，如果有别的属性值(例如时间等)也可以放到标志数组中(前提是不能有乘除运算)，但是如果这样设定，起点初始化为被访问过，置1，这样有些时间就整体提升了1，所以在最后要减去1。","text":"无论是BFS还是DFS都需要一个标志数组来防止无意义的重复路径访问，并不是只能访问一次，有些迷宫会有加血或者加时间的设定。但有些仅仅是简单的只能访问一次，这样只能用到数组的01两个状态，如果有别的属性值(例如时间等)也可以放到标志数组中(前提是不能有乘除运算)，但是如果这样设定，起点初始化为被访问过，置1，这样有些时间就整体提升了1，所以在最后要减去1。 题目Dungeon Master Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 68475 Accepted: 24773 Description You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. Is an escape possible? If yes, how long will it take? Input The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).L is the number of levels making up the dungeon.R and C are the number of rows and columns making up the plan of each level.Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C. Output Each maze generates one line of output. If it is possible to reach the exit, print a line of the form Escaped in x minute(s). where x is replaced by the shortest time it takes to escape.If it is not possible to escape, print the line Trapped! Sample Input 123456789101112131415161718192021223 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0 Sample Output 12Escaped in 11 minute(s).Trapped! 算法这个题也可以不将起点置1，这样起点就可以访问两次(访问第二次后就不能再次访问)，对本题没有什么影响，因为本题的起点终点一定不会重合，但我实在不提倡这种做法 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;using namespace std;char migong[31][31][31];int visit[31][31][31];int l,r,c;struct Point&#123; int x,y,z;&#125; qi,zhong,a,b;int lujing[6][3]&#x3D;&#123;1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1&#125;;void bfs()&#123; queue&lt;Point&gt; q; a&#x3D;qi; if(a.x&#x3D;&#x3D;zhong.x&amp;&amp;a.y&#x3D;&#x3D;zhong.y&amp;&amp;a.z&#x3D;&#x3D;zhong.z) &#123;cout&lt;&lt;&quot;Escaped in 0 minute(s).&quot;&lt;&lt;endl;return ; &#125; memset(visit,0,sizeof(visit)); visit[a.x][a.y][a.z]&#x3D;1; q.push(a); while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;6;i++) &#123; b.x&#x3D;a.x+lujing[i][0]; b.y&#x3D;a.y+lujing[i][1]; b.z&#x3D;a.z+lujing[i][2]; if(b.x&gt;&#x3D;1&amp;&amp;b.x&lt;&#x3D;l&amp;&amp;b.y&gt;&#x3D;1&amp;&amp;b.y&lt;&#x3D;r&amp;&amp;b.z&gt;&#x3D;1&amp;&amp;b.z&lt;&#x3D;c&amp;&amp;migong[b.x][b.y][b.z]!&#x3D;&#39;#&#39;&amp;&amp;visit[b.x][b.y][b.z]&#x3D;&#x3D;0) &#123; visit[b.x][b.y][b.z]&#x3D;visit[a.x][a.y][a.z]+1; if(b.x&#x3D;&#x3D;zhong.x&amp;&amp;b.y&#x3D;&#x3D;zhong.y&amp;&amp;b.z&#x3D;&#x3D;zhong.z)&#123; cout&lt;&lt;&quot;Escaped in &quot;&lt;&lt;visit[b.x][b.y][b.z]-1&lt;&lt;&quot; minute(s).&quot;&lt;&lt;endl;return ; &#125; q.push(b); &#125; &#125;​ &#125; cout&lt;&lt;&quot;Trapped!&quot;&lt;&lt;endl;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;l&gt;&gt;r&gt;&gt;c&amp;&amp;l&amp;&amp;r&amp;&amp;c) &#123; for(int i&#x3D;1;i&lt;&#x3D;l;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;r;j++) &#123; for(int k&#x3D;1;k&lt;&#x3D;c;k++) &#123; cin&gt;&gt;migong[i][j][k]; if(migong[i][j][k]&#x3D;&#x3D;&#39;E&#39;)&#123; zhong.x&#x3D;i;zhong.y&#x3D;j;zhong.z&#x3D;k; &#125; if(migong[i][j][k]&#x3D;&#x3D;&#39;S&#39;)&#123; qi.x&#x3D;i;qi.y&#x3D;j;qi.z&#x3D;k; &#125;​ &#125; &#125; &#125; bfs(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"妙用标志数组","slug":"妙用标志数组","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"}]},{"title":"POJ-1312","slug":"POJ-1312","date":"2020-02-18T08:19:28.000Z","updated":"2020-02-18T08:37:19.056Z","comments":true,"path":"2020/02/18/POJ-1312/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/18/POJ-1312/","excerpt":"此问题只要求不在同一行和同一列，新奇的标志数组，难点：每次递归范围的确定","text":"此问题只要求不在同一行和同一列，新奇的标志数组，难点：每次递归范围的确定 题目棋盘问题 Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 94015 Accepted: 42955 Description 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 Input 输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 Output 对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 Sample Input 1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output 1221 算法棋盘上不一定放多少棋子，不一定每一行都有棋子(相对于全排列)，所以每次递归的范围为上一个棋子的下一行开始一直到棋盘的最后，因此行一定不重复，所以标志数组只需表示某列有没有棋子，即lie[i]=0。同时需要用到上一个棋子的行数，可以选择保留整个点(这样可以输出所有可能的情况)，也可以选择只保留上一个点的x坐标(这样不方便输出每一种情况) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;char qipan[9][9];bool lie[9];int n,sum,k;struct Point&#123; int x; int y;&#125; point[9];bool judge(int x,int y,int n)&#123; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; if(point[i].x&#x3D;&#x3D;x||point[i].y&#x3D;&#x3D;y) return 0; &#125; return 1;&#125;void dfs(int nn)&#123; if(nn&#x3D;&#x3D;k+1) &#123; sum++; return ; &#125; for(int i&#x3D;point[nn-1].x+1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(qipan[i][j]&#x3D;&#x3D;&#39;#&#39;&amp;&amp;lie[j]&#x3D;&#x3D;0&amp;&amp;judge(i,j,nn-1)) &#123; lie[j]&#x3D;1; point[nn].x&#x3D;i; point[nn].y&#x3D;j; dfs(nn+1); lie[j]&#x3D;0; &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;n&gt;&gt;k&amp;&amp;n!&#x3D;-1&amp;&amp;k!&#x3D;-1) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;n;j++) cin&gt;&gt;qipan[i][j]; memset(lie,0,sizeof(lie)); memset(point,0,sizeof(point)); sum&#x3D;0; dfs(1); cout&lt;&lt;sum&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DFS","slug":"ACM/DFS","permalink":"https://donghuangzhong.github.io/categories/ACM/DFS/"}],"tags":[{"name":"八皇后简化版","slug":"八皇后简化版","permalink":"https://donghuangzhong.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%80%E5%8C%96%E7%89%88/"},{"name":"特殊标志数组","slug":"特殊标志数组","permalink":"https://donghuangzhong.github.io/tags/%E7%89%B9%E6%AE%8A%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"},{"name":"递归范围","slug":"递归范围","permalink":"https://donghuangzhong.github.io/tags/%E9%80%92%E5%BD%92%E8%8C%83%E5%9B%B4/"}]},{"title":"HDU-1016","slug":"HDU-1016","date":"2020-02-17T10:12:58.000Z","updated":"2020-02-17T10:54:37.869Z","comments":true,"path":"2020/02/17/HDU-1016/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/HDU-1016/","excerpt":"典型的DFS数据类问题，介绍一个快速打表素数的方法","text":"典型的DFS数据类问题，介绍一个快速打表素数的方法 题目素环问题\\时间限制：4000/2000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）提交总数：82346接受提交：33935** 问题描述 圆环由n个圆组成，如图所示。将自然数1、2，…，n分别放入每个圆，并且两个相邻圆中的数字总和应为质数。 注意：第一个圆的数目应始终为1。 输入值 n（0 &lt;n &lt;20）。 输出量 输出格式如下所示。每一行代表环中从顺时针和逆时针1开始的一系列圆圈编号。数字顺序必须满足上述要求。按字典顺序打印解决方案。 您将编写一个完成上述过程的程序。 在每种情况下都打印空白行。 样本输入 1268 样本输出 123456789情况1：1 4 3 2 5 61 6 5 2 3 4情况2：1 2 3 8 5 6 7 41 2 5 8 3 4 7 61 4 7 6 5 8 3 21 6 7 4 3 8 5 2 算法快速打表素数(0~n)利用memset置0(对字节操作，不能置1的)，0代表是素数，如果i是素数，则2i~ni都不是素数，只要将素数的倍数们都标记为非素数即可,需要注意的是它们的表示与我们通常的认知相反，用法:!sushu[i] 12345bool sushu[45]&#x3D;&#123;0&#125;;for(int i&#x3D;2;i&lt;8;i++)&#x2F;&#x2F;此处的8&#x3D;sqrt(45)+1 if(!sushu[i]) for(int j&#x3D;i*i;j&lt;45;j+&#x3D;i) sushu[j]&#x3D;1; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;int n;int flag[21];int b[21];int sum;bool sushu[45]&#x3D;&#123;0&#125;;bool judge(int a)&#123; return !sushu[a];&#125;void dfs2(int q)&#123; if(q&#x3D;&#x3D;1) &#123; flag[1]&#x3D;1; b[1]&#x3D;1; dfs2(2); return ; &#125; if(q&#x3D;&#x3D;n+1) &#123; if(judge(b[q-1]+1)) &#123; sum++; for(int k&#x3D;1;k&lt;&#x3D;n;k++) &#123; cout&lt;&lt;b[k]; if(k!&#x3D;n) cout&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(flag[i]&#x3D;&#x3D;0&amp;&amp;judge(b[q-1]+i)) &#123; flag[i]&#x3D;1; b[q]&#x3D;i; dfs2(q+1); flag[i]&#x3D;0; &#125; &#125; &#125; int main()&#123; for(int i&#x3D;2;i&lt;8;i++) if(!sushu[i]) for(int j&#x3D;i*i;j&lt;45;j+&#x3D;i) sushu[j]&#x3D;1; int ca&#x3D;1; while(cin&gt;&gt;n) &#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;ca++&lt;&lt;&quot;:&quot;&lt;&lt;endl; sum&#x3D;0; memset(flag,0,sizeof(flag)); dfs2(1); &#x2F;&#x2F;cout&lt;&lt;&quot;种数&quot;&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;endl; &#125;&#125; &#x2F;*void dfs(int nn,int ln)&#123; if(nn&#x3D;&#x3D;1) &#123; b[nn]&#x3D;1; flag[1]&#x3D;1; dfs(2,1); return ; &#125; if(nn&#x3D;&#x3D;n+1) &#123; if(judge(1+ln)) &#123; sum++; for(int k&#x3D;1;k&lt;&#x3D;n;k++) &#123; cout&lt;&lt;b[k]; if(k!&#x3D;n) cout&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return ; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(flag[i]&#x3D;&#x3D;0&amp;&amp;judge(ln+i)) &#123; flag[i]&#x3D;1; b[nn]&#x3D;i; dfs(nn+1,i); flag[i]&#x3D;0; &#125; &#125;&#125;*&#x2F; presentation error输出的最后一个数字后面不应该有空格","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DFS","slug":"ACM/DFS","permalink":"https://donghuangzhong.github.io/categories/ACM/DFS/"}],"tags":[{"name":"素数环","slug":"素数环","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A0%E6%95%B0%E7%8E%AF/"},{"name":"回溯","slug":"回溯","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"PTA-L1-006","slug":"PTA-L1-006","date":"2020-02-17T07:00:35.000Z","updated":"2020-02-17T10:12:40.142Z","comments":true,"path":"2020/02/17/PTA-L1-006/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/PTA-L1-006/","excerpt":"给一个数，求这个数的最长连续因数","text":"给一个数，求这个数的最长连续因数 题目L1-006 连续因子 (20分) 一个正整数 N 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数 N，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。 输入格式：输入在一行中给出一个正整数 N（1&lt;N&lt;231）。 输出格式：首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按 因子1*因子2*……*因子k 的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。 输入样例：1630 输出样例：1235*6*7 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main() &#123; int N, temp; int count &#x3D; 0, maxcount &#x3D; 0, start &#x3D; 0; cin &gt;&gt; N; for (int i &#x3D; 2; i &lt;&#x3D; sqrt(N) ; i++) &#123; temp &#x3D; N; count &#x3D; 0; int j &#x3D; i; while (temp%j&#x3D;&#x3D;0) &#123; temp &#x2F;&#x3D; j++; count++; &#125; if (count &gt; maxcount) &#123; maxcount &#x3D; count; start &#x3D; i; &#125; &#125; if (maxcount) &#123; cout &lt;&lt; maxcount &lt;&lt; endl; for (int i &#x3D; start; i &lt; start+maxcount; i++) &#123; if(i!&#x3D;start)cout&lt;&lt;&quot;*&quot;; cout&lt;&lt;i; &#125; &#125; else cout &lt;&lt;&quot;1&quot;&lt;&lt;endl&lt;&lt; N; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"因数","slug":"ACM/因数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%9B%A0%E6%95%B0/"}],"tags":[{"name":"最长连续因数","slug":"最长连续因数","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%9B%A0%E6%95%B0/"},{"name":"按序列累除","slug":"按序列累除","permalink":"https://donghuangzhong.github.io/tags/%E6%8C%89%E5%BA%8F%E5%88%97%E7%B4%AF%E9%99%A4/"}]},{"title":"pintia-L1-005","slug":"pintia-L1-005","date":"2020-02-17T02:03:38.000Z","updated":"2020-02-17T02:07:56.034Z","comments":true,"path":"2020/02/17/pintia-L1-005/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/pintia-L1-005/","excerpt":"简单字典问题","text":"简单字典问题 题目L1-005 考试座位号 (15分) 每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。 输入格式：输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 16 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。 考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。 输出格式：对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。 输入样例：123456743310120150912233 2 43310120150912119 4 13310120150912126 1 33310120150912002 3 223 4 输出样例：123310120150912002 23310120150912119 1 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;struct student&#123; string xuehao; int shiji; int kszwh;&#125; st[1001];int num[1001];int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; for(int i&#x3D;0;i&lt;n;i++) cin&gt;&gt;st[i].xuehao&gt;&gt;st[i].shiji&gt;&gt;st[i].kszwh; int nn; cin&gt;&gt;nn; for(int i&#x3D;0;i&lt;n;i++) &#123; int nnn; cin&gt;&gt;nnn; for(int j&#x3D;0;j&lt;n;j++) &#123; if(st[j].shiji&#x3D;&#x3D;nnn) &#123; num[i]&#x3D;j; break; &#125; &#125; &#125; for(int i&#x3D;0;i&lt;nn;i++) cout&lt;&lt;st[num[i]].xuehao&lt;&lt;&quot; &quot;&lt;&lt;st[num[i]].kszwh&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"map","slug":"map","permalink":"https://donghuangzhong.github.io/tags/map/"},{"name":"字典","slug":"字典","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E5%85%B8/"}]},{"title":"pintia-L1-004","slug":"pintia-L1-004","date":"2020-02-17T01:47:27.000Z","updated":"2020-02-17T02:06:09.565Z","comments":true,"path":"2020/02/17/pintia-L1-004/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/pintia-L1-004/","excerpt":"给华氏温度求摄氏温度","text":"给华氏温度求摄氏温度 题目L1-004 计算摄氏温度 (5分) 给定一个华氏温度F，本题要求编写程序，计算对应的摄氏温度C。计算公式：C=5×(F−32)/9。题目保证输入与输出均在整型范围内。 输入格式:输入在一行中给出一个华氏温度。 输出格式:在一行中按照格式“Celsius = C”输出对应的摄氏温度C的整数值。 输入样例:1150 输出样例:1Celsius &#x3D; 65 代码1234567891011#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;&quot;Celsius &#x3D; &quot;&lt;&lt;(int)(5*(n-32)&#x2F;9)&lt;&lt;endl; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"摄氏华氏温度转换","slug":"摄氏华氏温度转换","permalink":"https://donghuangzhong.github.io/tags/%E6%91%84%E6%B0%8F%E5%8D%8E%E6%B0%8F%E6%B8%A9%E5%BA%A6%E8%BD%AC%E6%8D%A2/"}]},{"title":"pintia-L1-003","slug":"pintia-L1-003","date":"2020-02-17T00:28:10.000Z","updated":"2020-02-17T02:06:01.928Z","comments":true,"path":"2020/02/17/pintia-L1-003/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/pintia-L1-003/","excerpt":"统计字数的个数","text":"统计字数的个数 题目L1-003 个位数统计 (15分) 给定一个 k 位整数 N=dk−110k−1+⋯+d1101+d0 (0≤di*≤9, *i=0,⋯,k−1, d*k−1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 *N=100311，则有 2 个 0，3 个 1，和 1 个 3。 输入格式：每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。 输出格式：对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。 输入样例：1100311 输出样例：1230:21:33:1 代码1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; char ch[1001];int a[10]&#x3D;&#123;0&#125;;cin&gt;&gt;ch;int lenth&#x3D;strlen(ch);while(lenth--)&#123; for(int i&#x3D;0;i&lt;&#x3D;9;i++) if((ch[lenth]-&#39;0&#39;)&#x3D;&#x3D;i) a[i]++;&#125;for(int i&#x3D;0;i&lt;&#x3D;9;i++)&#123; if(a[i]) cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;a[i]&lt;&lt;endl;&#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"统计数字的个数","slug":"统计数字的个数","permalink":"https://donghuangzhong.github.io/tags/%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%AA%E6%95%B0/"}]},{"title":"pintia-L1-002","slug":"pintia-L1-002","date":"2020-02-17T00:27:46.000Z","updated":"2020-02-17T02:04:26.454Z","comments":true,"path":"2020/02/17/pintia-L1-002/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/pintia-L1-002/","excerpt":"公式求n,两个循环打印","text":"公式求n,两个循环打印 题目L1-002 打印沙漏 (20分) 本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 12345***** *** * ******** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式:输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。 输出格式:首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。 输入样例:119 * 输出样例:123456***** *** * ********2 代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n; char ch; cin&gt;&gt;n&gt;&gt;ch; int nn&#x3D;(int)sqrt((n+1)&#x2F;2); for(int i&#x3D;nn;i&gt;&#x3D;1;i--) &#123; int k&#x3D;nn-i; while(k--) cout&lt;&lt;&quot; &quot;; k&#x3D;2*i-1; while(k--) cout&lt;&lt;ch; cout&lt;&lt;endl; &#125; for(int i&#x3D;2;i&lt;&#x3D;nn;i++) &#123; int k&#x3D;nn-i; while(k--) cout&lt;&lt;&quot; &quot;; k&#x3D;2*i-1; while(k--) cout&lt;&lt;ch; cout&lt;&lt;endl; &#125; int c&#x3D;n-2*nn*nn+1; &#x2F;&#x2F;if(c) cout&lt;&lt;c;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"沙漏","slug":"沙漏","permalink":"https://donghuangzhong.github.io/tags/%E6%B2%99%E6%BC%8F/"},{"name":"等差数列","slug":"等差数列","permalink":"https://donghuangzhong.github.io/tags/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/"}]},{"title":"HDU-1008","slug":"HDU-1008","date":"2020-02-16T09:46:41.000Z","updated":"2020-02-16T10:00:36.521Z","comments":true,"path":"2020/02/16/HDU-1008/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/16/HDU-1008/","excerpt":"给出楼层，计算电梯的运行时间","text":"给出楼层，计算电梯的运行时间 题目电梯\\时间限制：2000/1000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）总提交数量：100638接受提交数量：54525** 问题描述 我们城市最高的建筑物只有一部电梯。请求列表由N个正数组成。数字按指定顺序表示电梯将停在的楼层。将电梯上移一层需要6秒钟，而将一层下移则需要4秒钟。电梯将在每个站点停留5秒钟。 对于给定的请求列表，您将计算完成列表上的请求所花费的总时间。电梯在开始时位于0楼，并且在满足请求后不必返回一楼。 输入值 有多个测试用例。每个案例包含一个正整数N，后跟N个正数。输入中的所有数字均小于100。N = 0的测试用例表示输入结束。该测试用例将不被处理。 输出量 将每个测试用例的总时间打印在一行上。 样本输入 1231 23 2 3 10 样本输出 121741 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n,floor,lfloor; while(cin&gt;&gt;n&amp;&amp;n) &#123; int time&#x3D;0; lfloor&#x3D;0; while(n--) &#123; cin&gt;&gt;floor; if(floor&gt;lfloor) time+&#x3D;6*(floor-lfloor); else time+&#x3D;4*(lfloor-floor); lfloor&#x3D;floor; time+&#x3D;5; &#125; cout&lt;&lt;time&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"电梯","slug":"电梯","permalink":"https://donghuangzhong.github.io/tags/%E7%94%B5%E6%A2%AF/"}]},{"title":"dotcpp-1004","slug":"dotcpp-1004","date":"2020-02-16T07:59:20.000Z","updated":"2020-02-16T08:03:02.178Z","comments":true,"path":"2020/02/16/dotcpp-1004/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/16/dotcpp-1004/","excerpt":"第一年一头成年母牛，每年生一小牛，小牛四年后才成年，求第N年的牛的个数","text":"第一年一头成年母牛，每年生一小牛，小牛四年后才成年，求第N年的牛的个数 题目题目描述 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ 输入 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 输出 对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。 样例输入 12342450 样例输出 123246 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n; int a[56]; a[1]&#x3D;1; a[2]&#x3D;2; a[3]&#x3D;3; a[4]&#x3D;4; for(int i&#x3D;5;i&lt;56;i++) &#123; a[i]&#x3D;a[i-1]+a[i-3]; &#125; while(cin&gt;&gt;n&amp;&amp;n) &#123; cout&lt;&lt;a[n]&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://donghuangzhong.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"},{"name":"兔子问题","slug":"兔子问题","permalink":"https://donghuangzhong.github.io/tags/%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98/"}]},{"title":"HDU-1006","slug":"HDU-1006","date":"2020-02-14T03:10:09.000Z","updated":"2020-02-14T04:00:58.166Z","comments":true,"path":"2020/02/14/HDU-1006/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/14/HDU-1006/","excerpt":"一般我们的思维都是先找第一段符合题目的解，然后找第二段第三段，从而理解题目和找出规律。但对于有些题目，规律甚至第一段的解都非常难找，但如果我们知道解位于一个临界集合中，我们就可以不用去找这个解，转而寻找这个临界集合(因为寻找解非常复杂，寻找临界集合却比较容易)，前提是可以把解从临界集合中分离出来(一般是临界集合的最值)。这样我们就可以避开寻找解这个非常复杂的过程，简化题目。","text":"一般我们的思维都是先找第一段符合题目的解，然后找第二段第三段，从而理解题目和找出规律。但对于有些题目，规律甚至第一段的解都非常难找，但如果我们知道解位于一个临界集合中，我们就可以不用去找这个解，转而寻找这个临界集合(因为寻找解非常复杂，寻找临界集合却比较容易)，前提是可以把解从临界集合中分离出来(一般是临界集合的最值)。这样我们就可以避开寻找解这个非常复杂的过程，简化题目。 题目滴答和滴答\\时间限制：2000/1000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）提交总计：26354接受提交：7208** 问题描述 时钟的三只指针每秒旋转一次，并且每天相遇很多次。最后，他们对此感到无聊，并且每个人都希望远离其他两个人。如果一只手与其余任何一只手至少有D度，那它就是快乐的。您要计算一天中所有双手都开心的时间。 输入值 输入包含许多测试用例。他们每个人都有一条单行，其实数D在0和120之间（含0和120）。输入以-1的D终止。 输出量 对于每个D，用一行打印一天中所有手牌都高兴的时间百分比，精确到小数点后3位。 样本输入 1234012090-1 样本输出 123100.0000.0006.251 算法为什么暴力遍历每一秒不行因为本题对精度有非常高的要求，这个表应该是静音表(扫秒表)，不会发出滴答滴答的声音，并且要用到角速度，因为只有这样才能满足精度要求 分析本题如果仔细思考求解的话，整个过程是非常复杂的，因为你不知道每一小段开始时究竟是那两个针到达临界值。既然这样那就求临界集合，将分针和时针从重合到再次重合看做一个大周期，将分针和表针从重合到再次重合看做一个周期，将时针和秒针从重合到再次重合看做一个小周期。一共有三个针，C32共有三种可能，也就是说每一小段的开始时刻必然在临界开始集合(分-时=n,秒-时=n,秒-分=n)中，并且是临界开始集合的最大值，而每一小段的结束必然存在于临界结束集合(分-时=360-n,秒-时=360-n,秒-分=360-n)中，并且是临界结束集合的最小值。这样只求两个临界集合就行了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;double max(double a,double b,double c)&#123; double max=a&gt;b?a:b; return max&gt;c?max:c;&#125;double min(double a,double b,double c)&#123; double min=a&lt;b?a:b; return min&lt;c?min:c;&#125;int main()&#123; freopen(\"input.txt\", \"r\", stdin);double n;while(cin&gt;&gt;n&amp;&amp;n!=-1)&#123; double maxx=12*60*60; double shij=30.0/60/60; double fenj=6/60.0; double miaoj=6/1.0; double sfx=fenj-shij; double smx=miaoj-shij; double fmx=miaoj-fenj; double sfz=360/sfx; double sfn=n/sfx; double sf_n=(360-n)/sfx; double fmz=360/fmx; double fmn=n/fmx; double fm_n=(360-n)/fmx; double smz=360/smx; double smn=n/smx; double sm_n=(360-n)/smx; double shichang=0; for(double i=0;i&lt;=maxx;i+=sfz) &#123; for(double j=0;j&lt;=maxx;j+=fmz) &#123; if(j+fm_n&lt;i+sfn) continue; if(i+sf_n&lt;j+fmn) break; for(double k=0;k&lt;=maxx;k+=smz) &#123; if(k+sm_n&lt;i+sfn||k+sm_n&lt;j+fmn) continue; if(j+fm_n&lt;k+smn||i+sf_n&lt;k+smn) break; double kaishi=max(i+sfn,j+fmn,k+smn); double jieshu=min(i+sf_n,j+fm_n,k+sm_n); if(jieshu&gt;kaishi) shichang+=jieshu-kaishi; &#125; &#125; &#125; printf(\"%.3f\\n\",100.0*shichang/maxx); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"盲集合求交","slug":"ACM/盲集合求交","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%9B%B2%E9%9B%86%E5%90%88%E6%B1%82%E4%BA%A4/"}],"tags":[{"name":"临界最优","slug":"临界最优","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%B4%E7%95%8C%E6%9C%80%E4%BC%98/"},{"name":"屏蔽细节","slug":"屏蔽细节","permalink":"https://donghuangzhong.github.io/tags/%E5%B1%8F%E8%94%BD%E7%BB%86%E8%8A%82/"}]},{"title":"HDU-1005","slug":"HDU-1005","date":"2020-02-09T04:33:27.000Z","updated":"2020-02-09T05:45:39.499Z","comments":true,"path":"2020/02/09/HDU-1005/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/09/HDU-1005/","excerpt":"这个题大家第一次应该都是超时吧，这个题网上流传的%49或者%48都是错误的，大家反而觉得他们解释的逻辑很对，我也是服了，这么一份错答案竟然能够横扫CSDN！能够在网络上横行！HDUOJ也真是水！后台数据太水了！！！","text":"这个题大家第一次应该都是超时吧，这个题网上流传的%49或者%48都是错误的，大家反而觉得他们解释的逻辑很对，我也是服了，这么一份错答案竟然能够横扫CSDN！能够在网络上横行！HDUOJ也真是水！后台数据太水了！！！ 题目Number Sequence\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 234505 Accepted Submission(s): 59544** Problem Description A number sequence is defined as follows: f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7. Given A, B, and n, you are to calculate the value of f(n). Input The input consists of multiple test cases. Each test case contains 3 integers A, B and n on a single line (1 &lt;= A, B &lt;= 1000, 1 &lt;= n &lt;= 100,000,000). Three zeros signal the end of input and this test case is not to be processed. Output For each test case, print the value of f(n) on a single line. Sample Input 1231 1 31 2 100 0 0 Sample Output 1225 代码算法这个确实要用到循环节，公式为f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7由前两项推出第三项，所以如果出现连续两项相同，后面的也完全相同，对7取余，结果为0~6，一项有7种可能，将连续两项(2n+1,2n+2)看做一个循环节，则循环节共有7*7=49种可能，所以根据抽屉原理，前50个循环节内，必然存在两个一样的循环节，第一个循环节后的序列为周期序列，整个序列不一定是周期序列。例如序列:3、4项分别和13、14项相同，则从第3项开始，这个序列才是周期序列，整个序列不一定是周期序列。所以算出前100项，找出两个相同循环节(位置分别为a,b)，周期t=b-a，则从a开始，这个序列为周期序列，n&lt;=a，则直接输出，n&gt;a，则输出第(n-a)%t+a项 测试数据如果取余49是正确的，那么就是说第50项一定为1。写代码的不觉得荒谬吗！测试数据1 5 50，自己去测试吧，可以用你们超时代码(超时代码的结果一定是正确的，只是时间太长)的测试结果和网上所谓取余49的代码的结果对比 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); int a,b,n,y,t,kaishi; int jieguo[101]; jieguo[1]=jieguo[2]=1; while((cin&gt;&gt;a&amp;&amp;cin&gt;&gt;b&amp;&amp;cin&gt;&gt;n)&amp;&amp;!(a==0&amp;&amp;b==0&amp;&amp;n==0)) &#123; for(int i=3;i&lt;=100;i++) jieguo[i]=(a*jieguo[i-1]+b*jieguo[i-2])%7; t=-1; for(int i=1;i&lt;=99;i+=2) &#123; if(t!=-1) break; for(int j=i+2;j&lt;=99;j+=2) &#123; if(jieguo[i]==jieguo[j]&amp;&amp;jieguo[i+1]==jieguo[j+1]) &#123; t=j-i; kaishi=i; break; &#125; &#125; &#125; if(n&lt;=kaishi) cout&lt;&lt;jieguo[n]&lt;&lt;endl; else cout&lt;&lt;jieguo[(n-kaishi)%t+kaishi]&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"大数动态周期","slug":"ACM/大数动态周期","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0%E5%8A%A8%E6%80%81%E5%91%A8%E6%9C%9F/"}],"tags":[{"name":"斐波那契取余版","slug":"斐波那契取余版","permalink":"https://donghuangzhong.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%8F%96%E4%BD%99%E7%89%88/"},{"name":"动态周期","slug":"动态周期","permalink":"https://donghuangzhong.github.io/tags/%E5%8A%A8%E6%80%81%E5%91%A8%E6%9C%9F/"}]},{"title":"HUD-1004","slug":"HUD-1004","date":"2020-02-07T09:38:59.000Z","updated":"2020-02-07T09:48:03.437Z","comments":true,"path":"2020/02/07/HUD-1004/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/07/HUD-1004/","excerpt":"我在本题没有用map,因为一开始没有过map,用的话还得去查怎么使用，我的算法是统计每一个颜色出现的次数，取最大值的下标，存在的问题是可能超时。但令我不解的是C++显示编译错误，G++ AC。while(cin&gt;&gt;n&amp;&amp;n)","text":"我在本题没有用map,因为一开始没有过map,用的话还得去查怎么使用，我的算法是统计每一个颜色出现的次数，取最大值的下标，存在的问题是可能超时。但令我不解的是C++显示编译错误，G++ AC。while(cin&gt;&gt;n&amp;&amp;n) 问题Let the Balloon Rise\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 175113 Accepted Submission(s): 69765** Problem Description Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges’ favorite time is guessing the most popular problem. When the contest is over, they will count the balloons of each color and find the result. This year, they decide to leave this lovely job to you. Input Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 1000) – the total number of balloons distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case letters. A test case with N = 0 terminates the input and this test case is not to be processed. Output For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a unique solution for each test case. Sample Input 12345678910115greenredblueredred3pinkorangepink0 Sample Output 12redpink 代码(G++下AC，C++下编译错误)1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; freopen(\"input.txt\", \"r\", stdin); string color[1000]; int n,max; int xiabiao; while(cin&gt;&gt;n&amp;&amp;n) &#123; max=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;color[i]; &#125; for(int j=0;j&lt;n;j++) &#123; int num=0; for(int k=0;k&lt;n;k++) &#123; if(color[j]==color[k]) num++; &#125; if(num&gt;max)&#123; xiabiao=j; max=num; &#125; &#125; cout&lt;&lt;color[xiabiao]&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"字典","slug":"ACM/字典","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E5%85%B8/"}],"tags":[{"name":"map","slug":"map","permalink":"https://donghuangzhong.github.io/tags/map/"},{"name":"字典","slug":"字典","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E5%85%B8/"}]},{"title":"HDU-1003","slug":"HDU-1003","date":"2020-02-07T08:06:14.000Z","updated":"2020-04-01T04:17:51.696Z","comments":true,"path":"2020/02/07/HDU-1003/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/07/HDU-1003/","excerpt":"这个问题作者都描述错了，应该是如果有多个结果，输出end最靠后，start最靠前的那个结果。这个和1002质量都不行，原来和1002是同一个作者","text":"这个问题作者都描述错了，应该是如果有多个结果，输出end最靠后，start最靠前的那个结果。这个和1002质量都不行，原来和1002是同一个作者 题目Max Sum\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 344830 Accepted Submission(s): 82002** Problem Description Given a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000). Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases. Sample Input 12325 6 -1 5 4 -77 0 6 -1 1 -6 7 -5 Sample Output 12345Case 1:14 1 4Case 2:7 1 6 代码:验证作者描述错误的序列:-100 5 5 -100 1 -1 10 -100 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); int t; cin&gt;&gt;t; for(int i=1;i&lt;=t;i++)&#123; int n,max,kaishi,jieshu,shuzi; max=0; int maxmax=-1; int maxkaishi,maxjieshu; cin&gt;&gt;n; kaishi=1; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;shuzi; if(max&gt;=0)&#123; max+=shuzi; jieshu=j; &#125; else &#123; max=shuzi; kaishi=j; jieshu=j; &#125; if(max&gt;=maxmax)&#123; maxmax=max; maxkaishi=kaishi; maxjieshu=jieshu; &#125; &#125; cout&lt;&lt;\"Case \"&lt;&lt;i&lt;&lt;\":\"&lt;&lt;endl&lt;&lt;maxmax&lt;&lt;\" \"&lt;&lt;maxkaishi&lt;&lt;\" \"&lt;&lt;maxjieshu&lt;&lt;endl; if(i!=t)cout&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"最大连续子序列","slug":"最大连续子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"}]},{"title":"HDU-1002","slug":"HDU-1002","date":"2020-02-06T10:50:21.000Z","updated":"2020-02-07T04:48:36.242Z","comments":true,"path":"2020/02/06/HDU-1002/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/06/HDU-1002/","excerpt":"此题在杭电oj上有问题，AC了也不一定代表可以正确，还有dev-cpp5.4.0这个环境，结束时自动输出一行换行","text":"此题在杭电oj上有问题，AC了也不一定代表可以正确，还有dev-cpp5.4.0这个环境，结束时自动输出一行换行 题目A + B Problem II\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 514958 Accepted Submission(s): 98584** Problem Description I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000. Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line is the an equation “A + B = Sum”, Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases. Sample Input 12321 2112233445566778899 998877665544332211 Sample Output 1234Case 1:1 + 2 &#x3D; 3Case 2: 步骤代码1：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); int n,ai,ci,j,sum,jinwei; char a[1000]; char c[1000]; char he[1000]; cin&gt;&gt;n; for(int k=1;k&lt;=n;k++) &#123; cout&lt;&lt;\"Case \"&lt;&lt;k&lt;&lt;\":\"&lt;&lt;endl; cin&gt;&gt;a&gt;&gt;c; cout&lt;&lt;a&lt;&lt;\" + \"&lt;&lt;c&lt;&lt;\" = \"; ai=strlen(a)-1; ci=strlen(c)-1; jinwei=0; int hei=0; while(ai&gt;=0&amp;&amp;ci&gt;=0) &#123; sum=a[ai]-'0'+c[ci]-'0'+jinwei; he[hei++]=sum%10+'0'; jinwei=sum&gt;=10?1:0; ai--; ci--; &#125; while(ai&gt;=0) &#123; sum=a[ai]-'0'+jinwei; he[hei++]=sum%10+'0'; jinwei=sum&gt;=10?1:0; ai--; &#125; while(ci&gt;=0)&#123; sum=c[ci]-'0'+jinwei; he[hei++]=sum%10+'0'; jinwei=sum&gt;=10?1:0; ci--; &#125; hei--; if(jinwei!=0) cout&lt;&lt;jinwei; while(hei&gt;=0) cout&lt;&lt;he[hei--]; cout&lt;&lt;endl; if(k!=n) cout&lt;&lt;endl;&#125;&#125; 错误的AC代码(未考虑进位，结果错误，但还是AC了，输出1+9=0)：由此可见，杭电oj部分题目的后台测试还是不太准确 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); int n,b,d; cin&gt;&gt;n; char a[1000]; char c[1000]; //cin&gt;&gt;n; for(int k=1;k&lt;=n;k++) &#123; cout&lt;&lt;\"Case \"&lt;&lt;k&lt;&lt;\":\"&lt;&lt;endl; cin&gt;&gt;a&gt;&gt;c; cout&lt;&lt;a&lt;&lt;\" + \"&lt;&lt;c&lt;&lt;\" = \"; int j; for(j=0;j&lt;1000;j++) if(a[j]=='\\0') break; b=j; for(j=0;j&lt;1000;j++) if(c[j]=='\\0') break; d=j; //cout&lt;&lt;b&lt;&lt;d; int min=b; if(min&gt;d) min=d; int jinwei=0; int sum; for(int i=1;i&lt;=min;i++)&#123; sum=a[b-i]-'0'+c[d-i]-'0'+jinwei; c[d-i]=sum%10+'0'; //cout&lt;&lt;c[d-i]&lt;&lt;\"\"; jinwei=sum/10; &#125; //cout&lt;&lt;endl; if(min==b) &#123; c[d-min-1]+=jinwei; cout&lt;&lt;c; cout&lt;&lt;endl; &#125; else&#123; a[b-min-1]+=jinwei; for(int i=0;i&lt;=b-min-1;i++) cout&lt;&lt;a[i]; for(int i=d-min;i&lt;=d-1;i++) cout&lt;&lt;c[i]; cout&lt;&lt;endl; &#125;if(k!=n) cout&lt;&lt;endl;&#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"大数","slug":"ACM/大数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0/"}],"tags":[{"name":"大数","slug":"大数","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0/"},{"name":"大数加法","slug":"大数加法","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95/"}]},{"title":"HDU-1001","slug":"HDU-1001","date":"2020-02-06T01:59:33.000Z","updated":"2020-02-06T02:57:26.129Z","comments":true,"path":"2020/02/06/HDU-1001/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/06/HDU-1001/","excerpt":"这个题的平均通过比率大约为0.25(20200206)，平均提交四次才能通过。确实有一个大陷阱，这道题需要我们了解C语言的基本知识和计算机中的运算过程。","text":"这个题的平均通过比率大约为0.25(20200206)，平均提交四次才能通过。确实有一个大陷阱，这道题需要我们了解C语言的基本知识和计算机中的运算过程。 题目Sum Problem \\Time Limit: 1000/500 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 677426 Accepted Submission(s): 170938** Problem Description Hey, welcome to HDOJ(Hangzhou Dianzi University Online Judge). In this problem, your task is to calculate SUM(n) = 1 + 2 + 3 + … + n. Input The input will consist of a series of integers n, one integer per line. Output For each case, output SUM(n) in one line, followed by a blank line. You may assume the result will be in the range of 32-bit signed integer. Sample Input 121100 Sample Output 12315050 C语言中IO和运算过程例如cin&gt;&gt;a;在屏幕上输入5然后点回车，存储过程为将5的补码存到a对应的地址，然后对这个补码进行运算。 例如2*a+1先计算2*a存到一个地方b，然后运算b+1。运算过程为一步一步的，每一步都保存结果，这样就导致了在运算过程中可能导致临时的结果溢出，例如本题中计算1+2+3+···+N有好多种算法(循环累加和公式法)，我们都会下意识的用比较简单的n*(n+1)/2，题目中告诉我们n*(n+1)/2在有符号整形的范围之内，但是计算n*(n+1)的时候要保存一个临时结果，这个结果是有可能比有符号整形大的，所以最终结果不准确。 解决方法调整运算顺序将增大运算和减小运算交错排布将n*(n+1)/2调整为n/2*(n+1)(n为偶数)或(n+1)/2*n(n+1为偶数) 12345678910111213#include &lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std; int main()&#123; int a; while(cin&gt;&gt;a)&#123; if(a%2==0) cout&lt;&lt;a/2*(a+1)&lt;&lt;endl&lt;&lt;endl; else cout&lt;&lt;(a+1)/2*a&lt;&lt;endl&lt;&lt;endl; &#125; return 0;&#125; 消除运算过程中的减小运算(将公式法改为累加法)1234567891011121314#include &lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std; int main()&#123; int a; while(cin&gt;&gt;a) &#123; int sum=0; for(int i=1;i&lt;=a;i++) sum+=i; cout&lt;&lt;sum&lt;&lt;endl&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"易错题","slug":"ACM/易错题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%98%93%E9%94%99%E9%A2%98/"}],"tags":[{"name":"大数陷阱","slug":"大数陷阱","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%99%B7%E9%98%B1/"},{"name":"代数式最大化部分溢出","slug":"代数式最大化部分溢出","permalink":"https://donghuangzhong.github.io/tags/%E4%BB%A3%E6%95%B0%E5%BC%8F%E6%9C%80%E5%A4%A7%E5%8C%96%E9%83%A8%E5%88%86%E6%BA%A2%E5%87%BA/"},{"name":"补码","slug":"补码","permalink":"https://donghuangzhong.github.io/tags/%E8%A1%A5%E7%A0%81/"},{"name":"计算机中运算过程","slug":"计算机中运算过程","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B/"}]},{"title":"HDU-1000","slug":"HDU-1000","date":"2020-02-05T01:17:01.000Z","updated":"2020-02-05T03:18:13.166Z","comments":true,"path":"2020/02/05/HDU-1000/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/05/HDU-1000/","excerpt":"C语言中EOF，C++中EOF，用input.txt代替手工输入，提高解题的测试速度","text":"C语言中EOF，C++中EOF，用input.txt代替手工输入，提高解题的测试速度 题目 A + B Problem Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 944642 Accepted Submission(s): 281848 Problem Description Calculate A + B. Input Each line will contain two integers A and B. Process to end of file. Output For each case, output A + B in one line. Sample Input 11 1 Sample Output 12 C语言EOF 1while(scanf(\"%d%d\",&amp;a,&amp;b)!=EOF) C++EOF 1while(cin&gt;&gt;a&gt;&gt;b)&#123; 用input.txt代替手工输入 在源程序文件(.c、.cpp)的同级目录新建intut.txt文件，里面模拟手工输入的数据 在源程序中main()函数开始处添加代码(要添加#include&lt;stdio.h&gt;头文件)，！！！提交代码前一定要注释掉这行代码 12345#include&lt;stdio.h&gt;int main()&#123; freopen(\"input.txt\", \"r\", stdin);&#125; 本题AC代码： 1234567891011#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; freopen(\"input.txt\", \"r\", stdin); int a,b; while(cin&gt;&gt;a&gt;&gt;b)&#123; cout&lt;&lt;a+b&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"EOF","slug":"EOF","permalink":"https://donghuangzhong.github.io/tags/EOF/"},{"name":"C++文件代替手工输入","slug":"C-文件代替手工输入","permalink":"https://donghuangzhong.github.io/tags/C-%E6%96%87%E4%BB%B6%E4%BB%A3%E6%9B%BF%E6%89%8B%E5%B7%A5%E8%BE%93%E5%85%A5/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-03T04:41:43.819Z","updated":"2020-02-03T04:58:24.929Z","comments":true,"path":"2020/02/03/hello-world/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/03/hello-world/","excerpt":"使用方法","text":"使用方法 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/categories/hexo/"}],"tags":[]},{"title":"ACM-BFS","slug":"ACM-BFS","date":"2019-08-31T06:45:05.000Z","updated":"2020-02-03T04:02:29.707Z","comments":true,"path":"2019/08/31/ACM-BFS/","link":"","permalink":"https://donghuangzhong.github.io/2019/08/31/ACM-BFS/","excerpt":"摘要","text":"摘要 1.BFS的作用：遍历图找到与步长强相关的属性的最优解（也可以附带路径）2.原理起点入队，起点出队，从出队点开始下一步可以到达（符合条件）的所有点入队，队首再出队，从出队点开始下一步可以到达（符合条件）的所有点入队……。总之，步长为n的所有符合条件的点依次批量入队（n=0,1,2……），所以最先访问即步长最短，与步长相关的例如路径长度，消耗的时间最短，即最先访问即最优！ 3.判断是否可以回头(不可随意重复访问标志的设立) 传统01：不可重复访问 如果图中存在能量补充点、时间重置点等等是可以回头的，可以回头的条件是剩余的能量或时间要大于上一次来到这个点时的剩余能量或时间 4.初始化 三个数组 地图数组（一般二维，可三维）：存放墙，可走点，能量补充点、时间充值点 路径变换数组（s[走法种类数][维度]）：通常加法变换，也可以写成乘法矩阵变换 随意访问的数组（跟地图数组一个格式的结构体）：存标志量(传统01，上次到此点剩余能量时间)、路径量(这个点的上一个点的坐标）、其他想随时访问的属性 队列节点结构体 含x,y和仅终点访问的属性 3.实现方式（按常用程度排序） C自带队列 缺点：无法随意访问队列中任意节点，所以如果想要随时访问一个属性，此属性可以存在随意访问数组中 优点：书写简介方便 头文件：#include &lt;queue&gt; 定义代码：queue&lt;node&gt; q; node:可以是结构体，一般含有x,y和仅终点访问的属性 通用代码： 12345678910111213141516171819202122232425262728293031323334353637void dfs()&#123; queue&lt;node&gt; q; node a,b;//a:起点、当前节点、出队点;b:下一节点 …………//初始化a …………/*初始化其他的不可计算量（不可通过上一节点计算的，比如上一次到达这个节点的剩余的时间或者能量） 用lasttime[][],memset(lastime,0,sizeof(lasttime))*/ …………//设置a点不可计算量 if(…………)&#123;…………;return;&#125;//判断起点是不是最优解 q.push(a); while(!q.empty()) &#123; a=q.front(); q.pop(); if(…………)//当前节点必须可以走下一步，比如能量没用完，时间还有 //有些时候规定到达终点时间为0不算，要&gt;1 &#123; for(i=0;i&lt;4;++i)//向题目中规定的方向走 &#123; b.x=a.x+s[i][0];//s数组存储变换矩阵,s[变幻种类][维度] b.y=a.y+s[i][1];//当然也可以写成乘法那种矩阵 if()//判断是不是越界、和走到墙壁位置（如果是传统01标志现在就可以判断） &#123; …………//计算b if(…………)&#123;&#125;//判断是不是能量补充点、时间重置点等等 else&#123;&#125;//如果不是要消耗能量和时间 if(能量和剩余时间&lt;=上一次到达此点的能量和时间)&#123;…………;continue;&#125; //非01标志判断可不可以重复访问 if()&#123;return;&#125;//判断是不是终点，如果自定义队列求路径可以放在入队之后 …………//更新不可计算量（包括01标志） q.push(b); &#125; &#125; &#125; &#125; …………//输出不能到达终点&#125; 自定义队列（需要知道程序需要的最大队列节点数） 自己写队列，不释放入队节点，只移动队首下标。所以可以随意访问队列中任意元素，在求解路径中只需要在队列的结构体中添加一个上一个节点的下标的属性就可以 优点：方便求解路径 队列元素结构：struct point{int x,y,s;};s代表来源点的下标 队列结构：struct p{point pp[1000];int t,w;};其中t表示队列的头，w表示队列的尾 push():d.pp[d.w++]=a; !empty():d.w!=d.t front()&amp;pop():a=d.pp[d.t++]; 递归（没什么意义，还是用的队列） 就是原函数初始化在外面，while()循环体单独写成BFS函数，用!q.empty()判断是否运行此函数 dfs()1234567891011121314151617181920212223242526272829303132333435363738394041424344void dfs()&#123; a&#x3D;q.front(); q.pop(); if(…………)&#x2F;&#x2F;当前节点必须可以走下一步，比如能量没用完，时间还有 &#x2F;&#x2F;有些时候规定到达终点时间为0不算，要&gt;1 &#123; for(i&#x3D;0;i&lt;4;++i)&#x2F;&#x2F;向题目中规定的方向走 &#123; b.x&#x3D;a.x+s[i][0];&#x2F;&#x2F;s数组存储变换矩阵,s[变幻种类][维度] b.y&#x3D;a.y+s[i][1];&#x2F;&#x2F;当然也可以写成乘法那种矩阵 if()&#x2F;&#x2F;判断是不是越界、和走到墙壁位置（如果是传统01标志现在就可以判断） &#123; …………&#x2F;&#x2F;计算b if(…………)&#123;&#125;&#x2F;&#x2F;判断是不是能量补充点、时间重置点等等 else&#123;&#125;&#x2F;&#x2F;如果不是要消耗能量和时间 if(能量和剩余时间&lt;&#x3D;上一次到达此点的能量和时间)&#123;…………;continue;&#125; &#x2F;&#x2F;非01标志判断可不可以重复访问 if()&#123;return;&#125;&#x2F;&#x2F;判断是不是终点，如果自定义队列求路径可以放在入队之后 …………&#x2F;&#x2F;更新不可计算量（包括01标志） q.push(b); &#125; &#125; &#125; if(!q.empty()) dfs(); else …………;&#x2F;&#x2F;输出不能到达终点&#125;queue&lt;node&gt; q;node a,b;&#x2F;&#x2F;a:起点、当前节点、出队点;b:下一节点int main()&#123; …………&#x2F;&#x2F;初始化a …………&#x2F;*初始化其他的不可计算量（不可通过上一节点计算的，比如上一次到达这个节点的剩余的时间或者能量） 用lasttime[][],memset(lastime,0,sizeof(lasttime))*&#x2F; …………&#x2F;&#x2F;设置a点不可计算量 if(…………)&#123;…………;return;&#125;&#x2F;&#x2F;判断起点是不是最优解 q.push(a); if(!q.empty()) dfs(); &#125; 4. 路径打印因为一个点的来源只有一个，但一个点的去处可能有好多点，所以在存储路径的时候一般存储这个点的上一个点，但这样就出现了一个问题，打印路径的时候是倒着的，一般有两种方法解决这个问题，其实是一种 初始化 起点的前一个点的参数设置为-1，自带队列：a[0][0].x=a[0][0].y=-1;自定义：a.s=-1; 递归（隐式调用栈） c自带队列 12345678void print(int x,int y或者int n)&#x2F;&#x2F;注意参数是-，null-0-0-0-&#123;if(x&#x3D;&#x3D;-1&amp;&amp;y&#x3D;&#x3D;-1或者s&#x3D;&#x3D;-1) return ; print(a[x][y].x,a[x][y].y或者p.a[n].s); cout&lt;&lt;x&lt;&lt;y或者cout&lt;&lt;p.a[n].x&lt;&lt;p.a[n].y; &#125; 显式用栈:没什么意义，写起来不方便","categories":[{"name":"工具","slug":"工具","permalink":"https://donghuangzhong.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://donghuangzhong.github.io/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"https://donghuangzhong.github.io/tags/DFS/"}]}],"categories":[{"name":"dao","slug":"dao","permalink":"https://donghuangzhong.github.io/categories/dao/"},{"name":"linux","slug":"linux","permalink":"https://donghuangzhong.github.io/categories/linux/"},{"name":"igix","slug":"igix","permalink":"https://donghuangzhong.github.io/categories/igix/"},{"name":"md","slug":"md","permalink":"https://donghuangzhong.github.io/categories/md/"},{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"},{"name":"docker","slug":"docker","permalink":"https://donghuangzhong.github.io/categories/docker/"},{"name":"js","slug":"js","permalink":"https://donghuangzhong.github.io/categories/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://donghuangzhong.github.io/categories/nodejs/"},{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"search","slug":"java/search","permalink":"https://donghuangzhong.github.io/categories/java/search/"},{"name":"springCloud","slug":"java/springCloud","permalink":"https://donghuangzhong.github.io/categories/java/springCloud/"},{"name":"RabbitMQ","slug":"java/RabbitMQ","permalink":"https://donghuangzhong.github.io/categories/java/RabbitMQ/"},{"name":"blog","slug":"blog","permalink":"https://donghuangzhong.github.io/categories/blog/"},{"name":"前端","slug":"前端","permalink":"https://donghuangzhong.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Dubbo","slug":"Dubbo","permalink":"https://donghuangzhong.github.io/categories/Dubbo/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"},{"name":"sublime","slug":"sublime","permalink":"https://donghuangzhong.github.io/categories/sublime/"},{"name":"js","slug":"sublime/js","permalink":"https://donghuangzhong.github.io/categories/sublime/js/"},{"name":"常用js","slug":"js/常用js","permalink":"https://donghuangzhong.github.io/categories/js/%E5%B8%B8%E7%94%A8js/"},{"name":"idea","slug":"java/idea","permalink":"https://donghuangzhong.github.io/categories/java/idea/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"},{"name":"web相关","slug":"java/web相关","permalink":"https://donghuangzhong.github.io/categories/java/web%E7%9B%B8%E5%85%B3/"},{"name":"maven","slug":"java/maven","permalink":"https://donghuangzhong.github.io/categories/java/maven/"},{"name":"目标检测","slug":"目标检测","permalink":"https://donghuangzhong.github.io/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"},{"name":"深度学习","slug":"深度学习","permalink":"https://donghuangzhong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"TersorFlow","slug":"TersorFlow","permalink":"https://donghuangzhong.github.io/categories/TersorFlow/"},{"name":"Hexo","slug":"Hexo","permalink":"https://donghuangzhong.github.io/categories/Hexo/"},{"name":"VM","slug":"VM","permalink":"https://donghuangzhong.github.io/categories/VM/"},{"name":"tools","slug":"java/tools","permalink":"https://donghuangzhong.github.io/categories/java/tools/"},{"name":"配置文件","slug":"java/配置文件","permalink":"https://donghuangzhong.github.io/categories/java/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"name":"个人博客","slug":"个人博客","permalink":"https://donghuangzhong.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"博客搭建","slug":"个人博客/博客搭建","permalink":"https://donghuangzhong.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://donghuangzhong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"多边形填充","slug":"计算机图形学/多边形填充","permalink":"https://donghuangzhong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%A1%AB%E5%85%85/"},{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"category2","slug":"ACM/category2","permalink":"https://donghuangzhong.github.io/categories/ACM/category2/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"},{"name":"字符串","slug":"ACM/字符串","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"双向链表","slug":"ACM/双向链表","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"贪心","slug":"ACM/贪心","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%B4%AA%E5%BF%83/"},{"name":"快速幂","slug":"ACM/快速幂","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"爬虫","slug":"python/爬虫","permalink":"https://donghuangzhong.github.io/categories/python/%E7%88%AC%E8%99%AB/"},{"name":"RMQ","slug":"ACM/RMQ","permalink":"https://donghuangzhong.github.io/categories/ACM/RMQ/"},{"name":"tools","slug":"tools","permalink":"https://donghuangzhong.github.io/categories/tools/"},{"name":"C++","slug":"tools/C","permalink":"https://donghuangzhong.github.io/categories/tools/C/"},{"name":"解题报告","slug":"ACM/解题报告","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"高级dfs","slug":"ACM/高级dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%AB%98%E7%BA%A7dfs/"},{"name":"dfs","slug":"ACM/dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/dfs/"},{"name":"回文","slug":"ACM/回文","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%9B%9E%E6%96%87/"},{"name":"进制","slug":"ACM/进制","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%BF%9B%E5%88%B6/"},{"name":"矩阵乘法","slug":"ACM/矩阵乘法","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"},{"name":"线段交","slug":"ACM/线段交","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%BA%BF%E6%AE%B5%E4%BA%A4/"},{"name":"质因数","slug":"ACM/质因数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%B4%A8%E5%9B%A0%E6%95%B0/"},{"name":"递归","slug":"ACM/递归","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%92%E5%BD%92/"},{"name":"Huffuman","slug":"ACM/Huffuman","permalink":"https://donghuangzhong.github.io/categories/ACM/Huffuman/"},{"name":"大数","slug":"ACM/大数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0/"},{"name":"SPFA","slug":"ACM/SPFA","permalink":"https://donghuangzhong.github.io/categories/ACM/SPFA/"},{"name":"Bellman","slug":"ACM/Bellman","permalink":"https://donghuangzhong.github.io/categories/ACM/Bellman/"},{"name":"Floyd","slug":"ACM/Floyd","permalink":"https://donghuangzhong.github.io/categories/ACM/Floyd/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"},{"name":"DFS","slug":"ACM/DFS","permalink":"https://donghuangzhong.github.io/categories/ACM/DFS/"},{"name":"二进制","slug":"ACM/二进制","permalink":"https://donghuangzhong.github.io/categories/ACM/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"开关","slug":"ACM/开关","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%BC%80%E5%85%B3/"},{"name":"因数","slug":"ACM/因数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%9B%A0%E6%95%B0/"},{"name":"盲集合求交","slug":"ACM/盲集合求交","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%9B%B2%E9%9B%86%E5%90%88%E6%B1%82%E4%BA%A4/"},{"name":"大数动态周期","slug":"ACM/大数动态周期","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0%E5%8A%A8%E6%80%81%E5%91%A8%E6%9C%9F/"},{"name":"字典","slug":"ACM/字典","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E5%85%B8/"},{"name":"易错题","slug":"ACM/易错题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%98%93%E9%94%99%E9%A2%98/"},{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/categories/hexo/"},{"name":"工具","slug":"工具","permalink":"https://donghuangzhong.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"centos","slug":"centos","permalink":"https://donghuangzhong.github.io/tags/centos/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"},{"name":"ES6","slug":"ES6","permalink":"https://donghuangzhong.github.io/tags/ES6/"},{"name":"消息队列","slug":"消息队列","permalink":"https://donghuangzhong.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/tags/hexo/"},{"name":"vue","slug":"vue","permalink":"https://donghuangzhong.github.io/tags/vue/"},{"name":"微服务","slug":"微服务","permalink":"https://donghuangzhong.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"RPC","slug":"RPC","permalink":"https://donghuangzhong.github.io/tags/RPC/"},{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"},{"name":"ssm","slug":"ssm","permalink":"https://donghuangzhong.github.io/tags/ssm/"},{"name":"js","slug":"js","permalink":"https://donghuangzhong.github.io/tags/js/"},{"name":"sublime","slug":"sublime","permalink":"https://donghuangzhong.github.io/tags/sublime/"},{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/tags/java/"},{"name":"idea","slug":"idea","permalink":"https://donghuangzhong.github.io/tags/idea/"},{"name":"spring_boot","slug":"spring-boot","permalink":"https://donghuangzhong.github.io/tags/spring-boot/"},{"name":"redis","slug":"redis","permalink":"https://donghuangzhong.github.io/tags/redis/"},{"name":"cookie","slug":"cookie","permalink":"https://donghuangzhong.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"https://donghuangzhong.github.io/tags/session/"},{"name":"response","slug":"response","permalink":"https://donghuangzhong.github.io/tags/response/"},{"name":"web","slug":"web","permalink":"https://donghuangzhong.github.io/tags/web/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://donghuangzhong.github.io/tags/Mybatis/"},{"name":"mybatis","slug":"mybatis","permalink":"https://donghuangzhong.github.io/tags/mybatis/"},{"name":"springmvc","slug":"springmvc","permalink":"https://donghuangzhong.github.io/tags/springmvc/"},{"name":"spring+web","slug":"spring-web","permalink":"https://donghuangzhong.github.io/tags/spring-web/"},{"name":"maven","slug":"maven","permalink":"https://donghuangzhong.github.io/tags/maven/"},{"name":"jdbctemplate","slug":"jdbctemplate","permalink":"https://donghuangzhong.github.io/tags/jdbctemplate/"},{"name":"目标检测","slug":"目标检测","permalink":"https://donghuangzhong.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"WSL","slug":"WSL","permalink":"https://donghuangzhong.github.io/tags/WSL/"},{"name":"pandas","slug":"pandas","permalink":"https://donghuangzhong.github.io/tags/pandas/"},{"name":"numpy","slug":"numpy","permalink":"https://donghuangzhong.github.io/tags/numpy/"},{"name":"pyplot","slug":"pyplot","permalink":"https://donghuangzhong.github.io/tags/pyplot/"},{"name":"EL&JSTL","slug":"EL-JSTL","permalink":"https://donghuangzhong.github.io/tags/EL-JSTL/"},{"name":"_keras","slug":"keras","permalink":"https://donghuangzhong.github.io/tags/keras/"},{"name":"AlexNet","slug":"AlexNet","permalink":"https://donghuangzhong.github.io/tags/AlexNet/"},{"name":"jupyter","slug":"jupyter","permalink":"https://donghuangzhong.github.io/tags/jupyter/"},{"name":"GeForce940MX","slug":"GeForce940MX","permalink":"https://donghuangzhong.github.io/tags/GeForce940MX/"},{"name":"图片","slug":"图片","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%BE%E7%89%87/"},{"name":"数据库连接池","slug":"数据库连接池","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"name":"SpringTemplate","slug":"SpringTemplate","permalink":"https://donghuangzhong.github.io/tags/SpringTemplate/"},{"name":"VM","slug":"VM","permalink":"https://donghuangzhong.github.io/tags/VM/"},{"name":"共享文件","slug":"共享文件","permalink":"https://donghuangzhong.github.io/tags/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/"},{"name":"Java","slug":"Java","permalink":"https://donghuangzhong.github.io/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://donghuangzhong.github.io/tags/JDBC/"},{"name":"MySql","slug":"MySql","permalink":"https://donghuangzhong.github.io/tags/MySql/"},{"name":"Properties","slug":"Properties","permalink":"https://donghuangzhong.github.io/tags/Properties/"},{"name":"github_pages","slug":"github-pages","permalink":"https://donghuangzhong.github.io/tags/github-pages/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"MFC","slug":"MFC","permalink":"https://donghuangzhong.github.io/tags/MFC/"},{"name":"W","slug":"W","permalink":"https://donghuangzhong.github.io/tags/W/"},{"name":"设状态","slug":"设状态","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%BE%E7%8A%B6%E6%80%81/"},{"name":"记忆化dfs","slug":"记忆化dfs","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96dfs/"},{"name":"滚动数组","slug":"滚动数组","permalink":"https://donghuangzhong.github.io/tags/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"},{"name":"二分查找(大小于)","slug":"二分查找-大小于","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%A4%A7%E5%B0%8F%E4%BA%8E/"},{"name":"最长公共子序列","slug":"最长公共子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"最长上升子序列","slug":"最长上升子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"最长(非)单调子序列","slug":"最长-非-单调子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF-%E9%9D%9E-%E5%8D%95%E8%B0%83%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"Dilworth定理","slug":"Dilworth定理","permalink":"https://donghuangzhong.github.io/tags/Dilworth%E5%AE%9A%E7%90%86/"},{"name":"简单DP","slug":"简单DP","permalink":"https://donghuangzhong.github.io/tags/%E7%AE%80%E5%8D%95DP/"},{"name":"高阶01背包","slug":"高阶01背包","permalink":"https://donghuangzhong.github.io/tags/%E9%AB%98%E9%98%B601%E8%83%8C%E5%8C%85/"},{"name":"无限背包","slug":"无限背包","permalink":"https://donghuangzhong.github.io/tags/%E6%97%A0%E9%99%90%E8%83%8C%E5%8C%85/"},{"name":"01可不满背包","slug":"01可不满背包","permalink":"https://donghuangzhong.github.io/tags/01%E5%8F%AF%E4%B8%8D%E6%BB%A1%E8%83%8C%E5%8C%85/"},{"name":"食物链","slug":"食物链","permalink":"https://donghuangzhong.github.io/tags/%E9%A3%9F%E7%89%A9%E9%93%BE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://donghuangzhong.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"记忆化递归","slug":"记忆化递归","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92/"},{"name":"邻接表","slug":"邻接表","permalink":"https://donghuangzhong.github.io/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"},{"name":"优先队列","slug":"优先队列","permalink":"https://donghuangzhong.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"vector","slug":"vector","permalink":"https://donghuangzhong.github.io/tags/vector/"},{"name":"正向DP","slug":"正向DP","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E5%90%91DP/"},{"name":"数塔","slug":"数塔","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E5%A1%94/"},{"name":"正反向思考","slug":"正反向思考","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E5%8F%8D%E5%90%91%E6%80%9D%E8%80%83/"},{"name":"转移方程的构造","slug":"转移方程的构造","permalink":"https://donghuangzhong.github.io/tags/%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E7%9A%84%E6%9E%84%E9%80%A0/"},{"name":"极度优化","slug":"极度优化","permalink":"https://donghuangzhong.github.io/tags/%E6%9E%81%E5%BA%A6%E4%BC%98%E5%8C%96/"},{"name":"多数组DP","slug":"多数组DP","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%9A%E6%95%B0%E7%BB%84DP/"},{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"},{"name":"背包","slug":"背包","permalink":"https://donghuangzhong.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"字母","slug":"字母","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E6%AF%8D/"},{"name":"双向链表","slug":"双向链表","permalink":"https://donghuangzhong.github.io/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"索引表","slug":"索引表","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A2%E5%BC%95%E8%A1%A8/"},{"name":"整除2","slug":"整除2","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B4%E9%99%A42/"},{"name":"字符串比较","slug":"字符串比较","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"},{"name":"大数陷阱","slug":"大数陷阱","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%99%B7%E9%98%B1/"},{"name":"溢出陷阱","slug":"溢出陷阱","permalink":"https://donghuangzhong.github.io/tags/%E6%BA%A2%E5%87%BA%E9%99%B7%E9%98%B1/"},{"name":"贪心","slug":"贪心","permalink":"https://donghuangzhong.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数据规模","slug":"数据规模","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1/"},{"name":"二进制优化","slug":"二进制优化","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"},{"name":"wallpapers","slug":"wallpapers","permalink":"https://donghuangzhong.github.io/tags/wallpapers/"},{"name":"壁纸","slug":"壁纸","permalink":"https://donghuangzhong.github.io/tags/%E5%A3%81%E7%BA%B8/"},{"name":"ST","slug":"ST","permalink":"https://donghuangzhong.github.io/tags/ST/"},{"name":"STL","slug":"STL","permalink":"https://donghuangzhong.github.io/tags/STL/"},{"name":"蓝桥杯2020模拟赛","slug":"蓝桥杯2020模拟赛","permalink":"https://donghuangzhong.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"编码","slug":"编码","permalink":"https://donghuangzhong.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"动态二进制","slug":"动态二进制","permalink":"https://donghuangzhong.github.io/tags/%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"高级dfs","slug":"高级dfs","permalink":"https://donghuangzhong.github.io/tags/%E9%AB%98%E7%BA%A7dfs/"},{"name":"判断条件的先后","slug":"判断条件的先后","permalink":"https://donghuangzhong.github.io/tags/%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%88%E5%90%8E/"},{"name":"移动成回文最短","slug":"移动成回文最短","permalink":"https://donghuangzhong.github.io/tags/%E7%A7%BB%E5%8A%A8%E6%88%90%E5%9B%9E%E6%96%87%E6%9C%80%E7%9F%AD/"},{"name":"读数字","slug":"读数字","permalink":"https://donghuangzhong.github.io/tags/%E8%AF%BB%E6%95%B0%E5%AD%97/"},{"name":"妙用下标和","slug":"妙用下标和","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E4%B8%8B%E6%A0%87%E5%92%8C/"},{"name":"n维交","slug":"n维交","permalink":"https://donghuangzhong.github.io/tags/n%E7%BB%B4%E4%BA%A4/"},{"name":"分解质因数","slug":"分解质因数","permalink":"https://donghuangzhong.github.io/tags/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/"},{"name":"逻辑","slug":"逻辑","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"泛型编程","slug":"泛型编程","permalink":"https://donghuangzhong.github.io/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"},{"name":"函数模板","slug":"函数模板","permalink":"https://donghuangzhong.github.io/tags/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"},{"name":"龟兔赛跑","slug":"龟兔赛跑","permalink":"https://donghuangzhong.github.io/tags/%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91/"},{"name":"回形取数","slug":"回形取数","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/"},{"name":"字符串数组","slug":"字符串数组","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84/"},{"name":"八皇后问题","slug":"八皇后问题","permalink":"https://donghuangzhong.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"name":"黑白子","slug":"黑白子","permalink":"https://donghuangzhong.github.io/tags/%E9%BB%91%E7%99%BD%E5%AD%90/"},{"name":"两个最小值","slug":"两个最小值","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%A4%E4%B8%AA%E6%9C%80%E5%B0%8F%E5%80%BC/"},{"name":"大数阶乘","slug":"大数阶乘","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/"},{"name":"翻转边","slug":"翻转边","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E8%BE%B9/"},{"name":"来回总和最短","slug":"来回总和最短","permalink":"https://donghuangzhong.github.io/tags/%E6%9D%A5%E5%9B%9E%E6%80%BB%E5%92%8C%E6%9C%80%E7%9F%AD/"},{"name":"正环","slug":"正环","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E7%8E%AF/"},{"name":"排名","slug":"排名","permalink":"https://donghuangzhong.github.io/tags/%E6%8E%92%E5%90%8D/"},{"name":"逻辑路径","slug":"逻辑路径","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E8%B7%AF%E5%BE%84/"},{"name":"最短路径","slug":"最短路径","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"负环","slug":"负环","permalink":"https://donghuangzhong.github.io/tags/%E8%B4%9F%E7%8E%AF/"},{"name":"有向图绕圈","slug":"有向图绕圈","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%89%E5%90%91%E5%9B%BE%E7%BB%95%E5%9C%88/"},{"name":"翻转矩阵","slug":"翻转矩阵","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5/"},{"name":"最大最小距离","slug":"最大最小距离","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"},{"name":"组内最短路径","slug":"组内最短路径","permalink":"https://donghuangzhong.github.io/tags/%E7%BB%84%E5%86%85%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"易错题","slug":"易错题","permalink":"https://donghuangzhong.github.io/tags/%E6%98%93%E9%94%99%E9%A2%98/"},{"name":"标志数组做记录","slug":"标志数组做记录","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%81%9A%E8%AE%B0%E5%BD%95/"},{"name":"遍历所有可能性","slug":"遍历所有可能性","permalink":"https://donghuangzhong.github.io/tags/%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E6%80%A7/"},{"name":"两次BFS","slug":"两次BFS","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%A4%E6%AC%A1BFS/"},{"name":"函数数组形参","slug":"函数数组形参","permalink":"https://donghuangzhong.github.io/tags/%E5%87%BD%E6%95%B0%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82/"},{"name":"倒水","slug":"倒水","permalink":"https://donghuangzhong.github.io/tags/%E5%80%92%E6%B0%B4/"},{"name":"数论","slug":"数论","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"图的连通区域","slug":"图的连通区域","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%8C%BA%E5%9F%9F/"},{"name":"输出路径","slug":"输出路径","permalink":"https://donghuangzhong.github.io/tags/%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84/"},{"name":"妙用标志数组","slug":"妙用标志数组","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"},{"name":"多入口BFS","slug":"多入口BFS","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%9A%E5%85%A5%E5%8F%A3BFS/"},{"name":"火场逃生","slug":"火场逃生","permalink":"https://donghuangzhong.github.io/tags/%E7%81%AB%E5%9C%BA%E9%80%83%E7%94%9F/"},{"name":"标志数组妙用","slug":"标志数组妙用","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/"},{"name":"素数打表","slug":"素数打表","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A0%E6%95%B0%E6%89%93%E8%A1%A8/"},{"name":"逻辑相加妙用","slug":"逻辑相加妙用","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E7%9B%B8%E5%8A%A0%E5%A6%99%E7%94%A8/"},{"name":"同余定理","slug":"同余定理","permalink":"https://donghuangzhong.github.io/tags/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/"},{"name":"二进制表示十进制","slug":"二进制表示十进制","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%8D%81%E8%BF%9B%E5%88%B6/"},{"name":"翻转游戏","slug":"翻转游戏","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E6%B8%B8%E6%88%8F/"},{"name":"八皇后简化版","slug":"八皇后简化版","permalink":"https://donghuangzhong.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%80%E5%8C%96%E7%89%88/"},{"name":"特殊标志数组","slug":"特殊标志数组","permalink":"https://donghuangzhong.github.io/tags/%E7%89%B9%E6%AE%8A%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"},{"name":"递归范围","slug":"递归范围","permalink":"https://donghuangzhong.github.io/tags/%E9%80%92%E5%BD%92%E8%8C%83%E5%9B%B4/"},{"name":"素数环","slug":"素数环","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A0%E6%95%B0%E7%8E%AF/"},{"name":"回溯","slug":"回溯","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"最长连续因数","slug":"最长连续因数","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%9B%A0%E6%95%B0/"},{"name":"按序列累除","slug":"按序列累除","permalink":"https://donghuangzhong.github.io/tags/%E6%8C%89%E5%BA%8F%E5%88%97%E7%B4%AF%E9%99%A4/"},{"name":"map","slug":"map","permalink":"https://donghuangzhong.github.io/tags/map/"},{"name":"字典","slug":"字典","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E5%85%B8/"},{"name":"摄氏华氏温度转换","slug":"摄氏华氏温度转换","permalink":"https://donghuangzhong.github.io/tags/%E6%91%84%E6%B0%8F%E5%8D%8E%E6%B0%8F%E6%B8%A9%E5%BA%A6%E8%BD%AC%E6%8D%A2/"},{"name":"统计数字的个数","slug":"统计数字的个数","permalink":"https://donghuangzhong.github.io/tags/%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"name":"沙漏","slug":"沙漏","permalink":"https://donghuangzhong.github.io/tags/%E6%B2%99%E6%BC%8F/"},{"name":"等差数列","slug":"等差数列","permalink":"https://donghuangzhong.github.io/tags/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/"},{"name":"电梯","slug":"电梯","permalink":"https://donghuangzhong.github.io/tags/%E7%94%B5%E6%A2%AF/"},{"name":"斐波那契","slug":"斐波那契","permalink":"https://donghuangzhong.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"},{"name":"兔子问题","slug":"兔子问题","permalink":"https://donghuangzhong.github.io/tags/%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98/"},{"name":"临界最优","slug":"临界最优","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%B4%E7%95%8C%E6%9C%80%E4%BC%98/"},{"name":"屏蔽细节","slug":"屏蔽细节","permalink":"https://donghuangzhong.github.io/tags/%E5%B1%8F%E8%94%BD%E7%BB%86%E8%8A%82/"},{"name":"斐波那契取余版","slug":"斐波那契取余版","permalink":"https://donghuangzhong.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%8F%96%E4%BD%99%E7%89%88/"},{"name":"动态周期","slug":"动态周期","permalink":"https://donghuangzhong.github.io/tags/%E5%8A%A8%E6%80%81%E5%91%A8%E6%9C%9F/"},{"name":"最大连续子序列","slug":"最大连续子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"大数","slug":"大数","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0/"},{"name":"大数加法","slug":"大数加法","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95/"},{"name":"代数式最大化部分溢出","slug":"代数式最大化部分溢出","permalink":"https://donghuangzhong.github.io/tags/%E4%BB%A3%E6%95%B0%E5%BC%8F%E6%9C%80%E5%A4%A7%E5%8C%96%E9%83%A8%E5%88%86%E6%BA%A2%E5%87%BA/"},{"name":"补码","slug":"补码","permalink":"https://donghuangzhong.github.io/tags/%E8%A1%A5%E7%A0%81/"},{"name":"计算机中运算过程","slug":"计算机中运算过程","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B/"},{"name":"EOF","slug":"EOF","permalink":"https://donghuangzhong.github.io/tags/EOF/"},{"name":"C++文件代替手工输入","slug":"C-文件代替手工输入","permalink":"https://donghuangzhong.github.io/tags/C-%E6%96%87%E4%BB%B6%E4%BB%A3%E6%9B%BF%E6%89%8B%E5%B7%A5%E8%BE%93%E5%85%A5/"},{"name":"BFS","slug":"BFS","permalink":"https://donghuangzhong.github.io/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"https://donghuangzhong.github.io/tags/DFS/"}]}