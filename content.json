{"meta":{"title":"DHZ'S BLOG","subtitle":"","description":"","author":"东皇钟","url":"https://donghuangzhong.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2020-02-03T05:26:25.962Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"categories/index.html","permalink":"https://donghuangzhong.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-02-03T05:26:25.965Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"tags/index.html","permalink":"https://donghuangzhong.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-04T08:15:42.817Z","updated":"2020-02-04T08:15:42.817Z","comments":true,"path":"about/index.html","permalink":"https://donghuangzhong.github.io/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 菜鸟程序员一名，涉及ACM算法、python传统机器学习等，2021考研党 关于主题本站主题是：Material X"}],"posts":[{"title":"sublime text","slug":"sublime-text","date":"2021-03-26T00:13:15.000Z","updated":"2021-03-30T08:51:33.505Z","comments":true,"path":"2021/03/26/sublime-text/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/26/sublime-text/","excerpt":"sublime的相关配置","text":"sublime的相关配置 配置JS打开sublime text 新建文件，命名为JavaScript.sublime-build 1234&#123; &quot;cmd&quot;: [&quot;node&quot;, &quot;$file&quot;], &quot;selector&quot;: &quot;source.js&quot;&#125; 代码提示Sublime Text 3\\Data\\Packages\\SublimeCodeIntel目录下 1234567891011121314151617181920212223242526&#123; &quot;PHP&quot;: &#123; &quot;php&quot;: &#39;&#x2F;usr&#x2F;bin&#x2F;php&#39;, &quot;phpExtraPaths&quot;: [], &quot;phpConfigFile&quot;: &#39;php.ini&#39; &#125;, &quot;JavaScript&quot;: &#123; &quot;javascriptExtraPaths&quot;: [] &#125;, &quot;Perl&quot;: &#123; &quot;perl&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;perl&quot;, &quot;perlExtraPaths&quot;: [] &#125;, &quot;Ruby&quot;: &#123; &quot;ruby&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;ruby&quot;, &quot;rubyExtraPaths&quot;: [] &#125;, &quot;Python&quot;: &#123; &quot;python&quot;: &#39;&#x2F;usr&#x2F;bin&#x2F;python&#39;, &quot;pythonExtraPaths&quot;: [] &#125;, &quot;Python3&quot;: &#123; &quot;python&quot;: &#39;&#x2F;usr&#x2F;bin&#x2F;python3&#39;, &quot;pythonExtraPaths&quot;: [] &#125;&#125; 激活12345678910111213----- BEGIN LICENSE -----Member J2TeaMSingle User LicenseEA7E-1011316D7DA350E 1B8B0760 972F8B60 F3E64036B9B4E234 F356F38F 0AD1E3B7 0E9C5FADFA0A2ABE 25F65BD8 D51458E5 3923CE8087428428 79079A01 AA69F319 A1AF29A4A684C2DC 0B1583D4 19CBD290 217618CD5653E0A0 BACE3948 BB2EE45E 422D2C87DD9AF44B 99C49590 D2DBDEE1 75860FD28C8BB2AD B2ECE5A4 EFC08AF2 25A9B864------ END LICENSE ------​ 123456789101112ZYNGA INC.50 User LicenseEA7E-811825927BA117 84C9300F 4A0CCBC4 34A56B44985E4562 59F2B63B CCCFF92F 0E646B830FD6487D 1507AE29 9CC4F9F5 0A6F32E30343D868 C18E2CD5 27641A71 25475648309705B3 E468DDC4 1B766A18 7952D28CE627DDBA 960A2153 69A2D98A C87C060745DC6049 8C04EC29 D18DFA40 442C680B1342224D 44D90641 33A3B9F2 46AADB8F 123456789101112ZYNGA INC.50 User LicenseEA7E-811825927BA117 84C9300F 4A0CCBC4 34A56B44985E4562 59F2B63B CCCFF92F 0E646B830FD6487D 1507AE29 9CC4F9F5 0A6F32E30343D868 C18E2CD5 27641A71 25475648309705B3 E468DDC4 1B766A18 7952D28CE627DDBA 960A2153 69A2D98A C87C060745DC6049 8C04EC29 D18DFA40 442C680B1342224D 44D90641 33A3B9F2 46AADB8F 1234567891011Member J2TeaMSingle User LicenseEA7E-1011316D7DA350E 1B8B0760 972F8B60 F3E64036B9B4E234 F356F38F 0AD1E3B7 0E9C5FADFA0A2ABE 25F65BD8 D51458E5 3923CE8087428428 79079A01 AA69F319 A1AF29A4A684C2DC 0B1583D4 19CBD290 217618CD5653E0A0 BACE3948 BB2EE45E 422D2C87DD9AF44B 99C49590 D2DBDEE1 75860FD28C8BB2AD B2ECE5A4 EFC08AF2 25A9B864 更改插件的安装目录1C:\\Users\\DongHuangZhong\\AppData\\Roaming 此文件夹下的sublime目录删除 在sublime安装目录下新建Data，重新安装pacake control 的添加右键菜单 open_with_sublime.reg 123456789101112Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\*\\shell\\SublimeText3]@&#x3D;&quot;Open with Sublime Text 3 &quot;&quot;Icon&quot;&#x3D;&quot;E:\\\\bianchenggongju\\\\Sublime Text 3\\\\sublime_text.exe,0&quot;[HKEY_CLASSES_ROOT\\*\\shell\\SublimeText3\\command]@&#x3D;&quot;E:\\\\bianchenggongju\\\\Sublime Text 3\\\\sublime_text.exe %1&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\SublimeText3]@&#x3D;&quot;Open with Sublime Text 3 &quot;&quot;Icon&quot;&#x3D;&quot;E:\\\\bianchenggongju\\\\Sublime Text 3\\\\sublime_text.exe,0&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\SublimeText3\\command] @&#x3D;&quot;E:\\\\bianchenggongju\\\\Sublime Text 3\\\\sublime_text.exe %1&quot;","categories":[{"name":"sublime","slug":"sublime","permalink":"https://donghuangzhong.github.io/categories/sublime/"},{"name":"js","slug":"sublime/js","permalink":"https://donghuangzhong.github.io/categories/sublime/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://donghuangzhong.github.io/tags/js/"},{"name":"sublime","slug":"sublime","permalink":"https://donghuangzhong.github.io/tags/sublime/"}]},{"title":"js","slug":"js","date":"2021-03-22T05:41:16.000Z","updated":"2021-03-30T10:06:19.539Z","comments":true,"path":"2021/03/22/js/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/22/js/","excerpt":"摘要","text":"摘要 表格相关编辑模式禁止换行123456789101112131415161718&#x2F;&#x2F; 编辑状态下右侧表格禁止换行idp.event.register(&quot;grid_main&quot;, &quot;beforeSelectRow&quot;, function(e, data) &#123; &#x2F;&#x2F; debugger; if (!idp.uiview.fsmController.cannot(&quot;cancel&quot;)) &#123; idp.warn(idp.lang.get(&#39;EaoTag_CRow_check&#39;) || &quot;请先保存再切换行&quot;); return false; &#125; return true;&#125;);&#x2F;&#x2F;编辑状态下禁止编辑其他行idp.event.register(&quot;grid_main&quot;, &quot;beforeEdit&quot;, function(e, index) &#123; &#x2F;&#x2F; debugger; var selectRow &#x3D; idp.control.get(&quot;grid_main&quot;).getSelectedRow(); var curIndex &#x3D; selectRow.__index; if (index !&#x3D;&#x3D; curIndex) return false;&#125;); 默认选中首行第二种失效用第一种 123456idp.event.register(&quot;grid_467637&quot;, &quot;afterLoadData&quot;, function(e, p) &#123; var length &#x3D; idp.control.get(&quot;grid_467637&quot;).getData().length; if (length &gt; 0) &#123; idp.control.get(&quot;grid_467637&quot;).select(0); &#125; &#125;); 123456idp.event.register(&quot;grid_467637&quot;, &quot;afterShowData&quot;, function(e, data) &#123; var length &#x3D; idp.control.get(&quot;grid_467637&quot;).getData().length; if (length &gt; 0) &#123; idp.control.get(&quot;grid_467637&quot;).select(0); &#125;&#125;); 新增行相关afterAddGridRow执行时，只是新增一行，不改变状态机，等到执行完afterAddGridRow后进入编辑状态机(不会自动触发编辑选择新增行)，此时点击任意行都会触发编辑-&gt;选中事件，所以要手动进行选择一下 12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;&#x2F; 新增行后赋值初始数据 idp.event.register(&quot;grid_main&quot;, &quot;afterAddGridRow&quot;, function(table, row, id) &#123; debugger; var index &#x3D; idp.control.get(&quot;grid_main&quot;).rows.length - 1; if (index &gt;&#x3D; 0) &#123; idp.control.get(&quot;grid_main&quot;).select(index); &#125; var data &#x3D; idp.control.get(&quot;grid_main&quot;).getData(); $(&quot;.lee-panel-footer&quot;).css(&quot;pointer-events&quot;, &quot;none&quot;); function formatNum(number, len, ch) &#123; ch &#x3D; &quot;&quot; + ch; number &#x3D; &quot;&quot; + number; var strLength &#x3D; len - number.length; for (var i &#x3D; 0; i &lt; strLength; i++) &#123; number &#x3D; ch + number; &#125; return number; &#125; var codeid &#x3D; idp.control.get(&quot;grid_tagtype&quot;).getSelectedRow().CODE; var id &#x3D; idp.control.get(&quot;grid_tagtype&quot;).getSelectedRow().ID; var num; idp.service.fetch(&#39;&#x2F;api&#x2F;eao&#x2F;v1.0&#x2F;pub&#x2F;tag&#x2F;getOrderNum&#39;, id, false).done(function(data) &#123; num &#x3D; data.appendData; &#125;).fail(function(error) &#123; console.log(error); &#125;); if (num &#x3D;&#x3D; 0) &#123; num &#x3D; formatNum(codeid, 4, &quot;0&quot;) + &quot;00001&quot;; &#125; var ordernum &#x3D; num; idp.control.get(&quot;grid_main&quot;).updateRow(data.length - 1, &#123; &quot;ORDERNUM&quot;: ordernum &#125;); idp.control.get(&quot;grid_main&quot;).updateRow(data.length - 1, &#123; &quot;TYPEID&quot;: idp.control.get(&quot;grid_tagtype&quot;).getSelected().ID &#125;); &#125;); 修改idp的删除方法(左侧删除计数)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#x2F;&#x2F; 修改的idp删除方法function dele(extParam, isFront) &#123; var self &#x3D; idp.uiview; if (idp.uiview.gridController.mainGrid.getSelectedRows().length &gt; 1) &#123; idp.warn(idp.lang.get(&quot;SEL_DATA_TO_DEL&quot;)); return; &#125; var bindings &#x3D; idp.uiview.gridController.grids[idp.uiview.gridController.mainGrid.id]; var grid &#x3D; bindings.grid; var data &#x3D; idp.uiview.gridController.mainGrid.getSelected(); if (data) &#123; if (isFront) &#123; grid.endEdit(); if (data.__status &#x3D;&#x3D; &quot;add&quot;) &#123; grid.remove(data); &#125; else &#123; grid.deleteRow(data); &#125; &#125; else &#123; idp.confirm(idp.lang.get(&quot;DELETE_CONFIRM&quot;), function() &#123; if (data[&quot;__status&quot;] &#x3D;&#x3D; &quot;add&quot;) &#123; self.gridController.mainGrid.remove(data); &#125; else &#123; idp.loading(idp.lang.get(&quot;DELETING&quot;)); idp.service.deleteData(&quot;&quot;, self.config.styleid, data[self.modelController.pkcol], null, extParam).then(function(res) &#123; idp.loaded(); if (res.Code &#x3D;&#x3D; &quot;ok&quot;) &#123; idp.tips(idp.lang.get(&quot;DELETE_SUCESS&quot;)); self.gridController.mainGrid.remove(data); try &#123; self.gridController.mainGrid.options.total &#x3D; self.gridController.mainGrid.options.total - 1; self.gridController.mainGrid._buildPager(); &#125; catch (e) &#123; &#125; debugger; updateTagTypeNum(); &#x2F;&#x2F; idp.control.get(&quot;grid_tagtype&quot;).select(idp.control.get(&quot;grid_tagtype&quot;).getSelected().__index); &#125; else if (res.Code &#x3D;&#x3D; &quot;lockdata&quot;) &#123; idp.error(idp.lang.get(&quot;DELETE_LOCK&quot;)); &#x2F;&#x2F; defer.resolve(false); &#125; &#125;); &#125; &#125;); &#125; &#125; else &#123; idp.warn(idp.lang.get(&quot;SEL_DATA_TO_DEL&quot;)); return; &#125;&#125; 修改保存按钮(保存后更新计数）12$(&quot;.lee-panel-footer&quot;).css(&quot;pointer-events&quot;,&quot;&quot;);return idp.uiview.saveData().then(function(flag)&#123;if(flag)&#123;updateTagTypeNum();return true;&#125;else return false;&#125;); 模拟下载模板（XLSX.js）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#x2F;&#x2F;模拟实现下载function downloadEx(blob, filename) &#123; var eleLink &#x3D; document.createElement(&#39;a&#39;); eleLink.download &#x3D; filename; eleLink.style.display &#x3D; &#39;none&#39;; &#x2F;&#x2F; 字符内容转变成blob地址 var blob &#x3D; new Blob([blob]); eleLink.href &#x3D; URL.createObjectURL(blob); &#x2F;&#x2F; 触发点击 document.body.appendChild(eleLink); eleLink.click(); &#x2F;&#x2F; 然后移除 document.body.removeChild(eleLink);&#125;function sheet2blob(sheet, sheetName) &#123; sheetName &#x3D; sheetName || &#39;sheet1&#39;; var workbook &#x3D; &#123; SheetNames: [sheetName], Sheets: &#123;&#125; &#125;; workbook.Sheets[sheetName] &#x3D; sheet; &#x2F;&#x2F; 生成excel的配置项 var wopts &#x3D; &#123; bookType: &#39;xlsx&#39;, &#x2F;&#x2F; 要生成的文件类型 bookSST: false, &#x2F;&#x2F; 是否生成Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本IOS设备上有更好的兼容性 type: &#39;binary&#39; &#125;; var wbout &#x3D; XLSX.write(workbook, wopts); var blob &#x3D; new Blob([s2ab(wbout)], &#123; type: &quot;application&#x2F;octet-stream&quot; &#125;); &#x2F;&#x2F; 字符串转ArrayBuffer function s2ab(s) &#123; var buf &#x3D; new ArrayBuffer(s.length); var view &#x3D; new Uint8Array(buf); for (var i &#x3D; 0; i !&#x3D; s.length; ++i) view[i] &#x3D; s.charCodeAt(i) &amp; 0xFF; return buf; &#125; return blob;&#125;&#x2F;&#x2F; 导入模板下载function ddd() &#123; &#x2F;&#x2F; debugger; var jsonDatas &#x3D; [&#123; &quot;标签名称&quot;: &quot;&quot;, &quot;类别名称&quot;: &quot;&quot; &#125;]; var sheet &#x3D; XLSX.utils.json_to_sheet(jsonDatas); downloadEx(sheet2blob(sheet), &quot;importTemplate&quot; + &#39;.xlsx&#39;);&#125; 自定义操作单元格 row中有点击所在行(此时未选择此行)的信息，通过传参过去给点击事件函数 点击超链接-&gt;执行点击事件函数(此时未选中行)-&gt;执行完点击事件触发选中行事件，所以需要在点击事件函数中手动选择一下行，但这样会触发两次选择行事件，所以第一次选择行之前要加条件(比如在非编辑状态下才能执行第一次选中行)，不执行第一次手动选择行，让第二次执行的选择行事件负责给出错误提示信息(不然会出现两次错误提示信息) 12345function(row,index)&#123; var data&#x3D;JSON.stringify(row); return &quot;&lt;a href&#x3D;&#39;javascript:void(0)&#39; onclick&#x3D;&#39;edit(&quot;+data+&quot;)&#39;&gt;&quot;+&#39;编辑&#39;+&quot;&lt;&#x2F;a&gt;&amp;nbsp;&quot;+&quot;&lt;a href&#x3D;&#39;javascript:void(0)&#39; onclick&#x3D;&#39;del(&quot;+data+&quot;)&#39;&gt;&quot;+&#39;删除&#39;+&quot;&lt;&#x2F;a&gt;&quot;;&#125; 1234567891011121314151617181920212223242526function edit(args) &#123; &#x2F;&#x2F; debugger; if (!idp.uiview.fsmController.cannot(&quot;cancel&quot;)) &#123; if (idp.control.get(&quot;grid_main&quot;).getSelected() !&#x3D; null &amp;&amp; idp.control.get(&quot;grid_main&quot;).getSelected().__index &#x3D;&#x3D; args.__index) &#123; idp.warn(idp.lang.get(&#39;EAM_FD_ACTCONTROL_07&#39;) || &#39;请勿重复编辑此行&#39;); return; &#125; return; &#125; idp.control.get(&quot;grid_main&quot;).select(args.__index); idp.uiview.fsmController.action(&#39;modify&#39;); return idp.uiview.edit();&#125;function del(args) &#123; if (!idp.uiview.fsmController.cannot(&quot;cancel&quot;)) &#123; if (idp.control.get(&quot;grid_main&quot;).getSelected() !&#x3D; null &amp;&amp; idp.control.get(&quot;grid_main&quot;).getSelected().__index &#x3D;&#x3D; args.__index) &#123; idp.warn(idp.lang.get(&#39;EAM_FD_ACTCONTROL_07&#39;) || &#39;请先保存再删除本行&#39;); return; &#125; return; &#125; idp.control.get(&quot;grid_main&quot;).select(args.__index); return idp.uiview.deleteListTmp();&#125; 导入控件类型非varchar必填 回调函数，自动选择第一行 123456789return idp.importExcel(&#39;4ea45461-8f52-b35f-c25e-eaa81025bcd0&#39;,null,function()&#123; var length &#x3D; idp.control.get(&quot;grid_467637&quot;).getData().length; if (length &gt; 0) &#123; idp.control.get(&quot;grid_467637&quot;).select(0); &#125;&#125;);return idp.importExcel(&#39;4ea45461-8f52-b35f-c25e-eaa81025bcd0&#39;,null,function()&#123; var length &#x3D; idp.control.get(&quot;grid_467637&quot;).getData().length; if (length &gt; 0) &#123; idp.control.get(&quot;grid_467637&quot;).select(0); &#125;&#125;); 导出修改修改的源文件 12345678910111213141516171819202122232425idp.exportExcel &#x3D; function (id, sheetName) &#123; var $grid &#x3D; $(&quot;#&quot; + id).leeUI(); if (!sheetName) sheetName &#x3D; &quot;Sheet1&quot;; var obj &#x3D; &#123;&#125;; obj.rowsData &#x3D; $grid.getData(); var colheader &#x3D; []; $.each($grid.options.columns, function (i, item) &#123; if (!item.hide &amp;&amp; item.id !&#x3D; &#39;gridset&#39;) &#123; if (item.editor) &#123; item.columnType &#x3D; item.editor.type; &#125; colheader.push(item); &#125; &#125;); obj.colHeaders &#x3D; colheader; var extend &#x3D; idp.event.triggerHandler(id, &quot;beforeExcelExport&quot;, [obj]); if (extend) &#123; $.extend(true, obj, extend); &#125; var url &#x3D; IDPENV.API_RUNTIME + &quot;&#x2F;ExcelGrid&#x2F;exportMX?fileName&#x3D;导出&amp;sheetName&#x3D;&quot; + sheetName; url +&#x3D; &quot;&amp;SessionId&#x3D;&quot; + window.localStorage.session; idp.downLoadFile(url, JSON.stringify(obj).replace(&#x2F;\\&#39;&#x2F;g, &quot;&amp;apos;&quot;).replace(&#x2F;\\&quot;&#x2F;g, &quot;&quot;&quot;));&#125; 12345678910111213141516171819202122232425function exportt(id, sheetName) &#123; var $grid &#x3D; $(&quot;#&quot; + id).leeUI(); if (!sheetName) sheetName &#x3D; &quot;Sheet1&quot;; var obj &#x3D; &#123;&#125;; obj.rowsData &#x3D; $grid.getData(); var colheader &#x3D; []; var columns&#x3D;[]; $.each($grid.options.columns, function (i, item) &#123; &#x2F;&#x2F;新增的过滤条件 if (!item.hide &amp;&amp; item.id !&#x3D; &#39;gridset&#39;&amp;&amp;item.__id!&#x3D;&quot;CAOZUO&quot;) &#123; if (item.editor) &#123; item.columnType &#x3D; item.editor.type; &#125; colheader.push(item); &#125; &#125;); obj.colHeaders &#x3D; colheader; var extend &#x3D; idp.event.triggerHandler(id, &quot;beforeExcelExport&quot;, [obj]); if (extend) &#123; $.extend(true, obj, extend); &#125; var url &#x3D; IDPENV.API_RUNTIME + &quot;&#x2F;ExcelGrid&#x2F;exportMX?fileName&#x3D;导出&amp;sheetName&#x3D;&quot; + sheetName; url +&#x3D; &quot;&amp;SessionId&#x3D;&quot; + window.localStorage.session; idp.downLoadFile(url, JSON.stringify(obj).replace(&#x2F;\\&#39;&#x2F;g, &quot;&amp;apos;&quot;).replace(&#x2F;\\&quot;&#x2F;g, &quot;&quot;&quot;)); &#125; 有弹窗的修改用filter过滤虚字段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&#x2F;&#x2F; 修改的idp导出函数function cex(id, sheetName) &#123; var g &#x3D; idp.uiview.gridController.getExportOptions(id); var eType &#x3D; $(&quot;#exportSet&quot;).val(); var options &#x3D; &#123; &quot;sqlId&quot;: g.styleid, &quot;fields&quot;: g.filter, &quot;orders&quot;: g.orders, &quot;page&quot;: g.curPage, &quot;pageSize&quot;: g.pageSize ? g.pageSize : 10000, &quot;count&quot;: true, &quot;columns&quot;: g.columns.filter(item &#x3D;&gt; item.id !&#x3D; &quot;CAOZUO&quot;) &#125; debugger; if (g.usePager) &#123; if (eType &#x3D;&#x3D; &quot;2&quot;) &#123; options.page &#x3D; 1; options.pageSize &#x3D; g.total; &#125; else if (eType &#x3D;&#x3D; &quot;3&quot;) &#123; var statrPage &#x3D; $(&quot;#exportSetStart&quot;).val(); var endPage &#x3D; $(&quot;#exportSetEnd&quot;).val(); if (statrPage &#x3D;&#x3D; &quot;&quot; || endPage &#x3D;&#x3D; &quot;&quot;) &#123; idp.error(lang.get(&quot;ENTER_START_END_PAGE&quot;)); return false; &#125; if (Number(statrPage) &lt;&#x3D; 0 || Number(endPage) &lt;&#x3D; 0) &#123; idp.error(lang.get(&quot;ENTER_STARTEND_PAGE&quot;)); return false; &#125; if (Number(statrPage) &gt; Number(endPage)) &#123; idp.error(lang.get(&quot;START_LARGER_END&quot;)); return false; &#125; if (statrPage &gt; g.pageCount || endPage &gt; g.pageCount) &#123; idp.error(lang.get(&quot;EXPORT_EXCEED_MAX&quot;)); return false; &#125; options.page &#x3D; Number(statrPage); options.pageSize &#x3D; g.pageSize; options.endPage &#x3D; Number(endPage); &#x2F;&#x2F;options.pageSize &#x3D; (Number(endPage) - Number(statrPage) + 1) * g.pageSize; &#125; else &#123; options.page &#x3D; g.curPage; &#125; &#125; else &#123; options.page &#x3D; 1; options.pageSize &#x3D; g.total; &#125; var url &#x3D; IDPENV.API_RUNTIME + &quot;&#x2F;ExcelGrid&#x2F;export?fileName&#x3D;export&amp;sheetName&#x3D;&quot; + sheetName; url +&#x3D; &quot;&amp;SessionId&#x3D;&quot; + window.localStorage.session; idp.uiview.downLoadFile(url, JSON.stringify(options)); &#x2F;&#x2F;this.writeAudit(&quot;export&quot;); return true;&#125;&#x2F;&#x2F; 修改的idp导出函数function exx(id, sheetName) &#123; debugger; var self &#x3D; idp.uiview; if (!id) id &#x3D; self.gridController.mainGridID; if (self.gridController.isPager(id)) &#123; if (!idp.uiview._exportLoad) &#123; var html &#x3D; $(&quot;&lt;div id&#x3D;&#39;exportInfo&#39; style&#x3D;&#39;display:none;&#39; &gt;&lt;div style&#x3D;&#39;margin:5px;&#39;&gt;&lt;input id&#x3D;&#39;exportSet&#39; value&#x3D;&#39;1&#39;&#x2F;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&#39;exportNumberWrap&#39; &gt;&lt;div style&#x3D;&#39;margin:15px;display:inline-block&#39;&gt;开始&lt;&#x2F;div&gt;&lt;div style&#x3D;&#39;margin:5px;display:inline-block&#39;&gt;&lt;input id&#x3D;&#39;exportSetStart&#39; value&#x3D;&#39;1&#39; style&#x3D;&#39;width:60px;&#39;&#x2F;&gt;&lt;&#x2F;div&gt;&lt;div style&#x3D;&#39;margin:5px;display:inline-block&#39;&gt;结束&lt;&#x2F;div&gt; &lt;div style&#x3D;&#39;margin:5px;display:inline-block&#39;&gt;&lt;input id&#x3D;&#39;exportSetEnd&#39; style&#x3D;&#39;width:60px;&#39;&#x2F;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&quot;); $(&quot;body&quot;).append(html); $(&quot;#exportSet&quot;).leeRadioList(&#123; data: [&#123; id: &quot;1&quot;, text: idp.lang.get(&quot;CURRENT_PAGE&quot;) &#125;, &#123; id: &quot;2&quot;, text: idp.lang.get(&quot;ALL_PAGES&quot;) &#125;, &#123; id: &quot;3&quot;, text: idp.lang.get(&quot;SEL_PAGE_NUM&quot;) &#125;], onChangeValue: function(row) &#123; if (row &#x3D;&#x3D; &quot;3&quot;) &#123; $(&quot;.exportNumberWrap&quot;).show(); &#125; else &#123; $(&quot;.exportNumberWrap&quot;).hide(); &#125; &#125; &#125;); $(&quot;.exportNumberWrap&quot;).hide(); $(&quot;#exportSetStart,#exportSetEnd&quot;).leeTextBox(&#123; digits: true &#125;); idp.uiview._exportLoad &#x3D; true; &#125; $(&quot;body&quot;).css(&quot;overflow&quot;, &quot;auto&quot;); $.leeDialog.open(&#123; title: idp.lang.get(&quot;EXPORT_CONFIG&quot;), width: &quot;400&quot;, height: &#39;120&#39;, targetBody: true, target: $(&quot;#exportInfo&quot;), overflow: &quot;hidden&quot;, isResize: false, max: false, onStopResize: function() &#123;&#125;, buttons: [&#123; text: idp.lang.get(&quot;CANCEL&quot;), cls: &#39;lee-dialog-btn-cancel &#39;, onclick: function(item, dialog) &#123; dialog.close(); &#125; &#125;, &#123; text: idp.lang.get(&quot;OK&quot;), cls: &#39;lee-btn-primary lee-dialog-btn-ok&#39;, onclick: function(item, dialog) &#123; if (cex(id, sheetName)) &#123; dialog.close(); &#125; &#125; &#125;] &#125;); $(&quot;body&quot;).css(&quot;overflow&quot;, &quot;hidden&quot;); &#125; else &#123; cex(id, sheetName); &#125;&#125; 连接数据库写实体1234567891011121314151617181920212223242526272829303132333435363738394041424344@Data@Builder@NoArgsConstructor@AllArgsConstructor@Entity@DynamicUpdate@Table(name &#x3D; &quot;eaotag&quot;)public class EaoTagEntity &#123; @Id @Column(name &#x3D; &quot;id&quot;) private String id; @Basic @Column(name &#x3D; &quot;name&quot;) private String name; @Basic @Column(name &#x3D; &quot;orderNum&quot;) private int orderNum; @Basic @Column(name &#x3D;&quot;createdBy&quot;) private String createdBy; @Basic @Column(name &#x3D;&quot;createdOn&quot;) private Timestamp createdOn; @Basic @Column(name &#x3D; &quot;lastChangedBy&quot;) private String lastChangedBy; @Basic @Column(name &#x3D;&quot;lastChangedOn&quot;) private Timestamp lastChangedOn; @Basic @Column(name &#x3D; &quot;typeId&quot;) private String typeId;&#125; 用JPA写接口12345678&#x2F;&#x2F;包含多语字段用public interface EaoTagTypeRepository extends CafJpaRepository&lt;EaoTagTypeEntity,String&gt; &#123; EaoTagTypeEntity findByName(String name);&#125; 123456789101112131415161718192021222324252627282930public interface EaoTagRepository extends DataRepository&lt;EaoTagEntity,String&gt; &#123; int deleteByName(String name); int countByTypeId(String typeid); int deleteByOrderNum(int orderNum); @Query(&quot;SELECT max(orderNum) from EaoTagEntity WHERE typeId &#x3D; :typeId&quot;) Object getMaxOrOrderNum(@Param(&quot;typeId&quot;)String typeId); EaoTagEntity findByName(String name); @Override &lt;S extends EaoTagEntity&gt; S saveAndFlush(S s); @Override &lt;S extends EaoTagEntity&gt; S save(S s); @Modifying @Transactional @Query(&quot;update EaoTagEntity set typeId&#x3D;:typeId,orderNum&#x3D;:orderNum,createdBy&#x3D;:createdBy,createdOn&#x3D;:createdOn,lastChangedBy&#x3D;:lastChangedBy,lastChangedOn&#x3D;:lastChangedOn where name&#x3D;:name&quot;) int update(@Param(&quot;typeId&quot;) String typeId, @Param(&quot;orderNum&quot;) int orderNum,@Param(&quot;createdBy&quot;) String createdBy, @Param(&quot;createdOn&quot;) Timestamp createdOn, @Param(&quot;lastChangedBy&quot;) String lastChangedBy, @Param(&quot;lastChangedOn&quot;) Timestamp lastChangedOn, @Param(&quot;name&quot;) String name); @Override List&lt;EaoTagEntity&gt; findAll();&#125; API相关在api的包中新建webservice接口12345678910111213141516171819package com.inspur.gs.eao.pub.api.webservice;@Path(&quot;&#x2F;tag&quot;)@Produces(MediaType.APPLICATION_JSON)@Consumes(MediaType.APPLICATION_JSON)public interface EaoTagWebService &#123; @POST @Path(&quot;&#x2F;countByType&quot;) OperationResult countByType(List&lt;String&gt; ids) throws JsonProcessingException; @POST @Path(&quot;&#x2F;getOrderNum&quot;) OperationResult getOrderNum(String typeId); @POST @Path(&quot;&#x2F;excelImport&quot;) @Consumes(&#123;&quot;multipart&#x2F;form-data&quot;&#125;) OperationResult excelImport(@Multipart(&quot;file&quot;) Attachment var1);&#125; 在core中webservice(同级)写实现类注入需要的eaoTagRepository 1234567891011121314151617181920212223242526272829public class EaoTagWebServiceImpl implements EaoTagWebService &#123; private final EaoTagRepository eaoTagRepository; public EaoTagWebServiceImpl(EaoTagRepository eaoTagRepository) &#123; this.eaoTagRepository &#x3D; eaoTagRepository; &#125; @Override public OperationResult countByType(List&lt;String&gt; ids) throws JsonProcessingException &#123; List&lt;Integer&gt; nums&#x3D;new ArrayList&lt;Integer&gt;(); for (String id : ids) &#123; nums.add(eaoTagRepository.countByTypeId(id)); &#125;&#x2F;&#x2F; JsonNode ids &#x3D; jsonNode.get(&quot;ids&quot;);&#x2F;&#x2F; for (JsonNode id : ids) &#123;&#x2F;&#x2F; nums.add(eaoTagRepository.countByTypeId(id.toString()));&#x2F;&#x2F; &#125;&#x2F;&#x2F; System.out.println(nums); ObjectMapper objectMapper &#x3D; new ObjectMapper(); String nums_json &#x3D; objectMapper.writeValueAsString(nums); return new OperationResult(ResultType.SUCCESS,&quot;查询成功&quot;,nums); &#125;&#125; 放到spring中 前端调用1234567891011121314idp.service.fetch(&#39;&#x2F;api&#x2F;eao&#x2F;v1.0&#x2F;pub&#x2F;tag&#x2F;countByType&#39;, ids, false).done(function(data) &#123; console.log(data); var grid_data &#x3D; idp.control.get(&quot;grid_tagtype&quot;).getData(); for (var i &#x3D; 0; i &lt; grid_data.length; i++) &#123; var show_name &#x3D; grid_data[i][&quot;NAME$LANGUAGE$&quot;]; var index &#x3D; show_name.indexOf(&quot;(&quot;); var fname &#x3D; show_name.slice(0, index + 1) + data.appendData[i] + &quot;)&quot;; idp.control.get(&quot;grid_tagtype&quot;).updateRow(i, &#123; &quot;NAME$LANGUAGE$&quot;: fname &#125;); &#125; &#125;).fail(function(error) &#123; console.log(error); &#125;); 扩展相关在core.service包中写xxxservice类,注入eaoTagRepository123456789101112@Transactionalpublic class EaoTagTypeServiceImpl implements IExcelImportEvent&#123; private final EaoTagTypeRepository eaoTagTypeRepository; private final EaoTagRepository eaoTagRepository; public EaoTagTypeServiceImpl(EaoTagTypeRepository eaoTagTypeRepository, EaoTagRepository eaoTagRepository) &#123; this.eaoTagTypeRepository &#x3D; eaoTagTypeRepository; this.eaoTagRepository &#x3D; eaoTagRepository; &#125;&#125; 放入spring(core.config.DemoAutoConfiguration)1234@Beanpublic EaoTagTypeServiceImpl eaoTagTypeService(EaoTagTypeRepository eaoTagTypeRepository, EaoTagRepository eaoTagRepository)&#123; return new EaoTagTypeServiceImpl(eaoTagTypeRepository, eaoTagRepository);&#125; 功能相关日期格式化12345678910111213141516Date.prototype.Format = function(fmt) &#123; var o = &#123; \"M+\": this.getMonth() + 1, //月份 \"d+\": this.getDate(), //日 \"H+\": this.getHours(), //小时 \"m+\": this.getMinutes(), //分 \"s+\": this.getSeconds(), //秒 \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度 \"S\": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return fmt;&#125;//var dateStr=new Date().Format(\"yyMMdd\"); 数字格式化123456789function formatNum(number, len, ch) &#123; ch &#x3D; &quot;&quot; + ch; number &#x3D; &quot;&quot; + number; var strLength &#x3D; len - number.length; &#x2F;&#x2F;格式长度减去数字的长度，就是数字前补&quot;0&quot;的个数 for (var i &#x3D; 0; i &lt; strLength; i++) &#123; number &#x3D; ch + number; &#125; return number; &#125;","categories":[{"name":"js","slug":"js","permalink":"https://donghuangzhong.github.io/categories/js/"},{"name":"常用js","slug":"js/常用js","permalink":"https://donghuangzhong.github.io/categories/js/%E5%B8%B8%E7%94%A8js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://donghuangzhong.github.io/tags/js/"}]},{"title":"idea","slug":"idea","date":"2021-03-17T01:27:30.000Z","updated":"2021-03-17T01:30:57.455Z","comments":true,"path":"2021/03/17/idea/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/17/idea/","excerpt":"记录idea的相关操作","text":"记录idea的相关操作 对齐注释file–&gt;settings–&gt;editor–&gt;code style–&gt;xml 取消勾选Line comment at first column","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"idea","slug":"java/idea","permalink":"https://donghuangzhong.github.io/categories/java/idea/"}],"tags":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/tags/java/"},{"name":"idea","slug":"idea","permalink":"https://donghuangzhong.github.io/tags/idea/"}]},{"title":"spring_boot","slug":"spring-boot","date":"2021-03-16T05:40:40.000Z","updated":"2021-03-17T07:06:23.550Z","comments":true,"path":"2021/03/16/spring-boot/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/16/spring-boot/","excerpt":"摘要","text":"摘要 Spring Boot概述Spring Boot是一个便捷搭建 基于spring工程的脚手架；作用是帮助开发人员快速搭建大型的spring 项目。简化工程的配置，依赖管理；实现开发人员把时间都集中在业务开发上。 spring的优缺点 优点 1Spring是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的Enterprise JavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。 缺点 12345虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。 springBoot的特点 为基于Spring的开发提供更快的入门体验 开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等 SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式 Spring Boot入门实现可以在浏览器中访问http://localhost:8080/hello输出一串字符 创建一个普通的maven工程 添加SpringBoot的起步依赖 SpringBoot要求，项目要继承SpringBoot的起步依赖spring-boot-starter-parent SpringBoot要集成SpringMVC进行Controller的开发，所以项目要导入web的启动依赖 修改pom.xml 123456789101112131415&lt;!--继承SpringBoot的起步依赖spring-boot-starter-parent--&gt;&lt;parent&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;version&gt;2.3.9.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt;&lt;!--导入web的启动依赖--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3.9.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 编写启动类要通过SpringBoot提供的引导类起步SpringBoot才可以进行访问，注意该类不能从组件的默认包启动，所以需要建立一个包，然后将引导类放入其中。 123456@SpringBootApplicationpublic class AppRun &#123; public static void main(String[] args) &#123; SpringApplication.run(AppRun.class,args); &#125;&#125; 编写Controller12345678910@Controllerpublic class TestController &#123; @RequestMapping(&quot;hello&quot;) @ResponseBody String hello()&#123; return &quot;hello spring_boot&quot;; &#125;&#125; 运行启动类中的main方测试网址：http://localhost:8080/hello Java代码方式配置可以使用@Value获取配置文件配置项并结合@Bean注册组件到Spring jdbc.properties:（在resources目录下） 1234jdbc.driverClassName&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testjdbc.username&#x3D;rootjdbc.password&#x3D;root spring配置类config: 123456789101112131415161718192021222324252627@Configuration@PropertySource(\"classpath:jdbc.properties\")public class Config &#123; @Value(\"$&#123;jdbc.driverClassName&#125;\") private String driverClassName; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean DataSource druid()&#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(driverClassName); druidDataSource.setUrl(url); druidDataSource.setUsername(username); druidDataSource.setPassword(password); return druidDataSource; &#125;&#125; Spring Boot属性注入方式复杂方式(不推荐)创建application.properties文件(resources目录下)1234jdbc.driverClassName&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testjdbc.username&#x3D;rootjdbc.password&#x3D;root 创建配置项类JdbcProperties类并加注解12345678910111213141516171819202122232425262728293031323334353637383940@Component &#x2F;&#x2F;与ConfigurationProperties搭配使用(注入时)@ConfigurationProperties(prefix &#x3D; &quot;jdbc&quot;)public class JdbcProperties &#123; private String driverClassName; private String url; private String username; private String password; public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName &#x3D; driverClassName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url &#x3D; url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username &#x3D; username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password &#x3D; password; &#125;&#125; 在spring的配置类中通过函数参数注入JdbcProperties12345678910@BeanDataSource druid(JdbcProperties jdbcProperties)&#123; DruidDataSource druidDataSource &#x3D; new DruidDataSource(); druidDataSource.setDriverClassName(jdbcProperties.getDriverClassName()); druidDataSource.setUrl(jdbcProperties.getUrl()); druidDataSource.setUsername(jdbcProperties.getUsername()); druidDataSource.setPassword(jdbcProperties.getPassword()); return druidDataSource;&#125; 简单方式（推荐）需求：将配置文件中的配置项读取到一个对象中； 实现：可以使用Spring Boot提供的注解@ConfigurationProperties，该注解可以将Spring Boot的配置文件（默认必须为application.properties或application.yml）中的配置项读取到一个对象中。 创建application.properties文件(resources目录下)1234jdbc.driverClassName&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testjdbc.username&#x3D;rootjdbc.password&#x3D;root 使用@ConfigurationProperties在方法上面使用在spring的配置类中，会按照属性名对应自动注入 12345@Bean@ConfigurationProperties(prefix = \"jdbc\")public DataSource dataSource() &#123; return new DruidDataSource();&#125; 多个yml文件配置yaml与properties配置文件除了展示形式不相同以外，其它功能和作用都是一样的；在项目中原路的读取方式不需要改变。 1）yml配置文件的特征： 树状层级结构展示配置项； 配置项之间如果有关系的话需要分行空两格； 配置项如果有值的话，那么需要在 :之后空一格再写配置项值； 将application.properties配置文件修改为application.yml的话： 123456789101112jdbc: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/heima username: root password: rootkey: abc: cba def://结合或列表 - g - h - j 2）多个yml配置文件；在spring boot中是被允许的。这些配置文件的名称必须为application-***.yml，并且这些配置文件必须要在application.yml配置文件中激活之后才可以使用。 3）如果properties和yml配置文件同时存在在spring boot项目中；那么这两类配置文件都有效。在两个配置文件中如果存在同名的配置项的话会以properties文件的为主。 小结： 在多个配置文件时，需要将这些文件在application.yml文件中进行激活： 1234#激活配置文件;需要指定其它的配置文件名称spring: profiles: active: abc,def //abc对应application-abc.yml 自动配置原理目标：了解Spring Boot项目的配置加载流程 小结： 在 External Libraries\\*spring-boot-autocnfig\\META-INF\\spring.fatories文件中定义了很多自动配置类；可以根据在pom.xml文件中添加的 启动器依赖自动配置组件 通过如下流程可以去修改application配置文件，改变自动配置的组件默认参数 在org.springframework.boot.autoconfigure中分类的文件夹下找jar包 修改tomcat端口示例找到相关的xxxProperties文件，查看prefix端口相关的在web文件夹下的org.springframework.boot.autoconfigure.web.ServerProperties 12 修改application.properties lombok应用 编写数据库表对应的实体类；一般情况下需要编写get/set/toString等这些方法会耗时并且会让实体类看起来比较臃肿。可以使用lombok插件对实体类进行简化。 lombok是一个插件工具类包；提供了一些注解@Data、@Getter等这些注解去简化实体类中的构造方法、get/set等方法的编写。 在IDEA中安装lombok插件； 添加lombok对应的依赖到项目pom.xml文件； 改造实体类使用lombok注解 小结： 在Bean上使用：@Data ：自动提供getter和setter、hashCode、equals、toString等方法@Getter：自动提供getter方法@Setter：自动提供setter方法@Slf4j：自动在bean中提供log变量，其实用的是slf4j的日志功能。 Spring Boot整合-SpringMVC静态资源 在spring boot项目中静态资源可以放置在如下目录： Spring Boot整合-SpringMVC拦截器目标：可以在Spring Boot项目中配置自定义SpringMVC拦截器 分析： 编写拦截器（实现HandlerInterceptor）； 编写配置类实现 WebMvcConfigurer，在该类中添加各种组件； 测试 编写拦截器（实现HandlerInterceptor）123456789101112131415161718public class MyIntercepter implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle running&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle running&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion running&quot;); &#125;&#125; 编写配置类实现 WebMvcConfigurer，重写方法添加1234567@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyIntercepter()).addPathPatterns(&quot;&#x2F;*&quot;); &#125;&#125; Spring Boot整合-事务和连接池数据库声明 事务配置 添加事务相关的启动器依赖，mysql相关依赖； 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 编写业务类UserService使用事务注解@Transactional 整合hikari连接池 修改application.yml 123456spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test username: root password: root 测试即可 11. Spring Boot整合-Mybatis目标：配置Mybatis在Spring Boot工程中的整合包，设置mybatis的实体类别名，输出执行sql语句配置项 分析： 添加启动器依赖； 配置Mybatis：实体类别名包，日志，映射文件等； 配置MapperScan 小结： 添加mybatis官方对于spring boot的一个启动器 123456&lt;!--mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt; 配置mybatis 1234567mybatis: # 实体类别名包路径 type-aliases-package: com.itheima.pojo # 映射文件路径 # mapper-locations: classpath:mappers/*.xml configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 设置启动器类中的mapper扫描 12. Spring Boot整合-通用Mapper目标：配置通用Mapper组件到Spring Boot项目中并使用Mapper接口 分析： 通用Mapper：可以实现自动拼接sql语句；所有的mapper都不需要编写任何方法也就是不用编写sql语句。可以提高开发效率。 添加启动器依赖； 改造UserMapper继承Mapper； 修改启动引导类Application中的Mapper扫描注解； 修改User实体类添加jpa注解； 改造UserService实现业务功能； 小结： 在启动引导类上面的mapper扫描注解 一定要修改为 通用mapper的扫描注解 13. Spring Boot整合测试目标：可以访问处理器对应路径将数据库中的数据根据id查询 分析： 改造HelloController，注入UserService利用其方法实现查询； 启动项目进行测试 http://localhost/user/用户id –&gt; http://localhost/user/8 小结： 修改了HelloController： 123456789101112@Autowiredprivate UserService userService;/** * 根据用户id查询用户 * @param id 用户id * @return 用户 */@GetMapping(\"/user/&#123;id&#125;\")public User queryById(@PathVariable Long id)&#123; return userService.queryById(id);&#125; 14. Spring Boot整合-Junit目标：在Spring Boot项目中使用Junit进行单元测试UserService的方法 分析： 添加启动器依赖spring-boot-starter-test； 编写测试类 小结： 12345678910111213141516171819202122232425@RunWith(SpringRunner.class)@SpringBootTestpublic class UserServiceTest &#123; @Autowired private UserService userService; @Test public void queryById() &#123; User user = userService.queryById(8L); System.out.println(\"user = \" + user); &#125; @Test public void saveUser() &#123; User user = new User(); user.setUserName(\"test2\"); user.setName(\"test2\"); user.setAge(13); user.setPassword(\"123456\"); user.setSex(1); user.setCreated(new Date()); userService.saveUser(user); &#125;&#125; 在Spring Boot项目中如果编写测试类则必须要在类上面添加@SpringBootTest 15. Spring Boot整合-redis目标：在Spring Boot项目中使用Junit测试RedisTemplate的使用 分析： 添加启动器依赖；spring-boot-starter-data-redis 配置application.yml中修改redis的连接参数；（redis需要启动） 编写测试类应用RedisTemplate操作redis中的5种数据类型（string/hash/list/set/sorted set） 小结： 123456789101112131415161718192021222324252627282930313233343536373839404142434445@RunWith(SpringRunner.class)@SpringBootTestpublic class RedisTest &#123; @Autowired private RedisTemplate redisTemplate; @Test public void test()&#123; //string 字符串 //redisTemplate.opsForValue().set(\"str\", \"heima\"); redisTemplate.boundValueOps(\"str\").set(\"heima\"); System.out.println(\"str = \" + redisTemplate.opsForValue().get(\"str\")); //hash 散列 redisTemplate.boundHashOps(\"h_key\").put(\"name\", \"heima\"); redisTemplate.boundHashOps(\"h_key\").put(\"age\", 13); //获取所有域 Set set = redisTemplate.boundHashOps(\"h_key\").keys(); System.out.println(\" hash散列的所有域：\" + set); //获取所有值 List list = redisTemplate.boundHashOps(\"h_key\").values(); System.out.println(\" hash散列的所有域的值：\" + list); //list 列表 redisTemplate.boundListOps(\"l_key\").leftPush(\"c\"); redisTemplate.boundListOps(\"l_key\").leftPush(\"b\"); redisTemplate.boundListOps(\"l_key\").leftPush(\"a\"); //获取全部元素 list = redisTemplate.boundListOps(\"l_key\").range(0, -1); System.out.println(\" list列表中的所有元素：\" + list); // set 集合 redisTemplate.boundSetOps(\"s_key\").add(\"a\", \"b\", \"c\"); set = redisTemplate.boundSetOps(\"s_key\").members(); System.out.println(\" set集合中的所有元素：\" + set); // sorted set 有序集合 redisTemplate.boundZSetOps(\"z_key\").add(\"a\", 30); redisTemplate.boundZSetOps(\"z_key\").add(\"b\", 20); redisTemplate.boundZSetOps(\"z_key\").add(\"c\", 10); set = redisTemplate.boundZSetOps(\"z_key\").range(0, -1); System.out.println(\" zset有序集合中的所有元素：\" + set); &#125;&#125; 16. Spring Boot项目部署目标：将Spring Boot项目使用maven指令打成jar包并运行测试 分析： 需要添加打包组件将项目中的资源、配置、依赖包打到一个jar包中；可以使用maven的package； 部署：java -jar 包名 小结： 添加打包组件 123456789&lt;build&gt; &lt;plugins&gt; &lt;!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 部署运行 1java -jar 包名","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"},{"name":"spring_boot","slug":"spring-boot","permalink":"https://donghuangzhong.github.io/tags/spring-boot/"}]},{"title":"Redis","slug":"Redis","date":"2021-03-03T23:22:40.000Z","updated":"2021-03-04T08:58:18.933Z","comments":true,"path":"2021/03/04/Redis/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/04/Redis/","excerpt":"redis 概念 下载安装 命令操作 数据结构 持久化操作 使用Java客户端操作redis","text":"redis 概念 下载安装 命令操作 数据结构 持久化操作 使用Java客户端操作redis 概述 概念： redis是一款高性能的NOSQL系列的非关系型数据库 NOSQL：NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 NOSQL和关系型数据库比较 12345678910111213141516171819优点：1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。缺点：1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。3）不提供关系型数据库对事务的处理。非关系型数据库的优势：1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。关系型数据库的优势：1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 支持的数据类型 123451) 字符串类型 string2) 哈希类型 hash3) 列表类型 list4) 集合类型 set5) 有序集合类型 sortedset redis的应用场景 1234567• 缓存（数据查询、短连接、新闻内容、商品内容等等）• 聊天室的在线好友列表• 任务队列。（秒杀、抢购、12306等等）• 应用排行榜• 网站访问统计• 数据过期处理（可以精确到毫秒• 分布式集群架构中的session分离 下载安装1234561. 官网：https:&#x2F;&#x2F;redis.io2. 中文网：http:&#x2F;&#x2F;www.redis.net.cn&#x2F;3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 命令操作12345678redis的数据结构：* redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 字符串类型 string1234567891. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot;3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 哈希类型 hash123456789101112131415161718191. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 12. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 列表类型 list123456789101112131415161718192021列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 集合类型 set123456789101112集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 有序集合类型 sortedset12345678910111213141516171819202122232425有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 通用命令1231. keys * : 查询所有的键2. type key ： 获取键对应的value的类型3. del key：删除指定的key value 持久化redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 123456789101112131415161718192021redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 Java客户端 Jedis Jedis: 一款java操作redis数据库的工具. 持久化：redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 使用步骤 下载jedis的jar包 使用 123456&#x2F;&#x2F;1. 获取连接 Jedis jedis &#x3D; new Jedis(&quot;localhost&quot;,6379); &#x2F;&#x2F;2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); &#x2F;&#x2F;3. 关闭连接 jedis.close(); Jedis操作各种redis中的数据结构字符串类型 string1234567891011121314151617setget&#x2F;&#x2F;1. 获取连接Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口&#x2F;&#x2F;2. 操作&#x2F;&#x2F;存储jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);&#x2F;&#x2F;获取String username &#x3D; jedis.get(&quot;username&quot;);System.out.println(username);&#x2F;&#x2F;可以使用setex()方法存储可以指定过期时间的 key valuejedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);&#x2F;&#x2F;将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对&#x2F;&#x2F;3. 关闭连接jedis.close(); 哈希类型 hash ： map格式1234567891011121314151617181920212223242526272829hsethgethgetAll&#x2F;&#x2F;1. 获取连接Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口&#x2F;&#x2F;2. 操作&#x2F;&#x2F; 存储hashjedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;);jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;);jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;);&#x2F;&#x2F; 获取hashString name &#x3D; jedis.hget(&quot;user&quot;, &quot;name&quot;);System.out.println(name);&#x2F;&#x2F; 获取hash的所有map中的数据Map&lt;String, String&gt; user &#x3D; jedis.hgetAll(&quot;user&quot;);&#x2F;&#x2F; keysetSet&lt;String&gt; keySet &#x3D; user.keySet();for (String key : keySet) &#123;&#x2F;&#x2F;获取valueString value &#x3D; user.get(key);System.out.println(key + &quot;:&quot; + value);&#125;&#x2F;&#x2F;3. 关闭连接jedis.close(); 列表类型 list ： linkedlist格式。支持重复元素12345678910111213141516171819202122232425262728lpush &#x2F; rpushlpop &#x2F; rpoplrange start end : 范围获取&#x2F;&#x2F;1. 获取连接Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口&#x2F;&#x2F;2. 操作&#x2F;&#x2F; list 存储jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);&#x2F;&#x2F;从左边存jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);&#x2F;&#x2F;从右边存&#x2F;&#x2F; list 范围获取List&lt;String&gt; mylist &#x3D; jedis.lrange(&quot;mylist&quot;, 0, -1);System.out.println(mylist);&#x2F;&#x2F; list 弹出String element1 &#x3D; jedis.lpop(&quot;mylist&quot;);&#x2F;&#x2F;cSystem.out.println(element1);String element2 &#x3D; jedis.rpop(&quot;mylist&quot;);&#x2F;&#x2F;cSystem.out.println(element2);&#x2F;&#x2F; list 范围获取List&lt;String&gt; mylist2 &#x3D; jedis.lrange(&quot;mylist&quot;, 0, -1);System.out.println(mylist2);&#x2F;&#x2F;3. 关闭连接jedis.close(); 集合类型 set ： 不允许重复元素123456789101112131415saddsmembers:获取所有元素&#x2F;&#x2F;1. 获取连接Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口&#x2F;&#x2F;2. 操作&#x2F;&#x2F; set 存储jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;);&#x2F;&#x2F; set 获取Set&lt;String&gt; myset &#x3D; jedis.smembers(&quot;myset&quot;);System.out.println(myset);&#x2F;&#x2F;3. 关闭连接jedis.close(); 有序集合类型 sortedset：不允许重复元素，且元素有顺序zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close();jedis连接池： JedisPool使用123456789101112131415161. 创建JedisPool连接池对象2. 调用方法 getResource()方法获取Jedis连接&#x2F;&#x2F;0.创建一个配置对象JedisPoolConfig config &#x3D; new JedisPoolConfig();config.setMaxTotal(50);config.setMaxIdle(10);&#x2F;&#x2F;1.创建Jedis连接池对象JedisPool jedisPool &#x3D; new JedisPool(config,&quot;localhost&quot;,6379);&#x2F;&#x2F;2.获取连接Jedis jedis &#x3D; jedisPool.getResource();&#x2F;&#x2F;3. 使用jedis.set(&quot;hehe&quot;,&quot;heihei&quot;);&#x2F;&#x2F;4. 关闭 归还到连接池中jedis.close(); 连接池工具类12345678910111213141516171819202122232425262728293031public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; &#x2F;&#x2F;读取配置文件 InputStream is &#x3D; JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); &#x2F;&#x2F;创建Properties对象 Properties pro &#x3D; new Properties(); &#x2F;&#x2F;关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;获取数据，设置到JedisPoolConfig中 JedisPoolConfig config &#x3D; new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); &#x2F;&#x2F;初始化JedisPool jedisPool &#x3D; new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); &#125; &#x2F;** * 获取连接方法 *&#x2F; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; ​","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://donghuangzhong.github.io/tags/redis/"}]},{"title":"Cookie&Session","slug":"Cookie-Session","date":"2021-03-03T09:46:32.000Z","updated":"2021-03-04T23:52:59.162Z","comments":true,"path":"2021/03/03/Cookie-Session/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/03/Cookie-Session/","excerpt":"会话技术 Cookie Session","text":"会话技术 Cookie Session 会话技术1. 会话：一次会话中包含多次请求和响应。 * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 2. 功能：在一次会话的范围内的多次请求间，共享数据 3. 方式： 1. 客户端会话技术：Cookie 2. 服务器端会话技术：SessionCookie： 客户端会话技术，将数据保存到客户端 实现原理：基于响应头set-cookie和请求头cookie实现 使用步骤1234561. 创建Cookie对象，绑定数据 * new Cookie(String name, String value) 2. 发送Cookie对象 * response.addCookie(Cookie cookie) 3. 获取Cookie，拿到数据 * Cookie[] request.getCookies() cookie的细节12345678910111213141516171819202122232425262728293031323334351. 一次可不可以发送多个cookie? * 可以 * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。2. cookie在浏览器中保存多长时间？ 1. 默认情况下，当浏览器关闭后，Cookie数据被销毁 2. 持久化存储： * setMaxAge(int seconds) 1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 2. 负数：默认值 3. 零：删除cookie信息 3. cookie能不能存中文？ * 在tomcat 8 之前 cookie中不能直接存储中文数据。 * 需要将中文数据转码---一般采用URL编码(%E3) * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 4. cookie共享问题？ 1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ * 默认情况下cookie不能共享 * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 * 如果要共享，则可以将path设置为&quot;&#x2F;&quot; 2. 不同的tomcat服务器间cookie共享问题？ * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享 5. Cookie的特点和作用 1. cookie存储数据在客户端浏览器 2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) * 作用： 1. cookie一般用于存出少量的不太敏感的数据 2. 在不登录的情况下，完成服务器对客户端的身份识别 案例：记住上一次访问时间 需求分析 1234567891011121314151. 需求： 1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 2. 分析： 1. 可以采用Cookie来完成 2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie 1. 有：不是第一次访问 1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20 2. 写回Cookie：lastTime&#x3D;2018年6月10日11:50:01 2. 没有：是第一次访问 1. 响应数据：您好，欢迎您首次访问 2. 写回Cookie：lastTime&#x3D;2018年6月10日11:50:01 3.注意事项 建议使用url编解码，因为不支持空格等特殊字符 代码 1234567891011121314151617181920212223242526272829303132@WebServlet(&quot;&#x2F;cookie&quot;)public class CookieServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); boolean flag&#x3D;false; Cookie[] cookies &#x3D; req.getCookies(); if (cookies!&#x3D;null&amp;&amp;cookies.length&gt;0) &#123; for (Cookie cookie : cookies) &#123; if (&quot;lastTime&quot;.equals(cookie.getName()))&#123; resp.getWriter().write(&quot;欢迎回来您上一次访问本网站的时间是&quot;+ URLDecoder.decode(cookie.getValue(),&quot;utf-8&quot;)); flag&#x3D;true; break; &#125;&#125; if(flag&#x3D;&#x3D;false)resp.getWriter().write(&quot;欢迎您，这是您第一次访问本网站&quot;); &#125;else &#123; resp.getWriter().write(&quot;欢迎您，这是您第一次访问本网站&quot;); &#125; SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy年MM月d日 HH:mm:ss&quot;); Cookie coo &#x3D; new Cookie(&quot;lastTime&quot;, URLEncoder.encode(simpleDateFormat.format(new Date()),&quot;utf-8&quot;)); coo.setMaxAge(60); resp.addCookie(coo); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125;&#125; Session：主菜 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。 原理：Session的实现是依赖于Cookie的。 使用步骤1234567快速入门： 1. 获取HttpSession对象： HttpSession session &#x3D; request.getSession(); 2. 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) session的细节12345678910111213141516171819202122232425262728291. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ * 默认情况下。不是。 * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c &#x3D; new Cookie(&quot;JSESSIONID&quot;,session.getId()); c.setMaxAge(60*60); response.addCookie(c);2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 * session的钝化： * 在服务器正常关闭之前，将session对象系列化到硬盘上 * session的活化： * 在服务器启动后，将session文件转化为内存中的session对象即可。 3. session什么时候被销毁？ 1. 服务器关闭 2. session对象调用invalidate() 。 3. session默认失效时间 30分钟 选择性配置修改 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt; &lt;&#x2F;session-config&gt; 4. session的特点 1. session用于存储一次会话的多次请求的数据，存在服务器端 2. session可以存储任意类型，任意大小的数据 * session与Cookie的区别： 1. session存储数据在服务器端，Cookie在客户端 2. session没有数据大小限制，Cookie有 3. session数据安全，Cookie相对于不安全 案例：验证码1. 案例需求： 1. 访问带有验证码的登录页面login.jsp 2. 用户输入用户名，密码以及验证码。 * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 * 如果验证码输入有误，跳转登录页面，提示：验证码错误 * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 2. 分析：​","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"web相关","slug":"java/web相关","permalink":"https://donghuangzhong.github.io/categories/java/web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"cookie","slug":"cookie","permalink":"https://donghuangzhong.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"https://donghuangzhong.github.io/tags/session/"}]},{"title":"Response","slug":"Response","date":"2021-03-03T09:39:16.000Z","updated":"2021-03-04T10:53:10.641Z","comments":true,"path":"2021/03/03/Response/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/03/Response/","excerpt":"HTTP协议：响应消息 Response对象 ServletContext对象","text":"HTTP协议：响应消息 Response对象 ServletContext对象 请求消息 响应消息：服务器端发送给客户端的数据 数据格式 12341. 响应行2. 响应头3. 响应空行4. 响应体 响应行123456789101112131. 响应行 1. 组成：协议&#x2F;版本 响应状态码 状态码描述 2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1. 状态码都是3位数字 2. 分类： 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误。 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头123456782. 响应头： 1. 格式：头名称： 值 2. 常见的响应头： 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据 * 值： * in-line:默认值,在当前页面内打开 * attachment;filename&#x3D;xxx：以附件形式打开响应体。文件下载 响应空行响应体:传输的数据123456789101112131415* 响应字符串格式 HTTP&#x2F;1.1 200 OK Content-Type: text&#x2F;html;charset&#x3D;UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; hello , response &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; Response对象设置响应行1231. 设置响应行 1. 格式：HTTP&#x2F;1.1 200 ok 2. 设置状态码：setStatus(int sc) 设置响应头12. 设置响应头：setHeader(String name, String value) 特殊的设置响应格式 1response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); 设置响应体123456783. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 重定向12&#x2F;&#x2F;简单的重定向方法response.sendRedirect(&quot;&#x2F;day15&#x2F;responseDemo2&quot;); 重定向和转发的区别 12345678* 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据* 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 路径相关相对路径12345671. 相对路径：通过相对路径不可以确定唯一资源 * 如：.&#x2F;index.html * 不以&#x2F;开头，以.开头路径 * 规则：找到当前资源和目标资源之间的相对位置关系 * .&#x2F;：当前目录 * ..&#x2F;:后退一级目录 绝对路径1232. 绝对路径：通过绝对路径可以确定唯一资源 * 如：http:&#x2F;&#x2F;localhost&#x2F;day15&#x2F;responseDemo2 &#x2F;day15&#x2F;responseDemo2 * 以&#x2F;开头的路径 规则123456* 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * &lt;a&gt; , &lt;form&gt; 重定向... * 给服务器使用：不需要加虚拟目录 * 转发路径 乱码问题123456* 乱码问题： 1. PrintWriter pw &#x3D; response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); &#x2F;&#x2F;简单的形式，设置编码，是在获取流之前设置 ServletContext对象： 概念：代表整个web应用，可以和程序的容器(服务器)来通信 获取123452. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); 功能1234567891011121314151617181920211. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型&#x2F;小类型 text&#x2F;html image&#x2F;jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) String b &#x3D; context.getRealPath(&quot;&#x2F;b.txt&quot;);&#x2F;&#x2F;web目录下资源访问 System.out.println(b); String c &#x3D; context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;c.txt&quot;);&#x2F;&#x2F;WEB-INF目录下的资源访问 System.out.println(c); String a &#x3D; context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;a.txt&quot;);&#x2F;&#x2F;src目录下的资源访问 System.out.println(a); 案例：文件下载1234* 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载 12345* 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： * content-disposition:attachment;filename&#x3D;xxx 1234567* 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename&#x3D;xxx 4. 将数据写出到response输出流 12345* 问题： * 中文文件问题 * 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"web相关","slug":"java/web相关","permalink":"https://donghuangzhong.github.io/categories/java/web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"response","slug":"response","permalink":"https://donghuangzhong.github.io/tags/response/"}]},{"title":"Servlet&HTTP&Request","slug":"Servlet-HTTP-Request","date":"2021-03-03T08:45:58.000Z","updated":"2021-03-04T10:10:32.642Z","comments":true,"path":"2021/03/03/Servlet-HTTP-Request/","link":"","permalink":"https://donghuangzhong.github.io/2021/03/03/Servlet-HTTP-Request/","excerpt":"Servlet HTTP协议 Request","text":"Servlet HTTP协议 Request Servlet：Servlet的体系结构123456789101112Servlet -- 接口 |GenericServlet -- 抽象类 |HttpServlet -- 抽象类* GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可* HttpServlet：对http协议的一种封装，简化操作 1. 定义类继承HttpServlet 2. 复写doGet&#x2F;doPost方法 Servlet相关配置1234561. urlpartten:Servlet访问路径 1. 一个Servlet可以定义多个访问路径 ： @WebServlet(&#123;&quot;&#x2F;d4&quot;,&quot;&#x2F;dd4&quot;,&quot;&#x2F;ddd4&quot;&#125;) 2. 路径定义规则： 1. &#x2F;xxx：路径匹配 2. &#x2F;xxx&#x2F;xxx:多层路径，目录结构 3. *.do：扩展名匹配 HTTP： 概念：Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了客户端和服务器端通信时，发送数据的格式 特点 12341. 基于TCP&#x2F;IP的高级协议2. 默认端口号:803. 基于请求&#x2F;响应模型的:一次请求对应一次响应4. 无状态的：每次请求之间相互独立，不能交互数据 历史版本 12* 1.0：每一次请求响应都会建立新的连接* 1.1：复用连接 请求消息数据格式请求行12345678910111213请求方式 请求url 请求协议&#x2F;版本GET &#x2F;login.html HTTP&#x2F;1.1* 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 请求头客户端浏览器告诉服务器一些信息 12345678910请求头名称: 请求头值* 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http:&#x2F;&#x2F;localhost&#x2F;login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 请求空行空行，就是用于分割POST请求的请求头，和请求体的。 请求体(正文)封装POST请求消息的请求参数的 123456789101112* 字符串格式：POST &#x2F;login.html HTTP&#x2F;1.1Host: localhostUser-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko&#x2F;20100101 Firefox&#x2F;60.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateReferer: http:&#x2F;&#x2F;localhost&#x2F;login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1username&#x3D;zhangsan Request：request对象和response对象的原理 request和response对象是由服务器创建的。我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 request对象继承体系结构123456request对象继承体系结构： ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat) request功能获取请求行数据12345678910111213141516171819202122* GET &#x2F;day14&#x2F;demo1?name&#x3D;zhangsan HTTP&#x2F;1.1* 方法： 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：&#x2F;day14 * String getContextPath() 3. 获取Servlet路径: &#x2F;demo1 * String getServletPath() 4. 获取get方式请求参数：name&#x3D;zhangsan * String getQueryString() 5. (*)获取请求URI：&#x2F;day14&#x2F;demo1 * String getRequestURI(): &#x2F;day14&#x2F;demo1 * StringBuffer getRequestURL() :http:&#x2F;&#x2F;localhost&#x2F;day14&#x2F;demo1 * URL:统一资源定位符 ： http:&#x2F;&#x2F;localhost&#x2F;day14&#x2F;demo1 中华人民共和国 * URI：统一资源标识符 : &#x2F;day14&#x2F;demo1 共和国 6. 获取协议及版本：HTTP&#x2F;1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() 获取请求头数据123* 方法： * (*)String getHeader(String name):通过请求头的名称获取请求头的值 * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 获取请求体数据12345678* 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数* 步骤： 1. 获取流对象 * BufferedReader getReader()：获取字符输入流，只能操作字符数据 * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 * 在文件上传知识点后讲解 2. 再从流对象中拿数据 获取请求参数通用方式1234567891011121314不论get还是post请求方式都可以使用下列方法来获取请求参数1. String getParameter(String name):根据参数名称获取参数值 username&#x3D;zs&amp;password&#x3D;1232. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby&#x3D;xx&amp;hobby&#x3D;game3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合* 中文乱码问题： * get方式：tomcat 8 已经将get方式乱码问题解决了 * post方式：会乱码 * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;); 请求转发123456789一种在服务器内部的资源跳转方式1. 步骤： 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 2. 特点： 1. 浏览器地址栏路径不发生变化 2. 只能转发到当前服务器内部资源中。 3. 转发是一次请求 共享数据1234567共享数据： * 域对象：一个有作用范围的对象，可以在范围内共享数据 * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 * 方法： 1. void setAttribute(String name,Object obj):存储数据 2. Object getAttitude(String name):通过键获取值 3. void removeAttribute(String name):通过键移除键值对 获取ServletContext1ServletContext getServletContext() BeanUtils工具类1234567891011121314151617BeanUtils工具类，简化数据封装 * 用于封装JavaBean的 1. JavaBean：标准的Java类 1. 要求： 1. 类必须被public修饰 2. 必须提供空参的构造器 3. 成员变量必须使用private修饰 4. 提供公共setter和getter方法 2. 功能：封装数据 2. 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() --&gt; Username--&gt; username 3. 方法： 1. setProperty() 2. getProperty() 3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"web相关","slug":"java/web相关","permalink":"https://donghuangzhong.github.io/categories/java/web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/tags/java/"},{"name":"web","slug":"web","permalink":"https://donghuangzhong.github.io/tags/web/"}]},{"title":"Mybatis_多表+注解","slug":"Mybatis-多表-注解","date":"2021-02-25T06:57:41.000Z","updated":"2021-03-05T01:51:54.472Z","comments":true,"path":"2021/02/25/Mybatis-多表-注解/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/25/Mybatis-%E5%A4%9A%E8%A1%A8-%E6%B3%A8%E8%A7%A3/","excerpt":"Mybatis注解方式 分步查询","text":"Mybatis注解方式 分步查询 1.Mybatis多表查询一对一查询一对一查询的模型MapperScannerConfigurer用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询的语句对应的sql语句：select * from orders o,user u where o.uid=u.id; 查询的结果如下： 创建Order和User实体123456789101112131415161718public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125;public class User &#123; private int id; private String username; private String password; private Date birthday;&#125; 创建OrderMapper接口123public interface OrderMapper &#123; List&lt;Order&gt; findAll();&#125; 配置OrderMapper.xml无歧义不用单独配 123456789101112&lt;mapper namespace=\"com.dhz.mapper.OrderMapper\"&gt; &lt;resultMap id=\"orderMap\" type=\"order\"&gt; &lt;id column=\"oid\" property=\"id\"/&gt; &lt;result column=\"uid\" property=\"user.id\"&gt;&lt;/result&gt; &lt;result column=\"username\" property=\"user.username\"&gt;&lt;/result&gt; &lt;result column=\"password\" property=\"user.password\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"user.birthday\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"orderMap\"&gt; SELECT *,o.id oid,u.id uid FROM orders o,USER u WHERE o.uid=u.id; &lt;/select&gt;&lt;/mapper&gt; 其中还可以配置如下： 1234567891011&lt;resultMap id=\"orderMap\" type=\"com.itheima.domain.Order\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"ordertime\" column=\"ordertime\"&gt;&lt;/result&gt; &lt;result property=\"total\" column=\"total\"&gt;&lt;/result&gt; &lt;association property=\"user\" javaType=\"com.itheima.domain.User\"&gt; &lt;result column=\"uid\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"password\" property=\"password\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt; 测试结果12345OrderMapper mapper = sqlSession.getMapper(OrderMapper.class);List&lt;Order&gt; all = mapper.findAll();for(Order order : all)&#123; System.out.println(order);&#125; 一对多查询一对多查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 一对多查询的语句对应的sql语句：select *,o.id oid from user u left join orders o on u.id=o.uid; 查询的结果如下： 修改User实体12345678910111213141516171819public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125;public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList;&#125; 创建UserMapper接口123public interface UserMapper &#123; List&lt;User&gt; findAll();&#125; 配置UserMapper.xml1234567891011121314151617&lt;mapper namespace=\"com.dhz.mapper.UserMapper\"&gt; &lt;resultMap id=\"orderMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"uid\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"password\" column=\"password\"/&gt; &lt;result property=\"birthday\" column=\"birthday\"/&gt; &lt;collection property=\"orders\" ofType=\"order\"&gt; &lt;id property=\"id\" column=\"oid\"/&gt; &lt;result property=\"ordertime\" column=\"ordertime\"/&gt; &lt;result property=\"total\" column=\"total\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"orderMap\"&gt; SELECT *,o.id oid FROM USER u,orders o WHERE u.id=o.uid &lt;/select&gt;&lt;/mapper&gt; 测试结果12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAll();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Order&gt; orderList = user.getOrderList(); for(Order order : orderList)&#123; System.out.println(order); &#125; System.out.println(\"----------------------------------\");&#125; 多对多查询多对多查询的模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 多对多查询的语句对应的sql语句：select u.,r.,r.id rid from user u left join user_role ur on u.id=ur.user_id inner join role r on ur.role_id=r.id; 查询的结果如下： 创建Role实体，修改User实体1234567891011121314151617public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList; //代表当前用户具备哪些角色 private List&lt;Role&gt; roleList;&#125;public class Role &#123; private int id; private String roleName; private String roleDesc;&#125; 添加UserMapper接口方法1List&lt;User&gt; findAllUserAndRole(); 配置UserMapper.xml1234567891011121314&lt;resultMap id=\"userRoleMap\" type=\"com.itheima.domain.User\"&gt; &lt;result column=\"id\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"password\" property=\"password\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;collection property=\"roleList\" ofType=\"com.dhz.domain.Role\"&gt; &lt;result column=\"rid\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"rolename\" property=\"rolename\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"findAllUserAndRole\" resultMap=\"userRoleMap\"&gt; select u.*,r.*,r.id rid from user u left join user_role ur on u.id=ur.user_id inner join role r on ur.role_id=r.id&lt;/select&gt; 测试结果12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAllUserAndRole();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Role&gt; roleList = user.getRoleList(); for(Role role : roleList)&#123; System.out.println(role); &#125; System.out.println(\"----------------------------------\");&#125; 知识小结MyBatis多表配置方式： 一对一配置：使用做配置 一对多配置：使用+做配置 多对多配置：使用+做配置 2.Mybatis的注解开发MyBatis的常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper 映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。 @Insert：实现新增 @Update：实现更新 @Delete：实现删除 @Select：实现查询 @Result：实现结果集封装 @Results：可以与@Result 一起使用，封装多个结果集 @One：实现一对一结果集封装 @Many：实现一对多结果集封装 MyBatis的增删改查我们完成简单的user表的增删改查的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445private UserMapper userMapper;@Beforepublic void before() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(UserMapper.class);&#125;@Testpublic void testAdd() &#123; User user = new User(); user.setUsername(\"测试数据\"); user.setPassword(\"123\"); user.setBirthday(new Date()); userMapper.add(user);&#125;@Testpublic void testUpdate() throws IOException &#123; User user = new User(); user.setId(16); user.setUsername(\"测试数据修改\"); user.setPassword(\"abc\"); user.setBirthday(new Date()); userMapper.update(user);&#125;@Testpublic void testDelete() throws IOException &#123; userMapper.delete(16);&#125;@Testpublic void testFindById() throws IOException &#123; User user = userMapper.findById(1); System.out.println(user);&#125;@Testpublic void testFindAll() throws IOException &#123; List&lt;User&gt; all = userMapper.findAll(); for(User user : all)&#123; System.out.println(user); &#125;&#125; 修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可 1234&lt;mappers&gt; &lt;!--扫描使用注解的类--&gt; &lt;mapper class=\"com.itheima.mapper.UserMapper\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 或者指定扫描包含映射关系的接口所在的包也可以 //常用 1234&lt;mappers&gt; &lt;!--扫描使用注解的类所在的包--&gt; &lt;package name=\"com.itheima.mapper\"&gt;&lt;/package&gt;&lt;/mappers&gt; MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置 一对一查询一对一查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询的语句对应的sql语句： select * from orders; select * from user where id=查询出订单的uid;查询的结果如下： 创建Order和User实体123456789101112131415161718public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125;public class User &#123; private int id; private String username; private String password; private Date birthday;&#125; 创建OrderMapper接口123public interface OrderMapper &#123; List&lt;Order&gt; findAll();&#125; 使用注解配置Mapper 无歧义的会自动注入，主键最好不要省略 12345678910111213141516171819//方式一 @Select(\"SELECT * FROM orders\") @Results(&#123; @Result(id = true,property = \"id\",column = \"id\"), @Result(javaType = User.class,property = \"user\",column = \"uid\", one = @One(select = \"com.dhz.mapper.UserMapper.findById\") ) &#125;) List&lt;Order&gt; findAll();//方式二 @Select(\"SELECT *,o.id oid FROM orders o,USER u WHERE o.uid=u.id\") @Results(&#123; @Result(property =\"id\",column = \"oid\"), @Result(property =\"user.username\",column = \"username\"), @Result(property =\"user.password\",column = \"password\"), @Result(property =\"user.birthday\",column = \"birthday\") &#125;) List&lt;Order&gt; findAll(); 123456public interface UserMapper &#123; @Select(\"select * from user where id=#&#123;id&#125;\") User findById(int id); &#125; 测试结果1234567@Testpublic void testSelectOrderAndUser() &#123; List&lt;Order&gt; all = orderMapper.findAll(); for(Order order : all)&#123; System.out.println(order); &#125;&#125; 一对多查询一对多查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 一对多查询的语句对应的sql语句： select * from user; select * from orders where uid=查询出用户的id;查询的结果如下： 修改User实体12345678910111213141516171819public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125;public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList;&#125; 创建UserMapper接口1List&lt;User&gt; findAllUserAndOrder(); 使用注解配置Mapper12345678910111213141516171819public interface UserMapper &#123; @Select(\"select * from user\") @Results(&#123; @Result(id = true,property = \"id\",column = \"id\"), @Result(property = \"username\",column = \"username\"), @Result(property = \"password\",column = \"password\"), @Result(property = \"birthday\",column = \"birthday\"), @Result(property = \"orderList\",column = \"id\", javaType = List.class, many = @Many(select = \"com.itheima.mapper.OrderMapper.findByUid\")) &#125;) List&lt;User&gt; findAllUserAndOrder();&#125;public interface OrderMapper &#123; @Select(\"select * from orders where uid=#&#123;uid&#125;\") List&lt;Order&gt; findByUid(int uid);&#125; 测试结果123456789List&lt;User&gt; all = userMapper.findAllUserAndOrder();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Order&gt; orderList = user.getOrderList(); for(Order order : orderList)&#123; System.out.println(order); &#125; System.out.println(\"-----------------------------\");&#125; 多对多查询多对多查询的模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 2.6.2 多对多查询的语句对应的sql语句： select * from user; SELECT * FROM sys_user_role uo,sys_role r WHERE uo.roleId=r.id AND uo.userId=用户的uid查询的结果如下(uid=1)： 2.6.3 创建Role实体，修改User实体1234567891011121314151617public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orders; //代表当前用户具备哪些角色 private List&lt;Role&gt; roles;&#125;public class Role &#123; private int id; private String roleName; private String roleDesc;&#125; 添加UserMapper接口方法1List&lt;User&gt; findAllUserAndRole(); 使用注解配置Mapper12345678910111213141516 @Select(\"select * from user\") @Results(&#123; @Result(id = true, property = \"id\",column = \"id\"), @Result(javaType = List.class,property = \"roles\",column = \"id\", many = @Many(select = \"com.dhz.mapper.RoleMapper.findByUid\") ) &#125;) List&lt;User&gt; findAllUserAndRole();public interface RoleMapper &#123; @Select(\"SELECT * FROM sys_user_role uo,sys_role r WHERE uo.roleId=r.id AND uo.userId=#&#123;uid&#125;\") List&lt;Role&gt; findByUid(int uid);&#125; 2.6.6 测试结果12345UserMapper userMapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; users = userMapper.findAllUserAndRole();for (User user : users) &#123; System.out.println(user);&#125; SSM框架整合1.1 原始方式整合1.准备工作 2.创建Maven工程 3.导入Maven坐标参考：素材/配置文件/pom.xml文件 4.编写实体类123456public class Account &#123; private int id; private String name; private double money; //省略getter和setter方法&#125; 5.编写Mapper接口123456public interface AccountMapper &#123; //保存账户数据 void save(Account account); //查询账户数据 List&lt;Account&gt; findAll();&#125; 6.编写Service接口1234public interface AccountService &#123; void save(Account account); //保存账户数据 List&lt;Account&gt; findAll(); //查询账户数据&#125; 7.编写Service接口实现123456789101112131415@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123; public void save(Account account) &#123; SqlSession sqlSession = MyBatisUtils.openSession(); AccountMapper accountMapper = sqlSession.getMapper(AccountMapper.class); accountMapper.save(account); sqlSession.commit(); sqlSession.close(); &#125; public List&lt;Account&gt; findAll() &#123; SqlSession sqlSession = MyBatisUtils.openSession(); AccountMapper accountMapper = sqlSession.getMapper(AccountMapper.class); return accountMapper.findAll(); &#125;&#125; 8.编写Controller123456789101112131415161718@Controllerpublic class AccountController &#123; @Autowired private AccountService accountService; @RequestMapping(\"/save\") @ResponseBody public String save(Account account)&#123; accountService.save(account); return \"save success\"; &#125; @RequestMapping(\"/findAll\") public ModelAndView findAll()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"accountList\"); modelAndView.addObject(\"accountList\",accountService.findAll()); return modelAndView; &#125;&#125; 9.编写添加页面1234567891011121314&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;保存账户信息表单&lt;/h1&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/save.action\" method=\"post\"&gt; 用户名称&lt;input type=\"text\" name=\"name\"&gt;&lt;br/&gt; 账户金额&lt;input type=\"text\" name=\"money\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"保存\"&gt;&lt;br/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 10.编写列表页面1234567891011121314&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;账户id&lt;/th&gt; &lt;th&gt;账户名称&lt;/th&gt; &lt;th&gt;账户金额&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;accountList&#125;\" var=\"account\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;account.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;account.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;account.money&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 11.编写相应配置文件(文件参考目录：素材/配置文件)•Spring配置文件：applicationContext.xml •SprngMVC配置文件：spring-mvc.xml •MyBatis映射文件：AccountMapper.xml •MyBatis核心文件：sqlMapConfig.xml •数据库连接信息文件：jdbc.properties •Web.xml文件：web.xml •日志文件：[log4j.xml]( 12.测试添加账户 13.测试账户列表 1.2 Spring整合MyBatis1.整合思路 2.将SqlSessionFactory配置到Spring容器中1234567891011121314&lt;!--加载jdbc.properties--&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;&lt;!--配置数据源--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/bean&gt;&lt;!--配置MyBatis的SqlSessionFactory--&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:sqlMapConfig.xml\"/&gt;&lt;/bean&gt; 3.扫描Mapper，让Spring容器产生Mapper实现类1234&lt;!--配置Mapper扫描--&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.itheima.mapper\"/&gt;&lt;/bean&gt; 4.配置声明式事务控制12345678910111213&lt;!--配置声明式事务控制--&gt;&lt;bean id=\"transacionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transacionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/&gt;&lt;/aop:config&gt; 5.修改Service实现类代码12345678910111213@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountMapper accountMapper; public void save(Account account) &#123; accountMapper.save(account); &#125; public List&lt;Account&gt; findAll() &#123; return accountMapper.findAll(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://donghuangzhong.github.io/tags/Mybatis/"}]},{"title":"Mybatis_Dao","slug":"Mybatis-Dao","date":"2021-02-25T03:19:34.000Z","updated":"2021-03-05T01:49:12.439Z","comments":true,"path":"2021/02/25/Mybatis-Dao/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/25/Mybatis-Dao/","excerpt":"Mybatis代理方式实现(无需Mapper(Dao)的实现类) 动态SQL 自定义类型转换(Date) 分页助手插件","text":"Mybatis代理方式实现(无需Mapper(Dao)的实现类) 动态SQL 自定义类型转换(Date) 分页助手插件 Mybatis的Dao层实现传统开发方式编写UserDao接口123public interface UserDao &#123; List&lt;User&gt; findAll() throws IOException;&#125; 编写UserDaoImpl实现123456789101112public class UserDaoImpl implements UserDao &#123; public List&lt;User&gt; findAll() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.findAll\"); sqlSession.close(); return userList; &#125;&#125; 测试传统方式123456@Testpublic void testTraditionDao() throws IOException &#123; UserDao userDao = new UserDaoImpl(); List&lt;User&gt; all = userDao.findAll(); System.out.println(all);&#125; 代理开发方式代理开发方式介绍采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper 接口开发需要遵循以下规范： 1) Mapper.xml文件中的namespace与mapper接口的全限定名相同 2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 编写UserMapper接口 测试代理方式1234567891011@Testpublic void testProxyDao() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findById(1); System.out.println(user); sqlSession.close();&#125; 知识小结MyBatis的Dao层实现的两种方式： 手动对Dao进行实现：传统开发方式 代理方式对Dao进行实现： **UserMapper userMapper = sqlSession.getMapper(UserMapper.class);**MyBatis映射文件深入动态sql语句动态sql语句概述Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。 参考的官方文档，描述如下： 动态 SQL 之&lt;if&gt;我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 1234567891011&lt;select id=\"findByCondition\" parameterType=\"user\" resultType=\"user\"&gt; select * from User &lt;where&gt; &lt;if test=\"id!=0\"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 当查询条件id和username都存在时，控制台打印的sql语句如下： 12345678 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User condition = new User(); condition.setId(1); condition.setUsername(\"lucy\"); User user = userMapper.findByCondition(condition); … … … 当查询条件只有id存在时，控制台打印的sql语句如下： 1234567 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User condition = new User();condition.setId(1);User user = userMapper.findByCondition(condition);… … … 动态 SQL 之&lt;foreach&gt;循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。 12345678&lt;select id=\"findByIds\" parameterType=\"list\" resultType=\"user\"&gt; select * from User &lt;where&gt; &lt;foreach collection=\"list\" open=\"id in(\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 测试代码片段如下： 1234567 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);int[] ids = new int[]&#123;2,5&#125;;List&lt;User&gt; userList = userMapper.findByIds(ids);System.out.println(userList);… … … foreach标签的属性含义如下： 标签用于遍历集合，它的属性： •collection：代表要遍历的集合元素，注意编写时不要写#{}，list或者array •open：代表语句的开始部分 •close：代表结束部分 •item：代表遍历集合的每个元素，生成的变量名 •sperator：代表分隔符 SQL片段抽取Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的 12345678910111213&lt;!--抽取sql片段简化编写--&gt;&lt;sql id=\"selectUser\" select * from User&lt;/sql&gt;&lt;select id=\"findById\" parameterType=\"int\" resultType=\"user\"&gt; &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; where id=#&#123;id&#125;&lt;/select&gt;&lt;select id=\"findByIds\" parameterType=\"list\" resultType=\"user\"&gt; &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=\"array\" open=\"id in(\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; MyBatis核心配置文件深入typeHandlers标签无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器（截取部分）。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。 开发步骤： ①定义转换类继承类BaseTypeHandler ②覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时 mysql的字符串类型转换成 java的Type类型的方法 ③在MyBatis核心配置文件中进行注册 测试转换是否正确 1234567891011121314151617public class DateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; public void setNonNullParameter(PreparedStatement ps, int i, Date parameter, JdbcType jdbcType) throws SQLException &#123; ps.setLong(i,parameter.getTime()); &#125; public Date getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return new Date(rs.getLong(columnName)); &#125; public Date getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return new Date(rs.getLong(columnIndex)); &#125; public Date getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return new Date(cs.getLong(columnIndex)); &#125;&#125; 1234&lt;!--注册类型自定义转换器--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=\"com.itheima.typeHandlers.MyDateTypeHandler\"&gt;&lt;/typeHandler&gt;&lt;/typeHandlers&gt; 测试添加操作： 12user.setBirthday(new Date());userMapper.save(user); plugins标签MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据 开发步骤： ①导入通用PageHelper的坐标 ②在mybatis核心配置文件中配置PageHelper插件 ③测试分页数据获取 ①导入通用PageHelper坐标1234567891011&lt;!-- 分页助手 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; ②在mybatis核心配置文件中配置PageHelper插件12345&lt;!-- 注意：分页助手的插件 配置在通用馆mapper之前 --&gt; &lt;plugins&gt; &lt;!-- PageHelper5版本配置 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"/&gt; &lt;/plugins&gt; ③测试分页代码实现12345678910@Testpublic void testPageHelper()&#123; //设置分页参数 PageHelper.startPage(1,2); List&lt;User&gt; select = userMapper2.select(null); for(User user : select)&#123; System.out.println(user); &#125;&#125; 获得分页相关的其他参数 12345678//其他分页的数据PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(select);System.out.println(\"总条数：\"+pageInfo.getTotal());System.out.println(\"总页数：\"+pageInfo.getPages());System.out.println(\"当前页：\"+pageInfo.getPageNum());System.out.println(\"每页显示长度：\"+pageInfo.getPageSize());System.out.println(\"是否第一页：\"+pageInfo.isIsFirstPage());System.out.println(\"是否最后一页：\"+pageInfo.isIsLastPage()); 知识小结MyBatis核心配置文件常用标签： 1、properties标签：该标签可以加载外部的properties文件 2、typeAliases标签：设置类型别名 3、environments标签：数据源环境配置标签 4、typeHandlers标签：配置自定义类型处理器 5、plugins标签：配置MyBatis的插件","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://donghuangzhong.github.io/tags/mybatis/"}]},{"title":"Mybatis","slug":"Mybatis","date":"2021-02-24T09:41:45.000Z","updated":"2021-03-05T01:44:03.476Z","comments":true,"path":"2021/02/24/Mybatis/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/24/Mybatis/","excerpt":"Mybatis简介和xml方式配置","text":"Mybatis简介和xml方式配置 Mybatis简介原始jdbc操作（查询数据） 原始jdbc操作（插入数据） 原始jdbc操作的分析原始jdbc开发存在的问题如下： ①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能 ②sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。 ③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置 应对上述问题给出的解决方案： ①使用数据库连接池初始化连接资源 ②将sql语句抽取到xml配置文件中 ③使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 什么是Mybatismybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。 Mybatis的快速入门MyBatis开发步骤MyBatis官网地址：http://www.mybatis.org/mybatis-3/ MyBatis开发步骤： ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml ⑥编写测试类 环境搭建1)导入MyBatis的坐标和其他相关坐标 1234567891011121314151617181920212223242526&lt;!--mybatis坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql驱动坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--单元测试坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--日志坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; 2) 创建user数据表 3) 编写User实体 123456public class User &#123; private int id; private String username; private String password; //省略get个set方法&#125; 4)编写UserMapper映射文件 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"userMapper\"&gt; &lt;select id=\"findAll\" resultType=\"com.dhz.domain.User\"&gt; select * from User &lt;/select&gt;&lt;/mapper&gt; 5) 编写MyBatis核心文件 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;!-- 数据源环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///test\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;!-- 加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"com\\dhz\\mapper\\UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写测试代码123456789101112//加载核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");//获得sqlSession工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);//获得sqlSession对象SqlSession sqlSession = sqlSessionFactory.openSession();//执行sql语句List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.findAll\");//打印结果System.out.println(uselrList);//释放资源sqlSession.close(); 知识小结MyBatis开发步骤： ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml ⑥编写测试类 MyBatis的映射文件概述 MyBatis的增删改查操作MyBatis的插入数据操作1)编写UserMapper映射文件 12345&lt;mapper namespace=\"userMapper\"&gt; &lt;insert id=\"add\" parameterType=\"com.dhz.domain.User\"&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 2)编写插入实体User的代码 123456789InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int insert = sqlSession.insert(\"userMapper.add\", user);System.out.println(insert);//提交事务sqlSession.commit();sqlSession.close(); 3)插入操作注意问题 • 插入语句使用insert标签 • 在映射文件中使用parameterType属性指定要插入的数据类型 •Sql语句中使用#{实体属性名}方式引用实体中的属性值 •插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象); •插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() MyBatis的修改数据操作1)编写UserMapper映射文件 12345&lt;mapper namespace=\"userMapper\"&gt; &lt;update id=\"update\" parameterType=\"com.itheima.domain.User\"&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 2)编写修改实体User的代码 1234567InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int update = sqlSession.update(\"userMapper.update\", user);System.out.println(update);sqlSession.commit();sqlSession.close(); 3)修改操作注意问题 • 修改语句使用update标签 • 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); MyBatis的删除数据操作1)编写UserMapper映射文件 12345&lt;mapper namespace=\"userMapper\"&gt; &lt;delete id=\"delete\" parameterType=\"java.lang.Integer\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 2)编写删除数据的代码 1234567InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int delete = sqlSession.delete(\"userMapper.delete\",3);System.out.println(delete);sqlSession.commit();sqlSession.close(); 3)删除操作注意问题 • 删除语句使用delete标签 •Sql语句中使用#{任意字符串}方式引用传递的单个参数 •删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); 知识小结1234567891011121314151617增删改查映射配置与API：查询数据： List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.findAll\"); &lt;select id=\"findAll\" resultType=\"com.itheima.domain.User\"&gt; select * from User &lt;/select&gt;添加数据： sqlSession.insert(\"userMapper.add\", user); &lt;insert id=\"add\" parameterType=\"com.itheima.domain.User\"&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;修改数据： sqlSession.update(\"userMapper.update\", user); &lt;update id=\"update\" parameterType=\"com.itheima.domain.User\"&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;删除数据：sqlSession.delete(\"userMapper.delete\",3); &lt;delete id=\"delete\" parameterType=\"java.lang.Integer\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; MyBatis核心配置文件概述MyBatis核心配置文件层级关系 MyBatis常用配置解析1)environments标签 数据库环境的配置，支持多环境配置 其中，事务管理器（transactionManager）类型有两种： •JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 •MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： •UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 •POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 •JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 2)mapper标签 该标签的作用是加载映射的，加载方式有如下几种： •使用相对于类路径的资源引用，例如： •使用完全限定资源定位符（URL），例如： •使用映射器接口实现类的完全限定类名，例如： •将包内的映射器接口实现全部注册为映射器，例如： 3)Properties标签 实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件 4)typeAliases标签（在SqlMapConfig.xml里，注意顺序） 类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下 配置typeAliases，为com.itheima.domain.User定义别名为user 上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名 知识小结核心配置文件常用配置： properties标签：该标签可以加载外部的properties文件 1&lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt; typeAliases标签：设置类型别名 1&lt;typeAlias type=\"com.itheima.domain.User\" alias=\"user\"&gt;&lt;/typeAlias&gt; mappers标签：加载映射配置 1&lt;mapper resource=\"com/itheima/mapper/UserMapping.xml\"&gt;&lt;/mapper&gt; environments标签：数据源环境配置标签 MyBatis相应APISqlSession工厂构建器SqlSessionFactoryBuilder常用API：SqlSessionFactory build(InputStream inputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 1234String resource = \"org/mybatis/builder/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); 其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。 SqlSession工厂对象SqlSessionFactorySqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个： SqlSession会话对象SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有： 12345&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter) 操作事务的方法主要有： 12void commit() void rollback()","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://donghuangzhong.github.io/tags/Mybatis/"}]},{"title":"springmvc_快速操作","slug":"springmvc-快速操作","date":"2021-02-21T00:47:24.000Z","updated":"2021-03-05T01:40:30.976Z","comments":true,"path":"2021/02/21/springmvc-快速操作/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/21/springmvc-%E5%BF%AB%E9%80%9F%E6%93%8D%E4%BD%9C/","excerpt":"快速搭建springmvc环境","text":"快速搭建springmvc环境 快速搭建环境创建maven项目选中webapp,修改web.xml maven-archetype-webapp创建web.xml默认不支持EL 修改web.xml如下 123&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot; id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;3.0&quot;&gt;...&lt;&#x2F;web-app&gt; 新建各种包和配置文件新建包controller、service、dao、domain、utils 新建配置文件(resources下)applicationContext.xml、spring-mvc.xml、jdbc.properties、log4j.properties applicationContext.xml 1234567891011121314151617181920212223&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!--1、加载jdbc.properties--&gt; &lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt; &lt;!--2、配置数据源对象--&gt; &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--3、配置JdbcTemplate对象--&gt; &lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;context:component-scan base-package&#x3D;&quot;com.dhz&quot;&gt;&lt;&#x2F;context:component-scan&gt;&lt;&#x2F;beans&gt; spring-mvc.xml 12345678910111213141516171819202122&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!--1、mvc注解驱动--&gt; &lt;mvc:annotation-driven&#x2F;&gt; &lt;!--2、配置视图解析器--&gt; &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;pages&#x2F;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--3、静态资源权限开放--&gt; &lt;mvc:default-servlet-handler&#x2F;&gt; &lt;!--4、组件扫描 扫描Controller--&gt; &lt;context:component-scan base-package&#x3D;&quot;com.dhz.controller&quot;&#x2F;&gt;&lt;&#x2F;beans&gt; jdbc.properties 1234jdbc.driver&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testjdbc.username&#x3D;rootjdbc.password&#x3D;root log4j.properties 123456789101112131415### direct log messages to stdout ###log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target&#x3D;System.outlog4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file&#x3D;org.apache.log4j.FileAppenderlog4j.appender.file.File&#x3D;c:&#x2F;mylog.loglog4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; ###log4j.rootLogger&#x3D;info, stdout 导入需要坐标(pom.xml)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.32&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;&#x2F;groupId&gt; &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt; &lt;version&gt;0.9.1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.10&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;3.0.1&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2.1&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-logging&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt; &lt;version&gt;1.7.7&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2.17&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; web集成spring和springmvc(web.xml)1234567891011121314151617181920212223&lt;!--全局的初始化参数--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;context-param&gt; &lt;!--Spring的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt; &lt;&#x2F;listener&gt; &lt;!--SpringMVC的前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;2&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://donghuangzhong.github.io/tags/springmvc/"}]},{"title":"SpringMVC的文件上传","slug":"SpringMVC的文件上传","date":"2021-02-20T05:19:05.000Z","updated":"2021-03-04T03:05:18.861Z","comments":true,"path":"2021/02/20/SpringMVC的文件上传/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/20/SpringMVC%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"摘要","text":"摘要 SpringMVC的文件上传客户端表单实现(应用)文件上传客户端表单需要满足： 表单项type=“file” 表单的提交方式是post 表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data” 12345&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/quick22\" method=\"post\" enctype=\"multipart/form-data\"&gt; 名称&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; 文件1&lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; 文件上传的原理(理解) 单文件上传的代码实现1(应用)添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 配置多媒体解析器 12345&lt;!--配置文件上传解析器--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt; &lt;property name=\"maxUploadSize\" value=\"500000\"/&gt; &lt;/bean&gt; 后台程序 123456789@RequestMapping(\"/upload1\")@ResponseBodypublic String upload1(String username, MultipartFile uploadFile) throws IOException &#123; System.out.println(username); System.out.println(uploadFile); String filename = uploadFile.getOriginalFilename(); uploadFile.transferTo(new File(\"E:/upload/\"+filename)); return username+\"\\n\"+uploadFile.toString();&#125; 多文件上传的代码实现(应用)多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可 123456&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/upload2\" method=\"post\" enctype=\"multipart/form-data\"&gt; 名称&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; 文件1&lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;br/&gt; 文件2&lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 1234567891011@RequestMapping(\"/upload2\")@ResponseBodypublic String upload2(String username, MultipartFile[] uploadFile) throws IOException &#123; System.out.println(username); System.out.println(uploadFile); for (MultipartFile file : uploadFile) &#123; String filename = file.getOriginalFilename(); file.transferTo(new File(\"E:/upload/\"+filename)); &#125; return username+\"\\n\"+uploadFile.toString();&#125; 知识要点(理解，记忆) SpringMVC的拦截器拦截器的作用(理解)Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（InterceptorChain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。 interceptor和filter区别(理解，记忆)关于interceptor和filter的区别，如图所示： 快速入门(应用)自定义拦截器很简单，只有如下三步： ①创建拦截器类实现HandlerInterceptor接口 ②配置拦截器 ③测试拦截器的拦截效果 编写拦截器： 1234567891011121314151617181920public class MyInterceptor1 implements HandlerInterceptor &#123; //在目标方法执行之前 执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"preHandle.....\"); return \"yes\".equals(request.getParameter(\"status\")); &#125; //在目标方法执行之后 视图对象返回之前执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"postHandle....\"); &#125; //在流程都执行完毕后 执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"afterCompletion...\"); &#125;&#125; 配置：在SpringMVC的配置文件中配置 1234567&lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.dhz.interceptor.MyInterceptor1\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 编写测试程序测试： 编写Controller,发请求到controller,跳转页面 12345@RequestMapping(value = \"/save\",method = RequestMethod.GET)public String save()&#123; System.out.println(\"controller save ...\"); return \"save\";&#125; 页面 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;save ........&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 快速入门详解(应用)拦截器在预处理后什么情况下会执行目标资源，什么情况下不执行目标资源，以及在有多个拦截器的情况下拦截器的执行顺序是什么? 再编写一个拦截器2， 1234567891011121314151617public class MyInterceptor2 implements HandlerInterceptor &#123; //在目标方法执行之前 执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123; System.out.println(\"preHandle22222.....\"); return true; &#125; //在目标方法执行之后 视图对象返回之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; System.out.println(\"postHandle2222...\"); &#125; //在流程都执行完毕后 执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; System.out.println(\"afterCompletion2222....\"); &#125;&#125; 配置拦截器2 12345678910111213&lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.itheima.interceptor.MyInterceptor2\"/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.itheima.interceptor.MyInterceptor1\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 结论： 当拦截器的preHandle方法返回true则会执行目标资源，如果返回false则不执行目标资源 多个拦截器情况下，配置在前的先执行，配置在后的后执行 拦截器中的方法执行顺序是：preHandler——-目标资源—-postHandle—- afterCompletion 知识小结(记忆)拦截器中的方法说明如下 06-SpringMVC拦截器-用户登录权限控制分析(理解)在day06-Spring练习案例的基础之上：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作 需求图： 07-SpringMVC拦截器-用户登录权限控制代码实现1(应用)判断用户是否登录 本质：判断session中有没有user，如果没有登陆则先去登陆，如果已经登陆则直接放行访问目标资源 先编写拦截器如下： 1234567891011121314public class PrivilegeInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException &#123; //逻辑：判断用户是否登录 本质：判断session中有没有user HttpSession session = request.getSession(); User user = (User) session.getAttribute(\"user\"); if(user==null)&#123; //没有登录 response.sendRedirect(request.getContextPath()+\"/login.jsp\"); return false; &#125; //放行 访问目标资源 return true; &#125;&#125; 然后配置该拦截器：找到项目案例的spring-mvc.xml，添加如下配置： 12345678&lt;!--配置权限拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.itheima.interceptor.PrivilegeInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 08-SpringMVC拦截器-用户登录权限控制代码实现2(应用)在登陆页面输入用户名密码，点击登陆，通过用户名密码进行查询，如果登陆成功，则将用户信息实体存入session，然后跳转到首页，如果登陆失败则继续回到登陆页面 在UserController中编写登陆逻辑 12345678910@RequestMapping(\"/login\") public String login(String username,String password,HttpSession session)&#123; User user = userService.login(username,password); if(user!=null)&#123; //登录成功 将user存储到session session.setAttribute(\"user\",user); return \"redirect:/index.jsp\"; &#125; return \"redirect:/login.jsp\"; &#125; service层代码如下： 12345//service层public User login(String username, String password) &#123; User user = userDao.findByUsernameAndPassword(username,password); return user;&#125; dao层代码如下： 12345//dao层 public User findByUsernameAndPassword(String username, String password) throws EmptyResultDataAccessException&#123; User user = jdbcTemplate.queryForObject(\"select * from sys_user where username=? and password=?\", new BeanPropertyRowMapper&lt;User&gt;(User.class), username, password); return user; &#125; 此时仍然登陆不上，因为我们需要将登陆请求url让拦截器放行,添加资源排除的配置 12345678910&lt;!--配置权限拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--配置哪些资源排除拦截操作--&gt; &lt;mvc:exclude-mapping path=\"/user/login\"/&gt; &lt;bean class=\"com.itheima.interceptor.PrivilegeInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 09-SpringMVC拦截器-用户登录权限控制代码实现3(应用)JdbcTemplate.queryForObject对象如果查询不到数据会抛异常，导致程序无法达到预期效果，如何来解决该问题？ 在业务层处理来自dao层的异常，如果出现异常service层返回null,而不是将异常抛给controller 因此改造登陆的业务层代码,添加异常的控制 12345678public User login(String username, String password) &#123; try &#123; User user = userDao.findByUsernameAndPassword(username,password); return user; &#125;catch (EmptyResultDataAccessException e)&#123; return null; &#125; &#125; SpringMVC异常处理机制异常处理的思路系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。 系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图： 异常处理两种方式① 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver ② 实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器 简单异常处理器SimpleMappingExceptionResolverSpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置 12345678910&lt;!--配置简单映射异常处理器--&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;property name=\"defaultErrorView\" value=\"error\"/&gt; &lt;!--默认异常，服从前后缀(jsp/error.jsp)--&gt; &lt;property name=\"exceptionMappings\"&gt; &lt;map&gt; &lt;entry key=\"com.dhz.exception.MyExcepton\" value=\"error1\"/&gt; &lt;!--自定义异常--&gt; &lt;entry key=\"java.lang.ArithmeticException\" value=\"error2\"/&gt; &lt;!--除数为0异常--&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 测试 123456789101112131415161718@RequestMapping(&quot;&#x2F;yichang&#x2F;&#123;id&#125;&quot;)@ResponseBodypublic void yichang(@PathVariable(value &#x3D; &quot;id&quot;) int id) throws MyExcepton &#123; System.out.println(&quot;---------------------&quot;); if (id&#x3D;&#x3D;0)&#123; System.out.println(&quot;0.....&quot;); int j&#x3D;1&#x2F;0; &#125; else if (id&#x3D;&#x3D;1)&#123; System.out.println(&quot;1.....&quot;); int k&#x3D;Integer.parseInt(&quot;张三&quot;); &#125; else &#123; System.out.println(&quot;2.....&quot;); throw new MyExcepton(); &#125;&#125; 自定义异常处理步骤①创建异常处理器类实现HandlerExceptionResolver 123456789101112131415161718public class MyExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; ModelAndView modelAndView = new ModelAndView(); if (ex instanceof MyExcepton) &#123; modelAndView.addObject(\"error_info\",\"自定义异常\"); &#125; else if (ex instanceof ArithmeticException)&#123; modelAndView.addObject(\"error_info\",\"除数为0异常\"); &#125; else &#123; modelAndView.addObject(\"error_info\",\"通用异常\"); &#125; modelAndView.setViewName(\"error_msg\"); return modelAndView; &#125;&#125; ②配置异常处理器 1&lt;bean class=\"com.dhz.resovler.MyExceptionResolver\"/&gt; ③编写异常页面 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;error_info&#125;&lt;/body&gt;&lt;/html&gt; ④测试异常跳转 123456789101112131415161718@RequestMapping(\"/yichang/&#123;id&#125;\")@ResponseBodypublic void yichang(@PathVariable(value = \"id\") int id) throws MyExcepton &#123; System.out.println(\"---------------------\"); if (id==0)&#123; System.out.println(\"0.....\"); int j=1/0; &#125; else if (id==1)&#123; System.out.println(\"1.....\"); int k=Integer.parseInt(\"张三\"); &#125; else &#123; System.out.println(\"2.....\"); throw new MyExcepton(); &#125;&#125; 1.5 知识要点异常处理方式 配置简单异常处理器SimpleMappingExceptionResolver 自定义异常处理器自定义异常处理步骤 ①创建异常处理器类实现HandlerExceptionResolver ②配置异常处理器 ③编写异常页面 ④测试异常跳转","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"SpringMVC的请求和响应","slug":"SpringMVC的请求和响应","date":"2021-02-18T10:26:01.000Z","updated":"2021-03-05T01:40:05.761Z","comments":true,"path":"2021/02/18/SpringMVC的请求和响应/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/18/SpringMVC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/","excerpt":"springmvc的请求响应 静态资源引用开启 全局乱码过滤器 自定义类型转换器","text":"springmvc的请求响应 静态资源引用开启 全局乱码过滤器 自定义类型转换器 SpringMVC的请求和响应SpringMVC的数据响应数据响应方式(理解) 页面跳转 直接返回字符串 通过ModelAndView对象返回 回写数据 直接返回字符串 返回对象或集合 页面跳转返回字符串形式（应用） 返回ModelAndView形式1(应用)在Controller中方法返回ModelAndView对象，并且设置视图名称 1234567891011121314@RequestMapping(\"/MAV1\") public ModelAndView ModelAndView1()&#123; /* Model:模型 作用封装数据 View：视图 作用展示数据 */ System.out.println(\"ModelAndView1 ...\"); ModelAndView modelAndView=new ModelAndView(); //设置模型数据,可以直接在jsp中用$&#123;username&#125; modelAndView.addObject(\"username\",\"DongHuangZhong\"); //设置视图名称 modelAndView.setViewName(\"mav1\");//也受前缀后缀约束,文件在/jsp/mav1.jsp return modelAndView; &#125; mav1.jsp 12345678910&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;h1&gt;mav1&lt;&#x2F;h1&gt; username:$&#123;username&#125;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 返回ModelAndView形式2(应用)n在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面 1234567@RequestMapping(\"/MAV2\") public ModelAndView ModelAndView2(ModelAndView modelAndView)&#123; System.out.println(\"ModelAndView1 ...\"); modelAndView.addObject(\"username\",\"ManJi\"); modelAndView.setViewName(\"mav1\");//也受前缀后缀约束 return modelAndView; &#125; 返回ModelAndView3(应用)在Controller方法的形参上可以直接使用原生的HttpServeltRequest对象，只需声明即可 123456@RequestMapping(\"/MAV3\") public String ModelAndView2(HttpServletRequest request)&#123; System.out.println(\"ModelAndView3 ...\"); request.setAttribute(\"username\",\"MiLin\"); return \"mav1\"; &#125; 回写数据直接回写字符串(应用)通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”) 回写数据，此时不需要视图跳转，业务方法返回值为void 将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回 123456789101112@RequestMapping(\"/re_str2\") @ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应 public String re_str2()&#123; System.out.println(\"re_str2 ...\"); return \"hello restr2\"; &#125;@RequestMapping(\"/re_str1\") public void re_str1(HttpServletResponse response) throws IOException &#123; System.out.println(\"re_str1 ...\"); response.getWriter().write(\"response return ....\"); &#125; 直接回写json格式字符串(应用)123456@RequestMapping(\"/re_str_json1\") @ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应 public String re_str_json1()&#123; System.out.println(\"re_str_json1 ...\"); return \"&#123;\\\"username\\\":\\\"zhangsan\\\",\\\"age\\\":18&#125;\"; &#125; 手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换,通过jackson转换json格式字符串，回写字符串 添加依赖jar包(不要低于2.6版本) 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 用ObjectMapper得到json 123456789@RequestMapping(&quot;&#x2F;re_str_json2&quot;)@ResponseBody &#x2F;&#x2F;告知SpringMVC框架 不进行视图跳转 直接进行数据响应public String re_str_json2() throws JsonProcessingException &#123; System.out.println(&quot;re_str_json2 ...&quot;); User user&#x3D;new User(&quot;lisi&quot;,22); ObjectMapper mapper &#x3D; new ObjectMapper(); String user_json &#x3D; mapper.writeValueAsString(user); return user_json;&#125; 返回对象或集合(应用)通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置： 1234567&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 1234567@RequestMapping(\"/re_obj_json1\") @ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应 public User re_obj_json1() throws JsonProcessingException &#123; System.out.println(\"re_obj_json1 ...\"); User user=new User(\"lisi\",22); return user; &#125; 09-SpringMVC的数据响应-回写数据-返回对象或集合2(应用)在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置(返回对象自动变成json) 1&lt;mvc:annotation-driven/&gt; 在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 使用&lt;mvc:annotation-driven /&gt;自动加载 RequestMappingHandlerMapping（处理映射器）和 RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用 &lt;mvc:annotation-driven /&gt;替代注解处理器和适配器的配置。 同时使用&lt;mvc:annotation-driven /&gt; 默认底层就会集成jackson进行对象或集合的json格式字符串的转换 10-SpringMVC的数据响应-知识要点小结(理解，记忆)1） 页面跳转 直接返回字符串 通过ModelAndView对象返回 2） 回写数据 直接返回字符串 HttpServletResponse 对象直接写回数据，HttpServletRequest对象带回数据，Model对象带回数据或者@ResponseBody将字符串数据写回 返回对象或集合 @ResponseBody+&lt;mvc:annotation-driven/&gt; SpringMVC的请求请求参数类型(理解)客户端请求参数的格式是：name=value&amp;name=value…… 服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 获得基本类型参数(应用)Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换； 自动的类型转换是指从String向其他类型的转换 http://localhost:8080/user/get_base_para?name=zzz&amp;age=18 12345@RequestMapping(\"/get_base_para\")@ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应public String get_base_para(String name, int age)&#123; return \"paras=&#123;name=\"+name+\";age=\"+age+\"&#125;\";&#125; 获得POJO类型参数(应用)Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。 123456789101112131415161718192021222324252627282930313233343536373839package com.dhz.domain;public class User &#123; private String username; private int age; public User() &#123; &#125; public User(String username, int age) &#123; this.username = username; this.age = age; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"username='\" + username + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; http://localhost:8080/user/get_POPJ_para?username=popj&amp;age=18 123456@RequestMapping(\"/get_POPJ_para\")@ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应public User get_POPJ_para(User user)&#123; System.out.println(user); return user;&#125; 获得数组类型参数(应用)Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。 http://localhost:8080/user/get_arrays_para?name=zhangsan&amp;name=lisi 1234567@RequestMapping(\"/get_arrays_para\")@ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应public List&lt;String&gt; get_arrays_para(String[] name)&#123; List&lt;String&gt; names = Arrays.asList(name); System.out.println(names); return names;&#125; 获得User集合类型参数1(应用)获得集合参数时，要将集合参数包装到一个POJO中才可以。 12345678&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/get_userList\" method=\"post\"&gt; &lt;%--表明是第一个User对象的username age--%&gt; &lt;input type=\"text\" name=\"userList[0].username\"&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"userList[0].age\"&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"userList[1].username\"&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"userList[1].age\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; 1234567891011121314151617181920212223package com.dhz.domain;import java.util.List;public class VO &#123; private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() &#123; return userList; &#125; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; @Override public String toString() &#123; return \"VO&#123;\" + \"userList=\" + userList + '&#125;'; &#125;&#125; 注：public List get_userList2(List userList) 不行 123456@RequestMapping(\"/get_userList\")@ResponseBodypublic VO get_userList(VO vo) throws IOException &#123; System.out.println(vo); return vo;&#125; 获得集合类型参数2(应用)当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装 1234567891011&lt;script src=\"$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.js\"&gt;&lt;/script&gt;&lt;script&gt; var userList = new Array(); userList.push(&#123;username:\"zhangsan\",age:18&#125;); userList.push(&#123;username:\"lisi\",age:28&#125;); $.ajax(&#123; type:\"POST\", url:\"$&#123;pageContext.request.contextPath&#125;/user/get_ajax_userlist\", data:JSON.stringify(userList), contentType:\"application/json;charset=utf-8\" &#125;); 注：需要按照下面的步骤开启静态资源的引用 12345@RequestMapping(\"/get_ajax_userlist\")@ResponseBodypublic void get_ajax_userlist(@RequestBody List&lt;User&gt; userList)&#123; System.out.println(userList);&#125; 静态资源引用的开启(应用)当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源： •在spring-mvc.xml配置文件中指定放行的资源 ​ &lt;mvc:resources mapping=&quot;/js/**&quot;location=&quot;/js/&quot;/&gt; •使用&lt;mvc:default-servlet-handler/&gt;标签 12345&lt;!--开发资源的访问--&gt; &lt;!--&lt;mvc:resources mapping=\"/js/**\" location=\"/js/\"/&gt; &lt;mvc:resources mapping=\"/img/**\" location=\"/img/\"/&gt;--&gt; &lt;mvc:default-servlet-handler/&gt; 配置全局乱码过滤器(应用)当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。在web.xml中 12345678910111213&lt;!--配置全局过滤的filter--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 参数绑定注解@RequestParam(应用)当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定 http://localhost:8080/user/get_para_anno?xingming=lisi 123456@RequestMapping(\"/get_para_anno\")@ResponseBodypublic String get_para_anno(@RequestParam(value = \"xingming\",required = false,defaultValue = \"null\") String name)&#123; System.out.println(name); return name;&#125; Restful风格的参数的获取(应用)Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。 Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下： GET：用于获取资源 POST：用于新建资源 PUT：用于更新资源 DELETE：用于删除资源 例如： /user/1 GET ： 得到 id = 1 的 user /user/1 DELETE： 删除 id = 1 的 user /user/1 PUT： 更新 id = 1 的 user /user POST： 新增 user 上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。 http://localhost:8080/user/request_restful/zhansgan 123456@RequestMapping(\"/request_restful/&#123;name&#125;\")@ResponseBodypublic String request_restful(@PathVariable(value = \"name\") String name)&#123; System.out.println(name); return name;&#125; 自定义类型转换器(应用)SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。默认格式:2020/03/05 编写DateConverter类继承Converter，重写convert方法 12345678910111213public class DateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String dateStr) &#123; SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date &#x3D; null; try &#123; date &#x3D; simpleDateFormat.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125; 声明转换器 1234567&lt;bean id&#x3D;&quot;conversionService&quot; class&#x3D;&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;converters&quot;&gt; &lt;list&gt; &lt;bean class&#x3D;&quot;com.dhz.converter.DateConverter&quot;&#x2F;&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt; 配置到mvc.xml 1&lt;mvc:annotation-driven conversion-service&#x3D;&quot;conversionService&quot;&#x2F;&gt; 测试 123456@RequestMapping(&quot;&#x2F;date&quot;)@ResponseBodypublic String date(Date date)&#123; System.out.println(date); return date.toString();&#125; 获得Servlet相关API(应用)SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下： HttpServletRequest HttpServletResponse HttpSession 1234567@RequestMapping(value=\"/quick19\") @ResponseBody public void save19(HttpServletRequest request, HttpServletResponse response, HttpSession session) throws IOException &#123; System.out.println(request); System.out.println(response); System.out.println(session); &#125; 获得请求头信息(应用)使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name) @RequestHeader注解的属性如下： value：请求头的名称 required：是否必须携带此请求头 12345@RequestMapping(value=\"/quick20\") @ResponseBody public void save20(@RequestHeader(value = \"User-Agent\",required = false) String user_agent) throws IOException &#123; System.out.println(user_agent); &#125; 使用@CookieValue可以获得指定Cookie的值 @CookieValue注解的属性如下： value：指定cookie的名称 required：是否必须携带此cookie 12345@RequestMapping(value=\"/quick21\") @ResponseBody public void save21(@CookieValue(value = \"JSESSIONID\") String jsessionId) throws IOException &#123; System.out.println(jsessionId); &#125;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"}]},{"title":"Spring与Web环境集成","slug":"Spring与Web环境集成","date":"2021-02-18T01:53:16.000Z","updated":"2021-03-05T01:35:47.514Z","comments":true,"path":"2021/02/18/Spring与Web环境集成/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/18/Spring%E4%B8%8EWeb%E7%8E%AF%E5%A2%83%E9%9B%86%E6%88%90/","excerpt":"spring与web环境集成 springmvc简介 spring的执行过程 spring组件解析","text":"spring与web环境集成 springmvc简介 spring的执行过程 spring组件解析 Spring与Web环境集成ApplicationContext应用上下文获取方式弊端应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。 在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。 所以我们需要做的只有两件事： ①在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标） ②使用WebApplicationContextUtils获得应用上下文对象ApplicationContext 获取步骤导入Spring集成web的坐标12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置ContextLoaderListener监听器1234567891011&lt;!--全局参数--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--Spring的监听器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; 通过工具获得应用上下文对象12ApplicationContext app = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext()); UserService userService = app.getBean(UserService.class); SpringMVC的简介SpringMVC概述SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。 SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。 SpringMVC快速入门需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。 开发步骤 ①导入SpringMVC相关坐标 ②配置SpringMVC核心控制器DispathcerServlet ③创建Controller类和视图页面 ④使用注解配置Controller类中业务方法的映射地址 ⑤配置SpringMVC核心文件 spring-mvc.xml ⑥客户端发起请求测试 代码实现 ①导入Spring和SpringMVC的坐标、导入Servlet和Jsp的坐标 123456789101112131415161718192021222324 &lt;!--Spring坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringMVC坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--Servlet坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--Jsp坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; ②创建Controller和业务方法 return “save.jsp” ：从当前请求路径下 return “/save.jsp” 从当前web容器的的路径下，推荐写法 123456public class UserController &#123; public String save()&#123; System.out.println(\"controller save ...\"); return \"save.jsp\"; &#125;&#125; ③配置注解 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;&#x2F;save&quot;) public String save()&#123; System.out.println(&quot;controller save ...&quot;); return &quot;save.jsp&quot;; &#125;&#125; ④创建视图页面save.jsp 12345&lt;html&gt;&lt;body&gt; &lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; ⑤创建spring-mvc.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.dhz.controller\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; ⑥在web.xml配置SpringMVC的核心控制器 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt; ⑦访问测试地址 1http://localhost:8080/save SpringMVC的组件解析SpringMVC的执行流程 ①用户发送请求至前端控制器DispatcherServlet。 ②DispatcherServlet收到请求调用HandlerMapping处理器映射器。 ③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 ④DispatcherServlet调用HandlerAdapter处理器适配器。 ⑤HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 ⑥Controller执行完成返回ModelAndView。 ⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 ⑧DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ⑨ViewReslover解析后返回具体View。 ⑩DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。 SpringMVC组件解析 前端控制器：DispatcherServlet ​ 用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器：HandlerMapping ​ HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器适配器：HandlerAdapter ​ 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 处理器：Handler ​ 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。 视图解析器：View Resolver ​ View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 视图：View ​ SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面 SpringMVC注解解析@RequestMapping作用：用于建立请求 URL 和处理请求方法之间的对应关系 位置： ​ 类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录 ​ 方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径 属性： ​ value：用于指定请求的URL。它和path属性的作用是一样的 ​ method：用于指定请求的方式 ​ params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样 例如： ​ params = {“accountName”}，表示请求参数必须有accountName ​ params = {“moeny!100”}，表示请求参数中money不能是100 1234示例： @RequestMapping(value &#x3D; &quot;&#x2F;save&quot;,method &#x3D; RequestMethod.GET) public String save()&#123; return &quot;save.jsp&quot;; &#125; 1.mvc命名空间引入 123456命名空间：xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"约束地址：http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd 2.组件扫描 SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scan base-package=“com.itheima.controller”/&gt;进行组件扫描。 扫描可以如下配置过滤(或包含)指定的注解，一般只扫描controller 1234&lt;context:component-scan base-package&#x3D;&quot;com.dhz.controller&quot;&gt; &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt; &lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt; &lt;&#x2F;context:component-scan&gt; SpringMVC的XML配置解析SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties(下方external library-&gt;spring_webmvc)，该文件中配置了默认的视图解析器，如下： 1org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver 翻看该解析器源码，可以看到该解析器的默认设置，如下： 1234REDIRECT_URL_PREFIX = \"redirect:\" --重定向前缀FORWARD_URL_PREFIX = \"forward:\" --转发前缀（默认值）在return \"[forword:]/save.jsp\";prefix = \"\"; --视图名称前缀suffix = \"\"; --视图名称后缀 视图解析器 我们可以通过属性注入的方式修改视图的的前后缀，return “save”===访问/jsp/save.jsp 12345&lt;!--配置内部资源视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/jsp/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; 3.5 知识要点SpringMVC的相关组件 前端控制器：DispatcherServlet 处理器映射器：HandlerMapping 处理器适配器：HandlerAdapter 处理器：Handler 视图解析器：View Resolver 视图：View SpringMVC的注解和配置 请求映射注解：@RequestMapping 视图解析器配置： REDIRECT_URL_PREFIX = “redirect:” FORWARD_URL_PREFIX = “forward:” prefix = “”; suffix = “”;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring+web","slug":"spring-web","permalink":"https://donghuangzhong.github.io/tags/spring-web/"}]},{"title":"maven","slug":"maven","date":"2021-02-17T10:33:53.000Z","updated":"2021-03-04T09:00:51.273Z","comments":true,"path":"2021/02/17/maven/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/17/maven/","excerpt":"maven基本jar包、插件、配置","text":"maven基本jar包、插件、配置 安装配置相关Idea卡在Resolving Maven dependencies 更换阿里云镜像 123456789101112131415161718192021&#x2F;&#x2F;修改apache-maven-3.5.2-bin\\apache-maven-3.5.2\\conf\\settings.xml&#x2F;&#x2F;在镜像位置增加如下内容 &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;&#x2F;id&gt; &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;&#x2F;name&gt; &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&lt;&#x2F;url&gt; &lt;&#x2F;mirror&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;&#x2F;id&gt; &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt; &lt;name&gt;阿里云谷歌仓库&lt;&#x2F;name&gt; &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;google&lt;&#x2F;url&gt; &lt;&#x2F;mirror&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;&#x2F;id&gt; &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt; &lt;name&gt;阿里云阿帕奇仓库&lt;&#x2F;name&gt; &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;apache-snapshots&lt;&#x2F;url&gt; &lt;&#x2F;mirror&gt; 修改maven设置 1修改maven Importing的jvm参数, 默认为700多, 直接修改成 -Xms1024m -Xmx2048m pom.xml相关jar包servlet123456789101112131415&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;7.0.47&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 插件tomcat712345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;&#x2F;port&gt; &lt;path&gt;&#x2F;&lt;&#x2F;path&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"maven","slug":"java/maven","permalink":"https://donghuangzhong.github.io/categories/java/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://donghuangzhong.github.io/tags/maven/"}]},{"title":"spring_problem","slug":"spring-problem","date":"2021-02-17T09:49:52.000Z","updated":"2021-05-20T07:58:12.491Z","comments":true,"path":"2021/02/17/spring-problem/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/17/spring-problem/","excerpt":"摘要","text":"摘要 常见问题类存在，但报找不到的错误 原因：target-&gt;classes目录下没有该文件 解决方法：手动进行maven编译 jsp无法解析EL表达式(${username}) 原因 Application server in question doesn’t support JSP 2.0. （应用服务器不支持JSP2.0) The web.xml is not declared as Servlet 2.4 or higher. (web.xml中servlet版本没有声明在2.4以上） The @page is configured with isELIgnored=true. （页面上配置了&lt;%@ page isELIgnored=”true” %&gt; ) The web.xml is configured with &lt;el-ignored&gt;true&lt;/el-ignored&gt; in &lt;jsp-config&gt;. (web.xml中显式地配置了忽略EL表达式） maven-archetype-webapp创建web.xml默认不支持EL 解决方法：修改web.xml如下，重启tomcat 123&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot; id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;3.0&quot;&gt;...&lt;&#x2F;web-app&gt; spring mvc导入jackson报错 原因：mvc为4.x。需要Jackson为2.6以上 解决方法：修改pom.xml中三个jackson jar包的版本为2.6以上即可 maven项目没有webapp文件夹 没有web.xml也可以部署到tomcat上 依次点击file -&gt; project structure-&gt;module,然后点右上角加号选择web 修改路径后点击o即可 Tomat Deployment 没有Artifact选择 依次点击file -&gt; project structure-&gt;Artifacts,然后点加号，选择如图后一直下一步即可","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"}]},{"title":"Spring JdbcTemplate&声明式事务","slug":"Spring-JdbcTemplate-声明式事务","date":"2021-02-17T00:39:55.000Z","updated":"2021-05-20T07:17:06.310Z","comments":true,"path":"2021/02/17/Spring-JdbcTemplate-声明式事务/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/17/Spring-JdbcTemplate-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/","excerpt":"JDBCTemplate声明式事务控制 基于xal 基于注解","text":"JDBCTemplate声明式事务控制 基于xal 基于注解 JdbcTemplate基本使用概述(了解)JdbcTemplate是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。例如：操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。 开发步骤(理解)①导入spring-jdbc和spring-tx坐标 ②创建数据库表和实体 ③创建JdbcTemplate对象 ④执行数据库操作 快速入门代码实现(应用) 导入spring-jdbc、spring-tx、数据库相关坐标 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.3.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.3.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 创建数据库表和实体 123456789101112131415161718192021222324252627282930package com.dhz.domain;public class Account &#123; private String name; private double money; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, money&#x3D;&quot; + money + &#39;&#125;&#39;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money &#x3D; money; &#125;&#125; 创建JdbcTemplate对象，执行数据库操作 123456789101112131415161718@Test //测试JdbcTemplate开发步骤 public void test1() throws PropertyVetoException &#123; //创建数据源对象 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUser(\"root\"); dataSource.setPassword(\"root\"); JdbcTemplate jdbcTemplate = new JdbcTemplate(); //设置数据源对象 知道数据库在哪 jdbcTemplate.setDataSource(dataSource); //执行操作 int row = jdbcTemplate.update(\"insert into account values(?,?)\", \"tom\", 5000); System.out.println(row); &#125; spring产生模板对象分析(理解)我们可以将JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring，在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中,然后通过Spring容器获得JdbcTemplate对象来执行操作。 spring产生模板对象代码实现(应用)配置如下： 123456789101112&lt;!--数据源对象--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///test\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--jdbc模板对象--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; 测试代码 12345678@Test //测试Spring产生jdbcTemplate对象 public void test2() throws PropertyVetoException &#123; ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class); int row = jdbcTemplate.update(\"insert into account values(?,?)\", \"lisi\", 5000); System.out.println(row); &#125; spring产生模板对象代码实现（抽取jdbc.properties）(应用)将数据库的连接信息抽取到外部配置文件中，和spring的配置文件分离开，有利于后期维护 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root 配置文件修改为: 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--加载jdbc.properties--&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt; &lt;!--数据源对象--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt; &lt;!--jdbc模板对象--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 声明式事务控制编程式事务控制相关对象PlatformTransactionManagerPlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。 注意： PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：Dao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager TransactionDefinitionTransactionDefinition 是事务的定义信息对象，里面有如下方法： 事务隔离级别设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE 事务传播行为 REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式运行，如果当前存在事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 是否只读：建议查询时设置为只读 TransactionStatusTransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。 基于 XML 的声明式事务控制什么是声明式事务控制Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。 声明式事务处理的作用 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便 注意：Spring 声明式事务控制底层就是AOP。 声明式事务控制的实现声明式事务控制明确事项： 谁是切点？ 谁是通知？ 配置切面？ ①引入tx命名空间 1234567891011121314&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; ②配置事务增强 1234567891011&lt;!--平台事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--事务增强配置--&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt;//对不同的方法采用不同的事务参数(name是方法名，之后一堆事务参数) &lt;/tx:attributes&gt;&lt;/tx:advice&gt; ③配置事务 AOP 织入 12345&lt;!--事务的aop增强--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"myPointcut\"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; ④测试事务控制转账业务代码 123456@Overridepublic void transfer(String outMan, String inMan, double money) &#123; accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money);&#125; 切点方法的事务参数的配置123456&lt;!--事务增强配置--&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 其中，tx:method 代表切点方法的事务参数的配置，例如： 1&lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" timeout=\"-1\" read-only=\"false\"/&gt; name：切点方法名称 isolation:事务的隔离级别 propogation：事务的传播行为 timeout：超时时间 read-only：是否只读 3 基于注解的声明式事务控制3.1 使用注解配置声明式事务控制 正常注入+方法(或者类)上加@Transactional 编写 AccoutDao 1234567891011@Repository(\"accountDao\")public class AccountDaoImpl implements AccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void out(String outMan, double money) &#123; jdbcTemplate.update(\"update account set money=money-? where name=?\",money,outMan); &#125; public void in(String inMan, double money) &#123; jdbcTemplate.update(\"update account set money=money+? where name=?\",money,inMan); &#125;&#125; 编写 AccoutService 123456789101112@Service(\"accountService\")@Transactional //可以加在类上public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED) //也可以加在方法上,方法的优先级高 public void transfer(String outMan, String inMan, double money) &#123; accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money); &#125;&#125; 编写 applicationContext.xml 配置文件 12345&lt;!—之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt;&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=\"com.itheima\"/&gt;&lt;!--事务的注解驱动--&gt;&lt;tx:annotation-driven/&gt; 3.2 注解配置声明式事务控制解析①使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。 ②注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。 ③使用在方法上，不同的方法可以采用不同的事务参数配置。 ④Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt; 3.3 知识要点注解声明式事务控制的配置要点 平台事务管理器配置（xml方式） 事务通知的配置（@Transactional注解配置） 事务注解驱动的配置 tx:annotation-driven/","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"},{"name":"jdbctemplate","slug":"jdbctemplate","permalink":"https://donghuangzhong.github.io/tags/jdbctemplate/"}]},{"title":"Java_Spring","slug":"Java-Spring","date":"2021-02-14T07:51:11.000Z","updated":"2021-05-20T06:43:24.102Z","comments":true,"path":"2021/02/14/Java-Spring/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/14/Java-Spring/","excerpt":"spring入门环境快速搭建","text":"spring入门环境快速搭建 spring概述Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层 SpringMVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架 自动注入默认使用无参构造方法 spring入门spring无注解快速搭建 新建空的maven项目，在pom.xml中引入spring jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 新建测试的Bean 1234567891011public class TestBean &#123; public void run()&#123; System.out.println(&quot;TestBean Running...&quot;); &#125; public void init()&#123; System.out.println(&quot;init method ...&quot;); &#125; public void destroy()&#123; System.out.println(&quot;destroy method ...&quot;); &#125;&#125; resource目录下新建applicationCOntext.xml，配置bean 1234567&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;com.dhz.bean.TestBean&quot;&gt;&lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; 编写运行类测试 1234567public class Run &#123; public static void main(String[] args) &#123; ApplicationContext app&#x3D;new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); TestBean testBean&#x3D; (TestBean) app.getBean(&quot;testBean&quot;); testBean.run(); &#125;&#125; 配置文件详解 1234567891011121314151617181920212223242526public class Dog &#123; private String name; public Dog() &#123; &#125; public Dog(String name) &#123; this.name &#x3D; name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; void eat()&#123; System.out.println(name+&quot; is eatting...&quot;); &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Zoo &#123; private Dog dog; private int peopleNum; private List&lt;String&gt; peopleNames; private List&lt;Dog&gt; dogs; private Map&lt;String,Dog&gt; dogMap; private Properties properties; public void setDog(Dog dog) &#123; this.dog &#x3D; dog; &#125; public void setPeopleNum(int peopleNum) &#123; this.peopleNum &#x3D; peopleNum; &#125; public void setPeopleNames(List&lt;String&gt; peopleNames) &#123; this.peopleNames &#x3D; peopleNames; &#125; public void setDogs(List&lt;Dog&gt; dogs) &#123; this.dogs &#x3D; dogs; &#125; public void setDogMap(Map&lt;String, Dog&gt; dogMap) &#123; this.dogMap &#x3D; dogMap; &#125; public void setProperties(Properties properties) &#123; this.properties &#x3D; properties; &#125; @Override public String toString() &#123; return &quot;Zoo&#123;&quot; + &quot;dog&#x3D;&quot; + dog + &quot;, peopleNum&#x3D;&quot; + peopleNum + &quot;, peopleNames&#x3D;&quot; + peopleNames + &quot;, dogs&#x3D;&quot; + dogs + &quot;, dogMap&#x3D;&quot; + dogMap + &quot;, properties&#x3D;&quot; + properties + &#39;&#125;&#39;; &#125;&#125; 12345public class NoStaticDogFactory &#123; public Dog creatDog()&#123; return new Dog(&quot;非静态创建的狗&quot;); &#125;&#125; 12345public class StaticDogFactory &#123; public static Dog creatDog()&#123; return new Dog(&quot;静态创建的狗&quot;); &#125;&#125; dog_applicationContext.xml 1234567891011121314151617181920212223242526272829&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;!--默认用无参构造方法生成实例后用set设置参数--&gt; &lt;bean id&#x3D;&quot;dog1&quot; class&#x3D;&quot;com.dhz.bean.Dog&quot;&gt; &lt;!--String等基本数据类型用value--&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;泰迪&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;bean id&#x3D;&quot;dog2&quot; class&#x3D;&quot;com.dhz.bean.Dog&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;金毛&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--使用有参构造生成bean--&gt; &lt;bean id&#x3D;&quot;constructorDog&quot; class&#x3D;&quot;com.dhz.bean.Dog&quot;&gt; &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;有参构造的狗&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--通过静态方法生成bean--&gt; &lt;bean id&#x3D;&quot;staticDog&quot; class&#x3D;&quot;com.dhz.factory.StaticDogFactory&quot; factory-method&#x3D;&quot;creatDog&quot;&#x2F;&gt; &lt;!--通过非静态方法生成bean--&gt; &lt;bean id&#x3D;&quot;factoryBean&quot; class&#x3D;&quot;com.dhz.factory.NoStaticDogFactory&quot;&#x2F;&gt; &lt;bean id&#x3D;&quot;noStaticDog&quot; factory-bean&#x3D;&quot;factoryBean&quot; factory-method&#x3D;&quot;creatDog&quot;&#x2F;&gt;&lt;&#x2F;beans&gt; applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;com.dhz.bean.TestBean&quot;&gt;&lt;&#x2F;bean&gt; &lt;!--读取properties配置文件--&gt; &lt;context:property-placeholder location&#x3D;&quot;classpath:dog.properties&quot;&#x2F;&gt; &lt;bean id&#x3D;&quot;propertyDog&quot; class&#x3D;&quot;com.dhz.bean.Dog&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;$&#123;dogName&#125;&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--分模块配置中导入其他模块的配置--&gt; &lt;import resource&#x3D;&quot;dog_applicationContext.xml&quot;&#x2F;&gt; &lt;!--context命名空间下扫描注解配置--&gt; &lt;context:component-scan base-package&#x3D;&quot;com.dhz&quot;&#x2F;&gt;&lt;!-- 各种数据类型的注入--&gt; &lt;bean id&#x3D;&quot;zoo&quot; class&#x3D;&quot;com.dhz.bean.Zoo&quot;&gt; &lt;!--引用数据类型用ref注入--&gt; &lt;property name&#x3D;&quot;dog&quot; ref&#x3D;&quot;dog1&quot;&#x2F;&gt; &lt;!--基本数据类型用value--&gt; &lt;property name&#x3D;&quot;peopleNum&quot; value&#x3D;&quot;100&quot;&#x2F;&gt; &lt;!--List&lt;String&gt;的注入--&gt; &lt;property name&#x3D;&quot;peopleNames&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;&#x2F;value&gt; &lt;value&gt;李四&lt;&#x2F;value&gt; &lt;value&gt;Tom&lt;&#x2F;value&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt; &lt;!--List&lt;Dog&gt;的注入--&gt; &lt;property name&#x3D;&quot;dogs&quot;&gt; &lt;list&gt; &lt;ref bean&#x3D;&quot;dog1&quot;&#x2F;&gt; &lt;ref bean&#x3D;&quot;dog2&quot;&#x2F;&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt; &lt;!--Map&lt;String,Dog&gt;的注入--&gt; &lt;property name&#x3D;&quot;dogMap&quot;&gt; &lt;map&gt; &lt;entry key&#x3D;&quot;dog1&quot; value-ref&#x3D;&quot;dog1&quot;&#x2F;&gt; &lt;entry key&#x3D;&quot;dog2&quot; value-ref&#x3D;&quot;dog2&quot;&#x2F;&gt; &lt;&#x2F;map&gt; &lt;&#x2F;property&gt; &lt;!--Properties的注入--&gt; &lt;property name&#x3D;&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key&#x3D;&quot;key1&quot;&gt;value1&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;key2&quot;&gt;value2&lt;&#x2F;prop&gt; &lt;&#x2F;props&gt; &lt;&#x2F;property&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; dog.properties 1dogName&#x3D;dog_properties spring+注解 快速搭建 新建空的maven项目，在pom.xml中引入spring jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 新建测试的bean 1234567891011121314151617@Component(&quot;wang_cai&quot;)public class Dog &#123; @Value(&quot;旺财&quot;) private String name; public void eat()&#123; System.out.println(&quot;dog is eatting ...&quot;); &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125;&#125; 编写配置类 1234@Configuration@ComponentScan(&quot;com.dhz&quot;)public class SpringConfiguration &#123;&#125; 测试 12345678public class Run &#123; public static void main(String[] args) &#123; ApplicationContext app&#x3D;new AnnotationConfigApplicationContext(SpringConfiguration.class); Dog d &#x3D; (Dog) app.getBean(&quot;wang_cai&quot;); d.eat(); System.out.println(d); &#125;&#125; 常用注解原始注解 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 @Component(“id名”)1@Component(&quot;userDao&quot;) &#x2F;&#x2F;类注解，配置bean @Resource(name=”xxx”)相当于@Autowired+@Qualifier(“xxx”)，按照id注入 1234&#x2F;&#x2F; @Autowired&#x2F;&#x2F; @Qualifier(&quot;userDao&quot;) @Resource(name&#x3D;&quot;userDao&quot;) private UserDao userDao; @Value(“xxx”)基本数据类型赋值，xxx可为EL表达式 12@Value(&quot;$&#123;jdbc.driver&#125;&quot;)private String driver; @Scope(“xxx”)1234567加在类上scope&#x3D;&quot;singleton&quot; &#x2F;&#x2F;默认，单例，单例模式下，创建spring容器时仅创建一个单例ApplicationContext app&#x3D;new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);此时执行无参构造，仅创建一个实例，只要容器在，对象一直活着，销毁容器时，销毁此实例---------------------------------------------------------------------scope&#x3D;&quot;prototype&quot; &#x2F;&#x2F;多例，每一次getBean都创建一个实例，只要此实例在使用，实例一直活着，长时间不用就会被垃圾回收 @PostConstruct和@PreDestroy加在bean中的方法上 12@PostConstruct &#x2F;&#x2F;init方法@PreDestroy &#x2F;&#x2F;Destroy方法 新注解@Configuration1@Configuration &#x2F;&#x2F;类注解。标志Spring配置类 @ComponentScan(“路径名”)123@ComponentScan(&quot;com.dhz&quot;) &#x2F;&#x2F;类注解，配置注解扫描路径&#x2F;&#x2F;相当于&#x2F;&#x2F;&lt;context:component-scan base-package&#x3D;&quot;com.dhz&quot;&gt;&lt;&#x2F;context:component-scan&gt; @PropertySource(“xxx”)12@PropertySource(&quot;classpath:jdbc.properties&quot;)&#x2F;&#x2F;类注解&#x2F;&#x2F;classpath：表示resources目录下 @Import({xxx.class})1@Import(&#123;DataSourceConfiguration.class&#125;) &#x2F;&#x2F;类注解，引入其他配置类 @Bean123456789@Bean(name&#x3D;&quot;dataSource&quot;)public DataSource getDataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource &#x3D; new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource;&#125; 常用标签读取properties+EL表达式(${})12&lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;&#x2F;&#x2F;classpath：表示resources目录下 搭建SpringJunitTestpom.xml 引入jar包12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 编写测试类1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes &#x3D; &#123;SpringConfiguration.class&#125;)&#x2F;&#x2F;@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)&#x2F;&#x2F;或者直接加载配置文件public class SpringJunitTest &#123; @Autowired private UserService userService; @Test public void test()&#123; userService.save(); &#125;&#125; 注：Test方法必须是public AOPAOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 底层实现：通过 Spring 提供的的动态代理技术实现的。 常用的动态代理技术 JDK 代理 : 基于接口的动态代理技术 cglib 代理：基于父类的动态代理技术 自己实现aop目录结构 TargetInterface.java 12345package com.dhz.proxy.jdk;public interface TargetInterface &#123; void save();&#125; Advice.java 12345678910package com.dhz.proxy.cglib;public class Advice &#123; void before()&#123; System.out.println(&quot;before....&quot;); &#125; void after()&#123; System.out.println(&quot;after....&quot;); &#125;&#125; Target.java 12345678package com.dhz.proxy.cglib;public class Target &#123; public void save() &#123; System.out.println(&quot;save....&quot;); &#125;&#125; 基于JDK1234567891011121314151617181920public static void main(String[] args) &#123; final Target target&#x3D;new Target(); final Advice advice&#x3D;new Advice(); TargetInterface targetInterface&#x3D; (TargetInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(),&#x2F;&#x2F;目标对象的类加载器 target.getClass().getInterfaces(),&#x2F;&#x2F;目标对象的接口字节码对象数组 new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; advice.before(); Object invoke &#x3D; method.invoke(target, args); advice.after(); return invoke; &#125; &#125; ); targetInterface.save(); &#125; 基于cglib目录结构中没有TargetInterface.java 1234567891011121314151617181920212223public static void main(String[] args) &#123; final Target target&#x3D;new Target(); final Advice advice&#x3D;new Advice(); &#x2F;&#x2F;1.创建增强器 Enhancer enhancer&#x3D;new Enhancer(); &#x2F;&#x2F;2.设置父类（目标） enhancer.setSuperclass(Target.class); &#x2F;&#x2F;3.设置回调 enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; advice.before(); Object invoke &#x3D; method.invoke(target, args); advice.after(); return invoke; &#125; &#125;); &#x2F;&#x2F;4.创建代理对象 Target target1 &#x3D; (Target) enhancer.create(); target1.save();&#125; sprnig-AOP目录结构 基于xml的AOP快速入门①导入 AOP 相关坐标 ②创建目标接口和目标类（内部有切点） ③创建切面类（内部有增强方法） ④将目标类和切面类的对象创建权交给 spring ⑤在 applicationContext.xml 中配置织入关系 ⑥测试代码 导入 AOP 相关坐标 123456789101112&lt;!--导入spring的context坐标，context依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!-- aspectj的织入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt; &lt;version&gt;1.8.13&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 创建目标接口和目标类（内部有切点） 12345678910public interface TargetInterface &#123; void save();&#125;public class Target implements TargetInterface&#123; public void save() &#123; System.out.println(&quot;save....&quot;); &#125;&#125; 创建切面类（内部有增强方法） 12345678public class Myaspect &#123; public void before()&#123; System.out.println(&quot;before....&quot;); &#125; public void after()&#123; System.out.println(&quot;after....&quot;); &#125;&#125; 将目标类和切面类的对象创建权交给 spring 12&lt;bean id&#x3D;&quot;myaspect&quot; class&#x3D;&quot;com.dhz.aop.Myaspect&quot;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;target&quot; class&#x3D;&quot;com.dhz.aop.Target&quot;&gt;&lt;&#x2F;bean&gt; 在 applicationContext.xml 中配置织入关系 导入aop命名空间 1234567891011&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; 配置切点表达式和前置增强的织入关系 12345&lt;aop:config&gt; &lt;aop:aspect ref&#x3D;&quot;myaspect&quot;&gt; &lt;aop:before method&#x3D;&quot;before&quot; pointcut&#x3D;&quot;execution(public void com.dhz.aop.Target.save())&quot;&gt;&lt;&#x2F;aop:before&gt; &lt;&#x2F;aop:aspect&gt; &lt;&#x2F;aop:config&gt; 测试代码 12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest &#123; @Autowired private TargetInterface target; @Test public void test()&#123; target.save(); &#125;&#125; XML 配置 AOP 详解 切点表达式的写法 表达式语法： 1execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如： 12345execution(public void com.itheima.aop.Target.method()) execution(void com.itheima.aop.Target.*(..))execution(* com.itheima.aop.*.*(..))execution(* com.itheima.aop..*.*(..))execution(* *..*.*(..)) 通知的类型通知的配置语法： 1&lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式\"&gt;&lt;/aop:通知类型&gt; 注意环绕的方法如下： 1234567&#x2F;&#x2F;ProceedingJoinPoint是正在执行的方法public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;前置。。。&quot;); Object proceed &#x3D; pjp.proceed(); System.out.println(&quot;后置。。。&quot;); return proceed;&#125; 切点表达式的抽取 当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。 1234&lt;aop:aspect ref=\"myaspect\"&gt; &lt;aop:pointcut id=\"myPointCut\" expression=\"execution(* com.dhz.aop.*.*(..))\"/&gt; &lt;aop:around method=\"around\" pointcut-ref=\"myPointCut\"&gt;&lt;/aop:around&gt;&lt;/aop:aspect&gt; 基于注解的 AOP 开发快速入门 基于注解的aop开发步骤： ①创建目标接口和目标类（内部有切点） ②创建切面类（内部有增强方法） ③将目标类和切面类的对象创建权交给 spring ④在切面类中使用注解配置织入关系 ⑤在配置文件中开启组件扫描和 AOP 的自动代理 ⑥测试 ①创建目标接口和目标类（内部有切点） 12345678910public interface TargetInterface &#123; void save();&#125;public class Target implements TargetInterface &#123; public void save() &#123; System.out.println(&quot;save....&quot;); &#125;&#125; ②创建切面类（内部有增强方法) 12345public class Myaspect &#123; public void before()&#123; System.out.println(\"before....\"); &#125;&#125; ③将目标类和切面类的对象创建权交给 spring 123456789101112131415@Component(\"target\")public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(\"Target running....\"); &#125;&#125;@Component(\"myAspect\")public class MyAspect &#123; public void before()&#123; System.out.println(\"前置代码增强.....\"); &#125;&#125; ④在切面类中使用注解配置织入关系 12345678@Component(\"myaspect\")@Aspectpublic class Myaspect &#123; @Before(\"execution(* com.dhz.anno.*.*(..))\") public void before()&#123; System.out.println(\"before....\"); &#125;&#125; ⑤在配置文件中开启组件扫描和 AOP 的自动代理 12345&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=\"com.itheima.aop\"/&gt;&lt;!--aop的自动代理--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; ⑥测试代码 12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext_anno.xml\")public class AnnoTest &#123; @Autowired private TargetInterface target; @Test public void test()&#123; target.save(); &#125;&#125; 注解配置 AOP 详解注解通知的类型 通知的配置语法：@通知注解(“切点表达式”) 切点表达式的抽取 同 xml配置 aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下： 1234567891011121314151617181920212223242526@Component(\"myaspect\")@Aspectpublic class Myaspect &#123; @Before(\"execution(* com.dhz.anno.*.*(..))\") public void before()&#123; System.out.println(\"before....\"); &#125; @After(\"pointcut()\") public void after()&#123; System.out.println(\"after....\"); &#125; @Around(\"Myaspect.pointcut()\") public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(\"前置。。。\"); Object proceed = pjp.proceed(); System.out.println(\"后置。。。\"); return proceed; &#125; @Pointcut(\"execution(* com.dhz.anno.*.*(..))\") public void pointcut()&#123; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"}]},{"title":"目标检测","slug":"目标检测","date":"2021-02-08T01:50:49.000Z","updated":"2021-02-09T12:29:38.828Z","comments":true,"path":"2021/02/08/目标检测/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/08/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/","excerpt":"摘要","text":"摘要 R-CNN算法流程 一张图像生成1K~2K个候选区域(使用Selective Search方法) 对每个候选区域，缩放后(277277)使用*AlexNet CNN网络**提取特征向量 (4096维)，最终得到2k * 4096大小矩阵 特征送入每一类(共20类)的SVM 分类器， 判别是否属于该类 ，得到2k * 20矩阵 对每一列进行非极大值抑制 寻找得分最高的目标 计算其他目标与该目标的iou值 删除所有iou值大于给定阈值的目标 使用回归器精细修正候选框位置 算法框架 存在的问题 测试速度慢测试一张图片约53s(CPU)。 用Selective Search算法提取候选框用时约2秒， 一张图像内候选框之间存在大量重叠， 提取特征操作冗余。 训练速度慢 训练所需空间大对于SVM和bbox回归训练， 需要从每个图像中的每个目标候选框提取特征， 并写入磁盘。 对于非常深的网络， 如VGG16， 从VOC07训练集上的5k图像上提取的特征需要数百GB的存储空间。 Fast R-CNN算法流程 一张图像生成1K~2K个候选区域(使用Selective Search方法) 整幅图像输入到网络得到特征图，将筛选后64个候选框投影到特征图后得到64个特征矩阵 特征矩阵通过ROI pooling层缩放到7x7大小的特征图，展平得到特征向量 特征向量并联分类器和边界框回归器 主要组件分类器 N+1个节点(N个类别+1个背景) 经过softmax处理 边界框回归器 (N+1)*4个节点(每个类别对应4个边界框回归参数(dx, dy, dw, dh) ) Px, Py, Pw, Ph 分别为候选框的中心x y坐标，以及宽高 Gˆx,Gˆ y,Gˆw,Gˆh 分别为最终预测的边界框中心x y坐标，以及宽高 损失函数 p : 分类器输出的softmax输出 u : 真实类别标签 算法框架 Faster R-CNN实际就是RPN + Fast R-CNN 算法流程 将图像输入网络得到相应的特征图 使用RPN结构生成候选框， 将RPN生成的候选框投影到特征图上获得相应的特征矩阵 将每个特征矩阵通过ROI pooling层缩放到7x7大小的特征图，接着将特征图展平通过一系列全连接层得到预测结果 RPNRPN在特征图的基础上用3*3的窗口(padding=1,步距为1)进行滑动，将3 * 3窗口的中心通过比例变换得到原图中的像素，以这个像素为中心生成9个anchor。去除跨越边界的anchor，对每一个anchor得到6个输出(2个表示是不是前景，后边四个表示回归参数)，采用非极大值抑制保留少数的候选框 YOLO v1算法思想 将一幅图像分成SxS个网格，如果某个类别真实候选框的中心落在这个网格中， 则这个网格就负责预测这个候选框。 每个网格要预测B个候选框和C个类别，候选框包含预测位置(x,y,w,h)和confidence值。 x,y,w,h都是相对值(相对于原图像)，都在0~1之间 网络结构 损失函数 缺点 群体性小目标检测效果不好(原论文7*7个网格，每个网格预测两个框) 目标出现新的尺寸比例的时候效果差(直接预测位置和宽高，而像R-CNN和SSD系列预测回归参数) YOLO v2算法尝试和创新 每个卷积层后加BN(Batch Normalization)层 更大的输入图片尺寸(更高分辨率) 基于Anchor Boxes，用K-means聚类得到anchor尺寸 用sigmoid函数限制变换后的位置 高层特征和底层特征(包含细节信息，解决v1小目标效果不好)结合 用4x4方格将宽高变为一半，深度变为4倍，与高层特征在深度上拼接 多尺度训练，解决输入图像尺寸固定的弊端，每迭代10个batch，随机选择图片尺寸 网络结构darknet-19 总结构 YOLO v3创新点 在三个尺度对目标进行检测 网络结构DarkNet-53 总结构) 损失函数 目标置信度损失目标置信度损失采用的是二值交叉熵损失(Binary Cross Entropy)，其中,表示预测目标边界框i中是否真实存在目标，0表示不存在，1表示存在。表示预测目标矩形框i内是否存在目标的Sigmoid概率（将预测值通过sigmoid函数得到）。 目标类别损失","categories":[{"name":"目标检测","slug":"目标检测","permalink":"https://donghuangzhong.github.io/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"目标检测","slug":"目标检测","permalink":"https://donghuangzhong.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"test","slug":"test","date":"2021-02-07T09:36:50.486Z","updated":"2021-02-07T09:57:12.775Z","comments":true,"path":"2021/02/07/test/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/07/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux_WSL","slug":"Linux-WSL","date":"2021-02-07T09:01:54.000Z","updated":"2021-02-10T04:24:48.769Z","comments":true,"path":"2021/02/07/Linux-WSL/","link":"","permalink":"https://donghuangzhong.github.io/2021/02/07/Linux-WSL/","excerpt":"摘要","text":"摘要 常用命令版本相关linux查看当前操作系统发行信息1cat &#x2F;etc&#x2F;issue 更新阿里源 备份原先的源 1mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup 下载新的阿里源 1wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-8.repo 运行 yum makecache 生成缓存 1yum makecache 更新 1yum -y update 安装常用软件 软件地址： 安装之前上传到usr/local文件夹 安装JDK 查看jdk版本 1java –version 查看安装的jdk信息 1rpm -qa | grep java 卸载jdk 12rpm -e --nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686rpm -e --nodeps java-1.7.0-openjdk-1.7.0.79-2.5.5.4.el6.i686 进入usr/local解压JDK，通常将软件安装到/usr/local 1tar –xvf jdk.tar.gz -C 目标路径 配置JDK的环境变量 123456789vi &#x2F;etc&#x2F;profile在末尾行添加#set java environmentJAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk&#x2F;jdk1.7.0_71CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib.tools.jarPATH&#x3D;$JAVA_HOME&#x2F;bin:$PATHexport JAVA_HOME CLASSPATH PATH保存退出 安装mysql 上传后解压 将系统自带的mysql卸载 123rpm –qa | grep mysql rpm -e --nodeps 名字 安装MYSQL服务端 会在/root/.mysql_secret中生成root用户的密码 安装MYSQL客户端 查看生成的root密码 开启mysql服务 1service mysql start 设置root用户的密码 1set password&#x3D;password(&#39;root&#39;) 设置mysql远程访问 123grant all privileges on *.* to &#39;root&#39; @&#39;%&#39; identified by &#39;root&#39;;flush privileges; 防火墙设置 1234567在linux中很防火墙打开3306端口&#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 3306 -j ACCEPT&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;iptables save&#x2F;etc&#x2F;init.d&#x2F;iptables status学习阶段我们也可以直接将防火墙关闭service iptables stop;多软件的端口都被”防火墙”限止，我们需要将防火墙关闭 安装tomcat 上传解压至usr/local 在tomcat/bin目录下执行 startup.sh 安装Redisredis是C语言开发，安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境。 安装c语言环境 1yum install gcc-c++ 下载redis 1wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.0.4.tar.gz 解压 1tar -xzvf redis-3.0.4.tar.gz 编译 12cd redis-3.0.4make 安装 1make PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis install 复制配置文件到/usr/local/redis/bin目录 123cd redis-3.0.4cp redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin 启动redis 1234567cd redis&#x2F;bin指定配置文件启动服务端.&#x2F;redis-server redis.conf启动客户端.&#x2F;redis-cli 安装Nginx 安装gcc环境 1yum install gcc-c++ 安装第三方的开发包 123yum install -y pcre pcre-develyum install -y zlib zlib-develyum install -y openssl openssl-devel 上传解压安装包到usr/local 1tar -zxvf nginx-1.8.0.tar.gz 进入解压目录生成makeFile 文件，然后make 1234567891011121314151617181920cd nginx-1.8.0&#x2F;.&#x2F;configure \\--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx \\--pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx&#x2F;nginx.pid \\--lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx.lock \\--error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log \\--http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client \\--http-proxy-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;proxy \\--http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;fastcgi \\--http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;uwsgi \\--http-scgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;scgimakemake install&#x2F;&#x2F;注：四条命令都要执行，最后会生成一个usr&#x2F;local&#x2F;nginx文件夹 安装完成，创建临时目录 1mkdir &#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client -p 启动 123cd sbin&#x2F;.&#x2F;nginx 关闭、刷新命令 123.&#x2F;nginx -s quit &#x2F;&#x2F;正常关闭.&#x2F;nginx -s stop &#x2F;&#x2F;杀进程.&#x2F;nginx -s reload &#x2F;&#x2F;刷新 安装Centos8下载镜像12 用命令行安装123windows命令行(管理员)：wsl --import &lt;分发版&gt; &lt;安装位置&gt; &lt;文件名&gt; [选项]wsl --import CentOS D:\\CentOS D:\\文件路径\\centos8.tar 启动1wsl -d Centos 迁移查看当前用户名12whoami&#x2F;&#x2F;我的用户名是 DongHuangZhong 在迁移目标磁盘创建一个文件夹 ，并设置权限123icacls E:\\bianchenggongju\\Kali.windows &#x2F;grant &quot;DongHuangZhong:(OI)(CI)(F)&quot;.\\lxrunoffline move -n kali-linux -d E:\\bianchenggongju\\Kali.windows 下载解压 LxRunOffline1网址:https:&#x2F;&#x2F;github.com&#x2F;DDoSolitary&#x2F;LxRunOffline&#x2F;releases 解压后，在此目录中按shift+鼠标右键，在此处打开powershell 查看已安装的Linux发行版本1.\\lxrunoffline list 用命令迁移1.\\lxrunoffline move -n kali-linux -d E:\\bianchenggongju\\Kali.windows 确认迁移完成1.&#x2F;LxRunOffline.exe get-dir -n kali-linux","categories":[{"name":"Linux","slug":"Linux","permalink":"https://donghuangzhong.github.io/categories/Linux/"}],"tags":[{"name":"WSL","slug":"WSL","permalink":"https://donghuangzhong.github.io/tags/WSL/"}]},{"title":"python_pandas","slug":"python-pandas","date":"2021-01-28T03:27:31.000Z","updated":"2021-01-28T03:43:08.223Z","comments":true,"path":"2021/01/28/python-pandas/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/28/python-pandas/","excerpt":"摘要","text":"摘要 主体数据类型：DataFrame 名称 功能 参数 返回值 pd.read_csv() 读取csv 路径字符串 DataFrame pd.DataFrame(np.zeros(shape=[1000, 20]), columns=move_class) 创建DataFarame ndarry，列标签 DataFrame DataFrame.sum(axis) 对行或列求和 axis，0列求和，1行求和","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"https://donghuangzhong.github.io/tags/pandas/"}]},{"title":"python_ndarray","slug":"python-ndarray","date":"2021-01-28T03:14:20.000Z","updated":"2021-01-28T04:05:01.935Z","comments":true,"path":"2021/01/28/python-ndarray/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/28/python-ndarray/","excerpt":"摘要","text":"摘要 1.ndarray创建1.通过list创建1a &#x3D; np.array([[1, 2, 3], [4, 5, 6]], dtype &#x3D; np.float32) 2.ndarray的属性 属性 含义 类型 shape 形状 元组 ndim 维度 整数 size 数组中元素个数 整数 itemsize 元素的字节数 整数 dtype 元素类型 “int32” 3.ndarray的方法1.reshape() &amp;&amp; resize()reshape()不改变数据，只改变逻辑上的维数 resize()会改变数据 2.stock_change[stock_change &gt; 0.5] = 1.1将stock_change元素中&gt;0.5的置为1.1 1234567print(score.shape)print(score.ndim)print(score.size)print(score.itemsize)print(score.dtype)score2 &#x3D; score.reshape(6, 5) 4.numpy的方法1.np.random.uniform(low,high,size)均匀分布[low,high)中随机采样size次得到一维数组 2.np.unique(ndarray)返回去重后的数组 3.numpy.random.normal(loc,scale,size)loc：均值 scale：方差 size：个数 4.np.hstack(a,b)在水平方向上连接a数组和b数组 5.np.concatenate((a,b),axis=0)axis=1表示对应行的数组进行拼接 axis=0表示对应列的数组进行拼接 6.np.split()12345678x &#x3D; np.arange(9)print(x)print(np.split(x, 3))print(np.split(x, [3, 5, 7, 8]))[0 1 2 3 4 5 6 7 8][array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])][array([0, 1, 2]), array([3, 4]), array([5, 6]), array([7]), array([8])]","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://donghuangzhong.github.io/tags/numpy/"}]},{"title":"python_pyplot","slug":"python-pyplot","date":"2021-01-28T01:49:00.000Z","updated":"2021-01-28T03:27:06.885Z","comments":true,"path":"2021/01/28/python-pyplot/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/28/python-pyplot/","excerpt":"摘要","text":"摘要 1.图形属性123plt.title(&quot;matplotlib demo&quot;)plt.figure(figsize&#x3D;(20, 8), dpi&#x3D;80) &#x2F;&#x2F;dpi每英寸像素数plt.show()&#x2F;&#x2F;最后都要加才能显示 2.其他图1.二维函数图123plt.xlabel(&quot;x axis&quot;)plt.ylabel(&quot;y axis&quot;)plt.plot(x, y) 2.散点图1plt.scatter(x, y) 3.柱状图1plt.bar(x_lebel, y, color&#x3D;[&#39;b&#39;, &#39;r&#39;, &#39;g&#39;, &#39;y&#39;, &#39;c&#39;, &#39;m&#39;, &#39;y&#39;, &#39;k&#39;, &#39;c&#39;]) 4.饼图1234567plt.pie(tickets, labels&#x3D;movie_names, colors&#x3D;[&#39;b&#39;, &#39;r&#39;, &#39;g&#39;, &#39;y&#39;],autopct&#x3D;&quot;%1.2f&quot;)&#x2F;&#x2F;autopct :控制饼图内百分比设置,可以使用format字符串或者format function &#39;%1.1f&#39;指小数点前后位数(没有用空格补齐) &#x2F;&#x2F;显示图例对应关系plt.legend() 5.直方图12345plt.hist(y, bins&#x3D;10)&#x2F;&#x2F;bins：有几条柱子plt.xticks(range(min(time), max(time), distance))&#x2F;&#x2F;x轴的开始结束和步距 3.中文乱码问题 百度安装simhei.ttf字体 打开python安装目录下python\\Lib\\site-packages\\matplotlib\\mpl-data\\matplotlibrc 搜索font.sans-serif ，去掉注释，在冒号后添加SimHei 搜索axes.unicode_minus，注释去掉，Ture改为False","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"}],"tags":[{"name":"pyplot","slug":"pyplot","permalink":"https://donghuangzhong.github.io/tags/pyplot/"}]},{"title":"JSP&&EL&JSTL","slug":"JSP-EL-JSTL","date":"2021-01-22T04:43:52.000Z","updated":"2021-03-05T00:39:31.497Z","comments":true,"path":"2021/01/22/JSP-EL-JSTL/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/22/JSP-EL-JSTL/","excerpt":"JSP: 指令 注释 内置对象 MVC开发模式 EL表达式 JSTL标签","text":"JSP: 指令 注释 内置对象 MVC开发模式 EL表达式 JSTL标签 JSP 概念：Java Server Pages： java服务器端页面 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写！！！ 原理：JSP本质上就是一个Servlet JSP的脚本：JSP定义Java代码的方式1231. &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。3. &lt;%&#x3D; 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 指令 作用：用于配置JSP页面，导入资源文件 格式 1&lt;%@ 指令名称 属性名1&#x3D;属性值1 属性名2&#x3D;属性值2 ... %&gt; 分类 page contentType：等同于response.setContentType() 设置响应体的mime类型以及字符集2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） import：导包 errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：标识当前也是是否是错误页面。 true：是，可以使用内置对象exception false：否。默认值。不可以使用内置对象exception include 页面包含的。导入页面的资源文件 1&lt;%@include file&#x3D;&quot;top.jsp&quot;%&gt; taglib 导入资源 12&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt; &#x2F;&#x2F;prefix：前缀，自定义的 注释 html注释 1&lt;!-- --&gt; &#x2F;&#x2F;只能注释html代码片段 jsp注释：推荐使用 1&lt;%-- --%&gt; &#x2F;&#x2F;可以注释所有 内置对象在jsp页面中不需要创建，直接使用的对象，一共有如下9个。 变量名 真实类型 作用 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源(转发) session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面(Servlet)的对象this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 * out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 * response.getWriter()和out.write()的区别： * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 * response.getWriter()数据输出永远在out.write()之前MVC：开发模式jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 MVC M：Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V：View，视图。JSP 展示数据 C：Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 优缺点 优点 耦合性低，方便维护，可以利于分工协作 重用性高 缺点：使得项目架构变得复杂，对开发人员要求高 EL表达式不用声明语句，直接在jsp中使用即可 概念Expression Language 表达式语言 作用替换和简化jsp页面中java代码的编写 语法${表达式} 忽略el表达式jsp默认支持el表达式的。如果要忽略el表达式 设置jsp中page指令中：isELIgnored=”true” 忽略当前jsp页面中所有的el表达式 \\${表达式} ：忽略当前这个el表达式 使用运算 算数运算符： + - * /(div) %(mod) 比较运算符： &gt; &lt; &gt;= &lt;= == != 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0 ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0 获取值 el表达式只能从域对象中获取值 语法 ${域名称.键名}：从指定域中获取指定键的值 域名称 12341. pageScope --&gt; pageContext2. requestScope --&gt; request3. sessionScope --&gt; session4. applicationScope --&gt; application（ServletContext） 举例：在request域中存储了name=张三 获取：${requestScope.name} ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 获取对象、List集合、Map集合的值 对象：${域名称.键名.属性名} 本质上会去调用对象的getter方法 List集合：${域名称.键名[索引]} Map集合 ${域名称.键名.key名称} ${域名称.键名[“key名称”]} 隐式对象el表达式中有11个隐式对象 pageContext 获取jsp其他八个内置对象 ${pageContext.request.contextPath}：动态获取虚拟目录 JSTL概念 JavaServer Pages Tag Library JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt; 作用用于简化和替换jsp页面上的java代码 使用步骤 导入jstl相关jar包 引入标签库：taglib指令： &lt;%@ taglib %&gt; 1&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt; 使用标签 常用的JSTL标签if:相当于java代码的if语句 test为必须属性，接受boolean表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合el表达式一起使用 c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 示例 1234567 &lt;% request.setAttribute(&quot;number&quot;,4); %&gt;&lt;c:if test&#x3D;&quot;$&#123;number % 2 !&#x3D; 0&#125;&quot;&gt; $&#123;number&#125;为奇数&lt;&#x2F;c:if&gt; choose:相当于java代码的switch语句 使用choose标签声明 相当于switch声明 使用when标签做判断 相当于case 使用otherwise标签做其他情况的声明 相当于default 示例 123456789101112131415&lt;% request.setAttribute(&quot;number&quot;,51); %&gt; &lt;c:choose&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 1&#125;&quot;&gt;星期一&lt;&#x2F;c:when&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 2&#125;&quot;&gt;星期二&lt;&#x2F;c:when&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 3&#125;&quot;&gt;星期三&lt;&#x2F;c:when&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 4&#125;&quot;&gt;星期四&lt;&#x2F;c:when&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 5&#125;&quot;&gt;星期五&lt;&#x2F;c:when&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 6&#125;&quot;&gt;星期六&lt;&#x2F;c:when&gt; &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 7&#125;&quot;&gt;星期天&lt;&#x2F;c:when&gt; &lt;c:otherwise&gt;数字输入有误&lt;&#x2F;c:otherwise&gt; &lt;&#x2F;c:choose&gt; foreach:相当于java代码的for语句属性 begin：开始值 end：结束值 var：临时变量 items:容器对象 普通for循环不用，增强for用 step：步长 varStatus:循环状态对象 index:容器中元素的索引，从0开始 count:循环次数，从1开始 示例 普通for 123&lt;c:forEach begin&#x3D;&quot;1&quot; end&#x3D;&quot;10&quot; var&#x3D;&quot;i&quot; step&#x3D;&quot;2&quot; varStatus&#x3D;&quot;s&quot;&gt; $&#123;i&#125; &lt;h3&gt;$&#123;s.index&#125;&lt;h3&gt; &lt;h4&gt; $&#123;s.count&#125; &lt;&#x2F;h4&gt;&lt;br&gt;&lt;&#x2F;c:forEach&gt; 增强for 1234567891011&lt;c:forEach items&#x3D;&quot;$&#123;requestScope.users&#125;&quot; var&#x3D;&quot;user&quot; varStatus&#x3D;&quot;s&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;s.count&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;user.address&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;user.qq&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;c:forEach&gt;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"web相关","slug":"java/web相关","permalink":"https://donghuangzhong.github.io/categories/java/web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/tags/java/"},{"name":"EL&JSTL","slug":"EL-JSTL","permalink":"https://donghuangzhong.github.io/tags/EL-JSTL/"}]},{"title":"深度学习_keras","slug":"深度学习-keras","date":"2021-01-17T02:37:19.000Z","updated":"2021-01-18T10:22:40.295Z","comments":true,"path":"2021/01/17/深度学习-keras/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-keras/","excerpt":"摘要","text":"摘要 1.函数式编程组件1.keras.layers.Conv2D12345678tf.keras.layers.Conv2D( filters, kernel_size, strides&#x3D;(1, 1), padding&#x3D;&#39;valid&#39;, data_format&#x3D;None, dilation_rate&#x3D;(1, 1), groups&#x3D;1, activation&#x3D;None, use_bias&#x3D;True, kernel_initializer&#x3D;&#39;glorot_uniform&#39;, bias_initializer&#x3D;&#39;zeros&#39;, kernel_regularizer&#x3D;None, bias_regularizer&#x3D;None, activity_regularizer&#x3D;None, kernel_constraint&#x3D;None, bias_constraint&#x3D;None, **kwargs) 函数式编程后边必须是四维的[batch,width,height,chanel] 1.增加维度 后增 1x_train &#x3D; x_train[:, tf.newaxis] 前增 1x_train &#x3D; x_train[tf.newaxis,:] 2.keras.preprocessing.image.ImageDataGenerator123456789tf.keras.preprocessing.image.ImageDataGenerator( featurewise_center&#x3D;False, samplewise_center&#x3D;False, featurewise_std_normalization&#x3D;False, samplewise_std_normalization&#x3D;False, zca_whitening&#x3D;False, zca_epsilon&#x3D;1e-06, rotation_range&#x3D;0, width_shift_range&#x3D;0.0, height_shift_range&#x3D;0.0, brightness_range&#x3D;None, shear_range&#x3D;0.0, zoom_range&#x3D;0.0, channel_shift_range&#x3D;0.0, fill_mode&#x3D;&#39;nearest&#39;, cval&#x3D;0.0, horizontal_flip&#x3D;False, vertical_flip&#x3D;False, rescale&#x3D;None, preprocessing_function&#x3D;None, data_format&#x3D;None, validation_split&#x3D;0.0, dtype&#x3D;None) featurewise_center：布尔值，使输入数据集去中心化（均值为0）, 按feature执行。 samplewise_center：布尔值，使输入数据的每个样本均值为0。 featurewise_std_normalization：布尔值，将输入除以数据集的标准差以完成标准化, 按feature执行。 samplewise_std_normalization：布尔值，将输入的每个样本除以其自身的标准差。 zca_whitening：布尔值，对输入数据施加ZCA白化。 rotation_range：整数，数据提升时图片随机转动的角度。随机选择图片的角度，是一个0180的度数，取值为0180。 width_shift_range：浮点数，图片宽度的某个比例，数据提升时图片随机水平偏移的幅度。 height_shift_range：浮点数，图片高度的某个比例，数据提升时图片随机竖直偏移的幅度。height_shift_range和width_shift_range是用来指定水平和竖直方向随机移动的程度，这是两个0~1之间的比例。 shear_range：浮点数，剪切强度（逆时针方向的剪切变换角度）。是用来进行剪切变换的程度。 zoom_range：浮点数或形如[lower,upper]的列表，随机缩放的幅度，若为浮点数，则相当于[lower,upper] = [1 - zoom_range, 1+zoom_range]。用来进行随机的放大。 channel_shift_range：浮点数，随机通道偏移的幅度。 fill_mode：‘constant’，‘nearest’，‘reflect’或‘wrap’之一，当进行变换时超出边界的点将根据本参数给定的方法进行处理 cval：浮点数或整数，当fill_mode=constant时，指定要向超出边界的点填充的值。 horizontal_flip：布尔值，进行随机水平翻转。随机的对图片进行水平翻转，这个参数适用于水平翻转不影响图片语义的时候。 vertical_flip：布尔值，进行随机竖直翻转。 rescale: 值将在执行其他处理前乘到整个图像上，我们的图像在RGB通道都是0255的整数，这样的操作可能使图像的值过高或过低，所以我们将这个值定为01之间的数。 preprocessing_function: 将被应用于每个输入的函数。该函数将在任何其他修改之前运行。该函数接受一个参数，为一张图片（秩为3的numpy array），并且输出一个具有相同shape的numpy array data_format：字符串，“channel_first”或“channel_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channel_last”对应原本的“tf”，“channel_first”对应原本的“th”。以128x128的RGB图像为例，“channel_first”应将数据组织为（3,128,128），而“channel_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channel_last”。 1.归一化1ImageDataGenerator(rescale&#x3D;1. &#x2F; 255) 2.flow_from_directory123456789101112131415def flow_from_directory(self, directory, target_size&#x3D;(256, 256), color_mode&#x3D;&#39;rgb&#39;, classes&#x3D;None, class_mode&#x3D;&#39;categorical&#39;, batch_size&#x3D;32, shuffle&#x3D;True, seed&#x3D;None, save_to_dir&#x3D;None, save_prefix&#x3D;&#39;&#39;, save_format&#x3D;&#39;png&#39;, follow_links&#x3D;False, subset&#x3D;None, interpolation&#x3D;&#39;nearest&#39;): directory: 目标文件夹路径,此文件夹下包含分类图片的文件夹，然后再是图片，比如此文件夹名为flower,下面含有[daisy,dandelion,roses,sunflowers,tulips]5个文件夹，roses文件夹下是玫瑰花的图片 target_size: 整数tuple,默认为(256, 256). 图像将被resize成该尺寸 batch_size: batch数据的大小,默认32 shuffle: 是否打乱数据,默认为True class_mode: “categorical”, “binary”, “sparse”或None之一. 默认为”categorical. 该参数决定了返回的标签数组的形式, “categorical”会返回2D的one-hot编码标签,”binary”返回1D的二值标签.”sparse”返回1D的整数标签,如果为None则不返回任何标签, 生成器将仅仅生成batch数据, 这种情况在使用model.predict_generator()和model.evaluate_generator()等函数时会用到. color_mode: 颜色模式,为”grayscale”,”rgb”之一,默认为”rgb”.代表这些图片是否会被转换为单通道或三通道的图片. classes: 可选参数,为子文件夹的列表,如[‘dogs’,’cats’]默认为None. 若未提供,则该类别列表将从directory下的子文件夹名称/结构自动推断。每一个子文件夹都会被认为是一个新的类。(类别的顺序将按照字母表顺序映射到标签值)。通过属性class_indices可获得文件夹名与类的序号的对应字典。 seed: 可选参数,打乱数据和进行变换时的随机数种子 save_to_dir: None或字符串，该参数能让你将提升后的图片保存起来，用以可视化 save_prefix：字符串，保存提升后图片时使用的前缀, 仅当设置了save_to_dir时生效 save_format：”png”或”jpeg”之一，指定保存图片的数据格式,默认”jpeg” flollow_links: 是否访问子文件夹中的软链接 .n属性可以获得数量 2.modelloss1.categorical_crossentropy:one-hot2.SparseCategoricalCrossentropy():数字编码1.steps_per_epoch一个step就是一个batch_size 3.搭建网络流程1.列好网络中各层的网络参数2.api编程搭建model3.存在的问题1.jupyter显存占用 每次运行完都重启一下服务","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://donghuangzhong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"_keras","slug":"keras","permalink":"https://donghuangzhong.github.io/tags/keras/"}]},{"title":"深度学习","slug":"深度学习","date":"2021-01-16T10:45:07.000Z","updated":"2021-01-19T04:04:44.510Z","comments":true,"path":"2021/01/16/深度学习/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","excerpt":"摘要","text":"摘要 1.AlexNet概述1.亮点 首次使用GPU加速 使用ReLu激活函数，非传统Sigmoid或Tanh LRN局部响应归一化 全连接层前两层使用Dropout随机失活神经元减少过拟合 2.8层结构卷积层公式12output&#x3D;(W-F+2P)&#x2F;S+1W:输入图片的大小(一般Width&#x3D;Height) F:卷积核大小 S:步长 P:Padding的像素数 层数\\参数 input_size kernels kernel_size padding stride output_size Conv1 [224, 224, 3] 48 * 2 = 96 11 [1, 2] 4 [55, 55, 96] Maxpool1 [55, 55, 96] None 3 0 2 [27, 27, 96] Conv2 [27, 27, 96] 256 5 [2, 2] 1 [27,27, 256] Maxpool2 [27, 27, 256] None 3 0 2 [13, 13, 256] Conv3 [13, 13, 256] 192*2= 384 3 [1, 1] 1 [13, 13, 384] Conv4 [13, 13, 384] 192*2= 384 3 [1, 1] 1 [13, 13, 384] Conv5 [13, 13, 384] 128*2= 256 3 [1, 1] 1 [13, 13, 256] Maxpool3 [13, 13, 256] None 3 0 2 [6, 6, 256] Fc1 2048 None None None None None Fc2 2048 None None None None None Fc3 1000 None None None None None 2.VGG网络1.概述VGG 在2014年由牛津大学著名研究组 VGG（Visual Geometry Group）提出，斩获该年 ImageNet 竞赛中 Localization Task（定位任务）第一名和 Classification Task（分类任务）第二名。 2.亮点 创新点通过堆叠多个小卷积核来替代大尺度卷积核，可以减少训练参数，同时能保证相同的感受野。论文中提到，可以通过堆叠两个3×3的卷积核替代5x5的卷积核，堆叠三个3×3的卷积核替代7x7的卷积核。 1在卷积神经网络中，决定某一层输出结果中一个元素所对应的输入层的区域大小，被称作感受野（receptive field）。 计算公式：F(i)=(F(i+1)−1)×Stride +Ksize F(i) 为第 i 层感受野 Stride为第 i 层的步距 Ksize 为 卷积核 或 池化核 尺寸 3.结构 3.GoogLeNet1.概述GoogLeNet在2014年由Google团队提出（与VGG网络同年，注意GoogLeNet中的L大写是为了致敬LeNet），斩获当年ImageNet竞赛中Classification Task (分类任务) 第一名。 2.亮点创新点 引入了 Inception 结构（融合不同尺度的特征信息） 使用1x1的卷积核进行降维以及映射处理 （虽然VGG网络中也有，但该论文介绍的更详细） 添加两个辅助分类器帮助训练 丢弃全连接层，使用平均池化层（大大减少模型参数，除去两个辅助分类器，网络大小只有vgg的1/20） inception 将特征矩阵同时输入到多个分支进行处理，并将输出的特征矩阵按深度进行拼接，得到最终输出。 作用：增加网络深度和宽度的同时减少参数。 3.结构","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://donghuangzhong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AlexNet","slug":"AlexNet","permalink":"https://donghuangzhong.github.io/tags/AlexNet/"}]},{"title":"jupyter","slug":"jupyter","date":"2021-01-16T01:32:24.000Z","updated":"2021-01-17T05:10:32.032Z","comments":true,"path":"2021/01/16/jupyter/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/16/jupyter/","excerpt":"单独的python安装jupyter","text":"单独的python安装jupyter 1.pip安装最好使用中科大的源 1pip install -i https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple jupyter 2.打开1jupyter notebook 3.可能出现的问题1.kernel error FileNotFoundError: [WinError 2] 系统找不到指定的文件解决方法 查看内核安装位置 1jupyter kernelspec list 在1中的路径打开kernel.jason查看Python编译器的路径是否正确 如果不正确，运行下面这天代码自动修正路径 1python -m ipykernel install --user 4.改默认路径1.生成config文件1jupyter notebook --generate-config 2.打开配置文件，搜索notebook_dir，删去#号修改即可3.重启jupyter5.代码补全1.进入Anaconda Prompt，依次运行以下代码1234567&#x2F;&#x2F;1.安装nbextensions pip install jupyter_contrib_nbextensions -i https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simplejupyter contrib nbextension install --user&#x2F;&#x2F;2.安装nbextensions_configuratorpip install --user jupyter_nbextensions_configurator jupyter nbextensions_configurator enable --user 2.重启jupyter可以看到增加了一个Nbextensions标签页，在这个页面里，勾选Hinterland","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"}],"tags":[{"name":"jupyter","slug":"jupyter","permalink":"https://donghuangzhong.github.io/tags/jupyter/"}]},{"title":"python","slug":"python","date":"2021-01-15T07:59:53.597Z","updated":"2021-01-16T01:34:29.586Z","comments":true,"path":"2021/01/15/python/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/15/python/","excerpt":"","text":"1.设置延时1pip --default-timeout&#x3D;200 install XXX 2.清楚模块(包)缓存1路径：C:\\Users\\用户名\\AppData\\Local\\pip 3.换源123中科大：https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;清华：https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple原始官方源：https:&#x2F;&#x2F;pypi.Python.org&#x2F;simple&#x2F; 1.永久换源1pip config set global.index-url https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 原始的源 1pip config set global.index-url https:&#x2F;&#x2F;pypi.Python.org&#x2F;simple&#x2F; 2.单次换源1pip install -i https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple XXX 4.卸载所有模块12pip freeze &gt; python_modules.txtpip uninstall -r python_modules.txt -y","categories":[],"tags":[]},{"title":"Win10_GeForce940MX_TersorFlow","slug":"Win10-GeForce940MX-TersorFlow","date":"2021-01-15T01:31:12.000Z","updated":"2021-03-01T01:37:18.724Z","comments":true,"path":"2021/01/15/Win10-GeForce940MX-TersorFlow/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/15/Win10-GeForce940MX-TersorFlow/","excerpt":"win10下GeForce940MX显卡安装 概述 安装","text":"win10下GeForce940MX显卡安装 概述 安装 1.安装TensorFlow-GPU1.安装环境 win10 GeForce940MX 自己安装的python3.7.4，非集成环境 2.pip命令安装tersorflow1pip --timeout&#x3D;100 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple tensorflow 必须设置timeout不然稍微网络不好就会报错，然后需要从头开始下载。 如果还是失败，手动去清华源下载whl文件，然后本地pip安装 1https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F; 这里面有版本的问题，不建议安装最新版的tersorflow，我安装的2.x，运行不了，后来重新安装了1.5 3.安装CUDA1https:&#x2F;&#x2F;developer.nvidia.com&#x2F;cuda-toolkit-archive 运行import tersorflow，如果报错cudart64_100.dll找不到，需要将CUDA安装目录下bin添加到系统环境变量path中 4.安装cuDNN1https:&#x2F;&#x2F;developer.nvidia.com&#x2F;cudnn 是一个压缩包，解压放到任何一个目录下就行，然后把其中的bin目录路径添加到Path环境变量里。 最好也将cuDNN安装目录下bin添加到系统环境变量path中 5.测试运行123import tensorflow as tfprint(&#39;Tensorflow Version:&#123;&#125;&#39;.format(tf.__version__))print(tf.test.is_gpu_available()) yolo12python convert.py yolov3.cfg yolov3.weights model_data&#x2F;yolo.h5python convert.py -w yolov3-tiny.cfg yolov3-tiny.weights model_data&#x2F;tiny_yolo_weights.h5","categories":[{"name":"TersorFlow","slug":"TersorFlow","permalink":"https://donghuangzhong.github.io/categories/TersorFlow/"}],"tags":[{"name":"GeForce940MX","slug":"GeForce940MX","permalink":"https://donghuangzhong.github.io/tags/GeForce940MX/"}]},{"title":"hexo便捷图片解决方案","slug":"hexo便捷图片解决方案","date":"2021-01-13T03:58:22.000Z","updated":"2021-02-09T12:32:02.559Z","comments":true,"path":"2021/01/13/hexo便捷图片解决方案/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/13/hexo%E4%BE%BF%E6%8D%B7%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"使图片在本地和网站上都能显示正常 win+s截图，在Typora上粘贴即可，不需要做任何操作","text":"使图片在本地和网站上都能显示正常 win+s截图，在Typora上粘贴即可，不需要做任何操作 1.安装图片插件1npm install hexo-asset-image --save 2.配置文件_config.yml 里post_asset_folder:选项设置为true这样每次hexo n “xxx”时就会一起生成同名文件夹 3.更改Typora设置1.文件-&gt;偏好设置-&gt;图像2.点击下拉框，选择复制到指定路径，如下图设置 3.随便截图，粘贴到Typora中即可","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://donghuangzhong.github.io/categories/Hexo/"}],"tags":[{"name":"图片","slug":"图片","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%BE%E7%89%87/"}]},{"title":"Java_JDBC连接池&JDBCTemplate","slug":"Java-JDBC连接池-JDBCTemplate","date":"2021-01-13T03:41:45.000Z","updated":"2021-03-05T00:09:08.321Z","comments":true,"path":"2021/01/13/Java-JDBC连接池-JDBCTemplate/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/13/Java-JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0-JDBCTemplate/","excerpt":"1.数据库连接池 2.C3p0 3.Druid 4.Spring JDBC : JDBC Template","text":"1.数据库连接池 2.C3p0 3.Druid 4.Spring JDBC : JDBC Template 数据库连接池概述概念其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处 节约资源 用户访问高效 实现标准接口：DataSource javax.sql包下的 获取连接：getConnection() 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 一般我们不去实现它，有数据库厂商来实现 C3P0：数据库连接池技术 Druid：数据库连接池实现技术，由阿里巴巴提供的 C3P0：数据库连接池技术硬编码方式123456ComboPooledDataSource cpds &#x3D; new ComboPooledDataSource();cpds.setDriverClass( &quot;org.postgresql.Driver&quot; ); &#x2F;&#x2F;loads the jdbc driver cpds.setJdbcUrl( &quot;jdbc:postgresql:&#x2F;&#x2F;localhost&#x2F;testdb&quot; );cpds.setUser(&quot;dbuser&quot;); cpds.setPassword(&quot;dbpassword&quot;); conn&#x3D;cpds.getConnection(); 步骤导入jar包 (两个) 和数据库驱动 c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar 不要忘记导入数据库驱动jar包 定义配置文件： 名称： c3p0.properties 或者 c3p0-config.xml 路径：直接将文件放在src目录下即可。 c3p0-config.xml文件内容： 12345678910111213141516171819202122232425262728&lt;c3p0-config&gt; &lt;!-- 使用默认的配置读取连接池对象 --&gt; &lt;default-config&gt; &lt;!-- 连接参数 --&gt; &lt;property name&#x3D;&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;jdbcUrl&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name&#x3D;&quot;initialPoolSize&quot;&gt;5&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;maxPoolSize&quot;&gt;10&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;checkoutTimeout&quot;&gt;3000&lt;&#x2F;property&gt; &lt;&#x2F;default-config&gt; &lt;named-config name&#x3D;&quot;otherc3p0&quot;&gt; &lt;!-- 连接参数 --&gt; &lt;property name&#x3D;&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;jdbcUrl&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;day25&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name&#x3D;&quot;initialPoolSize&quot;&gt;5&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;maxPoolSize&quot;&gt;8&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;checkoutTimeout&quot;&gt;1000&lt;&#x2F;property&gt; &lt;&#x2F;named-config&gt;&lt;&#x2F;c3p0-config&gt; 创建核心对象 数据库连接池对象 ComboPooledDataSource获取连接： getConnection代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class c3p0 &#123; public static void main(String[] args) &#123; Connection conn&#x3D;null; PreparedStatement ps&#x3D;null; ResultSet rs&#x3D;null; try &#123; &#x2F;&#x2F;主要是下面两句 ComboPooledDataSource ds &#x3D; new ComboPooledDataSource(); conn&#x3D;ds.getConnection(); ps&#x3D;conn.prepareStatement(&quot;select * from account where id&#x3D;?&quot;); ps.setInt(1,5); rs &#x3D; ps.executeQuery(); while(rs.next()) &#123; int id &#x3D; rs.getInt(&quot;id&quot;); String name &#x3D; rs.getString(&quot;NAME&quot;); int balance &#x3D; rs.getInt(&quot;balance&quot;); System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+balance); &#125; &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; &#x2F;&#x2F;关闭资源 if(conn!&#x3D;null) &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if(ps!&#x3D;null) &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if(rs!&#x3D;null) &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; &#125;&#125; Druid：数据库连接池实现技术，由阿里巴巴提供的步骤导入jar包 druid-1.0.9.jar在src目录下，定义properties配置文件druid.properties:1234567driverClassName&#x3D;com.mysql.jdbc.Driverurl&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db3username&#x3D;rootpassword&#x3D;rootinitialSize&#x3D;5maxActive&#x3D;10maxWait&#x3D;3000 加载配置文件druid.properties123Properties pro &#x3D; new Properties();InputStream is &#x3D; DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);pro.load(is); 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory1DataSource ds &#x3D; DruidDataSourceFactory.createDataSource(pro); 获取连接：getConnection1Connection conn &#x3D; ds.getConnection(); 代码12345678910111213Properties pro &#x3D; new Properties();pro.load(Druid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));DataSource ds &#x3D; DruidDataSourceFactory.createDataSource(pro);Connection conn &#x3D; ds.getConnection();PreparedStatement pstm &#x3D; conn.prepareStatement(&quot;select * from account where id&#x3D;?;&quot;);pstm.setInt(1,5);ResultSet rs &#x3D; pstm.executeQuery();while(rs.next())&#123; int id &#x3D; rs.getInt(&quot;id&quot;); String name &#x3D; rs.getString(&quot;NAME&quot;); int balance &#x3D; rs.getInt(&quot;balance&quot;); System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+balance);&#125; 编写工具类属性: 1DataSource ds; 方法： 1234静态代码块:用于初始化获得DataSourcegetDataSource()&#x2F;&#x2F;获取连接池getConnection()close(ResultSet resultSet, Statement statement,Connection connection) 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class DruidUtils &#123; private static DataSource ds; static &#123; try &#123; Properties pro &#x3D; new Properties(); pro.load(DruidUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); ds &#x3D; DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static DataSource getDataSource()&#123; return ds; &#125; public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; public static void close(ResultSet resultSet, Statement statement,Connection connection) &#123; if (resultSet!&#x3D;null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (statement!&#x3D;null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (connection!&#x3D;null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; public static void close(Statement statement,Connection connection) &#123; close(null,statement,connection); &#125;&#125; Spring JDBC(配合Druid使用)概念Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 步骤导入jar包（五个） 创建JdbcTemplate对象。依赖于数据源DataSource1JdbcTemplate template &#x3D; new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作update():执行DML语句。增、删、改语句123456@Test public void updateTest() &#123; int count &#x3D; jdbcTemplate.update(&quot;insert into account values(?,?,?)&quot;, 100, &quot;刘能&quot;,2000); System.out.println(count); &#125; 返回主键式insert12345678910111213141516171819202122public Long save(final User user) &#123; &#x2F;&#x2F;创建PreparedStatementCreator PreparedStatementCreator creator &#x3D; new PreparedStatementCreator() &#123; @Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException &#123; &#x2F;&#x2F;使用原始jdbc完成有个PreparedStatement的组建 PreparedStatement preparedStatement &#x3D; connection.prepareStatement(&quot;insert into sys_user values(?,?,?,?,?)&quot;, PreparedStatement.RETURN_GENERATED_KEYS); preparedStatement.setObject(1,null); preparedStatement.setString(2,user.getUsername()); preparedStatement.setString(3,user.getEmail()); preparedStatement.setString(4,user.getPassword()); preparedStatement.setString(5,user.getPhoneNum()); return preparedStatement; &#125; &#125;; &#x2F;&#x2F;创建keyHolder GeneratedKeyHolder keyHolder &#x3D; new GeneratedKeyHolder(); jdbcTemplate.update(creator,keyHolder); &#x2F;&#x2F;获得生成的主键 long userId &#x3D; keyHolder.getKey().longValue(); return userId; &#x2F;&#x2F;返回当前保存用户的id 该id是数据库自动生成的 &#125; query()：查queryForMap()查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 123456@Testpublic void queryForMapTest()&#123; Map&lt;String, Object&gt; rs &#x3D; jdbcTemplate.queryForMap(&quot;select * from account where NAME&#x3D;?&quot;, &quot;刘能&quot;); System.out.println(rs);&#125; 注意：这个方法查询的结果集长度只能是1！！！ queryForList()查询结果将结果集封装为list集合 123456@Testpublic void queryForListTest()&#123; List&lt;Map&lt;String, Object&gt;&gt; maps &#x3D; jdbcTemplate.queryForList(&quot;select * from account where id&#x3D;?&quot;, 5); System.out.println(maps);&#125; 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query() 查询结果，将结果封装为JavaBean对象列表 query的参数：sql，RowMapper，args… 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) 123456@Testpublic void queryTest()&#123; List&lt;Emp&gt; emps &#x3D; jdbcTemplate.query(&quot;select * from account where id&#x3D;?&quot;, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class), 5); System.out.println(emps);&#125; queryForObject() 参数：sql，返回类型的class，args… 查询结果，将结果封装为对象 一般用于聚合函数的查询 123456@Testpublic void queryForObjectTest()&#123; Long count &#x3D; jdbcTemplate.queryForObject(&quot;select count(NAME) from account where id&#x3D;?&quot;, Long.class, 5); System.out.println(count);&#125;","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"数据库连接池","slug":"数据库连接池","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"name":"SpringTemplate","slug":"SpringTemplate","permalink":"https://donghuangzhong.github.io/tags/SpringTemplate/"}]},{"title":"VM虚拟机和物理机共享文件夹","slug":"VM虚拟机和物理机共享文件夹","date":"2021-01-12T03:46:55.000Z","updated":"2021-02-09T12:32:37.283Z","comments":true,"path":"2021/01/12/VM虚拟机和物理机共享文件夹/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/12/VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E7%89%A9%E7%90%86%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/","excerpt":"VM虚拟机和实体机共享文件夹","text":"VM虚拟机和实体机共享文件夹 1.在VM中安装VMware Tools 如果没反应，看下面的提示，按win+R,输入D:\\setup.exe手动安装,之后可能需要重启 2.在虚拟机-&gt;设置-&gt;选项-&gt;共享文件夹-&gt;总是启用在下方点添加-&gt;选路径-&gt;勾选映射为驱动器(这一步一定要做！！！)一直下一步，直至完成 3.然后就可以在虚拟机我的电脑里面看到共享的驱动器了","categories":[{"name":"VM","slug":"VM","permalink":"https://donghuangzhong.github.io/categories/VM/"}],"tags":[{"name":"VM","slug":"VM","permalink":"https://donghuangzhong.github.io/tags/VM/"},{"name":"共享文件","slug":"共享文件","permalink":"https://donghuangzhong.github.io/tags/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/"}]},{"title":"Img_test","slug":"Img-test","date":"2021-01-12T02:45:29.000Z","updated":"2021-02-09T12:25:32.761Z","comments":true,"path":"2021/01/12/Img-test/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/12/Img-test/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"Java_idea生成类和方法注释","slug":"Java-idea生成类和方法注释","date":"2021-01-11T09:48:15.000Z","updated":"2021-03-04T02:41:35.998Z","comments":true,"path":"2021/01/11/Java-idea生成类和方法注释/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/11/Java-idea%E7%94%9F%E6%88%90%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A/","excerpt":"自定义Idea类和方法的内容和快捷键","text":"自定义Idea类和方法的内容和快捷键 只演示方法的，类的同样操作即可 1.Ctrl+Alt+S打开Idea设置,找到Editor-&gt;Live Templates2.点右上角加号先添加Template Group(命名为UserDefine)3.选中UserDefine再次点加号选Live Template4.Abbreviation处为快捷键(我设的a),Template Text如下 方法注释 1234567*** @Description: $description$* @Param: $params$* @return: $returns$* @Author: 此处改为你自己的名字* @Date: $date$**&#x2F; 类注释(弄好方法注释之后类的自然也会) 1234567*** @ClassName: $params$* @Description: $description$* @Author: Zhong ZhenJie* @Date: $date$* @Version: 1.0**&#x2F; 5.Template Text下方Define处点开全选6.可以点击右侧Edit Variables点击Expression选择这一项要显示的东西7.最后点OK，最终的快捷键为/+a(Abbreviation处设置的键)+Tab，类注释一样设置","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"tools","slug":"java/tools","permalink":"https://donghuangzhong.github.io/categories/java/tools/"}],"tags":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/tags/java/"},{"name":"idea","slug":"idea","permalink":"https://donghuangzhong.github.io/tags/idea/"}]},{"title":"Java_JDBC","slug":"Java_JDBC","date":"2021-01-11T09:48:15.000Z","updated":"2021-03-05T00:06:03.531Z","comments":true,"path":"2021/01/11/Java_JDBC/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/11/Java_JDBC/","excerpt":"概述 JDBC基本概念 快速入门 对JDBC中各个接口和类详解 JDBCUtils JDBC事务","text":"概述 JDBC基本概念 快速入门 对JDBC中各个接口和类详解 JDBCUtils JDBC事务 1.概念 Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 2. 快速入门1.步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2.右键--&gt;Add As Library 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql，接受返回结果 处理结果 释放资源 2. 代码实现12345678910111213141516&#x2F;&#x2F;1. 导入驱动jar包&#x2F;&#x2F;2.注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;3.获取数据库连接对象Connection conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3&quot;, &quot;root&quot;, &quot;root&quot;);&#x2F;&#x2F;4.定义sql语句String sql &#x3D; &quot;update account set balance &#x3D; 500 where id &#x3D; 1&quot;;&#x2F;&#x2F;5.获取执行sql的对象 StatementStatement stmt &#x3D; conn.createStatement();&#x2F;&#x2F;6.执行sqlint count &#x3D; stmt.executeUpdate(sql);&#x2F;&#x2F;7.处理结果System.out.println(count);&#x2F;&#x2F;8.释放资源stmt.close();conn.close(); 3. 详解各个对象1.DriverManager：驱动管理对象 注册驱动：告诉程序该使用哪一个数据库驱动jar12345678910static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(&quot;Can&#39;t register driver!&quot;); &#125; &#125; 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 获取数据库连接 1static Connection getConnection(String url, String user, String password) url：指定连接的路径 例子：jdbc:mysql://localhost:3306/db3 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 user：用户名 password：密码 2. Statement：执行sql的对象 boolean execute(String sql) 可以执行任意的sql 了解 int executeUpdate(String sql) 执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败， ResultSet executeQuery(String sql) 执行DQL（select)语句 3.PreparedStatement 防SQL注入、执行sql的对象 后期都会使用PreparedStatement来完成增删改查的所有操作 可以防止SQL注入 效率更高 SQL注入输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’ 在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 使用步骤 定义sql，”？”作为占位符 1如：String sql&#x3D;&quot;select * from user where username &#x3D; ? and password &#x3D; ?&quot;; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 1PreparedStatement ps&#x3D;connection.prepareStatement(sql) 给？赋值 12345setXxx(参数1,参数2)参数1：？的位置编号 从1 开始参数2：？的值ps.setString(1,&quot;张三&quot;) 执行sql，接受返回结果，不需要传递sql语句 1ResultSet rs&#x3D;ps.executeQuery(); 4.ResultSet：结果集对象,封装查询结果 boolean next() 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true getXxx(参数):获取数据 Xxx：代表数据类型 如： int getInt() , String getString() 参数： int：代表列的编号,从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 示例123456789while(rs.next())&#123; &#x2F;&#x2F;获取数据 &#x2F;&#x2F;6.2 获取数据 int id &#x3D; rs.getInt(1); String name &#x3D; rs.getString(&quot;name&quot;); double balance &#x3D; rs.getDouble(3); System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance); &#125; 4.抽取JDBC工具类 ： JDBCUtils 目的：简化书写 1.分析 注册驱动也抽取 抽取一个方法获取连接对象 需求：不想传递参数（麻烦），还得保证工具类的通用性。 解决：配置文件jdbc.properties 123url&#x3D;user&#x3D;password&#x3D; 抽取一个方法释放资源 2.代码public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; static { try { ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(&quot;jdbc.properties&quot;); String path = res.getPath(); Properties pro = new Properties(); pro.load(new FileReader(path)); url = pro.getProperty(&quot;url&quot;); user = pro.getProperty(&quot;user&quot;); password = pro.getProperty(&quot;password&quot;); driver = pro.getProperty(&quot;driver&quot;); Class.forName(driver); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } public static Connection getConnection() throws SQLException { Connection connection = DriverManager.getConnection(url, user, password); System.out.println(url+&quot;---数据库连接成功&quot;); return connection; } public static void close(Statement statement,Connection connection) { if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } System.out.println(url+&quot;---数据库关闭成功&quot;); } public static void close(ResultSet resultSet,Statement statement, Connection connection) { if(resultSet!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } System.out.println(url+&quot;---数据库关闭成功&quot;); } }​ 5.JDBC控制事务：事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 1. 开启事务1setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 注意：在执行sql之前开启事务 2.提交事务1commit() &#x2F;&#x2F;当所有sql都执行完提交事务 3.回滚事务1rollback() &#x2F;&#x2F;在catch中回滚事务 4.代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class JDBCDemo10 &#123; public static void main(String[] args) &#123; Connection conn &#x3D; null; PreparedStatement pstmt1 &#x3D; null; PreparedStatement pstmt2 &#x3D; null; try &#123; &#x2F;&#x2F;1.获取连接 conn &#x3D; JDBCUtils.getConnection(); &#x2F;&#x2F;开启事务 conn.setAutoCommit(false); &#x2F;&#x2F;2.定义sql &#x2F;&#x2F;2.1 张三 - 500 String sql1 &#x3D; &quot;update account set balance &#x3D; balance - ? where id &#x3D; ?&quot;; &#x2F;&#x2F;2.2 李四 + 500 String sql2 &#x3D; &quot;update account set balance &#x3D; balance + ? where id &#x3D; ?&quot;; &#x2F;&#x2F;3.获取执行sql对象 pstmt1 &#x3D; conn.prepareStatement(sql1); pstmt2 &#x3D; conn.prepareStatement(sql2); &#x2F;&#x2F;4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); &#x2F;&#x2F;5.执行sql pstmt1.executeUpdate(); &#x2F;&#x2F; 手动制造异常 int i &#x3D; 3&#x2F;0; pstmt2.executeUpdate(); &#x2F;&#x2F;提交事务 conn.commit(); &#125; catch (Exception e) &#123; &#x2F;&#x2F;事务回滚 try &#123; if(conn !&#x3D; null) &#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); &#125; &#125; &#125; ​ ​","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://donghuangzhong.github.io/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://donghuangzhong.github.io/tags/JDBC/"}]},{"title":"MySql","slug":"MySQL基础","date":"2021-01-11T09:48:15.000Z","updated":"2021-03-05T00:01:27.240Z","comments":true,"path":"2021/01/11/MySQL基础/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/11/MySQL%E5%9F%BA%E7%A1%80/","excerpt":"MySQL数据库软件 安装 卸载 配置和操作 SQL(DDL、DML、DQL、DCL) 数据库约束 数据库设计","text":"MySQL数据库软件 安装 卸载 配置和操作 SQL(DDL、DML、DQL、DCL) 数据库约束 数据库设计 MySQL数据库软件安装 进入官网：https://www.mysql.com/ 点击download 点击 MySQL Community (GPL) Downloads 点击MySQL Community Server 点击MSI安装文件下载 选择社区版下载，双击安装 点击自定义安装（Custom） 修改安装路径，然后一直下一步，直到弹出配置界面 自定义最大连接数 选择utf-8字符集 勾选添加到环境变量，然后一直下一步，直至完成 卸载 去mysql的安装目录找到my.ini文件 复制 datadir=”C:/ProgramData/MySQL/MySQL Server 5.5/Data/“ 卸载MySQL 删除C:/ProgramData目录下的MySQL文件夹 配置和操作 启动 手动找服务(service.msc) 命令(cmd管理员) 12net start mysql : 启动mysql的服务net stop mysql:关闭mysql服务 登录 123mysql -uroot -p密码mysql -h(远程主机的ip) -uroot -p连接目标的密码mysql --host&#x3D;ip --user&#x3D;root --password&#x3D;连接目标的密码 退出 12exitquit 备份和恢复 1234567891. 命令行： * 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径2. 图形化工具： SQLStructured Query Language：结构化查询语言 语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 3种注释 12单行注释: -- 注释内容 或 # 注释内容(mysql 特有) 多行注释: &#x2F;* 注释 *&#x2F; 分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表操作数据库：CRUD C(Create):创建 123456* 创建数据库：* create database 数据库名称;* 创建数据库，判断不存在，再创建：* create database if not exists 数据库名称;* 创建数据库，并指定字符集* create database 数据库名称 character set 字符集名; R(Retrieve)：查询 1234* 查询所有数据库的名称:* show databases;* 查询某个数据库的字符集:查询某个数据库的创建语句* show create database 数据库名称; U(Update):修改 12* 修改数据库的字符集* alter database 数据库名称 character set 字符集名称; D(Delete):删除 1234* 删除数据库* drop database 数据库名称;* 判断数据库存在，存在再删除* drop database if exists 数据库名称; 使用数据库 1234* 查询当前正在使用的数据库名称* select database();* 使用数据库* use 数据库名称; 操作表 C(Create):创建 创建 123456789* 创建表create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp); 1 复制表 12* 复制表：* create table 表名 like 被复制的表名; R(Retrieve)：查询 1234* 查询某个数据库中所有的表名称* show tables;* 查询表结构* desc 表名; U(Update):修改 12345678910111. 修改表名 alter table 表名 rename to 新的表名;2. 修改表的字符集 alter table 表名 character set 字符集名称;3. 添加一列 alter table 表名 add 列名 数据类型;4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型;5. 删除列 alter table 表名 drop 列名; D(Delete):删除 12* drop table 表名;* drop table if exists 表名 ; DML：增删改表中数据 添加数据 1234567* 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);* 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 删除数据 1234567* 语法： * delete from 表名 [where 条件]* 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 修改数据 12345* 语法： * update 表名 set 列名1 &#x3D; 值1, 列名2 &#x3D; 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。 DQL：查询表中的记录语法1234567891011121314select 字段列表from 表名列表where 条件列表group by 分组字段having 分组之后的条件order by 排序limit 分页限定 基础查询123456789101112131. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。2. 去除重复： * distinct3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。4. 起别名： * as：as也可以省略 条件查询123456789101112131. where子句后跟条件2. 运算符 * &gt; 、&lt; 、&lt;&#x3D; 、&gt;&#x3D; 、&#x3D; 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! 12345678910111213141516171819202122232425262728293031323334353637383940------------------------------------示例---------------------------------------------- -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;&#x3D; 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age &#x3D; 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age !&#x3D; 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;&#x3D; 20 &amp;&amp; age &lt;&#x3D;30; SELECT * FROM student WHERE age &gt;&#x3D; 20 AND age &lt;&#x3D;30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age &#x3D; 22 OR age &#x3D; 18 OR age &#x3D; 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english &#x3D; NULL; --不对的。null值不能使用&#x3D;（!&#x3D;）判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE &#39;___&#39;; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;; 排序查询123456789* 语法：order by 子句 * order by 排序字段1 排序方式1 ， 排序字段2 排序方式2...* 排序方式： * ASC：升序，默认的。 * DESC：降序。* 注意： * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 聚合函数12345678910111213聚合函数：将一列数据作为一个整体，进行纵向的计算。 1. count：计算个数 1. 一般选择非空的列：主键 2. count(*) 2. max：计算最大值 3. min：计算最小值 4. sum：计算和 5. avg：计算平均值 * 注意：聚合函数的计算，排除null值。 解决方案： 1. 选择不包含非空的列进行计算 2. IFNULL函数 分组查询语法：group by 分组字段； 分组之后查询的字段：分组字段、聚合函数 1234where 和 having 的区别？ where 在分组之前进行限定，如果不满足条件，则不参与分组。 having在分组之后进行限定，如果不满足结果，则不会被查询出来 where 后不可以跟聚合函数，having可以进行聚合函数的判断。 123456789101112131415示例：-- 按照性别分组。分别查询男、女同学的平均分SELECT sex , AVG(math) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 分页查询123456789 1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 &#x3D; （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页3. limit 是一个MySQL&quot;方言&quot; 约束概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 主键约束12345678910111213141516171819202122232425261. 注意： 1. 含义：非空且唯一 2. 一张表只能有一个字段为主键 3. 主键就是表中记录的唯一标识2. 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) );3. 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY;4. 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY;5. 自动增长： 1. 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 2. 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 自动增长12345删除自动增长 ALTER TABLE stu MODIFY id INT; 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 非空约束1234567891011* 非空约束：not null，值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); 唯一约束1234567891011121314* 唯一约束：unique，值不能重复1. 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); * 注意mysql中，唯一约束限定的列的值可以有多个null2. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number;3. 在创建表后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE; 外键约束1234567891011121314* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。 1. 在创建表时，可以添加外键 * 语法： create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 级联操作1234561. 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ;2. 分类： 1. 级联更新：ON UPDATE CASCADE 2. 级联删除：ON DELETE CASCADE 数据库的设计多表之间的关系1234567891011121314151617181920211. 多表之间的关系 1. 分类： 1. 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 数据库设计的范式12345678910111213141516171819202122* 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。分类：1. 第一范式（1NF）：每一列都是不可分割的原子数据项2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） * 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://donghuangzhong.github.io/tags/MySql/"}]},{"title":"Java_propertise传递信息","slug":"Java-propertise传递信息","date":"2021-01-11T07:30:55.000Z","updated":"2021-03-04T02:42:58.808Z","comments":true,"path":"2021/01/11/Java-propertise传递信息/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/11/Java-propertise%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/","excerpt":"用Java中的propertise传递信息(类似键值对)","text":"用Java中的propertise传递信息(类似键值对) 1.在src文件夹下新建xxx.propertise文件文件内容 1234url&#x3D;urltestuser&#x3D;usertestpassword&#x3D;passwordtestdriver&#x3D;drivertest 2.用ClassLoder获取xxx.propertise的路径不要写成绝对路径(没有通用性) 123ClassLoader classLoader &#x3D; JDBCUtils.class.getClassLoader();URL res &#x3D; classLoader.getResource(&quot;xxx.properties&quot;);String path &#x3D; res.getPath(); 3.利用Propertise类获取各个信息123456Properties pro &#x3D; new Properties();pro.load(new FileReader(path));String url &#x3D; pro.getProperty(&quot;url&quot;);String user &#x3D; pro.getProperty(&quot;user&quot;);String password &#x3D; pro.getProperty(&quot;password&quot;);String driver &#x3D; pro.getProperty(&quot;driver&quot;); 4.完整代码12345678910111213141516171819202122232425262728package primary_connect;import java.io.FileReader;import java.io.IOException;import java.net.URL;import java.util.Properties;public class JDBCUtils &#123; public static void main(String[] args) &#123; try &#123; ClassLoader classLoader &#x3D; JDBCUtils.class.getClassLoader(); URL res &#x3D; classLoader.getResource(&quot;jdbc.properties&quot;); String path &#x3D; res.getPath(); Properties pro &#x3D; new Properties(); pro.load(new FileReader(path)); String url &#x3D; pro.getProperty(&quot;url&quot;); String user &#x3D; pro.getProperty(&quot;user&quot;); String password &#x3D; pro.getProperty(&quot;password&quot;); String driver &#x3D; pro.getProperty(&quot;driver&quot;); System.out.println(&quot;url&#x3D;&quot;+url); System.out.println(&quot;user&#x3D;&quot;+user); System.out.println(&quot;password&#x3D;&quot;+password); System.out.println(&quot;driver&#x3D;&quot;+driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5.可能出现的问题1.加载时出现空指针异常1InputStream is &#x3D; JedisUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); 解决办法 在src下新建resourse包，，将jedis.properties放进去，然后点File-&gt;project structure-&gt;mudules 右键resourse文件夹，点resource","categories":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"配置文件","slug":"java/配置文件","permalink":"https://donghuangzhong.github.io/categories/java/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/tags/java/"},{"name":"Properties","slug":"Properties","permalink":"https://donghuangzhong.github.io/tags/Properties/"}]},{"title":"hexo+github_pages+阿里云域名","slug":"hexo-github-pages-阿里云域名","date":"2021-01-02T09:46:19.000Z","updated":"2021-02-09T12:37:20.828Z","comments":true,"path":"2021/01/02/hexo-github-pages-阿里云域名/","link":"","permalink":"https://donghuangzhong.github.io/2021/01/02/hexo-github-pages-%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/","excerpt":"hexo+github_pages+阿里云域名，整理自B站视频:https://www.bilibili.com/video/BV1Yb411a7ty","text":"hexo+github_pages+阿里云域名，整理自B站视频:https://www.bilibili.com/video/BV1Yb411a7ty 1.安装Node.js官网:https://nodejs.org/en/xia安装LTS版本即可 2.安装 Git官网:https://git-scm.com/downloads 2个都安装完成如下： 3.安装hexo1.新建一个文件夹，右键空白处点Git Bash Here 关于博客的所有文件都在这个文件夹下面，我新建的名字是dipamkar。 验证node，npm 是否安装成功，没有成功的就重新安装node。 1键入node -v和npm -v。进行验证 2.安装个cnpm提高速度，以后下载什么东西都用cnpm1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 验证cnpm是否安装成功，键入cnpm -v 3.正式安装hexo1cnpm install -g hexo-cli 验证hexo是否安装成功，键入hexo -v 4.初始化hexo1.本地初始化1hexo init 在此文件夹就会出现一堆文件 2.运行测试常用命令： 1234hexo clean #用来清理缓存文件hexo g #生成文件hexo s #运行本地服务器hexo d #上传到服务器 先运行hexo s。在浏览器中打开网址localhost:4000即可，得到下图表示成功 5.部署到github1.注册登录github网址：github.com 2.点击your repositories然后点new,新建仓库 3.Repository name必须写github账号名+github.io 填成上图即可点击create完成仓库创建 4.安装部署插件1cnpm install --save hexo-deployer-git 5.修改配置文件_config.yml 右键这个文件-&gt;编辑 或者用记事本打开 到此文件最后的位置，只改Deployment，改成下图 注意：repo按照下图从仓库中复制过来，改完不要忘了保存 6.绑定邮箱和账号名键入以下命令，引号中的信息换成你自己的 12git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 7.用hexo d正式部署到github 键入hexo d，然后会让你输入github账号密码，最后出现Deploy done表示成功 然后就可以用github账号名.github.io访问了 8.常用流程和命令1234567891011121314151617181920&#x2F;&#x2F;新建文章(默认md文件)hexo n &quot;文章名称&quot;&#x2F;&#x2F;本地调试hexo s&#x2F;&#x2F;清理文件夹hexo clean&#x2F;&#x2F;生成静态网页hexo g&#x2F;&#x2F;部署到githubhexo d&#x2F;&#x2F;必须先生成然后再部署，生成+部署可以简写成一条命令hexo g -d&#x2F;&#x2F;一般先用hexo n “”生成md文件-&gt;写文章-&gt;hexo g -d","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://donghuangzhong.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"博客搭建","slug":"个人博客/博客搭建","permalink":"https://donghuangzhong.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/tags/hexo/"},{"name":"github_pages","slug":"github-pages","permalink":"https://donghuangzhong.github.io/tags/github-pages/"}]},{"title":"计算机图形学 MFC 鼠标绘制多边形并用指定数字填充","slug":"计算机图形学-MFC-鼠标绘制多边形并用指定数字填充","date":"2020-12-31T02:37:39.000Z","updated":"2021-02-09T12:34:55.568Z","comments":true,"path":"2020/12/31/计算机图形学-MFC-鼠标绘制多边形并用指定数字填充/","link":"","permalink":"https://donghuangzhong.github.io/2020/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-MFC-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%B9%B6%E7%94%A8%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97%E5%A1%AB%E5%85%85/","excerpt":"边标志算法的实现 ，用鼠标左键单击绘制顶点最后一个顶点用双击输入，然后用任意的数字填充，用vc6.0软件做的","text":"边标志算法的实现 ，用鼠标左键单击绘制顶点最后一个顶点用双击输入，然后用任意的数字填充，用vc6.0软件做的 1.新建MFC项目 然后点finish就行 2.添加鼠标左键单击和双击的响应事件 Class name必须选View结尾的，选择WM_LBUTTONDOWN，然后必须先点Add Function，然后再点OK 这样就可以在目录结构中看到添加的事件了 同样可以添加双击的事件 3.首先实现用鼠标绘制多边形的代码首先分析一个我们要干的事，用鼠标单击事件获取到点的坐标后需要，moveto和lineto来划线，但是第一个点的时候不用划线，只有第二个点的时候才需要和上一个点划线，之后我们还需要每一个边的起点终点的位置，所以必须把所有点保存下来，同时需要记录这个多边形对应的矩形区域 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int max_x,max_y,min_x,min_y;&#x2F;&#x2F;多边形的矩形区域bool flag1&#x3D;0,flag&#x3D;0;&#x2F;&#x2F;flag1控制只进行一次画多边形，flag控制存放起点CPoint p[100];&#x2F;&#x2F;保存顶点数组，填充需要int n&#x3D;0;&#x2F;&#x2F;表示多边形顶点的的个数void CShiyan2View::OnLButtonDown(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;如果多边形已经绘制完成，再次点击则不会响应 &#123; if(!flag)&#123; max_x&#x3D;min_x&#x3D;point.x;&#x2F;&#x2F;初始化最开始的矩形区域为第一个点的横纵坐标 max_y&#x3D;min_y&#x3D;point.y; flag&#x3D;1; p[n++]&#x3D;point; &#125; else &#123; if(point.x&gt;max_x)&#x2F;&#x2F;更新矩形区域的坐标 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); p[n++]&#x3D;point; &#125; &#125; ReleaseDC(pDC); CView::OnLButtonDown(nFlags, point);&#125;void CShiyan2View::OnLButtonDblClk(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;只有没有绘制完成才会对双击进行响应 &#123; if(point.x&gt;max_x)&#x2F;&#x2F;此为最后一个顶点，同样需要更新矩形区域 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); pDC-&gt;MoveTo(point); pDC-&gt;LineTo(p[0]); flag1&#x3D;1;&#x2F;&#x2F;表示多边形已经绘制完成 p[n++]&#x3D;point; p[n]&#x3D;p[0]; &#125; ReleaseDC(pDC); CView::OnLButtonDblClk(nFlags, point);&#125; 4.用边标志法实现多边形填充(先用纯色填充)需要一个bool数组mask，初始全0，遍历每一条边上的点，将这个点右边的msak取反，最后得到的mask中为1的区域就是需要填充的区域。 从顶点数组p中获取每一条边的顶点信息，然后根据y计算x，对mask进行取反即可 要注意两点： 注意遍历点的时候要纵坐标优先，也就是纵坐标每次变化1，用纵坐标去计算横坐标 在顶点数组中，有可能出现起点的y比终点的y大的情况，这样就需要手动转换了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void CShiyan2View::OnLButtonDblClk(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;只有没有绘制完成才会对双击进行响应 &#123; if(point.x&gt;max_x)&#x2F;&#x2F;此为最后一个顶点，同样需要更新矩形区域 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); pDC-&gt;MoveTo(point); pDC-&gt;LineTo(p[0]); flag1&#x3D;1;&#x2F;&#x2F;表示多边形已经绘制完成 p[n++]&#x3D;point; p[n]&#x3D;p[0]; &#125; &#x2F;&#x2F;填充部分 for(int i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) mask[i][j]&#x3D;0;&#x2F;&#x2F;将数组全置0 for(i&#x3D;0;i&lt;n;i++)&#x2F;&#x2F;处理每一条边 &#123; int s&#x3D;p[i].y&lt;p[i+1].y?i:i+1;&#x2F;&#x2F;s保存的是较小y点的下标，e保存y较大的点的下标 int e&#x3D;2*i+1-s;&#x2F;&#x2F;由于起点终点的下标一个是i,一个是i+1，和为2*i+1，所以可以通过s计算e double dx&#x3D;(p[e].x-p[s].x)&#x2F;double(p[e].y-p[s].y);&#x2F;&#x2F;保存dx&#x2F;dy。也就是y每变化1，x的变化值 for(int y&#x3D;p[s].y;y&lt;p[e].y;y++) &#123; int x&#x3D;(y-p[s].y)*dx+p[s].x;&#x2F;&#x2F;通过y计算x。简单的直线方程 for(int t&#x3D;x;t&lt;&#x3D;max_x;t++) mask[t][y]&#x3D;!mask[t][y]; &#x2F;&#x2F;将此点右边的全取反 &#125; &#125; for(i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) if(mask[i][j]) pDC-&gt;SetPixel(i,j,RGB(100,100,100));&#x2F;&#x2F;将数组中为1的区域涂色 ReleaseDC(pDC); CView::OnLButtonDblClk(nFlags, point);&#125; 5.用任意数字填充首先要生成数字的点阵数组。然后就可以通过区域的周期性来画图。 生成指定数字的点阵数组，利用0~9镜像对称的数组来实现 1234567891011121314151617181920212223242526char a[10][8]&#x3D;&#123; &#123;0x00,0x18,0x24,0x24,0x24,0x24,0x24,0x18&#125;, &#x2F;&#x2F;0 &#123;0x00,0x18,0x1c,0x18,0x18,0x18,0x18,0x18&#125;, &#x2F;&#x2F;1 &#123;0x00,0x1e,0x30,0x30,0x1c,0x06,0x06,0x3e&#125;, &#x2F;&#x2F;2 &#123;0x00,0x1e,0x30,0x30,0x1c,0x30,0x30,0x1e&#125;, &#x2F;&#x2F;3 &#123;0x00,0x30,0x38,0x34,0x32,0x3e,0x30,0x30&#125;, &#x2F;&#x2F;4 &#123;0x00,0x1e,0x02,0x1e,0x30,0x30,0x30,0x1e&#125;, &#x2F;&#x2F;5 &#123;0x00,0x1c,0x06,0x1e,0x36,0x36,0x36,0x1c&#125;, &#x2F;&#x2F;6 &#123;0x00,0x3f,0x30,0x18,0x18,0x0c,0x0c,0x0c&#125;, &#x2F;&#x2F;7 &#123;0x00,0x1c,0x36,0x36,0x1c,0x36,0x36,0x1c&#125;, &#x2F;&#x2F;8 &#123;0x00,0x1c,0x36,0x36,0x36,0x3c,0x30,0x1c&#125;, &#x2F;&#x2F;9&#125;;&#x2F;&#x2F;数字的镜像对称数组，每个数字用8行8列的01表示，每一行看做一个8位二进制void Creat_array(int n,bool dianzhen[8][32])&#x2F;&#x2F;得到要显示四个数字的点阵数组&#123; int num[4]; for(int i&#x3D;3;i&gt;&#x3D;0;i--,n&#x2F;&#x3D;10)&#x2F;&#x2F;将这四位数放到数组中 num[i]&#x3D;n%10; for(i&#x3D;0;i&lt;8;i++)&#x2F;&#x2F;一共8行，每行显示4*8&#x3D;32个0或1 for(int j&#x3D;0;j&lt;4;j++) &#123; int x&#x3D;a[num[j]][i];&#x2F;&#x2F;得到num[j]对应的数字点阵的第i行二进制串 for(int k&#x3D;0;k&lt;8;k++,x&#x2F;&#x3D;2)&#x2F;&#x2F;依次得到二进制串的每一位 dianzhen[i][j*8+k]&#x3D;x%2?1:0;&#x2F;&#x2F;组合成指定数字的点阵数组 &#125; &#125; 利用区域的周期性填充区域 12345for(i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) if(mask[i][j]) pDC-&gt;SetPixel(i,j,(dianzhen[j%8][i%32])?RGB(230,0,0):RGB(255,255,255)); &#x2F;&#x2F;将数组中为1的区域打印成点阵数字 6.最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114int number&#x3D;1357;&#x2F;&#x2F;要显示的数字，必须填四位int max_x,max_y,min_x,min_y;&#x2F;&#x2F;多边形的矩形区域bool flag1&#x3D;0,flag&#x3D;0;&#x2F;&#x2F;flag1控制只进行一次画多边形，flag控制存放起点CPoint p[100];&#x2F;&#x2F;保存顶点数组，填充需要int n&#x3D;0;&#x2F;&#x2F;表示多边形顶点的的个数bool mask[1000][1000],dianzhen[8][32];char a[10][8]&#x3D;&#123; &#123;0x00,0x18,0x24,0x24,0x24,0x24,0x24,0x18&#125;, &#x2F;&#x2F;0 &#123;0x00,0x18,0x1c,0x18,0x18,0x18,0x18,0x18&#125;, &#x2F;&#x2F;1 &#123;0x00,0x1e,0x30,0x30,0x1c,0x06,0x06,0x3e&#125;, &#x2F;&#x2F;2 &#123;0x00,0x1e,0x30,0x30,0x1c,0x30,0x30,0x1e&#125;, &#x2F;&#x2F;3 &#123;0x00,0x30,0x38,0x34,0x32,0x3e,0x30,0x30&#125;, &#x2F;&#x2F;4 &#123;0x00,0x1e,0x02,0x1e,0x30,0x30,0x30,0x1e&#125;, &#x2F;&#x2F;5 &#123;0x00,0x1c,0x06,0x1e,0x36,0x36,0x36,0x1c&#125;, &#x2F;&#x2F;6 &#123;0x00,0x3f,0x30,0x18,0x18,0x0c,0x0c,0x0c&#125;, &#x2F;&#x2F;7 &#123;0x00,0x1c,0x36,0x36,0x1c,0x36,0x36,0x1c&#125;, &#x2F;&#x2F;8 &#123;0x00,0x1c,0x36,0x36,0x36,0x3c,0x30,0x1c&#125;, &#x2F;&#x2F;9&#125;;&#x2F;&#x2F;数字的镜像对称数组，每个数字用8行8列的01表示，每一行看做一个8位二进制void CShiyan2View::OnLButtonDown(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;如果多边形已经绘制完成，再次点击则不会响应 &#123; if(!flag)&#123; max_x&#x3D;min_x&#x3D;point.x;&#x2F;&#x2F;初始化最开始的矩形区域为第一个点的横纵坐标 max_y&#x3D;min_y&#x3D;point.y; flag&#x3D;1; p[n++]&#x3D;point; &#125; else &#123; if(point.x&gt;max_x)&#x2F;&#x2F;更新矩形区域的坐标 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); p[n++]&#x3D;point; &#125; &#125; ReleaseDC(pDC); CView::OnLButtonDown(nFlags, point);&#125;void Creat_array(int n,bool dianzhen[8][32])&#x2F;&#x2F;得到要显示四个数字的点阵数组&#123; int num[4]; for(int i&#x3D;3;i&gt;&#x3D;0;i--,n&#x2F;&#x3D;10)&#x2F;&#x2F;将这四位数放到数组中 num[i]&#x3D;n%10; for(i&#x3D;0;i&lt;8;i++)&#x2F;&#x2F;一共8行，每行显示4*8&#x3D;32个0或1 for(int j&#x3D;0;j&lt;4;j++) &#123; int x&#x3D;a[num[j]][i];&#x2F;&#x2F;得到num[j]对应的数字点阵的第i行二进制串 for(int k&#x3D;0;k&lt;8;k++,x&#x2F;&#x3D;2)&#x2F;&#x2F;依次得到二进制串的每一位 dianzhen[i][j*8+k]&#x3D;x%2?1:0;&#x2F;&#x2F;组合成指定数字的点阵数组 &#125; &#125;void CShiyan2View::OnLButtonDblClk(UINT nFlags, CPoint point) &#123; &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default CDC* pDC&#x3D;GetDC(); if(!flag1)&#x2F;&#x2F;只有没有绘制完成才会对双击进行响应 &#123; if(point.x&gt;max_x)&#x2F;&#x2F;此为最后一个顶点，同样需要更新矩形区域 max_x&#x3D;point.x; if(point.x&lt;min_x) min_x&#x3D;point.x; if(point.y&gt;max_y) max_y&#x3D;point.y; if(point.y&lt;min_y) min_y&#x3D;point.y; pDC-&gt;MoveTo(p[n-1]); pDC-&gt;LineTo(point); pDC-&gt;MoveTo(point); pDC-&gt;LineTo(p[0]); flag1&#x3D;1;&#x2F;&#x2F;表示多边形已经绘制完成 p[n++]&#x3D;point; p[n]&#x3D;p[0];&#x2F;&#x2F;此处将首尾相连，方便得到边的信息 &#125; &#x2F;&#x2F;填充部分 for(int i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) mask[i][j]&#x3D;0;&#x2F;&#x2F;将数组全置0 for(i&#x3D;0;i&lt;n;i++)&#x2F;&#x2F;处理每一条边 &#123; int s&#x3D;p[i].y&lt;p[i+1].y?i:i+1;&#x2F;&#x2F;s保存的是较小y点的下标，e保存y较大的点的下标 int e&#x3D;2*i+1-s;&#x2F;&#x2F;由于起点终点的下标一个是i,一个是i+1，和为2*i+1，所以可以通过s计算e double dx&#x3D;(p[e].x-p[s].x)&#x2F;double(p[e].y-p[s].y);&#x2F;&#x2F;保存dx&#x2F;dy。也就是y每变化1，x的变化值 for(int y&#x3D;p[s].y;y&lt;p[e].y;y++) &#123; int x&#x3D;(y-p[s].y)*dx+p[s].x;&#x2F;&#x2F;通过y计算x。简单的直线方程 for(int t&#x3D;x+1;t&lt;&#x3D;max_x;t++) mask[t][y]&#x3D;!mask[t][y]; &#x2F;&#x2F;将此点右边的全取反 &#125; &#125; Creat_array(number,dianzhen); for(i&#x3D;min_x;i&lt;&#x3D;max_x;i++) for(int j&#x3D;min_y;j&lt;&#x3D;max_y;j++) if(mask[i][j]) pDC-&gt;SetPixel(i,j,(dianzhen[j%8][i%32])?RGB(230,0,0):RGB(255,255,255)); &#x2F;&#x2F;将数组中为1的区域打印成点阵数字 ReleaseDC(pDC); CView::OnLButtonDblClk(nFlags, point);&#125;","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://donghuangzhong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"多边形填充","slug":"计算机图形学/多边形填充","permalink":"https://donghuangzhong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%A1%AB%E5%85%85/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"MFC","slug":"MFC","permalink":"https://donghuangzhong.github.io/tags/MFC/"}]},{"title":"蓝桥杯2018第九届省赛解题报告","slug":"蓝桥杯2018第九届省赛解题报告","date":"2020-04-14T00:39:21.000Z","updated":"2020-04-14T01:23:57.177Z","comments":true,"path":"2020/04/14/蓝桥杯2018第九届省赛解题报告/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/14/%E8%93%9D%E6%A1%A5%E6%9D%AF2018%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%9C%81%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"摘要","text":"摘要 第一题 标题：分数1/1 + 1/2 + 1/4 + 1/8 + 1/16 + …. 每项是前一项的一半，如果一共有20项,求这个和是多少，结果用分数表示出来。分子分母要求互质。 解题思路求和找最大公约数 答案：1048575/524288 （选中或复制后查看，下同） 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int gcd(int a,int b)&#123; return b&#x3D;&#x3D;0?a:gcd(b,a%b); &#125;int main()&#123;&#x2F;&#x2F; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int factor&#x3D;gcd((1&lt;&lt;20)-1,1&lt;&lt;19); cout&lt;&lt;(((1&lt;&lt;20)-1)&#x2F;factor)&lt;&lt;&quot;&#x2F;&quot;&lt;&lt;(1&lt;&lt;19)&#x2F;factor&lt;&lt;endl; return 0;&#125; 第二题 标题：星期一整个20世纪（1901年1月1日至2000年12月31日之间），一共有多少个星期一？ 解题思路找最后一个周一(可以查日历也可以算)，剩余天数除以7。但是因为最后一天是周日，所以可以直接除以7，有几个完整的星期就有几个周一。 答案5217 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int count_day(int year,int month,int day)&#123; int day_sum&#x3D;0; _for(i,1,month-1) &#123; if(i&#x3D;&#x3D;2) &#123; if((year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0)||year%400&#x3D;&#x3D;0) day_sum+&#x3D;29; else day_sum+&#x3D;28; &#125; else if(i&#x3D;&#x3D;4||i&#x3D;&#x3D;6||i&#x3D;&#x3D;9||i&#x3D;&#x3D;11) day_sum+&#x3D;30; else day_sum+&#x3D;31; &#125; return day_sum+day;&#125;int main()&#123; int y,m,d; &#x2F;&#x2F;while(cin&gt;&gt;y&gt;&gt;m&gt;&gt;d&amp;&amp;y) &#x2F;&#x2F; cout&lt;&lt;count_day(y,m,d); int sum_2001&#x3D;count_day(2020,4,5); _for(i,2001,2019) sum_2001+&#x3D;count_day(i,12,31); sum_2001%&#x3D;7; int zhou&#x3D;(0-sum_2001)%7+1; cout&lt;&lt;&quot;2001&#x2F;01&#x2F;01:&quot;&lt;&lt;zhou&lt;&lt;endl; int sum_21&#x3D;0; _for(i,1901,2000) sum_21+&#x3D;count_day(i,12,31); cout&lt;&lt;&quot;21 century:&quot;&lt;&lt;sum_21&lt;&lt;endl; cout&lt;&lt;&quot;answer:&quot;&lt;&lt;sum_21&#x2F;7&lt;&lt;endl; return 0;&#125; 第三题 标题：乘积尾零如下的10行数据，每行有10个整数，请你求出它们的乘积的末尾有多少个零？ 5650 4542 3554 473 946 4114 3871 9073 90 4329 2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 1486 5722 3135 1170 4014 5510 5120 729 2880 9019 2049 698 4582 4346 4427 646 9742 7340 1230 7683 5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 6701 6645 1671 5978 2704 9926 295 3125 3878 6785 2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 689 5510 8243 6114 337 4096 8199 7313 3685 211 注意：需要提交的是一个整数，表示末尾零的个数。不要填写任何多余内容。 解题思路求因数中2和5的总数的最小值 答案31 12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,factor_2&#x3D;0,factor_5&#x3D;0; while(cin&gt;&gt;n) &#123; while(n%2&#x3D;&#x3D;0) n&#x2F;&#x3D;2,factor_2++; while(n%5&#x3D;&#x3D;0) n&#x2F;&#x3D;5,factor_5++; &#125; cout&lt;&lt;min(factor_2,factor_5); return 0;&#125; 第四题 标题：第几个幸运数到x星球旅行的游客都被发给一个整数，作为游客编号。x星的国王有个怪癖，他只喜欢数字3,5和7。国王规定，游客的编号如果只含有因子：3,5,7,就可以获得一份奖品。 我们来看前10个幸运数字是：3 5 7 9 15 21 25 27 35 45。 因而第11个幸运数字是：49 小明领到了一个幸运数字 59084709587505，他去领奖的时候，人家要求他准确地说出这是第几个幸运数字，否则领不到奖品。 请你帮小明计算一下，59084709587505是第几个幸运数字。需要提交的是一个整数，请不要填写任何多余内容。 解题思路三种思路， 答案1905","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"category2","slug":"ACM/category2","permalink":"https://donghuangzhong.github.io/categories/ACM/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"洛谷_P1233 木棍加工","slug":"洛谷-P1233-木棍加工","date":"2020-04-07T04:03:48.000Z","updated":"2020-04-07T04:03:48.289Z","comments":true,"path":"2020/04/07/洛谷-P1233-木棍加工/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/07/%E6%B4%9B%E8%B0%B7-P1233-%E6%9C%A8%E6%A3%8D%E5%8A%A0%E5%B7%A5/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"洛谷_P4933 大师","slug":"洛谷-P4933-大师","date":"2020-04-06T10:11:06.000Z","updated":"2020-04-06T10:23:40.706Z","comments":true,"path":"2020/04/06/洛谷-P4933-大师/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P4933-%E5%A4%A7%E5%B8%88/","excerpt":"DP关键的是设状态。","text":"DP关键的是设状态。 题目题目背景建筑大师最近在跟着数学大师ljt12138学数学，今天他学了等差数列，ljt12138决定给他留一道练习题。 题目描述ljt12138首先建了n个特斯拉电磁塔，这些电塔排成一排，从左到右依次标号为1到n，第i个电塔的高度为h[i]。 建筑大师需要从中选出一些电塔，然后这些电塔就会缩到地下去。这时候，如果留在地上的电塔的高度，从左向右构成了一个等差数列，那么这个选择方案就会被认为是美观的。 建筑大师需要求出，一共有多少种美观的选择方案，答案模998244353。 注意，如果地上只留了一个或者两个电塔，那么这种方案也是美观的。地上没有电塔的方案被认为是不美观的。 输入格式第一行一个正整数n。 第二行n个非负整数，第i个整数是第i个电塔的高度h[i]。 输出格式输出一个整数，表示美观的方案数模998244353的值。 输入输出样例输入 #1复制 12813 14 6 20 27 34 34 41 输出 #1复制 150 输入 #2复制 1210090 1004 171 99 1835 108 81 117 141 126 135 144 81 153 193 81 962 162 1493 171 1780 864 297 180 532 1781 189 1059 198 333 1593 824 207 1877 216 270 225 1131 336 1875 362 234 81 288 1550 243 463 1755 252 406 261 270 279 288 1393 261 1263 297 135 333 872 234 881 180 198 81 225 306 180 90 315 81 81 198 252 81 297 1336 1140 1238 81 198 297 661 81 1372 469 1132 81 126 324 333 342 81 351 481 279 1770 1225 549 输出 #2复制 111153 说明/提示我们用v表示最高的电塔高度。 对于前30%的数据，n&lt;=20。 对于前60%的数据，n&lt;=100，v&lt;=2000。 对于另外20%的数据，所有电塔的高度构成一个等差数列。 对于100%的数据，n&lt;=1000，v&lt;=20000。 算法用dp[i][a[i]-a[j]+20002]表示以i点为结束公差为a[i]-a[j]的数列，加上20002是因为a[i]-a[j]最小为0-20000,为了避免出现负数，注意ans不可以加上dp[i][a[i]-a[j]+20002]，因为会出现相同塔高的塔，会重复加这些塔 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int dp[1001][40002];int a[1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; long long ans&#x3D;0; _for(i,1,n)cin&gt;&gt;a[i]; _for(i,2,n) for(int j&#x3D;i-1;j&gt;&#x3D;1;j--) &#123; dp[i][a[i]-a[j]+20002]&#x3D;(dp[i][a[i]-a[j]+20002]+dp[j][a[i]-a[j]+20002]+1)%998244353; ans&#x3D;(ans+dp[j][a[i]-a[j]+20002]+1)%998244353; &#125; ans&#x3D;(ans+n)%998244353; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"W","slug":"W","permalink":"https://donghuangzhong.github.io/tags/W/"},{"name":"设状态","slug":"设状态","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%BE%E7%8A%B6%E6%80%81/"}]},{"title":"洛谷_P1040 加分二叉树","slug":"洛谷-P1040-加分二叉树","date":"2020-04-06T08:02:34.000Z","updated":"2020-04-06T08:06:20.849Z","comments":true,"path":"2020/04/06/洛谷-P1040-加分二叉树/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P1040-%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"设计好状态就行，可以用dp也可以用记忆dfs","text":"设计好状态就行，可以用dp也可以用记忆dfs 题目题目描述设一个nn个节点的二叉树tree的中序遍历为（1,2,3,…,n1,2,3,…,n），其中数字1,2,3,…,n1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第ii个节点的分数为di,treed**i,t*ree及它的每个子树都有一个加分，任一棵子树subtreesubtree（也包含treetre*e本身）的加分计算方法如下： subtrees*ubtree的左子树的加分× subtreesubtree的右子树的加分＋subtreesubtre*e的根的分数。 若某个子树为空，规定其加分为11，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n1,2,3,…,n）且加分最高的二叉树treet*ree*。要求输出； （1）treet*ree*的最高加分 （2）treet*ree*的前序遍历 输入格式第11行：11个整数n(n&lt;30)n(n&lt;30)，为节点个数。 第22行：nn个用空格隔开的整数，为每个节点的分数（分数&lt;100&lt;100）。 输出格式第11行：11个整数，为最高加分（Ans \\le 4,000,000,000≤4,000,000,000）。 第22行：nn个用空格隔开的整数，为该树的前序遍历。 输入输出样例输入 #1复制 1255 7 1 2 10 输出 #1复制 121453 1 2 4 5 算法记忆dfs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,a[31],root[31][31],mem[31][31];int dfs(int s,int e)&#123; if(mem[s][e]) return mem[s][e]; if(s&gt;e) return 1; if(s&#x3D;&#x3D;e) return a[s]; int maxx&#x3D;-1; _for(i,s,e) &#123; int t&#x3D;(dfs(s,i-1)*dfs(i+1,e)+a[i]); if(t&gt;maxx) &#123; maxx&#x3D;t; root[s][e]&#x3D;i; &#125; &#125; return mem[s][e]&#x3D;maxx;&#125; void p(int s,int e)&#123; if(s&gt;e) return ; if(s&#x3D;&#x3D;e) &#123; cout&lt;&lt;e&lt;&lt;&quot; &quot;; return ; &#125; cout&lt;&lt;root[s][e]&lt;&lt;&quot; &quot;; p(s,root[s][e]-1); p(root[s][e]+1,e);&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) cin&gt;&gt;a[i]; cout&lt;&lt;dfs(1,n)&lt;&lt;endl; p(1,n); return 0;&#125; DP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,a[31],root[31][31],dp[31][31];void p(int s,int e)&#123; if(s&gt;e) return ; if(s&#x3D;&#x3D;e) &#123; cout&lt;&lt;e&lt;&lt;&quot; &quot;; return ; &#125; cout&lt;&lt;root[s][e]&lt;&lt;&quot; &quot;; p(s,root[s][e]-1); p(root[s][e]+1,e);&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) cin&gt;&gt;a[i];&#x2F;&#x2F; dp[i][j]&#x3D;max(dp[i][k-1]*dp[k+1][j]+a[i]); _for(i,1,n)&#123;dp[i][i]&#x3D;a[i];dp[i][i-1]&#x3D;1;&#125; for(int i&#x3D;n;i&gt;&#x3D;1;i--) &#123; for(int j&#x3D;i+1;j&lt;&#x3D;n;j++) &#123; for(int k&#x3D;i;k&lt;&#x3D;j;k++) &#123; if(dp[i][j]&lt;dp[i][k-1]*dp[k+1][j]+a[k]) &#123; dp[i][j]&#x3D;dp[i][k-1]*dp[k+1][j]+a[k]; root[i][j]&#x3D;k; &#125; &#125; &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; p(1,n); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"记忆化dfs","slug":"记忆化dfs","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96dfs/"}]},{"title":"洛谷_P2758 编辑距离","slug":"洛谷-P2758-编辑距离","date":"2020-04-06T02:48:15.000Z","updated":"2020-04-06T03:15:15.039Z","comments":true,"path":"2020/04/06/洛谷-P2758-编辑距离/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P2758-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","excerpt":"DP精髓：不确定性就是DP范围。其实DP就是记忆化递归。","text":"DP精髓：不确定性就是DP范围。其实DP就是记忆化递归。 题目题目描述设A和B是两个字符串。我们要用最少的字符操作次数，将字符串A转换为字符串B。这里所说的字符操作共有三种： 1、删除一个字符； 2、插入一个字符； 3、将一个字符改为另一个字符； ！皆为小写字母！ 输入格式第一行为字符串A；第二行为字符串B；字符串A和B的长度均小于2000。 输出格式只有一个正整数，为最少字符操作次数。 输入输出样例输入 #1复制 12sfdqxbwgfdgw 输出 #1复制 14 算法普通二维数组dp[i][j]表示的是将第一个串s1前i个字符变为第二个串s2的前j个字符的最少操作次数，那么如果s1[i]==s2[j]，那么无需对s1[i]操作，将s1前i字符转换为s2前j字符的操作次数就是将s1前i-1字符转换为s2前j-1字符的操作次数，即dp[i][j]=dp[i-1][j-1]。如果s1[i]!=s2[j]那么就需要对s1[i]进行操作，操作的目的是将第一个串s1前i个字符变为第二个串s2的前j个字符，操作有三种 1.删去s1[i]，将s1前i-1字符变为s2前j字符，dp[i][j]=dp[i-1][j]+1 2.插入，将s1前i字符变为s2前j-1字符dp[i][j]=dp[i][j-1]+1 3.替换，将s1前i-1字符变为s2前j-1字符 dp[i][j]=dp[i-1][j]+1 取最小值 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int dp[2001][2001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; for(int i&#x3D;0;i&lt;&#x3D;s1.length();i++) dp[i][0]&#x3D;i; for(int j&#x3D;0;j&lt;&#x3D;s2.length();j++) dp[0][j]&#x3D;j; _for(i,1,s1.length()) _for(j,1,s2.length()) &#123; if(s1[i-1]&#x3D;&#x3D;s2[j-1]) dp[i][j]&#x3D;dp[i-1][j-1]; else dp[i][j]&#x3D;min(min(dp[i-1][j]+1,dp[i][j-1]+1),dp[i-1][j-1]+1); &#125; cout&lt;&lt;dp[s1.length()][s2.length()]&lt;&lt;endl; _for(i,0,s1.length()) &#123; _for(j,0,s2.length()) &#123; cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 滚动数组观察到计算i行只需要i、i-1行，所以可以改造成滚动数组 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int dp[2][2001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; for(int i&#x3D;0;i&lt;&#x3D;s2.length();i++) dp[0][i]&#x3D;i; bool index; _for(i,1,s1.length()) &#123; index&#x3D;i&amp;1; dp[index][0]&#x3D;i; _for(j,1,s2.length()) &#123; if(s1[i-1]&#x3D;&#x3D;s2[j-1]) dp[index][j]&#x3D;dp[1-index][j-1]; else dp[index][j]&#x3D;min(min(dp[1-index][j]+1,dp[index][j-1]+1),dp[1-index][j-1]+1); &#125; &#125; cout&lt;&lt;dp[index][s2.length()]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"滚动数组","slug":"滚动数组","permalink":"https://donghuangzhong.github.io/tags/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"}]},{"title":"洛谷_P1280 尼克的任务","slug":"洛谷-P1280-尼克的任务","date":"2020-04-06T00:03:27.000Z","updated":"2020-04-06T00:24:51.737Z","comments":true,"path":"2020/04/06/洛谷-P1280-尼克的任务/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P1280-%E5%B0%BC%E5%85%8B%E7%9A%84%E4%BB%BB%E5%8A%A1/","excerpt":"当前时间点只有一个任务时，必须选择这个任务。当前时间点有多个任务时，选择哪个任务取决于哪个任务结束的时候有更多的空闲时间。假设当前有多个任务，开始的时间是s，结束的时间是e1,e2,e3。选择哪一个任务取决于开始时间是e1,e2,e3的时候一直到最后哪个剩余的空闲时间多。以所有的起点为基准，dp[i]表示以i为起点的时候剩余的空闲时间。那么dp[i]=max(end-start+dp[strat])，i是当前的起点，end是当前的终点，start是终点后面第一个起点。从后向前算，起点和终点好说，怎么找终点后面的第一个起点，遍历的话是k,二分查找的话是logn","text":"当前时间点只有一个任务时，必须选择这个任务。当前时间点有多个任务时，选择哪个任务取决于哪个任务结束的时候有更多的空闲时间。假设当前有多个任务，开始的时间是s，结束的时间是e1,e2,e3。选择哪一个任务取决于开始时间是e1,e2,e3的时候一直到最后哪个剩余的空闲时间多。以所有的起点为基准，dp[i]表示以i为起点的时候剩余的空闲时间。那么dp[i]=max(end-start+dp[strat])，i是当前的起点，end是当前的终点，start是终点后面第一个起点。从后向前算，起点和终点好说，怎么找终点后面的第一个起点，遍历的话是k,二分查找的话是logn 题目题目描述尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 尼克的一个工作日为 nn 分钟，从第 11 分钟开始到第 nn 分钟结束。当尼克到达单位后他就开始干活，公司一共有 kk 个任务需要完成。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第 pp 分钟开始，持续时间为 tt 分钟，则该任务将在第 (p+t-1)(p+t−1) 分钟结束。 写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。 输入格式输入数据第一行含两个用空格隔开的整数 nn 和 kk。 接下来共有 kk 行，每一行有两个用空格隔开的整数 pp 和 tt，表示该任务从第 pp 分钟开始，持续时间为 tt 分钟。 输出格式输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。 输入输出样例输入 #1复制 123456715 61 21 64 118 58 111 5 输出 #1复制 14 说明/提示数据规模与约定 对于 100%100% 的数据，保证 1 \\leq n \\leq 10^4,1 \\leq k \\leq 10^4,1 \\leq p \\leq n,1 \\leq p+t-1 \\leq n1≤n≤104,1≤k≤104,1≤p≤n,1≤p+t−1≤n。 算法为了方便把1看成一个起点为1终点为1的时间段 vector(k*n)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct Time&#123; int s,e;&#125;;vector&lt;Time&gt; v;int dp[10001];int n,k,end;int get(int e)&#123; _for(j,1,v.size()-1) &#123; if(v[j].s&gt;&#x3D;e) return v[j].s; &#125; return n;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;k; n++; v.push_back(&#123;1,1&#125;); _for(i,1,k) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; v.push_back(&#123;s,e+s&#125;); &#125; for(int i&#x3D;v.size()-1;i&gt;&#x3D;0;i--) &#123; int j&#x3D;i,maxx&#x3D;-1; while(v[j].s&#x3D;&#x3D;v[i].s) &#123; int start&#x3D;get(v[j].e); maxx&#x3D;max(maxx,start-v[j].e+dp[start]); j--; &#125; dp[v[i].s]&#x3D;maxx; i&#x3D;j+1; &#125; cout&lt;&lt;dp[1]; return 0;&#125; 结构体+二分查找(k*lgn)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct Time&#123; int s,e;&#125; v[10005];int dp[10005];int a[10005];int n,k,end;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;k; n++; int len&#x3D;0; v[0].s&#x3D;1; v[0].e&#x3D;1; _for(i,1,k) &#123; int s,t; cin&gt;&gt;s&gt;&gt;t; v[i].s&#x3D;s; v[i].e&#x3D;s+t; if(s!&#x3D;a[len]) &#123; a[++len]&#x3D;s; &#125; &#125; a[++len]&#x3D;n; for(int i&#x3D;k;i&gt;&#x3D;0;i--) &#123; int j&#x3D;i,maxx&#x3D;-1; while(v[j].s&#x3D;&#x3D;v[i].s) &#123; int start&#x3D;*lower_bound(a+1,a+len+1,v[j].e); maxx&#x3D;max(maxx,start-v[j].e+dp[start]); j--; &#125; dp[v[i].s]&#x3D;maxx; i&#x3D;j+1; &#125; cout&lt;&lt;dp[1]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"二分查找(大小于)","slug":"二分查找-大小于","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%A4%A7%E5%B0%8F%E4%BA%8E/"}]},{"title":"洛谷_P1439 【模板】最长公共子序列","slug":"洛谷-P1439-【模板】最长公共子序列","date":"2020-04-05T23:50:50.000Z","updated":"2020-04-06T00:04:23.449Z","comments":true,"path":"2020/04/06/洛谷-P1439-【模板】最长公共子序列/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/06/%E6%B4%9B%E8%B0%B7-P1439-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"可以用通用m*n算法。由于这两个序列都是全排列的一种，假设这两串数字分别是s1,s2。将s1的元素从第一个开始全部表示为a,b,c……。将s2中对应的数字也变为字母。比如s1:3,2,1，s2:2,3,1。将3替换为a，2替换为b，1替换为c。s1变为a,b,c。s2变为b,a,c。最长公共子序列的长度不变，现在的问题就变成了求a,b,c和b,c,a中的最长公共子序列。于是就可以转换为求最长递增子序列的长度。","text":"可以用通用m*n算法。由于这两个序列都是全排列的一种，假设这两串数字分别是s1,s2。将s1的元素从第一个开始全部表示为a,b,c……。将s2中对应的数字也变为字母。比如s1:3,2,1，s2:2,3,1。将3替换为a，2替换为b，1替换为c。s1变为a,b,c。s2变为b,a,c。最长公共子序列的长度不变，现在的问题就变成了求a,b,c和b,c,a中的最长公共子序列。于是就可以转换为求最长递增子序列的长度。 题目题目描述给出 1,2,\\ldots,n1,2,…,n 的两个排列 P_1P1 和 P_2P2 ，求它们的最长公共子序列。 输入格式第一行是一个数 nn。 接下来两行，每行为 nn 个数，为自然数 1,2,\\ldots,n1,2,…,n 的一个排列。 输出格式一个数，即最长公共子序列的长度。 输入输出样例输入 #1复制 1235 3 2 1 4 51 2 3 4 5 输出 #1复制 13 说明/提示 对于 50%50% 的数据， n \\le 10^3n≤103； 对于 100%100% 的数据， n \\le 10^5n≤105。 算法通用算法m*n123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)#define N 10001using namespace std;int lcs[N][N];int a[N];int b[N];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); &#x2F;&#x2F;lcs[i][j]&#x3D;lcs[i-1][j-1]+1; a[i]&#x3D;&#x3D;b[i] &#x2F;&#x2F;lcs[i][j]&#x3D;max(lcs[i][j-1],lcs[i-1][j]); int n; cin&gt;&gt;n; _for(i,1,n) cin&gt;&gt;a[i]; _for(i,1,n) cin&gt;&gt;b[i]; _for(i,1,n) _for(j,1,n) &#123; if(a[i]&#x3D;&#x3D;b[i]) lcs[i][j]&#x3D;lcs[i-1][j-1]+1; else lcs[i][j]&#x3D;max(lcs[i][j-1],lcs[i-1][j]); &#125; cout&lt;&lt;lcs[n][n]; return 0;&#125; 最长上升子序列nlogn123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)#define N 100001int a[N],b[N],c[N];using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) &#123; cin&gt;&gt;a[i]; c[a[i]]&#x3D;i; &#125; _for(i,1,n) cin&gt;&gt;a[i]; int len&#x3D;0; _for(i,1,n) &#123; if(c[a[i]]&gt;b[len]) b[++len]&#x3D;c[a[i]]; else *upper_bound(b+1,b+len+1,c[a[i]])&#x3D;c[a[i]]; &#125; cout&lt;&lt;len; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"最长公共子序列","slug":"最长公共子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"最长上升子序列","slug":"最长上升子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"}]},{"title":"洛谷_P1020 导弹拦截","slug":"洛谷-P1020-导弹拦截","date":"2020-04-04T07:12:04.000Z","updated":"2020-04-04T08:34:20.073Z","comments":true,"path":"2020/04/04/洛谷-P1020-导弹拦截/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/04/%E6%B4%9B%E8%B0%B7-P1020-%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/","excerpt":"第一问一眼能看出是求最大单调非递增序列；第二问可以用Dilworth定理：最长x的子序列链的个数等于最长!X链的长度。或者这么考虑，问的是最少的导弹系统的个数，所以如果用x1,x2,……xn表示导弹系统1，2，……n现在可以到达的高度，其中x1,x2……xn互不相同，假设x1=1,x2=2,现在来了一个高度为1的导弹，肯定用x1来击落它，不会浪费高的导弹系统。所以它们互不相同。对于每一个新导弹系统击落的第一个导弹来说，x1,x2,……xn都比这个导弹的高度低(如果高的话就不会动用新的导弹系统)，所以最少导弹系统的个数一定是一个上升子序列的长度。考虑到如果存在一个最长的单调递增子序列，每个元素都需要一个新的导弹系统，所以新的导弹系统的个数最少是最长上升子序列的长度，又因为最少导弹系统的个数一定是一个上升子序列的长度，所以新的导弹系统的个数就是最长上升子序列的长度。","text":"第一问一眼能看出是求最大单调非递增序列；第二问可以用Dilworth定理：最长x的子序列链的个数等于最长!X链的长度。或者这么考虑，问的是最少的导弹系统的个数，所以如果用x1,x2,……xn表示导弹系统1，2，……n现在可以到达的高度，其中x1,x2……xn互不相同，假设x1=1,x2=2,现在来了一个高度为1的导弹，肯定用x1来击落它，不会浪费高的导弹系统。所以它们互不相同。对于每一个新导弹系统击落的第一个导弹来说，x1,x2,……xn都比这个导弹的高度低(如果高的话就不会动用新的导弹系统)，所以最少导弹系统的个数一定是一个上升子序列的长度。考虑到如果存在一个最长的单调递增子序列，每个元素都需要一个新的导弹系统，所以新的导弹系统的个数最少是最长上升子序列的长度，又因为最少导弹系统的个数一定是一个上升子序列的长度，所以新的导弹系统的个数就是最长上升子序列的长度。 题目题目描述 某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度（雷达给出的高度数据是\\le 50000≤50000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入格式11行，若干个整数（个数\\le 100000≤100000） 输出格式22行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出样例输入 #1复制 1389 207 155 300 299 170 158 65 输出 #1复制 1262 说明/提示为了让大家更好地测试n方算法，本题开启spj，n方100分，nlogn200分 每点两问，按问给分 算法DP（n2）a数组存数据，b[i]/r[i]表示以a[i]结尾(包括a[i])的最大非上升/上升子序列的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int a[100001];int b[100001];int r[100001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int c&#x3D;0,ans&#x3D;0,rans&#x3D;0; while(cin&gt;&gt;a[c++]) &#123; int he&#x3D;0; for(int i&#x3D;c-1;i&gt;&#x3D;0;i--) &#123; if(a[i]&gt;a[c-1]) &#123; he&#x3D;max(he,b[i]); &#125; &#125; b[c-1]&#x3D;he+1; ans&#x3D;max(ans,b[c-1]); he&#x3D;0; for(int i&#x3D;c-1;i&gt;&#x3D;0;i--) &#123; if(a[i]&lt;a[c-1]) &#123; he&#x3D;max(he,r[i]); &#125; &#125; r[c-1]&#x3D;he+1; rans&#x3D;max(rans,r[c-1]); &#125;cout&lt;&lt;ans&lt;&lt;endl;cout&lt;&lt;rans; return 0;&#125; DP+二分查找a数组存数据，b[i]/r[i]表示长度为i的最大非上升/上升序列的最后一个元素的最大/小值。bs函数可以当做模板，参数（待查找的数组，起点，终点，要比较的数字，op）,op为1/-1表示找小/大于num的第一个数的下标。当然二分查找的前提是数组已经排好序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int a[100001];int b[100001];int r[100001];int bs(int s[],int start,int end,int num,int op)&#123; while(start&lt;&#x3D;end) &#123; int mid&#x3D;(start+end)&#x2F;2; if(op*num&lt;&#x3D;op*s[mid]) start&#x3D;mid+1; else end&#x3D;mid-1; &#125; while(op&#x3D;&#x3D;-1&amp;&amp;s[start-1]&#x3D;&#x3D;num) start--; return start;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int c&#x3D;0,len_b&#x3D;0,len_r&#x3D;0; memset(b,0x3f,sizeof(b)); while(cin&gt;&gt;a[c++]) &#123; int b_index&#x3D;bs(b,0,len_b,a[c-1],1); b[b_index]&#x3D;a[c-1]; if(b_index&gt;len_b) len_b&#x3D;b_index; int r_index&#x3D;bs(r,0,len_r,a[c-1],-1); r[r_index]&#x3D;a[c-1]; if(r_index&gt;len_r) len_r&#x3D;r_index; &#125; cout&lt;&lt;len_b&lt;&lt;endl&lt;&lt;len_r; return 0;&#125; 用STL里面的二分查找1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int a[100001];int b[100001];int r[100001];bool cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int c&#x3D;0,len_b&#x3D;0,len_r&#x3D;0; b[0]&#x3D;0x3f3f3f3f; while(cin&gt;&gt;a[c++]) &#123; if(a[c-1]&lt;&#x3D;b[len_b]) b[++len_b]&#x3D;a[c-1]; else *upper_bound(b+1,b+len_b+1,a[c-1],cmp)&#x3D;a[c-1]; if(a[c-1]&gt;r[len_r]) r[++len_r]&#x3D;a[c-1]; else *lower_bound(r+1,r+1+len_r,a[c-1])&#x3D;a[c-1]; &#125; cout&lt;&lt;len_b&lt;&lt;endl&lt;&lt;len_r; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"二分查找(大小于)","slug":"二分查找-大小于","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%A4%A7%E5%B0%8F%E4%BA%8E/"},{"name":"最长(非)单调子序列","slug":"最长-非-单调子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF-%E9%9D%9E-%E5%8D%95%E8%B0%83%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"Dilworth定理","slug":"Dilworth定理","permalink":"https://donghuangzhong.github.io/tags/Dilworth%E5%AE%9A%E7%90%86/"}]},{"title":"洛谷_P1002 过河卒","slug":"洛谷-P1002-过河卒","date":"2020-04-03T04:22:21.000Z","updated":"2020-04-03T04:25:31.362Z","comments":true,"path":"2020/04/03/洛谷-P1002-过河卒/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/03/%E6%B4%9B%E8%B0%B7-P1002-%E8%BF%87%E6%B2%B3%E5%8D%92/","excerpt":"注意初始化不能直接对起点操作，因为这样就不能判断起点是不是马的控制点。","text":"注意初始化不能直接对起点操作，因为这样就不能判断起点是不是马的控制点。 题目题目描述棋盘上 AA 点有一个过河卒，需要走到目标 BB 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 CC 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。 棋盘用坐标表示，AA 点 (0, 0)(0,0)、BB 点 (n, m)(n,m)，同样马的位置坐标是需要给出的。 现在要求你计算出卒从 AA 点能够到达 BB 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。 输入格式一行四个正整数，分别表示 BB 点坐标和马的坐标。 输出格式一个整数，表示所有的路径条数。 输入输出样例输入 #1复制 16 6 3 3 输出 #1复制 16 说明/提示对于 100 %100% 的数据，1 \\le n, m \\le 201≤n,m≤20，0 \\le0≤ 马的坐标 \\le 20≤20。 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m,horse_x,horse_y;long long map[22][22];int dir[8][2]&#x3D;&#123;1,2,1,-2,-1,2,-1,-2,2,1,2,-1,-2,1,-2,-1&#125;;bool judge(int x,int y)&#123; if(x&#x3D;&#x3D;horse_x&amp;&amp;y&#x3D;&#x3D;horse_y) return 0; _for(i,0,7) &#123; int xx&#x3D;horse_x+dir[i][0]; int yy&#x3D;horse_y+dir[i][1]; if(x&#x3D;&#x3D;xx&amp;&amp;y&#x3D;&#x3D;yy) return 0; &#125; return 1;&#125; int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input1.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m&gt;&gt;horse_x&gt;&gt;horse_y; n++;m++;horse_x++;horse_y++; map[1][0]&#x3D;1; _for(i,1,n) _for(j,1,m) if(judge(i,j)) map[i][j]&#x3D;map[i-1][j]+map[i][j-1]; cout&lt;&lt;map[n][m]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"简单DP","slug":"简单DP","permalink":"https://donghuangzhong.github.io/tags/%E7%AE%80%E5%8D%95DP/"}]},{"title":"洛谷_P1802 5倍经验日","slug":"洛谷-P1802-5倍经验日","date":"2020-04-03T01:31:44.000Z","updated":"2020-04-03T01:36:30.509Z","comments":true,"path":"2020/04/03/洛谷-P1802-5倍经验日/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/03/%E6%B4%9B%E8%B0%B7-P1802-5%E5%80%8D%E7%BB%8F%E9%AA%8C%E6%97%A5/","excerpt":"一个01可不装满背包的变形，注意循环必须[x,cost],然后[0,cost-1]，不然会重复！","text":"一个01可不装满背包的变形，注意循环必须[x,cost],然后[0,cost-1]，不然会重复！ 题目题目背景现在乐斗有活动了！每打一个人可以获得5倍经验！absi2011却无奈的看着那一些比他等级高的好友，想着能否把他们干掉。干掉能拿不少经验的。 题目描述现在absi2011拿出了x个迷你装药物(嗑药打人可耻….)，准备开始与那些人打了 由于迷你装一个只能管一次，所以absi2011要谨慎的使用这些药，悲剧的是，没到达最少打败该人所用的属性药了他打人必输&gt;.&lt;所以他用2个药去打别人，别人却表明3个药才能打过，那么相当于你输了并且这两个属性药浪费了。 现在有n个好友，有输掉拿的经验、赢了拿的经验、要嗑几个药才能打过。求出最大经验（注意，最后要乘以5） 输入格式第一行两个数，n和x 后面n行每行三个数，分别表示输了拿到的经验(lose[i])、赢了拿到的经验(win[i])、打过要至少使用的药数量(use[i])。 输出格式一个整数，最多获得的经验 输入输出样例输入 #1复制 12345676 821 52 121 70 521 48 214 38 314 36 114 36 2 输出 #1复制 11060 说明/提示【Hint】 五倍经验活动的时候，absi2011总是吃体力药水而不是这种属性药&gt;.&lt; 【数据范围】 对于10%的数据，保证x=0 对于30%的数据，保证n&lt;=10,x&lt;=20 对于60%的数据，保证n&lt;=100,x&lt;=100, 10&lt;=lose[i], win[i]&lt;=100,use[i]&lt;=5 对于100%的数据，保证n&lt;=1000,x&lt;=1000,0&lt;lose[i]&lt;=win[i]&lt;=1000000,0&lt;=use[i]&lt;=1000 【题目来源】 fight.pet.qq.com absi2011授权题目 算法12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;long long bag[1001]; int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,x; cin&gt;&gt;n&gt;&gt;x; _for(i,1,n) &#123; long long lose,win,cost; cin&gt;&gt;lose&gt;&gt;win&gt;&gt;cost; for(int j&#x3D;x;j&gt;&#x3D;cost;j--) bag[j]&#x3D;max(bag[j-cost]+win,bag[j]+lose); _for(j,0,cost-1) bag[j]+&#x3D;lose; &#125; cout&lt;&lt;bag[x]*5; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"高阶01背包","slug":"高阶01背包","permalink":"https://donghuangzhong.github.io/tags/%E9%AB%98%E9%98%B601%E8%83%8C%E5%8C%85/"}]},{"title":"洛谷_P1616 疯狂的采药","slug":"洛谷-P1616-疯狂的采药","date":"2020-04-02T10:06:29.000Z","updated":"2020-04-02T11:26:44.831Z","comments":true,"path":"2020/04/02/洛谷-P1616-疯狂的采药/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P1616-%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF/","excerpt":"无限物品的可不满背包","text":"无限物品的可不满背包 题目题目背景此题为NOIP2005普及组第三题的疯狂版。 此题为纪念LiYuxiang而生。 题目描述LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是LiYuxiang，你能完成这个任务吗？ 此题和原题的不同点： 1.每种草药可以无限制地疯狂采摘。 2.药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 输入格式输入第一行有两个整数T（1 &lt;= T &lt;= 100000）和M（1 &lt;= M &lt;= 10000），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到10000之间（包括1和10000）的整数，分别表示采摘某种草药的时间和这种草药的价值。 输出格式输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。 输入输出样例输入 #1复制 123470 371 10069 11 2 输出 #1复制 1140 说明/提示对于30%的数据，M &lt;= 1000； 对于全部的数据，M &lt;= 10000，且M*T&lt;10000000(别数了，7个0)。 加油LiYuxiang，第一个AC留给你！ 算法1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;long long bag[100001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int t,m; cin&gt;&gt;t&gt;&gt;m; _for(i,1,m) &#123; int herb_t,herb_v; cin&gt;&gt;herb_t&gt;&gt;herb_v; for(int j&#x3D;herb_t;j&lt;&#x3D;t;j++) &#123; if(bag[j-herb_t]+herb_v&gt;bag[j]) bag[j]&#x3D;bag[j-herb_t]+herb_v; &#125; &#125; cout&lt;&lt;bag[t]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"无限背包","slug":"无限背包","permalink":"https://donghuangzhong.github.io/tags/%E6%97%A0%E9%99%90%E8%83%8C%E5%8C%85/"}]},{"title":"洛谷_P1048 采药","slug":"洛谷-P1048-采药","date":"2020-04-02T07:21:21.000Z","updated":"2020-04-02T07:24:41.229Z","comments":true,"path":"2020/04/02/洛谷-P1048-采药/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P1048-%E9%87%87%E8%8D%AF/","excerpt":"简单可不装满的01背包，数组初始化全为0","text":"简单可不装满的01背包，数组初始化全为0 题目题目描述辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？ 输入格式第一行有 22 个整数 TT（1 \\le T \\le 10001≤T≤1000）和 MM（1 \\le M \\le 1001≤M≤100），用一个空格隔开，TT 代表总共能够用来采药的时间，MM 代表山洞里的草药的数目。 接下来的 MM 行每行包括两个在 11 到 100100 之间（包括 11 和 100100）的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出格式输出在规定的时间内可以采到的草药的最大总价值。 输入输出样例输入 #1复制 123470 371 10069 11 2 输出 #1复制 13 说明/提示 对于 30%30% 的数据，M \\le 10M≤10； 对于全部的数据，M \\le 100M≤100。 算法1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int bag[1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int t,m; cin&gt;&gt;t&gt;&gt;m; _for(i,1,m) &#123; int herb_t,herb_v; cin&gt;&gt;herb_t&gt;&gt;herb_v; for(int j&#x3D;t;j&gt;&#x3D;herb_t;j--) &#123; if(bag[j-herb_t]+herb_v&gt;bag[j]) bag[j]&#x3D;bag[j-herb_t]+herb_v; &#125; &#125; cout&lt;&lt;bag[t]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"01可不满背包","slug":"01可不满背包","permalink":"https://donghuangzhong.github.io/tags/01%E5%8F%AF%E4%B8%8D%E6%BB%A1%E8%83%8C%E5%8C%85/"}]},{"title":"洛谷_P4017 最大食物链计数","slug":"洛谷-P4017-最大食物链计数","date":"2020-04-02T05:50:09.000Z","updated":"2020-04-02T06:22:52.073Z","comments":true,"path":"2020/04/02/洛谷-P4017-最大食物链计数/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P4017-%E6%9C%80%E5%A4%A7%E9%A3%9F%E7%89%A9%E9%93%BE%E8%AE%A1%E6%95%B0/","excerpt":"本文用了三类方法，加上邻接表和vector的转换，一共写了五个方法，分别是优先队列，记忆dfs+vector，记忆dfs+邻接表，拓扑排序+二维数组，拓扑排序+邻接表","text":"本文用了三类方法，加上邻接表和vector的转换，一共写了五个方法，分别是优先队列，记忆dfs+vector，记忆dfs+邻接表，拓扑排序+二维数组，拓扑排序+邻接表 题目题目背景你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。 题目描述给你一个食物网，你要求出这个食物网中最大食物链的数量。 （这里的“最大食物链”，指的是生物学意义上的食物链，即最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者。） Delia 非常急，所以你只有 11 秒的时间。 由于这个结果可能过大，你只需要输出总数模上 8011200280112002 的结果。 输入格式第一行，两个正整数 n、mn、m，表示生物种类 nn 和吃与被吃的关系数 mm。 接下来 mm 行，每行两个正整数，表示被吃的生物A和吃A的生物B。 输出格式一行一个整数，为最大食物链数量模上 8011200280112002 的结果。 输入输出样例输入 #1复制 123456785 71 21 32 33 52 54 53 4 输出 #1复制 15 说明/提示各测试点满足以下约定： 【补充说明】 数据中不会出现环，满足生物学的要求。（感谢 @AKEE ） 算法优先队列这是我第一个想到的方法，因为这个题目的分类在DP中，想到把边用优先队列按照起点从小到大排序，这样就能满足这样一个转移方程 1sum[a.e]+&#x3D;(v[a.s]&#x3D;&#x3D;0)?1:sum[a.s]; 其中，v[i]=0表示纯起点，因为把边按照起点排序了，所以当前边终点的出度一定为0，起点又分为两种情况，一个是没有入度的(纯起点)，如果这样，sum[终点]应该加1。如果起点是既有入度又有出度的，sum[终点]+=sum[起点]。这个过程中还要改变点的状态，例如1-&gt;2,2标记为终点，然后1-&gt;3,3标记为终点，然后2-&gt;3,2标记为中转点，这样统计所有终点的sum值就可以得到结果。但是现实是残酷的，有500000个边，我估计队列都满了，并且时间效率也不好，失败的算法 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int sum[5001];int v[5001];&#x2F;&#x2F;0新起点，1终点，-1中转点 struct edge&#123; int s,e;&#125;;struct cmp&#123; bool operator()(edge a,edge b) &#123; return a.s&gt;b.s; &#125;&#125;;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,m; priority_queue&lt;edge ,vector&lt;edge&gt;, cmp&gt; q; cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; q.push(&#123;s,e&#125;); &#125; while(!q.empty()) &#123; edge a&#x3D;q.top(); q.pop();&#x2F;&#x2F; sum[a.e]&#x3D;(v[a.s]&#x3D;&#x3D;0)?(sum[a.e]+1):sum[a.s]; if(v[a.s]&#x3D;&#x3D;0) &#123; sum[a.e]++; &#125; else &#123; sum[a.e]+&#x3D;sum[a.s]; if(v[a.s]&#x3D;&#x3D;1) v[a.s]&#x3D;-1; &#125; v[a.e]&#x3D;1; &#125; int ans&#x3D;0; _for(i,1,n) &#123; if(v[i]&#x3D;&#x3D;1) ans+&#x3D;sum[i]; &#125; cout&lt;&lt;ans; return 0;&#125; 记忆dfs如果我们能知道以终点上一个点为终点的食物链数，那么终点的食物链数就是这些点食物链数的和。例如，知道5是其中一个终点，并且已知只有2-&gt;5,4-&gt;5，那么以5位终点的食物链数等于以2为终点的食物链数+以4为终点的食物链数。怎么知道以5为终点的边的起点呢？需要邻接表或者vector，怎么知道5是不是终点呢？需要一个数组标记一下和邻接表或者vector联合判断 记忆dfs+邻接表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct Edge&#123; int start,next;&#125; edge[5000005];int pre[5005];int num[5005];bool des[5005];int dfs(int e)&#123; if(!pre[e]) return 1; if(num[e]) return num[e]; int summ&#x3D;0; for(int i&#x3D;pre[e];i;i&#x3D;edge[i].next) &#123; summ+&#x3D;dfs(edge[i].start); summ%&#x3D;80112002; &#125; return num[e]&#x3D;summ;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,m; cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; edge[i].start&#x3D;s; edge[i].next&#x3D;pre[e]; pre[e]&#x3D;i; des[s]&#x3D;1; &#125; int ans&#x3D;0; _for(i,1,n) &#123; if(!des[i]&amp;&amp;pre[i]) &#123; ans+&#x3D;dfs(i); ans%&#x3D;80112002; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; 记忆dfs+vector12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int num[5005];bool des[5005];vector&lt;int&gt; v[5005];int dfs(int e)&#123; if(!v[e].size()) return 1; if(num[e]) return num[e]; int summ&#x3D;0; for(int i&#x3D;0;i&lt;v[e].size();i++) &#123; summ+&#x3D;dfs(v[e][i]); summ%&#x3D;80112002; &#125; return num[e]&#x3D;summ;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,m; cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; v[e].push_back(s); des[s]&#x3D;1; &#125; int ans&#x3D;0; _for(i,1,n) &#123; if(!des[i]&amp;&amp;v[i].size()) &#123; ans+&#x3D;dfs(i); ans%&#x3D;80112002; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; 拓扑排序每次取入度为0的点，也就是起点，然后把这个这个起点能到达的终点+当前食物链数目，再找入度为0的点，继续。直到只剩下终点统计一下就可以，这个需要已知起点找终点，可以用二维数组或者邻接表或者vector 拓扑+二维数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m;int map[5005][5005];int in[5005],out[5005];int sum[5005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; map[s][e]&#x3D;1; out[s]++; in[e]++; &#125; queue&lt;int&gt; q; _for(i,1,n) &#123; if(!in[i]) &#123; sum[i]&#x3D;1; q.push(i); &#125; &#125; int summ&#x3D;0; while(!q.empty()) &#123; int s&#x3D;q.front(); q.pop(); _for(i,1,n) &#123; if(map[s][i]) &#123; sum[i]+&#x3D;sum[s]; sum[i]%&#x3D;80112002; in[i]--; if(!in[i]) &#123; if(!out[i]) &#123; summ+&#x3D;sum[i]; summ%&#x3D;80112002; continue; &#125; q.push(i); &#125; &#125; &#125; &#125; cout&lt;&lt;summ; return 0;&#125; 拓扑+邻接表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;vector&gt; #include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct Edge&#123; int end,next;&#125; edge[5000005];int n,m;int pre[5005];int in[5005],out[5005];int sum[5005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m; _for(i,1,m) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; edge[i].end&#x3D;e; edge[i].next&#x3D;pre[s]; pre[s]&#x3D;i; out[s]++; in[e]++; &#125; queue&lt;int&gt; q; _for(i,1,n) &#123; if(!in[i]) &#123; sum[i]&#x3D;1; q.push(i); &#125; &#125; int summ&#x3D;0; while(!q.empty()) &#123; int s&#x3D;q.front(); q.pop(); for(int i&#x3D;pre[s];i;i&#x3D;edge[i].next) &#123; sum[edge[i].end]+&#x3D;sum[s]; sum[edge[i].end]%&#x3D;80112002; in[edge[i].end]--; if(!in[edge[i].end]) &#123; if(!out[edge[i].end]) &#123; summ+&#x3D;sum[edge[i].end]; summ%&#x3D;80112002; continue; &#125; q.push(edge[i].end); &#125; &#125; &#125; cout&lt;&lt;summ; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"食物链","slug":"食物链","permalink":"https://donghuangzhong.github.io/tags/%E9%A3%9F%E7%89%A9%E9%93%BE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://donghuangzhong.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"记忆化递归","slug":"记忆化递归","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92/"},{"name":"邻接表","slug":"邻接表","permalink":"https://donghuangzhong.github.io/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"},{"name":"优先队列","slug":"优先队列","permalink":"https://donghuangzhong.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"vector","slug":"vector","permalink":"https://donghuangzhong.github.io/tags/vector/"}]},{"title":"洛谷_P2196 挖地雷","slug":"洛谷-P2196-挖地雷","date":"2020-04-02T01:30:59.000Z","updated":"2020-04-02T01:36:37.696Z","comments":true,"path":"2020/04/02/洛谷-P2196-挖地雷/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P2196-%E6%8C%96%E5%9C%B0%E9%9B%B7/","excerpt":"摘要","text":"摘要 题目题目描述在一个地图上有NN个地窖(N \\le 20)(N≤20)，每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。当地窖及其连接的数据给出之后，某人可以从任一处开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。 输入格式有若干行。 第11行只有一个数字，表示地窖的个数NN。 第22行有NN个数，分别表示每个地窖中的地雷个数。 第33行至第N+1N+1行表示地窖之间的连接情况： 第33行有n-1n−1个数（00或11），表示第一个地窖至第22个、第33个、…、第nn个地窖有否路径连接。如第33行为1 1 0 0 0 … 011000…0，则表示第11个地窖至第22个地窖有路径，至第33个地窖有路径，至第44个地窖、第55个、…、第nn个地窖没有路径。 第44行有n-2n−2个数，表示第二个地窖至第33个、第44个、…、第nn个地窖有否路径连接。 … … 第n+1n+1行有11个数，表示第n-1n−1个地窖至第nn个地窖有否路径连接。（为00表示没有路径，为11表示有路径）。 输出格式有两行 第一行表示挖得最多地雷时的挖地雷的顺序，各地窖序号间以一个空格分隔，不得有多余的空格。 第二行只有一个数，表示能挖到的最多地雷数。 输入输出样例输入 #1复制 123456510 8 4 7 61 1 1 00 0 01 11 输出 #1复制 121 3 4 52 算法如果我们知道i点可以到达j点，并且知道到达i点时的最大值sum[i],那么我们就可以计算经过i点到达j点的最大值，与当前j点的最大值sum[j]做比较，取较大者。转移方程为 1sum[j]&#x3D;max(sum[i]+mines[j],sum[j]) 可行性分析：sum[i]必须是最优解，稍微分析一下能证明可行 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int mines[21]; int sum[21];int path[21];void print_path(int x)&#123; if(x&#x3D;&#x3D;0) return ; print_path(path[x]); cout&lt;&lt;x&lt;&lt;&quot; &quot;;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) &#123; cin&gt;&gt;mines[i]; sum[i]&#x3D;mines[i]; &#125; int ans&#x3D;-1; int index; _for(i,1,n-1) &#123; _for(j,i+1,n) &#123; bool connect; if(cin&gt;&gt;connect&amp;&amp;connect&amp;&amp;sum[i]+mines[j]&gt;sum[j]) &#123; sum[j]&#x3D;sum[i]+mines[j]; path[j]&#x3D;i; &#125; &#125; if(sum[i]&gt;ans) &#123; ans&#x3D;sum[i]; index&#x3D;i; &#125; &#125; if(sum[n]&gt;ans) &#123; ans&#x3D;sum[n]; index&#x3D;n; &#125; print_path(index); cout&lt;&lt;endl&lt;&lt;ans; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"正向DP","slug":"正向DP","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E5%90%91DP/"}]},{"title":"洛谷_P1434_[SHOI2002]滑雪","slug":"洛谷-P1434-SHOI2002-滑雪","date":"2020-04-01T23:45:26.000Z","updated":"2020-04-01T23:49:53.647Z","comments":true,"path":"2020/04/02/洛谷-P1434-SHOI2002-滑雪/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/02/%E6%B4%9B%E8%B0%B7-P1434-SHOI2002-%E6%BB%91%E9%9B%AA/","excerpt":"摘要","text":"摘要 题目题目描述Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子： 123451 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 2424－1717－1616－11（从 2424 开始，在 11 结束）。当然 2525－2424－2323－\\ldots…－33－22－11 更长。事实上，这是最长的一条。 输入格式输入的第一行为表示区域的二维数组的行数 RR 和列数 CC。下面是 RR 行，每行有 CC 个数，代表高度(两个数字之间用 11 个空格间隔)。 输出格式输出区域中最长滑坡的长度。 输入输出样例输入 #1复制 1234565 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 输出 #1复制 125 说明/提示对于 100%100% 的数据，1\\leq R,C\\leq 1001≤R,C≤100。 算法记忆化递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int map[101][101];int mem[101][101];int r,c;int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;int dfs(int x,int y)&#123; if(mem[x][y]) return mem[x][y]; int maxx&#x3D;0; _for(i,0,3) &#123; int xx&#x3D;x+dir[i][0]; int yy&#x3D;y+dir[i][1]; if(xx&gt;&#x3D;0&amp;&amp;xx&lt;r&amp;&amp;yy&gt;&#x3D;0&amp;&amp;yy&lt;c&amp;&amp;map[xx][yy]&lt;map[x][y]) &#123; maxx&#x3D;max(maxx,dfs(xx,yy)); &#125; &#125; return mem[x][y]&#x3D;maxx+1;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;r&gt;&gt;c; _for(i,0,r-1) _for(j,0,c-1) cin&gt;&gt;map[i][j]; int ans&#x3D;-1; _for(i,0,r-1) _for(j,0,c-1) ans&#x3D;max(ans,dfs(i,j)); cout&lt;&lt;ans; return 0;&#125; 优先队列DP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;queue&gt; #define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct node&#123; int x,y,num;&#125;;struct cmp&#123; bool operator()(node a,node b) &#123; return a.num&gt;b.num; &#125;&#125;;int r,c,map[101][101],step[101][101];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;r&gt;&gt;c; priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; q; _for(i,1,r) _for(j,1,c) &#123; step[i][j]&#x3D;1; cin&gt;&gt;map[i][j]; q.push(&#123;i,j,map[i][j]&#125;); &#125; int ans&#x3D;0; while(!q.empty()) &#123; node t&#x3D;q.top(); q.pop(); if(t.num&gt;map[t.x+1][t.y]) step[t.x][t.y]&#x3D;max(step[t.x][t.y],step[t.x+1][t.y]+1); if(t.num&gt;map[t.x-1][t.y]) step[t.x][t.y]&#x3D;max(step[t.x][t.y],step[t.x-1][t.y]+1); if(t.num&gt;map[t.x][t.y+1]) step[t.x][t.y]&#x3D;max(step[t.x][t.y],step[t.x][t.y+1]+1); if(t.num&gt;map[t.x][t.y-1]) step[t.x][t.y]&#x3D;max(step[t.x][t.y],step[t.x][t.y-1]+1); ans&#x3D;max(ans,step[t.x][t.y]); &#125; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"洛谷_P1216_数字三角形","slug":"洛谷-P1216-数字三角形","date":"2020-04-01T09:40:22.000Z","updated":"2020-04-01T10:08:26.881Z","comments":true,"path":"2020/04/01/洛谷-P1216-数字三角形/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/01/%E6%B4%9B%E8%B0%B7-P1216-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2/","excerpt":"摘要","text":"摘要 题目题目描述观察下面的数字金字塔。 写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。 12345 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 在上面的样例中,从 7 \\to 3 \\to 8 \\to 7 \\to 57→3→8→7→5 的路径产生了最大 输入格式第一个行一个正整数 rr ,表示行的数目。 后面每行为这个数字金字塔特定行包含的整数。 输出格式单独的一行,包含那个可能得到的最大的和。 输入输出样例输入 #1复制 123456573 88 1 02 7 4 44 5 2 6 5 输出 #1复制 130 说明/提示【数据范围】对于 100%100% 的数据，1\\le r \\le 10001≤r≤1000，所有输入在 [0,100][0,100] 范围内。 算法正向:计算起点到每个点的最大值从上向下走，找正向的来源，注意不能影响下一个点的来源 轴对称翻转代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int num[1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,number; cin&gt;&gt;n; _for(i,1,n) for(int j&#x3D;i;j&gt;&#x3D;1;j--) cin&gt;&gt;number,num[j]&#x3D;max(num[j],num[j-1])+number; int ans&#x3D;num[1]; _for(i,2,n) ans&#x3D;max(ans,num[i]); cout&lt;&lt;ans; return 0;&#125; 右对齐代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int num[1002];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,number; cin&gt;&gt;n; _for(i,1,n) for(int j&#x3D;n-i+1;j&lt;&#x3D;n;j++) cin&gt;&gt;number,num[j]&#x3D;max(num[j],num[j+1])+number; int ans&#x3D;num[1]; _for(i,2,n) ans&#x3D;max(ans,num[i]); cout&lt;&lt;ans; return 0;&#125; 反向：计算终点到每一个起点的最大值代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int map[1001][1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,0,n-1) _for(j,0,i) cin&gt;&gt;map[i][j]; for(int i&#x3D;n-2;i&gt;&#x3D;0;i--) for(int j&#x3D;0;j&lt;&#x3D;i;j++) map[i][j]+&#x3D;max(map[i+1][j],map[i+1][j+1]); cout&lt;&lt;map[0][0]; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"数塔","slug":"数塔","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E5%A1%94/"},{"name":"正反向思考","slug":"正反向思考","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E5%8F%8D%E5%90%91%E6%80%9D%E8%80%83/"}]},{"title":"HDU_1024_Max Sum Plus Plus","slug":"HDU-1024-Max-Sum-Plus-Plus","date":"2020-04-01T07:04:24.000Z","updated":"2020-04-01T07:51:43.084Z","comments":true,"path":"2020/04/01/HDU-1024-Max-Sum-Plus-Plus/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/01/HDU-1024-Max-Sum-Plus-Plus/","excerpt":"DP最重要的是找状态转移方程，也就是怎么通过已有的状态求未知的状态","text":"DP最重要的是找状态转移方程，也就是怎么通过已有的状态求未知的状态 题目Max Sum Plus Plus\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 48103 Accepted Submission(s): 17534** Problem DescriptionNow I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem. Given a consecutive number sequence S1, S2, S3, S4 … Sx, … Sn (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ Sx ≤ 32767). We define a function sum(i, j) = Si + … + Sj (1 ≤ i ≤ j ≤ n). Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i1, j1) + sum(i2, j2) + sum(i3, j3) + … + sum(im, jm) maximal (ix ≤ iy ≤ jx or ix ≤ jy ≤ jx is not allowed). But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(ix, jx)(1 ≤ x ≤ m) instead. ^_^ InputEach test case will begin with two integers m and n, followed by n integers S1, S2, S3 … Sn.Process to the end of file. OutputOutput the maximal summation described above in one line. Sample Input121 3 1 2 32 6 -1 4 -2 3 -2 3 Sample Output1268 题目大意输入m,n,然后输入n个数。求在这n个数中，分为m个区间，区间互不重叠，对每个区间求和得到sum1~m，再对这m个sum求和，求这个和的最大值 算法先从未优化的版本开始，max_sum[i][j]表示的是将[0,j]区间分为i个互不重叠子区间得到的最优解，那么状态转移方程就可以表示为 1max_sum[i][j]&#x3D;max(max_sum[i][j-1],max_sum[i-1][k]) k属于[i-1,j-1] 然后就可以发现，求解的时候只涉及max_sum数组的两行，第i行和第i-1行，因此可以用一个两行的滚动的数组表示DP数组。也就是用其中一行计算另一行，当另一行计算好了之后，转换角色。即 1max_sum[t][j]&#x3D;max(max_sum[t][j-1],max_sum[1-t][k]) k属于[i-1,j-1] 然后就会发现，时间复杂度太高，主要是max_sum[1-t][k]耗时，于是将后面的max_sum[1-t][k]用单独一个数组max_pre[j-1]代替，并且这样做也可以舍弃max_sum的第一维了。于是就简化转移方程为 1max_sum[j]&#x3D;max(max_sum[j-1],max_pre[j-1])+num[j]; 其中max_sum[j]表示的是[0,j]区间分为i个互不重叠小区间的最优解；max_pre[j-1]表示的是终点在[i,j-1]，并且分为i-1个区间的和的最大值，其实就是刚开始的max_sum[i-1][k] k属于[i-1,j-1]的最大值，即 1max(max_sum[i-1][i-1],max_sum[i-1][i],max_sum[i-1][i+1],…………,max_sum[i-1][j-1]) 舍弃掉第一维，可以用循环次数决定max_sum数组表示的是分为几个小区间的状态，比如循环一次就表示分为1个小区间的各种状态，循环m次就表示循环m次的状态，并且当每次循环的时候需要更新max_pre，当第i次循环的时候计算max_sum[j]的时候，需要用到max_pre[j-1]，并且在第i次循环中只使用这一次，以后就用不到了，并且此时的max_pre需要更新的值已经出来了，就是max_sum[x] x属于[0,j-1]的最大值，所以我们只需要维护一个max_summ表示第i次max_sum[x] x属于[0,j-1]的最大值就能够实现这两个数组的同步更新。、 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)#define MAX 0x3f3f3f3fusing namespace std;int num[1000001];int max_sum[1000001];int max_pre[1000001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int m,n,max_summ; while(cin&gt;&gt;m&gt;&gt;n) &#123; memset(max_sum,0,sizeof(max_sum)); memset(max_pre,0,sizeof(max_pre)); _for(i,1,n) cin&gt;&gt;num[i]; _for(i,1,m) &#123; max_summ&#x3D;-MAX; _for(j,i,n) &#123; max_sum[j]&#x3D;max(max_sum[j-1],max_pre[j-1])+num[j]; max_pre[j-1]&#x3D;max_summ; if(max_sum[j]&gt;max_summ) max_summ&#x3D;max_sum[j]; &#125; &#125; cout&lt;&lt;max_summ&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"转移方程的构造","slug":"转移方程的构造","permalink":"https://donghuangzhong.github.io/tags/%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E7%9A%84%E6%9E%84%E9%80%A0/"},{"name":"极度优化","slug":"极度优化","permalink":"https://donghuangzhong.github.io/tags/%E6%9E%81%E5%BA%A6%E4%BC%98%E5%8C%96/"}]},{"title":"算法提高 秘密行动","slug":"算法提高-秘密行动","date":"2020-04-01T01:21:03.000Z","updated":"2020-04-01T01:58:28.976Z","comments":true,"path":"2020/04/01/算法提高-秘密行动/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/01/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98-%E7%A7%98%E5%AF%86%E8%A1%8C%E5%8A%A8/","excerpt":"双数组DP","text":"双数组DP 题目算法提高 秘密行动提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 小D接到一项任务，要求他爬到一座n层大厦的顶端与神秘人物会面。这座大厦有一个神奇的特点，每层的高度都不一样，同时，小D也拥有一项特殊能力，可以一次向上跳跃一层或两层，但是这项能力无法连续使用。已知向上1高度消耗的时间为1，跳跃不消耗时间。由于事态紧急，小D想知道他最少需要多少时间到达顶层。 输入格式 第一行包含一个整数n，代表楼的高度。 接下来n行每行一个整数ai，代表i层的楼层高度（ai &lt;= 100）。 输出格式 输出1行，包含一个整数，表示所需的最短时间。 样例输入535184 样例输出1 数据规模和约定 对20%的数据,n&lt;=10 对40%的数据,n&lt;=100 对60%的数据,n&lt;=5000 对100%的数据,n&lt;=10000 算法通用做法(三个数组)三个数组，height[i]表示第i层楼的高度，climb[i]表示爬上第i层楼的最短时间，jump[i]表示跳到第i层楼的时间。显然，如果是爬到第i层楼，那它的起点只能是从第i-1层楼，所以如果知道到i-1层的最短时间就能知道爬到第i层楼的最短时间，到第i-1层楼的方式可能是爬，也可能是跳跃。所以就有了爬楼的转移方程 1climb[i]&#x3D;min(climb[i-1],jump[i-1])+height[i] 同理，跳跃的上一步只能是爬，因为题目说了不能连续跳跃，但是跳跃的起点有两个，所以转移方程为 1jump[i]&#x3D;min(climb[i-1],climb[i-2]) 所以i要从2开始，同时要初始化好climb[0],climb[1]和jump[1] 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int jump[10001];int climb[10001];int height[10001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,1,n) cin&gt;&gt;height[i]; climb[0]&#x3D;jump[0]&#x3D;0; climb[1]&#x3D;height[1]; _for(i,2,n) &#123; climb[i]&#x3D;min(climb[i-1],jump[i-1])+height[i]; jump[i]&#x3D;min(climb[i-1],climb[i-2]); &#125; cout&lt;&lt;min(climb[n],jump[n]); return 0;&#125; 两个数组的做法观察转移方程，hight[i]可以直接输入，不用保存。也就是说输入第i层楼的高度的时候，climb[i]和jump[i]已经可以算出来了 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int jump[10001];int climb[10001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; climb[0]&#x3D;jump[0]&#x3D;0; cin&gt;&gt;climb[1]; _for(i,2,n) &#123; int height; cin&gt;&gt;height; climb[i]&#x3D;min(climb[i-1],jump[i-1])+height; jump[i]&#x3D;min(climb[i-1],climb[i-2]); &#125; cout&lt;&lt;min(climb[n],jump[n]); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"多数组DP","slug":"多数组DP","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%9A%E6%95%B0%E7%BB%84DP/"}]},{"title":"HDU-1114_Piggy-Bank","slug":"HDU-1114-Piggy-Bank","date":"2020-04-01T01:01:31.000Z","updated":"2020-04-01T01:07:13.004Z","comments":true,"path":"2020/04/01/HDU-1114-Piggy-Bank/","link":"","permalink":"https://donghuangzhong.github.io/2020/04/01/HDU-1114-Piggy-Bank/","excerpt":"简单背包","text":"简单背包 题目Piggy-Bank\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 46180 Accepted Submission(s): 22736** Problem DescriptionBefore ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid. But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs! InputThe input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams. OutputPrint exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”. Sample Input12345678910111213310 11021 130 5010 11021 150 301 6210 320 4 Sample Output123The minimum amount of money in the piggy-bank is 60.The minimum amount of money in the piggy-bank is 100.This is impossible. 题目大意输入空的存钱罐的重量和装满钱的存钱罐的重量，然后再输入硬币的面值和重量，要求输出这个存钱罐恰好能够装的最小金钱的值 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int dp[10001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int t; cin&gt;&gt;t; while(t--) &#123; memset(dp,0x3f,sizeof(dp)); dp[0]&#x3D;0; int empty_w,full_w; cin&gt;&gt;empty_w&gt;&gt;full_w; int w&#x3D;full_w-empty_w; int coin_n; cin&gt;&gt;coin_n; while(coin_n--) &#123; int v,coin_w; cin&gt;&gt;v&gt;&gt;coin_w; for(int i&#x3D;coin_w;i&lt;&#x3D;w;i++) &#123; if(dp[i]&gt;dp[i-coin_w]+v) dp[i]&#x3D;dp[i-coin_w]+v; &#125; &#125; if(dp[w]&#x3D;&#x3D;0x3f3f3f3f) &#123; cout&lt;&lt;&quot;This is impossible.&quot;&lt;&lt;endl; continue; &#125; cout&lt;&lt;&quot;The minimum amount of money in the piggy-bank is &quot;&lt;&lt;dp[w]&lt;&lt;&quot;.&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"背包","slug":"背包","permalink":"https://donghuangzhong.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"算法训练 小生物的逃逸","slug":"算法训练-小生物的逃逸","date":"2020-03-31T09:09:29.000Z","updated":"2020-03-31T09:11:59.153Z","comments":true,"path":"2020/03/31/算法训练-小生物的逃逸/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/31/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%B0%8F%E7%94%9F%E7%89%A9%E7%9A%84%E9%80%83%E9%80%B8/","excerpt":"水","text":"水 题目算法训练 小生物的逃逸提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 空间中有n个球，这些球不相交也不相切。有m个可以视为质点的小生物，可能在某些球内，也可能在所有球之外，但不会在球面上。问这些生物从原来的地方逃逸到所有球外面的空间，至少要经过多少层球面。 输入格式 第一行两个数n、m：表示球的数量和小生物的数量； 接下来n行每行四个整数Xi、Yi、Zi和Ri：表示一个球的三维坐标和半径； 接下来m行每行三个整数Xi、Yi、Zi：表示一个生物的坐标。 输出格式 一行m个数：表示每个小生物逃逸时至少经过的球面数。 样例输入2 20 0 0 20 0 0 40 0 10 0 3 样例输出2 1 算法12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m;struct aa&#123; int x,y,z,r;&#125;;aa a[101];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input10.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m; _for(i,0,n-1) cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].z&gt;&gt;a[i].r; _for(i,1,m) &#123; int sum&#x3D;0; long long x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; _for(j,0,n-1) if((x-a[j].x)*(x-a[j].x)+(y-a[j].y)*(y-a[j].y)+(z-a[j].z)*(z-a[j].z)&lt;a[j].r*a[j].r) sum++; cout&lt;&lt;sum&lt;&lt;&quot; &quot;; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[]},{"title":"算法训练 相邻字母","slug":"算法训练-相邻字母","date":"2020-03-31T00:22:47.000Z","updated":"2020-03-31T00:24:38.853Z","comments":true,"path":"2020/03/31/算法训练-相邻字母/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/31/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E7%9B%B8%E9%82%BB%E5%AD%97%E6%AF%8D/","excerpt":"简单水题","text":"简单水题 题目算法训练 相邻字母提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 【问题描述】 从键盘输入一个英文字母，要求按字母的顺序打印出3个相邻的字母，指定的字母在中间。若指定的字母为Z，则打印YZA，若为A则打印ZAB。注意：需要区分大小写。 【输入格式】 一行，仅包含一个英文字母。 【输出格式】 一行，包含三个字母。 【样例输入**1****】 a 【样例输出**1****】 zab 【样例输入**2****】 B 【样例输出**2****】 ABC 算法12345678910111213141516171819202122#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int main()&#123; char c; cin&gt;&gt;c; if(c&#x3D;&#x3D;&#39;a&#39;||c&#x3D;&#x3D;&#39;A&#39;) printf(&quot;%c&quot;,c+25); else printf(&quot;%c&quot;,c-1); cout&lt;&lt;c; if(c&#x3D;&#x3D;&#39;z&#39;||c&#x3D;&#x3D;&#39;Z&#39;) printf(&quot;%c&quot;,c-25); else printf(&quot;%c&quot;,c+1); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"},{"name":"字母","slug":"字母","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E6%AF%8D/"}]},{"title":"算法训练 奇变的字符串","slug":"算法训练-奇变的字符串","date":"2020-03-31T00:06:56.000Z","updated":"2020-03-31T00:08:43.521Z","comments":true,"path":"2020/03/31/算法训练-奇变的字符串/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/31/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%A5%87%E5%8F%98%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"摘要","text":"摘要 题目算法训练 奇变的字符串提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 将一个字符串的奇数位（首位为第0位）取出，将其顺序弄反，再放回原字符串的原位置上。 如字符串”abcdefg”，奇数位为”bdf”，顺序弄反后为”fdb”，最后得到字符串”afcdebg”。 输入格式 输入共一行，为一个字符串，字符串中无空格。 输出格式 输出共一行，为一个字符串，即最后得到的字符串。 样例输入abcdefg 样例输出afcdebg 数据规模和约定 字符串长度不超过255. 算法1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); string a; cin&gt;&gt;a; int l&#x3D;0,r&#x3D;a.length()-1; while(r&gt;l) &#123; if((l&amp;1)&#x3D;&#x3D;0) l++; if((r&amp;1)&#x3D;&#x3D;0) r--; swap(a[l],a[r]); l+&#x3D;2; r-&#x3D;2; &#125; cout&lt;&lt;a; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"字符串","slug":"ACM/字符串","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"算法训练 自行车停放","slug":"算法训练-自行车停放","date":"2020-03-30T11:00:24.000Z","updated":"2020-03-30T11:11:58.852Z","comments":true,"path":"2020/03/30/算法训练-自行车停放/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E8%87%AA%E8%A1%8C%E8%BD%A6%E5%81%9C%E6%94%BE/","excerpt":"看数据规模，10的5次方，用数组的话大于是(n(n+1)/2)n^2级别的，实测12秒。只能转向双向链表！","text":"看数据规模，10的5次方，用数组的话大于是(n(n+1)/2)n^2级别的，实测12秒。只能转向双向链表！ 题目算法训练 自行车停放提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 有n辆自行车依次来到停车棚，除了第一辆自行车外，每辆自行车都会恰好停放在已经在停车棚里的某辆自行车的左边或右边。(e.g.停车棚里已经有3辆自行车，从左到右编号为：3,5,1。现在编号为2的第4辆自行车要停在5号自行车的左边，所以现在停车棚里的自行车编号是：3,2,5,1)。给定n辆自行车的停放情况，按顺序输出最后停车棚里的自行车编号。 输入格式 第一行一个整数n。 第二行一个整数x。表示第一辆自行车的编号。 以下n-1行，每行3个整数x,y,z。 z=0时，表示编号为x的自行车恰停放在编号为y的自行车的左边 z=1时，表示编号为x的自行车恰停放在编号为y的自行车的右边 输出格式 从左到右输出停车棚里的自行车编号 样例输入431 3 12 1 05 2 1 样例输出3 2 5 1 数据规模和约定 n&lt;=100000 自行车编号为不超过100000的正整数。 算法数组版(12秒)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int a[100001],b[100001];void insert(int n,int num,int sum)&#123; &#x2F;&#x2F;memcpy(a+n+1,a+n,4*(sum-n)); for(int i&#x3D;sum-1;i&gt;&#x3D;n;i--) &#123; a[i+1]&#x3D;a[i]; b[a[i]]++; &#125; a[n]&#x3D;num; b[num]&#x3D;n;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); int n; int cc&#x3D;clock(); cin&gt;&gt;n&gt;&gt;a[0]; b[a[0]]&#x3D;0; int now_sum&#x3D;1; int t&#x3D;n-1; while(t--) &#123; int x,y,z,i; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; i&#x3D;b[y]; int index_move&#x3D;z?i+1:i; insert(index_move,x,now_sum++); &#125; _for(i,0,now_sum-1) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; PP(&quot;time&#x3D;&quot;,clock()-cc); return 0;&#125; 双向链表版用的是带头结点和尾结点的双向链表，单纯是为了方便插入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;struct L&#123; L * pre; int n; L *next;&#125;;L* d[100001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input5.txt&quot;,&quot;r&quot;,stdin); L *head&#x3D;(L *)malloc(sizeof(L)); L *t1&#x3D;(L *)malloc(sizeof(L)); L * wei&#x3D;(L *)malloc(sizeof(L)); head-&gt;next&#x3D;t1; t1-&gt;pre&#x3D;head; t1-&gt;next&#x3D;wei; wei-&gt;pre&#x3D;t1; wei-&gt;next&#x3D;NULL; int n; cin&gt;&gt;n&gt;&gt;t1-&gt;n; d[t1-&gt;n]&#x3D;t1; int t&#x3D;n-1; while(t--) &#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; L* node&#x3D;(L *)malloc(sizeof(L)); node-&gt;n&#x3D;x; d[x]&#x3D;node; L* temp&#x3D;d[y]; if(z) &#123; node-&gt;pre&#x3D;temp; node-&gt;next&#x3D;temp-&gt;next; temp-&gt;next-&gt;pre&#x3D;node; temp-&gt;next&#x3D;node; &#125; else &#123; node-&gt;next&#x3D;temp; node-&gt;pre&#x3D;temp-&gt;pre; temp-&gt;pre-&gt;next&#x3D;node; temp-&gt;pre&#x3D;node; &#125; &#125; t1&#x3D;head-&gt;next; while(t1-&gt;next!&#x3D;NULL) &#123; cout&lt;&lt;t1-&gt;n&lt;&lt;&quot; &quot;; t1&#x3D;t1-&gt;next; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"双向链表","slug":"ACM/双向链表","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"双向链表","slug":"双向链表","permalink":"https://donghuangzhong.github.io/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"索引表","slug":"索引表","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A2%E5%BC%95%E8%A1%A8/"}]},{"title":"算法训练 数组逆序排列","slug":"算法训练-数组逆序排列","date":"2020-03-30T09:18:16.000Z","updated":"2020-03-30T09:19:37.871Z","comments":true,"path":"2020/03/30/算法训练-数组逆序排列/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E6%95%B0%E7%BB%84%E9%80%86%E5%BA%8F%E6%8E%92%E5%88%97/","excerpt":"摘要","text":"摘要 题目算法训练 数组逆序排列提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 编写一个程序，读入一组整数（不超过20个），并把它们保存在一个整型数组中。当用户输入0时，表示输入结束。然后程序将把这个数组中的值按逆序重新存放，并打印出来。要求：(1)只能定义一个数组；(2)在交换两个数组元素的值时，必须使用单独定义的一个函数swap。例如：假设用户输入了一组数据：7 19 -5 6 2 0，那么程序将会把前五个有效数据保存在一个数组中，即7 19 -5 6 2，然后把这个数组中的值按逆序重新存放，即变成了2 6 -5 19 7，然后把它们打印出来。 输入格式：输入只有一行，包括若干个整数，最后一个整数是0。 输出格式：输出只有一行，包括若干个整数，即逆序排列后的结果。 输入输出样例样例输入7 19 -5 6 2 0 样例输出2 6 -5 19 7 算法123456789101112131415161718192021222324#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int a[21]; int index&#x3D;1; while(cin&gt;&gt;a[index++]&amp;&amp;a[index-1]); index-&#x3D;2; _for(i,1,index&#x2F;2) swap(a[i],a[index+1-i]); _for(i,1,index) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"整除2","slug":"整除2","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B4%E9%99%A42/"}]},{"title":"算法训练 字符串比较","slug":"算法训练-字符串比较","date":"2020-03-30T08:50:22.000Z","updated":"2020-03-30T09:07:55.217Z","comments":true,"path":"2020/03/30/算法训练-字符串比较/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/","excerpt":"我也不知道怎么错的，测试用例都对了，但就是通不过！最后附上官方的代码！！","text":"我也不知道怎么错的，测试用例都对了，但就是通不过！最后附上官方的代码！！ 题目算法训练 字符串比较提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 strncmp函数的原型为：int strncmp(char *s, char *t, int n);，其功能是比较字符串s和t的前n个字符。如果s&lt;t，返回-1；如果s=t，返回0；如果s&gt;t，返回1。请自己编程实现该函数，并编写一个程序来测试其正确性。 输入格式：输入有三行，第一行为字符串s，第二行为字符串t，第三行为整数n。 输出格式：输出只有一个整数，即比较结果。 输入输出样例样例输入worldword4 样例输出1 代码测试用例在win10 下都能通过，但在蓝桥就是错误 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int cmp(string a,string b,int n)&#123; for(int i&#x3D;0;i&lt;&#x3D;n-1;i++) &#123; if(i&#x3D;&#x3D;a.length()||i&#x3D;&#x3D;b.length()) &#123; if(i!&#x3D;a.length()) return -1; else if(i!&#x3D;b.length()) return 1; else return 0; &#125; if(a[i]&gt;b[i]) return 1; if(a[i]&lt;b[i]) return -1; &#125; &#125;int main()&#123;&#x2F;&#x2F; ios::sync_with_stdio(0);&#x2F;&#x2F; cin.tie(0);&#x2F;&#x2F; cout.tie(0); freopen(&quot;input6.txt&quot;,&quot;r&quot;,stdin); string a,b; int n; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n;&#x2F;&#x2F; cout&lt;&lt;cmp(a,b,n)&lt;&lt;endl;&#x2F;&#x2F; printf(&quot;%d&quot;,cmp(a,b,n)); int c&#x3D;cmp(a,b,n); if(c&#x3D;&#x3D;0) cout&lt;&lt;&quot;0&quot;; else cout&lt;&lt;c; return 0;&#125; 这个是官方版，但是我觉得错误太明显了，应该是题目叙述错了，有改动，比如a,b的大小关系和az和ba的关系应该是一样的，但是官方给的程序测试结果不一样 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[10000],t[10000]; int i,n,a&#x3D;0,k&#x3D;1; scanf(&quot;%s&quot;,&amp;s); scanf(&quot;%s&quot;,&amp;t); scanf(&quot;%d&quot;,&amp;n); for(i&#x3D;n-1;i&gt;&#x3D;0;i--)&#123; a&#x3D;a+s[i]*k-t[i]*k; k&#x3D;k*10; &#125; if(a&gt;0)&#123; printf(&quot;1&quot;); &#125; else if(a&lt;0)&#123; printf(&quot;-1&quot;); &#125; else&#123; printf(&quot;0&quot;); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"字符串","slug":"ACM/字符串","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串比较","slug":"字符串比较","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"}]},{"title":"算法训练 石子游戏","slug":"算法训练-石子游戏","date":"2020-03-30T04:21:07.000Z","updated":"2020-03-30T04:29:41.805Z","comments":true,"path":"2020/03/30/算法训练-石子游戏/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/","excerpt":"分析时间复杂度n^2=10^6,一秒不会超时。这个题的样例还好，给出了要用long long的暗示，并且给出这个测试用例摆明给你降低难度。这个题应该数组合sum全部用long long，因为a=b+c，先是计算b+c存到一个和b一样的数据类型中，如果a是long long，b,c是int，先计算b+c存到一个int的数据类型里，然后再赋值给c，如果溢出的话，b+c已经溢出了，此时在赋值给c还是溢出。所以需要全部置为long long!","text":"分析时间复杂度n^2=10^6,一秒不会超时。这个题的样例还好，给出了要用long long的暗示，并且给出这个测试用例摆明给你降低难度。这个题应该数组合sum全部用long long，因为a=b+c，先是计算b+c存到一个和b一样的数据类型中，如果a是long long，b,c是int，先计算b+c存到一个int的数据类型里，然后再赋值给c，如果溢出的话，b+c已经溢出了，此时在赋值给c还是溢出。所以需要全部置为long long! 题目算法训练 石子游戏提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 石子游戏的规则如下： 地上有n堆石子，每次操作可选取两堆石子（石子个数分别为x和y）并将它们合并，操作的得分记为(x+1)×(y+1)，对地上的石子堆进行操作直到只剩下一堆石子时停止游戏。 请问在整个游戏过程中操作的总得分的最大值是多少？ 输入格式 输入数据的第一行为整数n，表示地上的石子堆数；第二行至第n+1行是每堆石子的个数。 输出格式 程序输出一行，为游戏总得分的最大值。 样例输入10510519400273091989227814251291927212517254194053 样例输出15212676150 数据规模和约定 1≤n≤1000，1≤一堆中石子数≤50000 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;long long a[1001];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; _for(i,0,n-1) cin&gt;&gt;a[i]; long long sum&#x3D;0; _for(i,1,n-1) &#123; int index1&#x3D;a[0]&gt;a[1]?0:1; int index2&#x3D;1-index1; _for(j,2,n-1) &#123; if(a[j]&gt;a[index2]) &#123; if(a[j]&gt;a[index1]) &#123; index2&#x3D;index1; index1&#x3D;j; &#125; else index2&#x3D;j; &#125; &#125; sum+&#x3D;(a[index1]+1)*(a[index2]+1); a[index1]+&#x3D;a[index2]; a[index2]&#x3D;-1; &#125; cout&lt;&lt;sum; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"贪心","slug":"ACM/贪心","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%B4%AA%E5%BF%83/"}],"tags":[{"name":"大数陷阱","slug":"大数陷阱","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%99%B7%E9%98%B1/"},{"name":"溢出陷阱","slug":"溢出陷阱","permalink":"https://donghuangzhong.github.io/tags/%E6%BA%A2%E5%87%BA%E9%99%B7%E9%98%B1/"}]},{"title":"算法训练 最大获利","slug":"算法训练-最大获利","date":"2020-03-30T03:52:59.000Z","updated":"2020-03-30T03:58:28.610Z","comments":true,"path":"2020/03/30/算法训练-最大获利/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E6%9C%80%E5%A4%A7%E8%8E%B7%E5%88%A9/","excerpt":"看数据规模，计算中会超过10的9次方，所以应该选择long long。","text":"看数据规模，计算中会超过10的9次方，所以应该选择long long。 题目算法训练 最大获利提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 Chakra是一位年轻有为的企业家，最近他在进军餐饮行业。他在各地开拓市场，共买下了N个饭店。在初期的市场调研中，他将一天划分为M个时间段，并且知道第i个饭店在第j个时间段内，会有Aij位服务员当值和Bij位客户光临。他还分析了不同饭店不同时间段客户的需求，得到第i个饭店在第j个时间段内，平均每位客户消费Cij元。为了创设品牌形象，Chakra决定每个饭店每天只选择一个时间段营业，每个服务员至多接待一位顾客（若顾客数多于服务员数，超过部分的顾客当天就无法在该店消费了）。 企业家的目的终究还是获利。请你安排营业时间，并告诉Chakra每天消费总额最多为多少。 输入格式 第一行两个整数，N、M。 第二行开始依次给出三个矩阵A(NM)、B(NM)、C(N*M)。 输出格式 一行一个整数，最大消费总额。 样例输入2 31 2 33 2 13 2 11 2 34 5 23 1 6 样例输出16 数据规模和约定 1 &lt;= M,N &lt;= 100 1 &lt;= Aij, Bij &lt;= 5000 0 &lt;= Cij &lt;= 10^9 算法根据一位服务员只能服务一名顾客可以计算出，顾客人数矩阵，然后在根据顾客平均消费矩阵计算出总额矩阵，每行选一个求和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;long long st[3][101][101];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); &#x2F;&#x2F;freopen(&quot;input3.txt&quot;,&quot;r&quot;,stdin); int n,m; cin&gt;&gt;n&gt;&gt;m; _for(j,0,2) _for(i,1,n) _for(k,1,m) cin&gt;&gt;st[j][i][k]; _for(i,1,n) _for(k,1,m) if(st[0][i][k]&lt;st[1][i][k]) st[1][i][k]&#x3D;st[0][i][k]; _for(i,1,n) _for(k,1,m) st[2][i][k]*&#x3D;st[1][i][k]; long long sum&#x3D;0; _for(i,1,n) &#123; long long max&#x3D;-1; _for(j,1,m) &#123; if(st[2][i][j]&gt;max) max&#x3D;st[2][i][j]; &#125; sum+&#x3D;max; &#125; cout&lt;&lt;sum; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://donghuangzhong.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数据规模","slug":"数据规模","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1/"}]},{"title":"算法训练 乘法次数","slug":"算法训练-乘法次数","date":"2020-03-30T03:19:42.000Z","updated":"2020-03-30T03:30:49.993Z","comments":true,"path":"2020/03/30/算法训练-乘法次数/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E4%B9%98%E6%B3%95%E6%AC%A1%E6%95%B0/","excerpt":"已知x^n次方的情况下获取x^(2n)的最少途径就是x^n*x^n。要求x^n的最小乘法次数，就是不断的求x^2,x^4,x^8……，找到小于x^n的那个x^y次方(y是2的幂），这样就解决了大头，至于剩下的小头，在重复上述操作。其实就是基于二进制优化的快速幂！！","text":"已知x^n次方的情况下获取x^(2n)的最少途径就是x^n*x^n。要求x^n的最小乘法次数，就是不断的求x^2,x^4,x^8……，找到小于x^n的那个x^y次方(y是2的幂），这样就解决了大头，至于剩下的小头，在重复上述操作。其实就是基于二进制优化的快速幂！！ 题目算法训练 乘法次数提交此题 资源限制 时间限制：1.0s 内存限制：999.4MB 问题描述 给你一个非零整数，让你求这个数的n次方，每次相乘的结果可以在后面使用，求至少需要多少次乘。如24：22=22（第一次乘），2222=24（第二次乘），所以最少共2次； 输入格式 第一行m表示有m(1&lt;=m&lt;=100)组测试数据； 每一组测试数据有一整数n（0&lt;n&lt;=100000000）; 输出格式 输出每组测试数据所需次数s; 样例输入3234 样例输出122 题目大意在已知有一个数x的情况下，求x^n需要经过的最少的乘法次数。 算法123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,c; cin&gt;&gt;c; while(c--) &#123; cin&gt;&gt;n; int t&#x3D;n; int count_1&#x3D;0; while(t) &#123; bool wei&#x3D;t&amp;1; if(wei) count_1++; t&gt;&gt;&#x3D;1; &#125; int high_wei&#x3D;log(n)&#x2F;log(2); cout&lt;&lt;high_wei+count_1-1&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"快速幂","slug":"ACM/快速幂","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"tags":[{"name":"二进制优化","slug":"二进制优化","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"}]},{"title":"C++坑点","slug":"C-坑点","date":"2020-03-29T08:22:05.000Z","updated":"2020-03-29T08:22:05.302Z","comments":true,"path":"2020/03/29/C-坑点/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/29/C-%E5%9D%91%E7%82%B9/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"python爬虫爬取wallpapers壁纸","slug":"python爬虫爬取wallpapers壁纸","date":"2020-03-28T11:55:30.000Z","updated":"2020-03-28T11:58:01.004Z","comments":true,"path":"2020/03/28/python爬虫爬取wallpapers壁纸/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/28/python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96wallpapers%E5%A3%81%E7%BA%B8/","excerpt":"python爬虫爬取wallpapers最新壁纸","text":"python爬虫爬取wallpapers最新壁纸 详细教程请访问：https://www.bilibili.com/video/av58978561/详细教程请访问：https://www.bilibili.com/video/av58978561/123456789101112131415161718192021222324252627import requests #这个包里有打开网页的包from bs4 import BeautifulSoup #这个包里有html解析器def getimg(url,path,name):#将步骤3封装成函数 参数（图片网址，路径，名字） with requests.get(url) as resp:#打开图片 with open(path+'/'+name+'.jpg','wb') as f:#打开路径，准备写入图片 f.write(resp.content)#将图片以传进来的名字以wb(w:写入 b:二进制方式)写入路径def getdurl(url,l,w):#步骤2 参数（每一页的网址，图片长度，图片宽度） with requests.get(url) as resp:#打开网址 html=resp.text#获取html代码 soup=BeautifulSoup(html,'html.parser')#将代码用bs4进行解析 h1=soup.select('h1')#找到html代码中标签为h1（html中h1代表标题）的赋值给变量h1 这样我们就找到了所有图片的名字，但是还有一个网页的标题Latest Wallpapers for i in h1:#for循环 if i.text=='Latest Wallpapers': continue#去掉网页标题 n=i.text imgurl='http://wallpaperswide.com/download/'+n.replace(' ','_').lower()+'-'+str(l)+'x'+str(w) #拼接网址，将名字中空格换成下划线，所有字母换小写 # print(imgurl) print('正在下载'+n+'。。。')#提示信息 getimg(imgurl,'D:\\编程\\python\\wallpapers',n)#调用步骤三函数循环下载 print(n+'下载完成。。。')#提示信息 # url='http://wallpaperswide.com/download/Cyberpunk2077-800x480'if __name__=='__main__':#此程序作为主程序运行 for i in range(2):#外循环，从第一页循环至第十页，这里的10可以改成别的 getdurl('http://wallpaperswide.com/latest_wallpapers/page/'+str(i+1)+'.html',1366,768)#拼接网址调用步骤二函数","categories":[{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"},{"name":"爬虫","slug":"python/爬虫","permalink":"https://donghuangzhong.github.io/categories/python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"wallpapers","slug":"wallpapers","permalink":"https://donghuangzhong.github.io/tags/wallpapers/"},{"name":"壁纸","slug":"壁纸","permalink":"https://donghuangzhong.github.io/tags/%E5%A3%81%E7%BA%B8/"}]},{"title":"蓝桥模拟_第十题_晚会节目单","slug":"蓝桥模拟-第十题-晚会节目单","date":"2020-03-27T10:20:44.000Z","updated":"2020-03-29T08:16:40.829Z","comments":true,"path":"2020/03/27/蓝桥模拟-第十题-晚会节目单/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/27/%E8%93%9D%E6%A1%A5%E6%A8%A1%E6%8B%9F-%E7%AC%AC%E5%8D%81%E9%A2%98-%E6%99%9A%E4%BC%9A%E8%8A%82%E7%9B%AE%E5%8D%95/","excerpt":"频繁的查询区间最值对于遍历来说开销非常大，所以产生了一种区间最值查询这种算法，本文只讲ST+RMQ，ST是稀疏矩阵的意思，这种方法要求数据必须是静态的不能变化的。","text":"频繁的查询区间最值对于遍历来说开销非常大，所以产生了一种区间最值查询这种算法，本文只讲ST+RMQ，ST是稀疏矩阵的意思，这种方法要求数据必须是静态的不能变化的。 问题引入有一个一位数组(长度为n)，频繁的查询[s,e]区间的最值。 算法详解定义一个二维数组ST(大小[n,lgn])。ST[i][j]表示的是从i开始(包括i)向后2^j个元素区间的最值，即区间[i,i+2^j-1]的最值，那么很明显ST[i][0]=a[i](因为[i,i]只有一个值)。现在我们开始推导递推式,[i,i+2^j-1]可以按照中间分为两个大小为2^(j-1)的区间[i,i+2^(j-1)-1]和[i+2^(j-1),i+2^j-1]，那么[i,i+2^j-1]的最值为这两个区间再求最值，即[i,i+2^j-1]=min/max([i,i+2^(j-1)-1],[i+2^(j-1),i+2^j-1])也就是： 1ST[i][j]&#x3D;min&#x2F;max(ST[i][j-1],ST[i+2^j][j-1]) 那么就可以发现第j列某个元素值的计算只跟它前一列的某两个值有关，并且刚刚我们已经算好了第一列，由第一列可以计算第二列，由第二列可以计算第三列……那么要算到哪一列呢？ST[i][j]表示的区间是[i,i+2^j-1]很明显i+2^j-1&lt;=n-1(n个元素，下标0~n-1)所以就有了建ST的模板： 123456789101112void cal(int a[],int n)&#123; for(int i&#x3D;0;i&lt;&#x3D;n-1;i++) ST[i][0]&#x3D;a[i]; for(int j&#x3D;1;(1&lt;&lt;(j))&lt;&#x3D;n;j++) &#123; for(int i&#x3D;0;i+(1&lt;&lt;j)-1&lt;&#x3D;n-1;i++) &#123; st[i][j]&#x3D;max&#x2F;min(st[i][j-1],st[i+1&lt;&lt;(j-1)][j-1]); &#125; &#125; &#125; 说了半天有了这个表该怎么用呢？假如我们要计算区间[s,e]的最值该怎么算呢？我们能够利用的是ST[此处可为任意数][此处必须为2的幂]如果我们能够找到一个k，使得区间[s,e]变成[s,s+2^k-1]和[s+2^k][e]，我们就可以利用表了，但是你会发现第二个区间没法表示，我们只能表示长度为2的幂的区间。于是聪明人就会发现用e减去2的幂不就行了！于是将[s,e]变成[s,s+2^k-1]和[e-2^k+1,e]，这样区间[s][e]的最值就可以变为min/max(ST[s][k],ST[e-2^K+1][e])但是可能有人又会提出疑问了，如果这两个集合没有交集怎么办？比如[2,6]分为[2,3]和[5,6] (k=1)，这样得到话明显不对啊！所以我们需要找一个比较大的k值，[s,s+2^k-1]必须包含在[s][e]里面,也就是s+2^k-1&lt;=e 解得$$k&lt;=log_2(e-s+1),令k=log_2(e-s+1)$$并且(int)k去除了k的小数部分，也就是说0&lt;=k-(int)k&lt;1，所以k-1&lt;(int)k&lt;=k，代入原式：$$2^{k-1}-1&lt;2^{(int)k}-1&lt;=2^k-1将k=log_2(e-s+1)代入得$$ $$(e-s)/2-1/2&lt;2^{(int)k}-1，此处2^{(int)k}-1是整数，所以(e-s)/2=&lt;2^{(int)k}-1$$ $$所以s+2^{(int)k}-1&gt;=s+(e-s)/2=(e+s)/2(中点)且e-2^k+1&lt;=e-(e+s)/2=(e+s)/2(中点)$$ 所以当k=(int)(log2(e-s+1))时，ST[s][k],ST[e-2^K+1][e]表示的区间一定有交集。所以要求[s,e]区间最值只需要计算min/max(ST[s][k],ST[e-2^K+1][e]),k=(int)(log2(e-s+1)) 例题第十题 晚会节目单题目【问题描述】小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。小明发现，观众对于晚会的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。 【输入格式】输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。第二行包含 n 个整数，依次为每个节目的好看值。 【输出格式】输出一行包含 m 个整数，为选出的节目的好看值。 【样例输入】5 33 1 2 5 4 【样例输出】3 5 4 【样例说明】选择了第1, 4, 5个节目。 【评测用例规模与约定】对于 30% 的评测用例，1 &lt;= n &lt;= 20；对于 60% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。 思路 O(N^2)ST+RMQ 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m;int a[100001];int tree[400001];int st[100001][20];int pow_2(int p) &#123; return 1 &lt;&lt; p;&#125;void cal(int a[],int n)&#123; for(int j&#x3D;1;(1&lt;&lt;(j-1))&lt;&#x3D;n;j++) &#123; for(int i&#x3D;0;i+(1&lt;&lt;j)-1&lt;&#x3D;n-1;i++) &#123; st[i][j]&#x3D;a[st[i][j-1]]&gt;a[st[i+pow_2(j-1)][j-1]]?st[i][j-1]:st[i+pow_2(j-1)][j-1]; &#125; &#125; &#125;int query(int s,int e)&#123; int t&#x3D;(int)(log(e-s+1)&#x2F;log(2)); return a[st[s][t]]&gt;a[st[e-(1&lt;&lt;t)+1][t]]?st[s][t]:st[e-(1&lt;&lt;t)+1][t];&#125; void build_tree(int s,int e,int node)&#123; if(s&#x3D;&#x3D;e) &#123; tree[node]&#x3D;s; return ; &#125; int mid&#x3D;(s+e)&#x2F;2; build_tree(s,mid,2*node+1); build_tree(mid+1,e,2*node+2); tree[node]&#x3D;a[tree[2*node+1]]&gt;a[tree[2*node+2]]?tree[2*node+1]:tree[2*node+2];&#125;int query_tree(int s,int e,int node,int l,int r)&#123; if(e&lt;l||s&gt;r) return 0; if(s&gt;&#x3D;l&amp;&amp;e&lt;&#x3D;r) return tree[node]; int mid&#x3D;(s+e)&#x2F;2; int ln&#x3D;query_tree(s,mid,2*node+1,l,r); int rn&#x3D;query_tree(mid+1,e,2*node+2,l,r); return a[ln]&gt;a[rn]?ln:rn;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; _for(i,0,n-1) &#123; cin&gt;&gt;a[i]; st[i][0]&#x3D;i; &#125; int c&#x3D;clock(); cal(a,n); int s&#x3D;0,k&#x3D;m; while(k!&#x3D;0) &#123; int z&#x3D;query(s,n-1-k+1); cout&lt;&lt;a[z]&lt;&lt;&quot; &quot;; s&#x3D;z+1; k--; &#125; P(&quot;&quot;); PP(&quot;time&#x3D;&quot;,clock()-c); c&#x3D;clock(); build_tree(0,n-1,0); cout&lt;&lt;&quot;tree:&quot;; s&#x3D;0;k&#x3D;m; while(k!&#x3D;0) &#123; int z&#x3D;query_tree(0,n-1,0,s,n-1-k+1); cout&lt;&lt;a[z]&lt;&lt;&quot; &quot;; s&#x3D;z+1; k--; &#125; cout&lt;&lt;endl&lt;&lt;&quot;time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"RMQ","slug":"ACM/RMQ","permalink":"https://donghuangzhong.github.io/categories/ACM/RMQ/"}],"tags":[{"name":"ST","slug":"ST","permalink":"https://donghuangzhong.github.io/tags/ST/"}]},{"title":"C++_string","slug":"C-STL","date":"2020-03-26T02:54:47.000Z","updated":"2020-04-04T08:40:41.759Z","comments":true,"path":"2020/03/26/C-STL/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/26/C-STL/","excerpt":"简要记录C家族有效方法","text":"简要记录C家族有效方法 字符串strlen()返回的是’\\0’的位置加1 sprintfsprintf(char a[],”%d”,10) 各种形式转换成字符数组，可以string str(a)转换成string,然后用string的方法 123char s[5];sprintf(s, &quot;%d&quot;, i);string str(s); stringstr.find()找字符参数:(字符，起点下标(缺省0)) 找字符串参数：(字符串，起点坐标(缺省0)，找字符串的前n个字符串(缺省)) 12345string s&#x3D;&quot;helollo&quot;;cout&lt;&lt;s.find(&#39;l&#39;,3)&lt;&lt;endl;cout&lt;&lt;s.find(&quot;ll&quot;,0,1)&lt;&lt;endl;&#x2F;&#x2F;4&#x2F;&#x2F;2 str.find_first_of宏定义#的用法有时候我们想在打印变量前标明一下变量名字，如果一个一个手打非常的不方便，于是我们可以用宏定义中的#代表加引号的变量 123#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endlprint(s.find(&#39;l&#39;,3));&#x2F;&#x2F;s.find(&#39;l&#39;,3)&#x3D;4 二分查找upper_bound lower_bound123456bool cmp(int a,int b) &#123;return a&gt;b&#125;;int a[];查找区间[a,a+len+1)upper_bound(a,a+len+1,x) &#x2F;&#x2F;默认升序 第一个大于x的地址lower_bound(a,a+len+1,x) &#x2F;&#x2F;默认升序 第一个大于等于x的地址upper_bound(a,a+len+1,x,cmp) &#x2F;&#x2F;降序 第一个小于x的地址lower_bound(a,a+len+1,x,cmp) &#x2F;&#x2F;降序 第一个小于等于x的地址","categories":[{"name":"tools","slug":"tools","permalink":"https://donghuangzhong.github.io/categories/tools/"},{"name":"C++","slug":"tools/C","permalink":"https://donghuangzhong.github.io/categories/tools/C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://donghuangzhong.github.io/tags/STL/"}]},{"title":"蓝桥杯2020三月模拟赛解题报告","slug":"蓝桥杯2020三月模拟赛解题报告","date":"2020-03-26T02:33:02.000Z","updated":"2020-03-29T08:16:50.738Z","comments":true,"path":"2020/03/26/蓝桥杯2020三月模拟赛解题报告/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/26/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E4%B8%89%E6%9C%88%E6%A8%A1%E6%8B%9F%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"摘要","text":"摘要 第一题 单位变换题目【问题描述】在计算机存储中，15.125GB是多少MB？ 【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 思路1G=1024M 答案15488 第二题 约数个数题目【问题描述】1200000有多少个约数（只计算正约数）。 【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 思路枚举+检查 参考代码123456789101112131415161718#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input2.txt&quot;,&quot;r&quot;,stdin); int i&#x3D;1200000,sum&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;i;j++) &#123; if(i%j&#x3D;&#x3D;0) sum++; &#125; cout&lt;&lt;sum; return 0;&#125; 答案96 第三题 叶结点数题目【问题描述】一棵包含有2019个结点的二叉树，最多包含多少个叶结点？ 【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 思路ni为出度为i的节点，二叉树只有三种节点，出度为0,1,2的三种。并且有下面的关系 n=n0+n1+n2 n0=n2+1 证明法1：n个节点的二叉树共有n-1条边，n-1=2*n2+n1,带入1式得：n0=n2+1 证明法2:n0为叶子节点的个数，每两个叶子节点经过一次合并产生一个n2，得到一个新的叶子节点，也就是说每两个叶子节点经过一次合并减少一个叶子节点，产生一个n2。所以需要n-1次合并产生n-1个n2得到根节点，所以n0=n2+1 为使叶子节点数（n0）最多，必须n1最小，设为0，而n0=n2+1，得n2=(2019-1)/2=1009所以n0=1010 答案1010 第四题 数字9题目【问题描述】在1至2019中，有多少个数的数位中包含数字9？注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算时只是算一个数。 【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 思路两个方法 (1)分别计算各个位上的数字然后判断 (2)字符串 伪代码123for i from 9 to 2019 if str(i).contains(&#39;9&#39;) ans++ 参考代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;time.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;bool check(int i) &#123; char s[5]; sprintf(s, &quot;%d&quot;, i); string str(s); return str.find(&#39;9&#39;) !&#x3D; string::npos;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input2.txt&quot;,&quot;r&quot;,stdin); int n&#x3D;2019,sum&#x3D;0; int a&#x3D;clock(); for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; int g&#x3D;j%10; int s&#x3D;(j&#x2F;10)%10; int b&#x3D;(j&#x2F;100)%10; int q&#x3D;(j&#x2F;1000)%10; if(g&#x3D;&#x3D;9||s&#x3D;&#x3D;9||b&#x3D;&#x3D;9||q&#x3D;&#x3D;9) sum++; &#x2F;&#x2F;cout&lt;&lt;q&lt;&lt;b&lt;&lt;s&lt;&lt;g&lt;&lt;endl; &#125; cout&lt;&lt;sum&lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-a&lt;&lt;endl; a&#x3D;clock(); sum&#x3D;0;char s[10]; for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123; sprintf(s,&quot;%d&quot;,i); string str(s);; if(str.find(&#39;9&#39;)!&#x3D;string::npos) sum++; &#125; cout &lt;&lt; sum &lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-a&lt;&lt;endl; return 0; &#125; 答案544 第五题 数位递增的数题目【问题描述】一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？ 【输入格式】输入的第一行包含一个整数 n。 【输出格式】输出一行包含一个整数，表示答案。 【样例输入】30 【样例输出】26【评测用例规模与约定】对于 40% 的评测用例，1 &lt;= n &lt;= 1000。对于 80% 的评测用例，1 &lt;= n &lt;= 100000。对于所有评测用例，1 &lt;= n &lt;= 1000000。 思路 O(kN)两个方法 (1)计算每一位，判断 (2)迭代1~n 转换为字符串 迭代字符串的每一位，判断是否满足要求 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;time.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input2.txt&quot;,&quot;r&quot;,stdin); int n,sum&#x3D;0; cin&gt;&gt;n; int c&#x3D;clock(); for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int t&#x3D;i,lwei&#x3D;10,j; for(j&#x3D;1;j&lt;&#x3D;7;j++) &#123; int wei&#x3D;t%10; t&#x2F;&#x3D;10; if(wei&gt;lwei) break; lwei&#x3D;wei; &#125; if(j&gt;7) sum++; &#125; cout&lt;&lt;sum&lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-c&lt;&lt;endl; sum&#x3D;0; c&#x3D;clock(); char a[7]; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int j; sprintf(a,&quot;%d&quot;,i); for(j&#x3D;1;j&lt;strlen(a);j++) if(a[j-1]&gt;a[j]) break; if(j&#x3D;&#x3D;strlen(a)) sum++; &#125; cout&lt;&lt;sum&lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0; &#125; 第六题 递增三元组题目【问题描述】在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。 【输入格式】输入的第一行包含一个整数 n。第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。 【输出格式】输出一行包含一个整数，表示答案。 【样例输入】51 2 5 3 5 【样例输出】2 【样例说明】a[2] 和 a[4] 可能是三元组的中心。 【评测用例规模与约定】对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。 思路 O(N^2)枚举每个元素 该元素与前面的元素比较，找到小的即可 该元素与后面的元素比较，找到大的即可 上面两项为真，即说明当前元素可以作为三元组的中心O(N^2)，因为N最大为1000，所以1秒内可以解决战斗。 参考代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;time.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,sum&#x3D;0,a[10000],j,k; cin&gt;&gt;n; for(int i&#x3D;0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; int c&#x3D;clock(); for(int i&#x3D;1;i&lt;&#x3D;n-2;i++) &#123; for(j&#x3D;0;j&lt;i;j++) &#123; if(a[j]&lt;a[i]) break; &#125; if(j&#x3D;&#x3D;i) continue; for(k&#x3D;i+1;k&lt;n;k++) &#123; if(a[i]&lt;a[k]) break; &#125; if(k&#x3D;&#x3D;n) continue; sum++; &#125; cout&lt;&lt;sum&lt;&lt;&quot; 用时:&quot;&lt;&lt;clock()-c; return 0;&#125; 第七题 音节判断题目【问题描述】小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。 【输入格式】输入一行，包含一个单词，单词中只包含小写英文字母。 【输出格式】输出答案，或者为yes，或者为no。 【样例输入】lanqiao 【样例输出】yes 【样例输入】world 【样例输出】no 【评测用例规模与约定】对于所有评测用例，单词中的字母个数不超过100。 思路三个方法 (1)遍历字符串，如果是辅音就设y(bool)为0，直到找到元音，记录下标，继续遍历，找到第二个元音，然后判断第一个元音的下标是不是0，必须非0并且第二个元音之后的都是辅音 (2)逻辑和:遍历字符串，计算(judge(s[i])+judge(s[i+1]))==1的次数，如果最后次数==3，说明合题意 (3)字符串现成的方法 找到第一个元音的下标index1，必须大于0，且能找到沿着index1继续找下一个非元音得到index2，必须能找到沿着index2继续找下一个元音得到index3，必须能找到最后判断index3-1位置的字符应该是从后往前第一个非元音（因为index3及以后的字符都必须是元音了） 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&#x2F;&#x2F;qwrtypsdfghjklzxcvbnmaeiouuoieamnbvcxzlkjhgfdspytrwqaaeeiioouu&#x2F;&#x2F;yes time&#x3D;0&#x2F;&#x2F;yes time&#x3D;0&#x2F;&#x2F;yes time&#x3D;0#include&lt;cstdio&gt;#include&lt;memory&gt;#include&lt;time.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;bool judge(char c)&#123; if(c&#x3D;&#x3D;&#39;a&#39;||c&#x3D;&#x3D;&#39;e&#39;||c&#x3D;&#x3D;&#39;i&#39;||c&#x3D;&#x3D;&#39;o&#39;||c&#x3D;&#x3D;&#39;u&#39;) return 1; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); string s; int index[2]; int in&#x3D;0,sum&#x3D;0,k; bool y&#x3D;0,flag&#x3D;0; cin&gt;&gt;s; int c&#x3D;clock(); for(int i&#x3D;0;i&lt;s.length();i++) &#123; if(judge(s[i])) &#123; if(y&#x3D;&#x3D;0) &#123; y&#x3D;1; index[in++]&#x3D;i; if(in&#x3D;&#x3D;2) &#123; if(index[0]&#x3D;&#x3D;0) &#123; flag&#x3D;0; break; &#125; for(k&#x3D;index[1];k&lt;s.length();k++) &#123; if(!judge(s[k])) &#123; flag&#x3D;0; break; &#125; &#125; if(k&#x3D;&#x3D;s.length()) flag&#x3D;1; else break; &#125; &#125; else continue; &#125; else y&#x3D;0; &#125; if(flag) cout&lt;&lt;&quot;yes&quot;; else cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; c&#x3D;clock(); int jiao&#x3D;0; for(int i&#x3D;0;i&lt;s.length()-1;i++) &#123; if((judge(s[i])+judge(s[i+1]))&#x3D;&#x3D;1) jiao++; &#125; if(jiao&#x3D;&#x3D;3) cout&lt;&lt;&quot;yes&quot;; else cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; c&#x3D;clock(); int index1&#x3D;s.find_first_of(&quot;aeiou&quot;); if(!index1||index1&#x3D;&#x3D;string::npos) &#123; cout&lt;&lt;&quot;no&quot;; return 0; &#125; int index2&#x3D;s.find_first_not_of(&quot;aeiou&quot;,index1+1); if(index2&#x3D;&#x3D;string::npos) &#123; cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0; &#125; int index3&#x3D;s.find_first_of(&quot;aeiou&quot;,index2+1); if(index3&#x3D;&#x3D;string::npos) &#123; cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0; &#125; int index4&#x3D;s.find_last_not_of(&quot;aeiou&quot;); if(index4!&#x3D;index3-1) &#123; cout&lt;&lt;&quot;no&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0; &#125; cout&lt;&lt;&quot;yes&quot;; cout&lt;&lt;&quot; time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; return 0;&#125; 第八题 长草题目【问题描述】小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。请告诉小明，k 个月后空地上哪些地方有草。 【输入格式】输入的第一行包含两个整数 n, m。接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。接下来包含一个整数 k。 【输出格式】输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。 【样例输入】4 5.g……....g..…..2 【样例输出】gggg.gggg.ggggg.ggg. 【评测用例规模与约定】对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= k &lt;= 1000。 思路 O(N*M)(1)dfs有可能会超时 (2)典型的多入口bfs，基本是个模板题。时间复杂度最多为O(N*M)。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;cstdio&gt;#include&lt;time.h&gt;#include&lt;memory&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;struct Point&#123; int x,y,kk;&#125;;char map[1010][1010],save[1010][1010];int m,n,k;queue&lt;Point&gt; q; int dir[4][2]&#x3D;&#123;0,1,0,-1,1,0,-1,0&#125;;void manyan(int x,int y)&#123; for(int i&#x3D;0;i&lt;4;i++) &#123; int xx&#x3D;x+dir[i][0]; int yy&#x3D;y+dir[i][1]; if(xx&gt;&#x3D;0&amp;&amp;xx&lt;m&amp;&amp;yy&gt;&#x3D;0&amp;&amp;yy&lt;n) &#123; if(map[xx][yy]&#x3D;&#x3D;&#39;.&#39;) map[xx][yy]&#x3D;&#39;d&#39;; &#125; &#125;&#125;void bfs()&#123; Point a,b; while(!q.empty()) &#123; a&#x3D;q.front(); if(a.kk&#x3D;&#x3D;k) return ; q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(b.x&gt;&#x3D;0&amp;&amp;b.x&lt;m&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;n&amp;&amp;map[b.x][b.y]&#x3D;&#x3D;&#39;.&#39;) &#123; b.kk&#x3D;a.kk+1; map[b.x][b.y]&#x3D;&#39;g&#39;; q.push(b); &#125; &#125; &#125;&#125;void show(char map[1010][1010])&#123; for(int i&#x3D;0;i&lt;m;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; cout&lt;&lt;map[i][j]; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;m&gt;&gt;n; for(int i&#x3D;0;i&lt;m;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]&#x3D;&#x3D;&#39;g&#39;) q.push(&#123;i,j,0&#125;); &#125; &#125; memcpy(save,map,sizeof(map)); cin&gt;&gt;k; int c&#x3D;clock(); bfs(); cout&lt;&lt;&quot;time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; show(map); memcpy(map,save,sizeof(map)); c&#x3D;clock(); for(int i&#x3D;0;i&lt;k;i++) &#123; for(int ii&#x3D;0;ii&lt;m;ii++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; if(map[ii][j]&#x3D;&#x3D;&#39;g&#39;) manyan(ii,j); &#125; &#125; for(int ii&#x3D;0;ii&lt;m;ii++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; if(map[ii][j]&#x3D;&#x3D;&#39;d&#39;) map[ii][j]&#x3D;&#39;g&#39;; &#125; &#125; &#125; cout&lt;&lt;&quot;time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; show(map); return 0;&#125; 第九题 序列计数题目【问题描述】小明想知道，满足以下条件的正整数序列的数量： 第一项为 n； 第二项不超过 n； 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。 【输入格式】输入一行包含一个整数 n。 【输出格式】输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。 【样例输入】4 【样例输出】7 【样例说明】以下是满足条件的序列：4 14 1 14 1 24 24 2 14 34 4 【评测用例规模与约定】对于 20% 的评测用例，1 &lt;= n &lt;= 5；对于 50% 的评测用例，1 &lt;= n &lt;= 10；对于 80% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 1000。 思路：void dfs1(当前选择的点，下一次选择的范围)正向思维，注意这里每次都可以选择不向下找了，将后面补0，直接递归看做结束的条件(严重超时) int dfs2(上上一个选择的数字,上一个选择的数据)逆向思维，和第一个半斤八两，初始化为1是因为本身就是一种情况 记忆性递归(O(n^3)) 参数和第二个相同从第一、二种中可以看出有可能重复，所以加上一个矩阵记录 递归优化dfs4(i,j) 表示前一个点是i,后一个点是[1,j]这些可能性的总和，显然dfs4(i,j)=dfs4(i,j-1)+1+dfs4(j,|i-j|)，为什么要加1？问的好，因为1表示的是(i,j(后面没有了))这一种情况 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int mem[1001][1001],sum;void dfs1(int aa,int jue)&#123; if(aa&#x3D;&#x3D;0) &#123; sum++; return ; &#125; dfs1(0,aa); _for(i,1,jue-1) &#123; int t&#x3D;(aa&gt;&#x3D;i)?(aa-i):(i-aa); dfs1(i,t); &#125;&#125;int dfs2(int a,int b)&#123; int t&#x3D;(a&gt;&#x3D;b?(a-b):(b-a)); int ans&#x3D;1; _for(i,1,t-1) ans+&#x3D;dfs2(b,i); return ans%10000; &#125;int dfs3(int a,int b)&#123; if(mem[a][b]) return mem[a][b]; int cha&#x3D;a&gt;&#x3D;b?(a-b):(b-a); int ans&#x3D;1; _for(i,1,cha-1) ans+&#x3D;dfs3(b,i); ans%&#x3D;10000; mem[a][b]&#x3D;ans; return ans;&#125; int dfs4(int a,int b)&#123; if(b&lt;&#x3D;0) return 0; if(mem[a][b]) return mem[a][b]; int t&#x3D;(a&gt;&#x3D;b?(a-b):(b-a)); return mem[a][b]&#x3D;(dfs4(a,b-1)+1+dfs4(b,t-1))%10000;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; int c&#x3D;clock(); sum&#x3D;0; _for(j,1,n) dfs1(j,n-j); P(sum%10000); PP(&quot;time&quot;,clock()-c); c&#x3D;clock(); sum&#x3D;0; _for(i,1,n) sum+&#x3D;dfs2(n,i); P(sum%10000); PP(&quot;time&quot;,clock()-c); c&#x3D;clock(); sum&#x3D;0; _for(i,1,n) sum+&#x3D;dfs3(n,i); P(sum%10000); PP(&quot;time&quot;,clock()-c); memset(mem,0,sizeof(mem)); c&#x3D;clock(); P(dfs4(n,n)); PP(&quot;time&quot;,clock()-c); return 0;&#125; 第十题 晚会节目单题目【问题描述】小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。小明发现，观众对于晚会的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。 【输入格式】输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。第二行包含 n 个整数，依次为每个节目的好看值。 【输出格式】输出一行包含 m 个整数，为选出的节目的好看值。 【样例输入】5 33 1 2 5 4 【样例输出】3 5 4 【样例说明】选择了第1, 4, 5个节目。 【评测用例规模与约定】对于 30% 的评测用例，1 &lt;= n &lt;= 20；对于 60% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。 错误思路如果用两次排序求解，那就错了。因为并不是要选出的方案的好看值总和最大，而是要从前往后尽量好看。即选出的M个数字典序最大 思路 O(N^2)ST+RMQ 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#define PP(a,b) cout&lt;&lt;a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;b&lt;&lt;endl#define P(a) cout&lt;&lt;a&lt;&lt;endl#define print(a) cout&lt;&lt;#a&lt;&lt;&quot;&#x3D;&quot;&lt;&lt;a&lt;&lt;endl#define _for(i,s,e) for(int i&#x3D;s;i&lt;&#x3D;e;i++)using namespace std;int n,m;int a[100001];int tree[400001];int st[100001][20];int pow_2(int p) &#123; return 1 &lt;&lt; p;&#125;void cal(int a[],int n)&#123; for(int j&#x3D;1;(1&lt;&lt;(j-1))&lt;&#x3D;n;j++) &#123; for(int i&#x3D;0;i+(1&lt;&lt;j)-1&lt;&#x3D;n-1;i++) &#123; st[i][j]&#x3D;a[st[i][j-1]]&gt;a[st[i+pow_2(j-1)][j-1]]?st[i][j-1]:st[i+pow_2(j-1)][j-1]; &#125; &#125; &#125;int query(int s,int e)&#123; int t&#x3D;(int)(log(e-s+1)&#x2F;log(2)); return a[st[s][t]]&gt;a[st[e-(1&lt;&lt;t)+1][t]]?st[s][t]:st[e-(1&lt;&lt;t)+1][t];&#125; void build_tree(int s,int e,int node)&#123; if(s&#x3D;&#x3D;e) &#123; tree[node]&#x3D;s; return ; &#125; int mid&#x3D;(s+e)&#x2F;2; build_tree(s,mid,2*node+1); build_tree(mid+1,e,2*node+2); tree[node]&#x3D;a[tree[2*node+1]]&gt;a[tree[2*node+2]]?tree[2*node+1]:tree[2*node+2];&#125;int query_tree(int s,int e,int node,int l,int r)&#123; if(e&lt;l||s&gt;r) return 0; if(s&gt;&#x3D;l&amp;&amp;e&lt;&#x3D;r) return tree[node]; int mid&#x3D;(s+e)&#x2F;2; int ln&#x3D;query_tree(s,mid,2*node+1,l,r); int rn&#x3D;query_tree(mid+1,e,2*node+2,l,r); return a[ln]&gt;a[rn]?ln:rn;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; _for(i,0,n-1) &#123; cin&gt;&gt;a[i]; st[i][0]&#x3D;i; &#125; int c&#x3D;clock(); cal(a,n); int s&#x3D;0,k&#x3D;m; while(k!&#x3D;0) &#123; int z&#x3D;query(s,n-1-k+1); cout&lt;&lt;a[z]&lt;&lt;&quot; &quot;; s&#x3D;z+1; k--; &#125; P(&quot;&quot;); PP(&quot;time&#x3D;&quot;,clock()-c); c&#x3D;clock(); build_tree(0,n-1,0); cout&lt;&lt;&quot;tree:&quot;; s&#x3D;0;k&#x3D;m; while(k!&#x3D;0) &#123; int z&#x3D;query_tree(0,n-1,0,s,n-1-k+1); cout&lt;&lt;a[z]&lt;&lt;&quot; &quot;; s&#x3D;z+1; k--; &#125; cout&lt;&lt;endl&lt;&lt;&quot;time&#x3D;&quot;&lt;&lt;clock()-c&lt;&lt;endl; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"解题报告","slug":"ACM/解题报告","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"蓝桥杯2020模拟赛","slug":"蓝桥杯2020模拟赛","permalink":"https://donghuangzhong.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}]},{"title":"UVA-1052-算法训练-Bit Compressor","slug":"UVA-1052-算法训练-Bit-Compressor","date":"2020-03-25T08:23:34.000Z","updated":"2020-03-26T02:19:58.169Z","comments":true,"path":"2020/03/25/UVA-1052-算法训练-Bit-Compressor/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/25/UVA-1052-%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-Bit-Compressor/","excerpt":"dfs奥义:不确定性即可能性！并且有时候可能性可以没有顺序！本文的不确定性在于对于前面有1的0，不确定是分隔符还是二进制中的一部分。这就是不确定性，也就是可能性。本程序还利用了二进制的动态计算。","text":"dfs奥义:不确定性即可能性！并且有时候可能性可以没有顺序！本文的不确定性在于对于前面有1的0，不确定是分隔符还是二进制中的一部分。这就是不确定性，也就是可能性。本程序还利用了二进制的动态计算。 试题 算法训练 Bit Compressor提交此题 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 数据压缩的目的是为了减少存储和交换数据时出现的冗余。这增加了有效数据的比重并提高了传输速率。有一种压缩二进制串的方法是这样的： 将连续的n个1替换为n的二进制表示（注：替换发生当且仅当这种替换减少了二进制串的总长度） （译者注：连续的n个1的左右必须是0或者是串的开头、结尾） 比如：11111111001001111111111111110011会被压缩成10000010011110011。原串长为32,被压缩后串长为17. 这种方法的弊端在于，有时候解压缩算法会得到不止一个可能的原串，使得我们无法确定原串究竟是什么。请你写一个程序来判定我们能否利用压缩后的信息来确定原串。给出原串长L，原串中1的个数N，以及压缩后的串。 L&lt;=16 Kbytes，压缩后的串长度&lt;=40 bits。 输入格式 第一行两个整数L,N，含义同问题描述 第二行一个二进制串，表示压缩后的串 输出格式 输出”YES”或”NO”或”NOT UNIQUE”（不包含引号） 分别表示： YES：原串唯一 NO：原串不存在 NOT UNIQUE：原串存在但不唯一 样例输入样例1：32 2610000010011110011样例2：9 71010101样例3：14 14111111 样例输出样例1：YES样例2：NOT UNIQUE样例3：NO 算法先说二进制的动态计算，你可能会说我还不会二进制转十进制吗？例如1101，分别计算1,11,110,1101。每一个的前面都是重复的，我们可以用到前面的计算结果，这样可以避免重复计算，提高效率。 dfs参数(要处理的位置下标，已经处理的原串中的字符个数，已经处理的原串中的1的个数)。后两个参数是为了剪枝的。如果碰到前面没有1的0直接跳过，因为肯定是原串中的0，对于每个前面有1的0我们提供两种选择，一是作为原串中的0(把前面的反编码成二进制个1)，二是作为二进制中的0。但是这样会出现一个棘手的问题，一是10不能反编码回去，因为反编码得到11，长度都是2，不合题意，你可能说1也不能反编码回去，但是1无论是反编码还是不反编码得到的都是一样的结果，既然这样为什么还认为1不能反编码增加额外代码量呢？也就是说原串中的11是不能编码成10的，所以编码后的串中如果出现11不能确定是原串中的是11还是111，也就是说按照碰到前面有1的0就提供两种可能性的策略，对于10不能进去，对于11少算了一个。对于少算的可以额外增加，因为可能性的顺序没关系。但是对于多算的我们要加条件过滤。于是代码就产生了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;#define maxn 50int n,m; string s;int answer&#x3D;0; void dfs(int pos,int len,int len_1)&#123; if(pos&#x3D;&#x3D;s.length()&amp;&amp;len&#x3D;&#x3D;n&amp;&amp;len_1&#x3D;&#x3D;m) &#123; answer++; return ; &#125; if(pos&gt;&#x3D;s.length()||len&gt;n||len_1&gt;m) return ; if(s[pos]&#x3D;&#x3D;&#39;0&#39;) &#123; dfs(pos+1,len+1,len_1); return ; &#125; int t&#x3D;0; for(int i&#x3D;pos;i&lt;s.length();i++) &#123; t*&#x3D;2; t+&#x3D;s[i]-&#39;0&#39;; if(len_1+t&gt;m||len+t&gt;n) break; if(s[i+1]!&#x3D;&#39;1&#39;&amp;&amp;(t!&#x3D;2)) dfs(i+1,len+t,len_1+t); &#125; if(s[pos+1]&#x3D;&#x3D;&#39;1&#39;&amp;&amp;s[pos+2]!&#x3D;&#39;1&#39;) dfs(pos+2,len+2,len_1+2);&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int e&#x3D;1; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n)&#123; answer&#x3D;0; cin&gt;&gt;s; dfs(0,0,0); printf(&quot;Case #%d: &quot;,e++); if(answer&#x3D;&#x3D;0) printf(&quot;NO\\n&quot;); else if(answer&#x3D;&#x3D;1) printf(&quot;YES\\n&quot;); else printf(&quot;NOT UNIQUE\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"高级dfs","slug":"ACM/高级dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%AB%98%E7%BA%A7dfs/"}],"tags":[{"name":"编码","slug":"编码","permalink":"https://donghuangzhong.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"动态二进制","slug":"动态二进制","permalink":"https://donghuangzhong.github.io/tags/%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"算法训练 cNteSahruPfefrlefe","slug":"算法训练-cNteSahruPfefrlefe","date":"2020-03-20T09:09:31.000Z","updated":"2020-03-20T09:09:31.642Z","comments":true,"path":"2020/03/20/算法训练-cNteSahruPfefrlefe/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/20/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-cNteSahruPfefrlefe/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"算法训练 Sticks","slug":"算法训练-Sticks","date":"2020-03-18T11:08:24.000Z","updated":"2020-03-18T11:38:23.496Z","comments":true,"path":"2020/03/18/算法训练-Sticks/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/18/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-Sticks/","excerpt":"还记得dfs的入门题吗？输入n个数和一个结果m,问这n个数能不能组合成m。这个题就是在能凑成m的基础上再从头开始搜索，注意不能运行多次dfs，而是要递归调用，因为不能确定找到一个m就是其中的一个m，有可能不合法。dfs的代码风格有两种，一种是正序，一种是倒序","text":"还记得dfs的入门题吗？输入n个数和一个结果m,问这n个数能不能组合成m。这个题就是在能凑成m的基础上再从头开始搜索，注意不能运行多次dfs，而是要递归调用，因为不能确定找到一个m就是其中的一个m，有可能不合法。dfs的代码风格有两种，一种是正序，一种是倒序 问题试题 算法训练 Sticks提交此题 资源限制 时间限制：1.0s 内存限制：999.4MB Sticks Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 113547 Accepted: 26078 问题描述 George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero. 输入格式 The input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the file contains zero. 输出格式 The output should contains the smallest possible length of original sticks, one per line. 样例输入95 2 1 5 2 1 5 2 141 2 3 40 样例输出56 题目大意多个测试用例，第一行输入木棒的个数n，下一行输入n个数代表不同木棒的长度，这些木棒可以组成m个长度为k的长木棒，输出k的最小值","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dfs","slug":"ACM/dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/dfs/"}],"tags":[{"name":"高级dfs","slug":"高级dfs","permalink":"https://donghuangzhong.github.io/tags/%E9%AB%98%E7%BA%A7dfs/"}]},{"title":"基础练习 字符串对比","slug":"基础练习-字符串对比","date":"2020-03-14T10:12:05.000Z","updated":"2020-03-14T10:18:28.577Z","comments":true,"path":"2020/03/14/基础练习-字符串对比/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E6%AF%94/","excerpt":"首先1很好判断，并且1和234对立(一组if else)，再看2，需要全部对比完才能；而34只要一个不满足就可以输出，所以34的判断在2的前面，根据题目逻辑，4要在三的前面。于是逻辑就清楚了。","text":"首先1很好判断，并且1和234对立(一组if else)，再看2，需要全部对比完才能；而34只要一个不满足就可以输出，所以34的判断在2的前面，根据题目逻辑，4要在三的前面。于是逻辑就清楚了。 问题试题 基础练习 字符串对比提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4中情况之一： 1：两个字符串长度不等。比如 Beijing 和 Hebei 2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如 Beijing 和 Beijing 3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如 beijing 和 BEIjing 4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing 编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。 输入格式 包括两行，每行都是一个字符串 输出格式 仅有一个数字，表明这两个字符串的关系编号 样例输入BEIjing 1beiJing 样例输出3 算法12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); char a[10],b[10]; cin&gt;&gt;a&gt;&gt;b; if(strlen(a)!&#x3D;strlen(b)) cout&lt;&lt;&quot;1&quot;; else&#123; for(int i&#x3D;0;i&lt;strlen(a);i++) &#123; int t&#x3D;a[i]-b[i]; if(!(t&#x3D;&#x3D;32||t&#x3D;&#x3D;-32||t&#x3D;&#x3D;0)) &#123;cout&lt;&lt;&quot;4&quot;;return 0; &#125; else if(t!&#x3D;0) &#123; cout&lt;&lt;&quot;3&quot;; return 0; &#125; &#125; cout&lt;&lt;&quot;2&quot;; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"判断条件的先后","slug":"判断条件的先后","permalink":"https://donghuangzhong.github.io/tags/%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%88%E5%90%8E/"}]},{"title":"基础练习 完美的代价","slug":"基础练习-完美的代价","date":"2020-03-14T09:59:56.000Z","updated":"2020-03-14T10:11:24.635Z","comments":true,"path":"2020/03/14/基础练习-完美的代价/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7/","excerpt":"注意交换方式是相邻互换，每次处理的范围都是[i,j]，k=j,k&gt;=i,k–。从j往前找和i一样的字符，找到了就k,j交换，记录交换次数，j–,i++；找不到则判断总数奇偶，偶则直接输出不可能，奇则做一个标记(因为总数是奇数可以允许一个字符不成对，但这个字符必须在中间)，然后记录将i移动到中间的步数(注意只是记录而不移动，因为移动了也会被再次打乱)，i++，继续从下一个找,如果有遇到一个找不到的，直接输出不可能","text":"注意交换方式是相邻互换，每次处理的范围都是[i,j]，k=j,k&gt;=i,k–。从j往前找和i一样的字符，找到了就k,j交换，记录交换次数，j–,i++；找不到则判断总数奇偶，偶则直接输出不可能，奇则做一个标记(因为总数是奇数可以允许一个字符不成对，但这个字符必须在中间)，然后记录将i移动到中间的步数(注意只是记录而不移动，因为移动了也会被再次打乱)，i++，继续从下一个找,如果有遇到一个找不到的，直接输出不可能 问题试题 基础练习 完美的代价提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。 交换的定义是：交换两个相邻的字符 例如mamad 第一次交换 ad : mamda 第二次交换 md : madma 第三次交换 ma : madam (回文！完美！) 输入格式 第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000) 第二行是一个字符串，长度为N.只包含小写字母 输出格式 如果可能，输出最少的交换次数。 否则输出Impossible 样例输入5mamad 样例输出3 算法1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n; char s[8001]; cin&gt;&gt;n&gt;&gt;s; int j&#x3D;n-1,sum&#x3D;0; bool flag&#x3D;0; for(int i&#x3D;0;i&lt;&#x3D;j;i++) &#123; for(int k&#x3D;j;k&gt;&#x3D;i;k--) &#123; if(i&#x3D;&#x3D;k) &#123; if(flag||(n&amp;1)&#x3D;&#x3D;0) &#123; cout &lt;&lt; &quot;Impossible&quot;; return 0; &#125; flag&#x3D;1; sum+&#x3D;n&#x2F;2-i; &#125; else if(s[i]&#x3D;&#x3D;s[k]) &#123; for(int i&#x3D;k;i&lt;&#x3D;j-1;i++) &#123; swap(s[i],s[i+1]); sum++; &#125; j--; break; &#125; &#125; &#125; cout&lt;&lt;sum;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"回文","slug":"ACM/回文","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%9B%9E%E6%96%87/"}],"tags":[{"name":"移动成回文最短","slug":"移动成回文最短","permalink":"https://donghuangzhong.github.io/tags/%E7%A7%BB%E5%8A%A8%E6%88%90%E5%9B%9E%E6%96%87%E6%9C%80%E7%9F%AD/"}]},{"title":"基础练习 数的读法","slug":"基础练习-数的读法","date":"2020-03-14T09:21:46.000Z","updated":"2020-03-14T09:59:32.837Z","comments":true,"path":"2020/03/14/基础练习-数的读法/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E6%95%B0%E7%9A%84%E8%AF%BB%E6%B3%95/","excerpt":"先看题目的规模，最大到十亿的单位。中文的数字单位有个特点，个十百千一组，万一组，亿一组。也就是读一个数先读亿前面的个十百千读法，然后加上亿，然后再读亿到万的个十百千读法，然后再读万，然后再读个十百千。比如12 3456 7890，先读亿前面的数字，十二，然后加上亿，在读亿和万之间的数字，三千四百五十六，然后加上万，然后读七千八百九十，最终读十二亿三千四百五十六万七千八百九十。还有一些其他的一些细节。","text":"先看题目的规模，最大到十亿的单位。中文的数字单位有个特点，个十百千一组，万一组，亿一组。也就是读一个数先读亿前面的个十百千读法，然后加上亿，然后再读亿到万的个十百千读法，然后再读万，然后再读个十百千。比如12 3456 7890，先读亿前面的数字，十二，然后加上亿，在读亿和万之间的数字，三千四百五十六，然后加上万，然后读七千八百九十，最终读十二亿三千四百五十六万七千八百九十。还有一些其他的一些细节。 问题试题 基础练习 数的读法提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 Tom教授正在给研究生讲授一门关于基因的课程，有一件事情让他颇为头疼：一条染色体上有成千上万个碱基对，它们从0开始编号，到几百万，几千万，甚至上亿。 比如说，在对学生讲解第1234567009号位置上的碱基时，光看着数字是很难准确的念出来的。 所以，他迫切地需要一个系统，然后当他输入12 3456 7009时，会给出相应的念法： 十二亿三千四百五十六万七千零九 用汉语拼音表示为 shi er yi san qian si bai wu shi liu wan qi qian ling jiu 这样他只需要照着念就可以了。 你的任务是帮他设计这样一个系统：给定一个阿拉伯数字串，你帮他按照中文读写的规范转为汉语拼音字串，相邻的两个音节用一个空格符格开。 注意必须严格按照规范，比如说“10010”读作“yi wan ling yi shi”而不是“yi wan ling shi”，“100000”读作“shi wan”而不是“yi shi wan”，“2000”读作“er qian”而不是“liang qian”。 输入格式 有一个数字串，数值大小不超过2,000,000,000。 输出格式 是一个由小写英文字母，逗号和空格组成的字符串，表示该数的英文读法。 样例输入1234567009 样例输出shi er yi san qian si bai wu shi liu wan qi qian ling jiu 算法知道了大概的读法之后就可以写了，于是就需要一个数组存数字的读法，一个数组存单位的读法，这里不需要个位，将个位置空就行，因为我们平时也不读个位。然后判断输入的规模到亿了吗？如果到亿(倒数第九位)了就将单位数组和亿对齐，并将个位置“yi”,到万(倒数第五位)则跟万对齐，个位置“wan”，否则对齐最后一位,个位置空。例如 12 3456 7890 10 ​ 3210 ​ 3210 第二三四行代表数组单位的下标，此时的对齐的标准是亿，个位置“yi”,然后读一个数字读一个单位，读出&quot;yi shi er yi&quot;，注意此时的个位置&quot;yi&quot;，所以读出&quot;yi&quot;。这样就可以读出数来了，然而还是存在一些问题，比如，12(仅限开头，412中的1还是要读的)应读作”shi er”而不是“yi shi er”,这个问题很好解决，加一个判断的条件，开头为1单位是“shi”的时候不读yi”。102应读作“yi bai ling er”而不是“yi bai ling shi er”,这个问题也很好解决，零的时候数字和单位都不读，如果遇到非零数字的上一个数字是零就多读一个“ling ”。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; char s[11]; cin&gt;&gt;s; string shu[10]&#x3D;&#123;&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;&#125;; string d[6]&#x3D;&#123;&quot;&quot;,&quot;shi&quot;,&quot;bai&quot;,&quot;qian&quot;,&quot;wan&quot;,&quot;yi&quot;&#125;; int len&#x3D;strlen(s); int p; for(int i&#x3D;0;i&lt;strlen(s);i++) &#123; if(strlen(s)-i&gt;&#x3D;9) p&#x3D;9; else if(strlen(s)-i&gt;&#x3D;5) p&#x3D;5; else p&#x3D;1; int j&#x3D;strlen(s)-p-i; if(s[i]!&#x3D;&#39;0&#39;) &#123; if(p&#x3D;&#x3D;9) d[0]&#x3D;&quot;yi &quot;; else if(p&#x3D;&#x3D;5) d[0]&#x3D;&quot;wan &quot;; else d[0]&#x3D;&quot;&quot;; if(i&gt;&#x3D;1&amp;&amp;s[i-1]&#x3D;&#x3D;&#39;0&#39;) cout&lt;&lt;&quot;ling&quot;&lt;&lt;&quot; &quot;; if(!(i&#x3D;&#x3D;0&amp;&amp;s[i]&#x3D;&#x3D;&#39;1&#39;&amp;&amp;j&#x3D;&#x3D;1)) cout&lt;&lt;shu[s[i]-&#39;0&#39;]&lt;&lt;&quot; &quot;; if(j!&#x3D;0) cout&lt;&lt;d[j]&lt;&lt;&quot; &quot;; &#125; if(j&#x3D;&#x3D;0) &#123; cout&lt;&lt;d[0]; d[0]&#x3D;&quot;&quot;; &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"读数字","slug":"读数字","permalink":"https://donghuangzhong.github.io/tags/%E8%AF%BB%E6%95%B0%E5%AD%97/"}]},{"title":"基础练习 时间转换","slug":"基础练习-时间转换","date":"2020-03-14T09:10:50.000Z","updated":"2020-03-14T09:21:25.741Z","comments":true,"path":"2020/03/14/基础练习-时间转换/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/","excerpt":"十进制转六十进制的倒数第三位","text":"十进制转六十进制的倒数第三位 题目试题 基础练习 时间转换提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 给定一个以秒为单位的时间t，要求用“::”的格式来表示这个时间。表示时间，表示分钟，而表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。 输入格式 输入只有一行，是一个整数t（0&lt;=t&lt;=86399）。 输出格式 输出只有一行，是以“::”的格式所表示的时间，不包括引号。 样例输入0 样例输出0:0:0 样例输入5436 样例输出1:30:36 算法1234567891011121314#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int t; cin&gt;&gt;t; int h&#x3D;t&#x2F;(60*60); t-&#x3D;h*(60*60); int m&#x3D;t&#x2F;60; t-&#x3D;m*60; cout&lt;&lt;h&lt;&lt;&quot;:&quot;&lt;&lt;m&lt;&lt;&quot;:&quot;&lt;&lt;t;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"进制","slug":"ACM/进制","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%BF%9B%E5%88%B6/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"基础练习 矩阵乘法","slug":"基础练习-矩阵乘法","date":"2020-03-14T08:27:26.000Z","updated":"2020-03-14T09:10:18.994Z","comments":true,"path":"2020/03/14/基础练习-矩阵乘法/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/","excerpt":"整数的乘法初始化为1，矩阵的乘法初始化为大小相同单位矩阵(只有对角线全是1)。必须由第三个变量保存结果。for循环不仅控制次数还控制积和被乘数每次的变换。","text":"整数的乘法初始化为1，矩阵的乘法初始化为大小相同单位矩阵(只有对角线全是1)。必须由第三个变量保存结果。for循环不仅控制次数还控制积和被乘数每次的变换。 问题试题 基础练习 矩阵乘法提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 给定一个N阶矩阵A，输出A的M次幂（M是非负整数） 例如： A = 1 2 3 4 A的2次幂 7 10 15 22 输入格式 第一行是一个正整数N、M（1&lt;=N&lt;=30, 0&lt;=M&lt;=5），表示矩阵A的阶数和要求的幂数 接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值 输出格式 输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开 样例输入2 21 23 4 样例输出7 1015 22 算法1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int juzhen[30][30],jieguo[2][30][30],nn&#x3D;0; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i&#x3D;0;i&lt;n;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; cin&gt;&gt;juzhen[i][j]; jieguo[0][i][j]&#x3D;i&#x3D;&#x3D;j?1:0; &#125; &#125; for(int i&#x3D;0;i&lt;m;i++) &#123; nn&#x3D;i&amp;1?0:1; for(int j&#x3D;0;j&lt;n;j++) &#123; for(int k&#x3D;0;k&lt;n;k++) &#123; int sum&#x3D;0; for(int l&#x3D;0;l&lt;n;l++) &#123; sum+&#x3D;jieguo[1-nn][j][l]*juzhen[l][k]; &#125; jieguo[nn][j][k]&#x3D;sum; &#125; &#125; &#125; for(int j&#x3D;0;j&lt;n;j++) &#123; for(int k&#x3D;0;k&lt;n;k++) cout&lt;&lt;jieguo[nn][j][k]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"矩阵乘法","slug":"ACM/矩阵乘法","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"}],"tags":[{"name":"妙用下标和","slug":"妙用下标和","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E4%B8%8B%E6%A0%87%E5%92%8C/"}]},{"title":"基础练习 矩形面积交","slug":"基础练习-矩形面积交","date":"2020-03-14T08:16:17.000Z","updated":"2020-03-14T08:26:58.826Z","comments":true,"path":"2020/03/14/基础练习-矩形面积交/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E4%BA%A4/","excerpt":"如果判断一个线段跟另一个线段相交的长度的话，起点就是两个线段起点的最大值，终点就是两个线段的终点的最小值。然后判断一下终点是不是比起点大，如果终点比起点小的话就不相交。但因为我们通常不知道线段的起点和终点，所以要进行比较。所以这个方法也可以推广到n维。","text":"如果判断一个线段跟另一个线段相交的长度的话，起点就是两个线段起点的最大值，终点就是两个线段的终点的最小值。然后判断一下终点是不是比起点大，如果终点比起点小的话就不相交。但因为我们通常不知道线段的起点和终点，所以要进行比较。所以这个方法也可以推广到n维。 问题试题 基础练习 矩形面积交提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。 输入格式 输入仅包含两行，每行描述一个矩形。 在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。 输出格式 输出仅包含一个实数，为交的面积，保留到小数后两位。 样例输入1 1 3 32 2 4 4 样例输出1.00 算法1234567891011121314151617#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; double a[8]; for(int i&#x3D;0;i&lt;8;i++) cin&gt;&gt;a[i]; double xmin&#x3D;max(min(a[0],a[2]),min(a[4],a[6])); double xmax&#x3D;min(max(a[0],a[2]),max(a[4],a[6])); double ymin&#x3D;max(min(a[1],a[3]),min(a[5],a[7])); double ymax&#x3D;min(max(a[1],a[3]),max(a[5],a[7])); if(xmin&lt;xmax&amp;&amp;ymin&lt;ymax) printf(&quot;%.2f&quot;,(xmax-xmin)*(ymax-ymin)); else cout&lt;&lt;&quot;0.00&quot;;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"线段交","slug":"ACM/线段交","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%BA%BF%E6%AE%B5%E4%BA%A4/"}],"tags":[{"name":"n维交","slug":"n维交","permalink":"https://donghuangzhong.github.io/tags/n%E7%BB%B4%E4%BA%A4/"}]},{"title":"基础练习 分解质因数","slug":"基础练习-分解质因数","date":"2020-03-14T08:11:19.000Z","updated":"2020-03-14T08:14:48.337Z","comments":true,"path":"2020/03/14/基础练习-分解质因数/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/","excerpt":"有好多种做法，最快的应该是从小到大打印素数表，然后挨个除。但是我觉得打印素数表太麻烦，于是就从2开始挨个除然后输出。","text":"有好多种做法，最快的应该是从小到大打印素数表，然后挨个除。但是我觉得打印素数表太麻烦，于是就从2开始挨个除然后输出。 题目试题 基础练习 分解质因数提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 求出区间[a,b]中所有整数的质因数分解。 输入格式 输入两个整数a，b。 输出格式 每行输出一个数的分解，形如k=a1a2a3…(a1&lt;=a2&lt;=a3…，k也是从小到大的)(具体可看样例) 样例输入3 10 样例输出3=34=225=56=237=78=2229=3310=25 提示 先筛出所有素数，然后再分解。 数据规模和约定 2&lt;=a&lt;=b&lt;=10000 算法1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;void zhiyinshu(int n)&#123; for(int i&#x3D;2;i&lt;&#x3D;n;i++) &#123; if(n%i&#x3D;&#x3D;0) &#123; n&#x2F;&#x3D;i; if(n&#x3D;&#x3D;1) cout&lt;&lt;i&lt;&lt;endl; else cout&lt;&lt;i&lt;&lt;&quot;*&quot;; i--; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int m,n; cin&gt;&gt;m&gt;&gt;n; for(int i&#x3D;m;i&lt;&#x3D;n;i++) &#123; cout&lt;&lt;i&lt;&lt;&quot;&#x3D;&quot;; zhiyinshu(i); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"质因数","slug":"ACM/质因数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%B4%A8%E5%9B%A0%E6%95%B0/"}],"tags":[{"name":"分解质因数","slug":"分解质因数","permalink":"https://donghuangzhong.github.io/tags/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/"}]},{"title":"基础练习 Sine之舞","slug":"基础练习-Sine之舞","date":"2020-03-14T08:08:27.000Z","updated":"2020-03-14T08:10:50.527Z","comments":true,"path":"2020/03/14/基础练习-Sine之舞/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-Sine%E4%B9%8B%E8%88%9E/","excerpt":"仔细观察，嵌套方式，然后写出来就行","text":"仔细观察，嵌套方式，然后写出来就行 问题试题 基础练习 Sine之舞提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 最近FJ为他的奶牛们开设了数学分析课，FJ知道若要学好这门课，必须有一个好的三角函数基本功。所以他准备和奶牛们做一个“Sine之舞”的游戏，寓教于乐，提高奶牛们的计算能力。 不妨设 An=sin(1–sin(2+sin(3–sin(4+…sin(n))…) Sn=(…(A1+n)A2+n-1)A3+…+2)An+1 FJ想让奶牛们计算Sn的值，请你帮助FJ打印出Sn的完整表达式，以方便奶牛们做题。 输入格式 仅有一个数：N&lt;201。 输出格式 请输出相应的表达式Sn，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。 样例输入3 样例输出((sin(1)+3)sin(1–sin(2))+2)sin(1–sin(2+sin(3)))+1 算法12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;void p(int s,int e)&#123; if(s&#x3D;&#x3D;e) &#123; printf(&quot;sin(%d)&quot;,e); return ; &#125; char c&#x3D;s&amp;1?&#39;-&#39;:&#39;+&#39;; printf(&quot;sin(%d%c&quot;,s,c); p(s+1,e); cout&lt;&lt;&quot;)&quot;;&#125;void pp(int an,int nn)&#123; if(an&#x3D;&#x3D;1) &#123; p(1,an); cout&lt;&lt;&quot;+&quot;&lt;&lt;nn; return ; &#125; cout&lt;&lt;&quot;(&quot;; pp(an-1,nn+1); cout&lt;&lt;&quot;)&quot;; p(1,an); cout&lt;&lt;&quot;+&quot;&lt;&lt;nn;&#125;int main()&#123; int n; cin&gt;&gt;n; pp(n,1);&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"递归","slug":"ACM/递归","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%92%E5%BD%92/"}],"tags":[{"name":"逻辑","slug":"逻辑","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91/"}]},{"title":"基础练习 FJ的字符串","slug":"基础练习-FJ的字符串","date":"2020-03-14T08:05:02.000Z","updated":"2020-03-14T08:07:29.021Z","comments":true,"path":"2020/03/14/基础练习-FJ的字符串/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/14/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-FJ%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"仔细观察就是二叉树的中序遍历","text":"仔细观察就是二叉树的中序遍历 题目试题 基础练习 FJ的字符串提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 FJ在沙盘上写了这样一些字符串： A1 = “A” A2 = “ABA” A3 = “ABACABA” A4 = “ABACABADABACABA” … … 你能找出其中的规律并写所有的数列AN吗？ 输入格式 仅有一个数：N ≤ 26。 输出格式 请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。 样例输入3 样例输出ABACABA 算法123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;void p(char c)&#123; if(c&#x3D;&#x3D;&#39;A&#39;) &#123; cout&lt;&lt;c; return ; &#125; p(c-1); cout&lt;&lt;c; p(c-1);&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; p(&#39;A&#39;-1+n); cout&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"递归","slug":"ACM/递归","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%92%E5%BD%92/"}],"tags":[{"name":"逻辑","slug":"逻辑","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"}]},{"title":"C++ to_string编写","slug":"C-to-string编写","date":"2020-03-13T01:38:31.000Z","updated":"2020-03-13T01:43:24.525Z","comments":true,"path":"2020/03/13/C-to-string编写/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/13/C-to-string%E7%BC%96%E5%86%99/","excerpt":"dev c++ 中不能用to_string函数，于是就自己用泛型写了一个。函数模板是函数的模板，需要经过编译两次，第一次检查错误，第二次生成具体的函数。","text":"dev c++ 中不能用to_string函数，于是就自己用泛型写了一个。函数模板是函数的模板，需要经过编译两次，第一次检查错误，第二次生成具体的函数。 1234567891011#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;template &lt;typename T &gt;string to_string(T i)&#123; stringstream s; s&lt;&lt;i; return s.str();&#125;","categories":[{"name":"tools","slug":"tools","permalink":"https://donghuangzhong.github.io/categories/tools/"},{"name":"C++","slug":"tools/C","permalink":"https://donghuangzhong.github.io/categories/tools/C/"}],"tags":[{"name":"泛型编程","slug":"泛型编程","permalink":"https://donghuangzhong.github.io/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"},{"name":"函数模板","slug":"函数模板","permalink":"https://donghuangzhong.github.io/tags/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"}]},{"title":"基础练习 芯片测试","slug":"基础练习-芯片测试","date":"2020-03-12T05:50:39.000Z","updated":"2020-03-12T05:50:39.301Z","comments":true,"path":"2020/03/12/基础练习-芯片测试/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E8%8A%AF%E7%89%87%E6%B5%8B%E8%AF%95/","excerpt":"摘要","text":"摘要","categories":[{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"}]},{"title":"基础练习 龟兔赛跑预测","slug":"基础练习-龟兔赛跑预测","date":"2020-03-12T04:15:22.000Z","updated":"2020-03-12T04:27:38.052Z","comments":true,"path":"2020/03/12/基础练习-龟兔赛跑预测/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E9%A2%84%E6%B5%8B/","excerpt":"结果一定是一个整数，题中说是两个速度的公倍数。必须一秒一秒的走，当兔子领先t米时，后退v1*s米就行，这样再经过s秒之后回到后退前的位置","text":"结果一定是一个整数，题中说是两个速度的公倍数。必须一秒一秒的走，当兔子领先t米时，后退v1*s米就行，这样再经过s秒之后回到后退前的位置 题目试题 基础练习 龟兔赛跑预测提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 话说这个世界上有各种各样的兔子和乌龟，但是研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。 然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。 输入格式 输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt;=100;t&lt;=300;s&lt;=10;l&lt;=10000且为v1,v2的公倍数) 输出格式 输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。 第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。 样例输入10 5 5 2 20 样例输出D4 样例输入10 5 5 1 20 样例输出R3 样例输入10 5 5 3 20 样例输出T4 算法12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;void shuchu(int , int , int , int , int );int main(void)&#123; int v1,v2,t,s,l; scanf(&quot;%d%d%d%d%d&quot;, &amp;v1 , &amp;v2 , &amp;t , &amp;s , &amp;l ); shuchu( v1 , v2 , t , s , l ); return 0;&#125;void shuchu(int v1 , int v2 , int t , int s , int l )&#123; int s1&#x3D; 0 , s2 &#x3D; 0 ,i &#x3D; 0; while(s1 &lt; l &amp;&amp; s2 &lt; l) &#123; s1 +&#x3D;v1 ; s2 +&#x3D;v2 ; i ++ ; if( s1 &#x3D;&#x3D; l || s2 &#x3D;&#x3D; l) &#123; break; &#125; if(s1-s2 &gt;&#x3D; t) &#123; s1-&#x3D; v1 * s; &#125; &#x2F;&#x2F;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s1&lt;&lt;&quot; &quot;&lt;&lt;s2&lt;&lt;endl; &#125; if(s1 &gt; s2 ) &#123; printf(&quot;R\\n&quot;); &#125; if( s2 &gt; s1) &#123; printf(&quot;T\\n&quot;); &#125; if(s1 &#x3D;&#x3D; s2) &#123; printf(&quot;D\\n&quot;); &#125; printf(&quot;%d&quot;, i );&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"龟兔赛跑","slug":"龟兔赛跑","permalink":"https://donghuangzhong.github.io/tags/%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91/"}]},{"title":"基础练习 回形取数","slug":"基础练习-回形取数","date":"2020-03-12T02:17:09.000Z","updated":"2020-03-12T02:21:41.638Z","comments":true,"path":"2020/03/12/基础练习-回形取数/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/","excerpt":"将一个方向的点遍历并输出，直到碰壁，然后改变方向，然后再输出……。不能用dfs因为需要的是碰壁再换方向，而不是每次都改变方向。","text":"将一个方向的点遍历并输出，直到碰壁，然后改变方向，然后再输出……。不能用dfs因为需要的是碰壁再换方向，而不是每次都改变方向。 问题试题 基础练习 回形取数提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 回形取数就是沿矩阵的边取数，若当前方向上无数可取或已经取过，则左转90度。一开始位于矩阵左上角，方向向下。 输入格式 输入第一行是两个不超过200的正整数m, n，表示矩阵的行和列。接下来m行每行n个整数，表示这个矩阵。 输出格式 输出只有一行，共mn个数，为输入矩阵回形取数得到的结果。数之间用一个空格分隔，行末不要有多余的空格。 样例输入3 31 2 34 5 67 8 9 样例输出1 4 7 8 9 6 3 2 5 样例输入3 21 23 45 6 样例输出1 3 5 6 4 2 算法12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;&#x2F;&#x2F;#include&lt;map&gt;#define PI 3.14159265358979323#define MAX 0x3f3f3f3fusing namespace std;int map[210][210],m,n,sum&#x3D;1,x,y;int dir[4][2]&#x3D;&#123;1,0,0,1,-1,0,0,-1&#125;;int main()&#123; &#x2F;&#x2F;freopen(&quot;input2.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;m&gt;&gt;n; for(int i&#x3D;0;i&lt;m;i++) for(int j&#x3D;0;j&lt;n;j++) cin&gt;&gt;map[i][j]; x&#x3D;y&#x3D;0; cout&lt;&lt;map[0][0]; map[x][y]&#x3D;-1; while(sum!&#x3D;m*n) &#123; for(int i&#x3D;0;i&lt;4;i++) &#123; int xx&#x3D;x+dir[i][0]; int yy&#x3D;y+dir[i][1]; while(xx&gt;&#x3D;0&amp;&amp;xx&lt;m&amp;&amp;yy&gt;&#x3D;0&amp;&amp;yy&lt;n&amp;&amp;map[xx][yy]!&#x3D;-1) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;map[xx][yy]; map[xx][yy]&#x3D;-1; x&#x3D;xx; y&#x3D;yy; sum++; xx&#x3D;x+dir[i][0]; yy&#x3D;y+dir[i][1]; &#125; &#125; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"回形取数","slug":"回形取数","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/"}]},{"title":"基础练习 报时助手","slug":"基础练习-报时助手","date":"2020-03-12T02:12:49.000Z","updated":"2020-03-12T02:16:36.655Z","comments":true,"path":"2020/03/12/基础练习-报时助手/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E6%8A%A5%E6%97%B6%E5%8A%A9%E6%89%8B/","excerpt":"由于0~23都有完整的字符串，所以20,30,40,50要连续存储，求他们的十位数加上一个偏移量","text":"由于0~23都有完整的字符串，所以20,30,40,50要连续存储，求他们的十位数加上一个偏移量 问题试题 基础练习 报时助手提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 给定当前的时间，请用英文的读法将它读出来。 时间用时h和分m表示，在英文的读法中，读一个时间的方法是： 如果m为0，则将时读出来，然后加上“o’clock”，如3:00读作“three o’clock”。 如果m不为0，则将时读出来，然后将分读出来，如5:30读作“five thirty”。 时和分的读法使用的是英文数字的读法，其中0~20读作： 0:zero, 1: one, 2:two, 3:three, 4:four, 5:five, 6:six, 7:seven, 8:eight, 9:nine, 10:ten, 11:eleven, 12:twelve, 13:thirteen, 14:fourteen, 15:fifteen, 16:sixteen, 17:seventeen, 18:eighteen, 19:nineteen, 20:twenty。 30读作thirty，40读作forty，50读作fifty。 对于大于20小于60的数字，首先读整十的数，然后再加上个位数。如31首先读30再加1的读法，读作“thirty one”。 按上面的规则21:54读作“twenty one fifty four”，9:07读作“nine seven”，0:15读作“zero fifteen”。 输入格式 输入包含两个非负整数h和m，表示时间的时和分。非零的数字前没有前导0。h小于24，m小于60。 输出格式 输出时间时刻的英文。 样例输入0 15 样例输出zero fifteen 算法123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;map&gt;#define PI 3.14159265358979323#define MAX 0x3f3f3f3fusing namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); string yingshe[]&#x3D;&#123;&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;,&quot;ten&quot;,&quot;eleven&quot;,&quot;twelve&quot;,&quot;thirteen&quot;,&quot;fourteen&quot;,&quot;fifteen&quot;,&quot;sixteen&quot;,&quot;seventeen&quot;,&quot;eighteen&quot;,&quot;nineteen&quot;,&quot;twenty&quot;,&quot;twenty one&quot;,&quot;twenty two&quot;,&quot;twenty three&quot;,&quot;twenty&quot;,&quot;thirty&quot;,&quot;forty&quot;,&quot;fifty&quot;&#125;; int h,m; cin&gt;&gt;h&gt;&gt;m; cout&lt;&lt;yingshe[h]&lt;&lt;&quot; &quot;; if(m&#x3D;&#x3D;0) &#123; cout&lt;&lt;&quot;o&#39;clock&quot;; &#125; else if(m&gt;0&amp;&amp;m&lt;&#x3D;23) cout&lt;&lt;yingshe[m]; else &#123; int s&#x3D;m&#x2F;10+2; int g&#x3D;m%10; cout&lt;&lt;yingshe[20+s]&lt;&lt;&quot; &quot;&lt;&lt;yingshe[g]; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"字符串数组","slug":"字符串数组","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84/"}]},{"title":"基础练习 2n皇后问题","slug":"基础练习-2n皇后问题","date":"2020-03-12T02:01:47.000Z","updated":"2020-03-12T02:12:26.853Z","comments":true,"path":"2020/03/12/基础练习-2n皇后问题/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-2n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/","excerpt":"不能用dfs并行运算，会重复，可以举例2*2的棋盘，必须分开算","text":"不能用dfs并行运算，会重复，可以举例2*2的棋盘，必须分开算 问题试题 基础练习 Huffuman树提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。 给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下： 1. 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa + pb。 2. 重复步骤1，直到{pi}中只剩下一个数。 在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。 本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。 例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下： 1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。 2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。 3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。 4. 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。 5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。 输入格式 输入的第一行包含一个正整数n（n&lt;=100）。 接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。 输出格式 输出用这些数构造Huffman树的总费用。 样例输入55 3 8 2 9 样例输出59 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#define PI 3.14159265358979323#define MAX 0x3f3f3f3fusing namespace std;int lieh[9],lieb[9];int map[9][9],n,sum&#x3D;0;bool judgeh(int x,int y)&#123; if(map[x][y]&#x3D;&#x3D;0) return 0; if(lieh[y]!&#x3D;0) return 0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(lieh[i]!&#x3D;0) &#123; double t&#x3D;(i-y)&#x2F;double(lieh[i]-x); if(t&#x3D;&#x3D;1||t&#x3D;&#x3D;-1) &#123; return 0; &#125; &#125; &#125; return 1;&#125;bool judgeb(int x,int y)&#123; if(map[x][y]&#x3D;&#x3D;0) return 0; if(lieb[y]!&#x3D;0||lieh[y]&#x3D;&#x3D;x) return 0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(lieb[i]!&#x3D;0) &#123; double t&#x3D;(i-y)&#x2F;double(lieb[i]-x); if(t&#x3D;&#x3D;1||t&#x3D;&#x3D;-1) &#123; return 0; &#125; &#125; &#125; return 1; &#125;void dfsb(int h)&#123; if(h&#x3D;&#x3D;n+1) &#123; sum++; return ; &#125; for(int i&#x3D;0;i&lt;&#x3D;n;i++) &#123; if(judgeb(h,i)) &#123; lieb[i]&#x3D;h; dfsb(h+1); lieb[i]&#x3D;0; &#125; &#125;&#125;void dfsh(int h)&#123; if(h&#x3D;&#x3D;n+1) &#123; dfsb(1); return ; &#125; for(int i&#x3D;0;i&lt;&#x3D;n;i++) &#123; if(judgeh(h,i)) &#123; lieh[i]&#x3D;h; dfsh(h+1); lieh[i]&#x3D;0; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; cin&gt;&gt;map[i][j]; &#125; &#125; memset(lieh,0,sizeof(lieh)); memset(lieb,0,sizeof(lieb)); dfsh(1); cout&lt;&lt;sum&lt;&lt;endl; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dfs","slug":"ACM/dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/dfs/"}],"tags":[{"name":"八皇后问题","slug":"八皇后问题","permalink":"https://donghuangzhong.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"name":"黑白子","slug":"黑白子","permalink":"https://donghuangzhong.github.io/tags/%E9%BB%91%E7%99%BD%E5%AD%90/"}]},{"title":"基础练习 Huffuman树","slug":"基础练习-Huffuman树","date":"2020-03-12T01:55:32.000Z","updated":"2020-03-12T02:01:13.715Z","comments":true,"path":"2020/03/12/基础练习-Huffuman树/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-Huffuman%E6%A0%91/","excerpt":"用两个变量保存最小值，用两个变量保存两个最小值的下标，然后相加放入其中一个变量，另一个变量置无穷大，n个变量需要n-1步操作变成最后的一个变量，记录他们的和","text":"用两个变量保存最小值，用两个变量保存两个最小值的下标，然后相加放入其中一个变量，另一个变量置无穷大，n个变量需要n-1步操作变成最后的一个变量，记录他们的和 问题试题 基础练习 Huffuman树提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。 给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下： 1. 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa + pb。 2. 重复步骤1，直到{pi}中只剩下一个数。 在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。 本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。 例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下： 1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。 2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。 3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。 4. 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。 5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。 输入格式 输入的第一行包含一个正整数n（n&lt;=100）。 接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。 输出格式 输出用这些数构造Huffman树的总费用。 样例输入55 3 8 2 9 样例输出59 算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;#include&lt;queue&gt;#define PI 3.14159265358979323#define MAX 0x3f3f3f3fusing namespace std;int main()&#123; int hf[100]; int n,minn1,minn2,index1,index2,sum&#x3D;0; cin&gt;&gt;n; for(int i&#x3D;0;i&lt;n;i++) &#123; cin&gt;&gt;hf[i]; &#125; for(int i&#x3D;0;i&lt;n-1;i++) &#123; minn1&#x3D;MAX; minn2&#x3D;MAX; for(int j&#x3D;0;j&lt;n;j++) &#123; if(hf[j]&lt;minn2) &#123; if(hf[j]&lt;minn1) &#123; minn2&#x3D;minn1; index2&#x3D;index1; minn1&#x3D;hf[j]; index1&#x3D;j; &#125; else &#123;minn2&#x3D;hf[j]; index2&#x3D;j; &#125; &#125; &#125; hf[index1]&#x3D;minn1+minn2; sum+&#x3D;hf[index1]; hf[index2]&#x3D;MAX; &#125; cout&lt;&lt;sum; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Huffuman","slug":"ACM/Huffuman","permalink":"https://donghuangzhong.github.io/categories/ACM/Huffuman/"}],"tags":[{"name":"两个最小值","slug":"两个最小值","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%A4%E4%B8%AA%E6%9C%80%E5%B0%8F%E5%80%BC/"}]},{"title":"基础练习 阶乘计算","slug":"基础练习-阶乘计算","date":"2020-03-12T01:46:49.000Z","updated":"2020-03-12T01:54:44.453Z","comments":true,"path":"2020/03/12/基础练习-阶乘计算/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/12/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97/","excerpt":"m位数乘以n位数的最大位数是（m+1）*n（n&lt;m）","text":"m位数乘以n位数的最大位数是（m+1）*n（n&lt;m） 问题试题 基础练习 阶乘计算提交此题 资源限制 时间限制：1.0s 内存限制：512.0MB 问题描述 输入一个正整数n，输出n!的值。 其中n!=123…*n*。 算法描述 n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。 将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。 首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。 输入格式 输入包含一个正整数n，n&lt;=1000。 输出格式 输出n!的准确值。 样例输入10 样例输出3628800 算法累乘，每次除10，求出i的位数，用len保存当前结果的位数，(len+1)*i的位数就是新结果的最大范围，依次更新并记录结果的实际位数 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;#include&lt;queue&gt;#define PI 3.14159265358979323using namespace std;int a[2600];int main()&#123; int n; cin&gt;&gt;n; memset(a,0,sizeof(a)); a[1]&#x3D;1; int jinwei&#x3D;0; int len&#x3D;1; for(int i&#x3D;2;i&lt;&#x3D;n;i++) &#123; int tlen&#x3D;len,t&#x3D;i; int wei&#x3D;0; while(t!&#x3D;0) &#123; t&#x2F;&#x3D;10; wei++; &#125; for(int j&#x3D;1;j&lt;&#x3D;(len+1)+wei;j++) &#123; a[j]&#x3D;i*a[j]+jinwei; if(a[j]&gt;&#x3D;10) &#123; jinwei&#x3D;a[j]&#x2F;10; a[j]&#x3D;a[j]%10; &#125; else jinwei&#x3D;0; if(j&gt;tlen&amp;&amp;a[j]) tlen&#x3D;j; &#125; len&#x3D;tlen; &#125; while(len) cout&lt;&lt;a[len--]; cout&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"大数","slug":"ACM/大数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0/"}],"tags":[{"name":"大数阶乘","slug":"大数阶乘","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/"}]},{"title":"POJ-1511-Invitation Cards","slug":"POJ-1511-Invitation-Cards","date":"2020-03-10T07:40:31.000Z","updated":"2020-03-10T07:52:08.464Z","comments":true,"path":"2020/03/10/POJ-1511-Invitation-Cards/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/10/POJ-1511-Invitation-Cards/","excerpt":"这个用Bellman一直超时，后来用了spfa，邻接表简直就是为spfa量身打造的，不过此题中的指针换成了变得索引，此题中由于要翻转边，所以需要把边的信息全部记下来，spfa开始的时候翻转，然后交换边的起点和终点，然后再调用一次spfa","text":"这个用Bellman一直超时，后来用了spfa，邻接表简直就是为spfa量身打造的，不过此题中的指针换成了变得索引，此题中由于要翻转边，所以需要把边的信息全部记下来，spfa开始的时候翻转，然后交换边的起点和终点，然后再调用一次spfa 题目邀请卡 时限： 8000MS 内存限制： 262144K 提交总数： 39132 接受的： 12664 描述在电视时代，很少有人参加戏剧表演。Malidinesia的古董喜剧演员知道这一事实。他们想传播戏剧，最重要的是传播古董喜剧。他们印有所有必要信息和计划的邀请卡。雇用了许多学生在人们中间分发这些邀请。每个学生志愿者都恰好分配了一个公交车站，他或她整天都呆在那里，并向乘公共汽车旅行的人发出邀请。开设了一门特殊的课程，让学生学习如何影响人以及影响力和抢劫之间的区别。 运输系统非常特殊：所有线路都是单向的，并且恰好连接两个站。公交车每半小时便有客流驶离始发站。到达目的地站后，他们返回到出发站为空，直到下一个完整的半小时，例如X：00或X：30，其中“ X”表示小时。两站之间的运输费用由特别表提供，应当场支付。线路的规划方式是，每次往返（即在同一站开始和结束的旅程）都要经过中央检查站（CCS），每位乘客都必须通过包括身体扫描在内的全面检查。 所有ACM学生成员每天早晨都离开CCS。每个志愿者将移动到一个预定的站点以邀请乘客。志愿人员的数量与站点的数量一样多。最终，所有学生都返回了CCS。您要编写一个计算机程序，以帮助ACM最大限度地减少每天支付给其员工的运输费用。 输入值输入包含N个案例。输入的第一行仅包含正整数N。然后遵循这些情况。每种情况均始于一条直线，该直线恰好包含两个整数P和Q，1 &lt;= P，Q &lt;=1000000。P是包含CCS的站点数，而Q是总线的数量。然后有Q条线，每条线描述一条总线。每行均包含三个数字-起始止损，目的地止损和价格。CCS由数字1表示。价格是正整数，其总和小于1000000000。您还可以假设始终可以从任何停靠点到达任何其他停靠点。 输出量对于每种情况，请打印一行，其中包含ACM每天为其志愿者支付的差旅费用的最低金额。 样本输入123456789101122 21 2 132 1 334 61 2 102 1 601 3 203 4 102 4 54 1 50 样本输出1246210 题目大意第一行输入测试用例，第二行分别输入顶点的个数和边的个数，剩下的行输入边的信息，起点终点费用 求来回的最小距离 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;#include&lt;queue&gt;#define N 1000005using namespace std;struct Point&#123; int start,end,price;&#125; route[N];int s,n,m,p[N],v[N],d[N],nextt[N];long long sum;void spfa()&#123; memset(p,0,(n+1)*sizeof(int)); memset(v,0,(n+1)*sizeof(int)); memset(d,0x3f,(n+1)*sizeof(int)); for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; nextt[i]&#x3D;p[route[i].start]; p[route[i].start]&#x3D;i; &#125; d[1]&#x3D;0; queue&lt;int&gt; q; q.push(1); v[1]&#x3D;1; while(!q.empty()) &#123; int a&#x3D;q.front(); q.pop(); v[a]&#x3D;0; int next&#x3D;p[a]; while(next!&#x3D;0) &#123; if(d[route[next].end]&gt;d[a]+route[next].price) &#123; d[route[next].end]&#x3D;d[a]+route[next].price; if(v[route[next].end]&#x3D;&#x3D;0) &#123; v[route[next].end]&#x3D;1; q.push(route[next].end); &#125; &#125; next&#x3D;nextt[next]; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; &#x2F;&#x2F;cout&lt;&lt;d[i]&lt;&lt;&quot; &quot;; sum+&#x3D;d[i]; &#125; &#x2F;&#x2F;cout&lt;&lt;endl;&#125;void turn()&#123; for (int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int temp&#x3D;route[i].start; route[i].start&#x3D;route[i].end; route[i].end&#x3D;temp; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int t; &#x2F;&#x2F;cin&gt;&gt;t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; sum&#x3D;0; &#x2F;&#x2F;cin&gt;&gt;n&gt;&gt;m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; &#x2F;&#x2F;cin&gt;&gt;route[i].start&gt;&gt;route[i].end&gt;&gt;route[i].price; scanf(&quot;%d%d%d&quot;,&amp;route[i].start,&amp;route[i].end,&amp;route[i].price); &#125; spfa(); turn(); spfa(); cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"SPFA","slug":"ACM/SPFA","permalink":"https://donghuangzhong.github.io/categories/ACM/SPFA/"}],"tags":[{"name":"翻转边","slug":"翻转边","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E8%BE%B9/"},{"name":"来回总和最短","slug":"来回总和最短","permalink":"https://donghuangzhong.github.io/tags/%E6%9D%A5%E5%9B%9E%E6%80%BB%E5%92%8C%E6%9C%80%E7%9F%AD/"}]},{"title":"HDU-1217-POJ-2240-Arbitrage","slug":"HDU-1217-POJ-2240-Arbitrage","date":"2020-03-09T01:58:42.000Z","updated":"2020-03-11T03:51:17.321Z","comments":true,"path":"2020/03/09/HDU-1217-POJ-2240-Arbitrage/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/09/HDU-1217-POJ-2240-Arbitrage/","excerpt":"HDU和POJ的数据都很水，这个题没说第一个货币一定在环中，但以第一种货币一定在环中的算法却都能AC，不信试试我给的测试数据，不得不说Bellman真的强，本文给出这个题的严谨证明和算法！！！不可转载谢谢！","text":"HDU和POJ的数据都很水，这个题没说第一个货币一定在环中，但以第一种货币一定在环中的算法却都能AC，不信试试我给的测试数据，不得不说Bellman真的强，本文给出这个题的严谨证明和算法！！！不可转载谢谢！ 题目套利\\时间限制：2000/1000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）提交总数：12754接受提交：5785** 问题描述套利是利用货币汇率差异将一种货币单位转换成一种以上相同货币单位。例如，假设1美元买入0.5英镑，1英镑买入10.0法国法郎，而1法国法郎买入0.21美元。然后，通过转换货币，一个聪明的交易者可以从1美元开始，买入0.5 * 10.0 * 0.21 = 1.05美元，获利5％。 您的工作是编写一个程序，该程序将货币汇率列表作为输入，然后确定是否可以进行套利。 输入值输入文件将包含一个或多个测试用例。在每个测试用例的第一行中，有一个整数n（1 &lt;= n &lt;= 30），代表不同货币的数量。接下来的n行分别包含一种货币的名称。名称中不会出现空格。下一行包含一个整数m，代表要跟随的表的长度。最后的m行分别包含源货币的名称ci，代表从ci到cj的汇率的实数rij和目标货币的名称cj。没有出现在表中的交换是不可能的。测试用例之间用空白行隔开。输入以n的零（0）值终止。 输出量对于每个测试用例，分别以“案例：是”和“案例：否”的格式打印一行，说明是否可以套利。 Sample Input123456789101112131415161718192021223USDollarBritishPoundFrenchFranc3USDollar 0.5 BritishPoundBritishPound 10.0 FrenchFrancFrenchFranc 0.21 USDollar3USDollarBritishPoundFrenchFranc6USDollar 0.5 BritishPoundUSDollar 4.9 FrenchFrancBritishPound 10.0 FrenchFrancBritishPound 1.99 USDollarFrenchFranc 0.09 BritishPoundFrenchFranc 0.19 USDollar0 Sample Output12Case 1: YesCase 2: No 算法先给出不严谨的算法(第一种货币一定在环中)，这个就不用证明了吧，这个在HDU、POJ都能AC！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;int n,m; map&lt;string,int&gt; y;struct &#123; int x,y; double h;&#125; bian[5000];double d[5000];int c&#x3D;1;bool Bellman()&#123; d[1]&#x3D;1; bool flag; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; flag&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(d[bian[j].y]&lt;d[bian[j].x]*bian[j].h) &#123; d[bian[j].y]&#x3D;d[bian[j].x]*bian[j].h; flag&#x3D;1; &#125; &#125; if(flag&#x3D;&#x3D;0) return 0; &#125; for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(d[bian[j].y]&lt;d[bian[j].x]*bian[j].h) &#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n) &#123; char a[100]; double hui; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; &#x2F;&#x2F;d[i]&#x3D;1; d[i]&#x3D;0; scanf(&quot;%s&quot;,a); y[a]&#x3D;i; &#125; cin&gt;&gt;m; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; scanf(&quot;%s%lf&quot;,a,&amp;hui); bian[i].x&#x3D;y[a]; bian[i].h&#x3D;hui; scanf(&quot;%s&quot;,a); bian[i].y&#x3D;y[a]; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;c++&lt;&lt;&quot;: &quot;; if(Bellman()) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125; 测试数据123456789104abcd3b 0.5 cc 1 dd 10 b0 这个数据将第一个点孤立了，b-&gt;c-&gt;d-&gt;b为正环，按照题目逻辑应该输出Yes,但是上述不严谨算法输出No，可见HDU、POJ数据太水了，上述不严谨算法都AC了 再给出严谨的算法，有人说遍历所有起点，多次调用Bellman，NoNoNo！还是太小看Bellman的算法，本题中如果指定第一种货币为起点则应该d[1]=1,其余全为0。严谨的做法应该是d全为1即可，但也不要生搬硬套，此题为乘法类，所以为1,如果是加法类就应该为0。如果d全为0，则起点在正负边(比如b-&gt;c为0.5倍，这是负边；d-&gt;b为10倍，为正边)交界的顶点，有人说正正边交界的顶点也是起点，那只能说你不明白Bellman算法。将正负交界的顶点放在一个集合S中，下面我来证明，一定有一个顶点q属于S,这个点到所有点都为正边(为什么要证明这个，因为碰到负边会走不下去)，现在的问题就变成了： 已知一个正环，S为正负边交界的顶点的集合，证明：一定存在点q属于S，q到此正环所有顶点的的边都为正边 将此正环相邻的相同符号的边看做一条边，即相邻的正边看做一条正边，相邻的负边看做一条负边，如下 这个是个有向图，顺时针，忘了画方向。相邻的正负(先正后负)边看做一个整体，比如上图有两部分，ad和da。这个图就有两组这样的正负边，一个正环可能有n组正负边，当n==2时，由于是一个正环，则这两组边有两种情况 1.都是正边，则结论得证 2.一正一负，那么从正的那组正负边的起点作为起点，结论得证 现在我要用数学归纳法，k==2时结论成立(k为正负边的组数，就是上面的n)，当k==k+1时,又有两种情况 1.都是正边，结论得证 2.存在负边，则将负边中任意一组去掉，变成k-1组正负边组合+一个负的正负边组合。因为整个环为正环，所以这k-1组也可以组成一个正环，k-1组正负边组成的正环符合结论，结论得证 所以可以证明，Bellman选择的起点集合中一定有一个点可以走遍整个环，附上代码，就改了d的初值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;int n,m; map&lt;string,int&gt; y;struct &#123; int x,y; double h;&#125; bian[5000];double d[5000];int c&#x3D;1;bool Bellman()&#123; &#x2F;&#x2F;d[1]&#x3D;1; bool flag; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; flag&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(d[bian[j].y]&lt;d[bian[j].x]*bian[j].h) &#123; d[bian[j].y]&#x3D;d[bian[j].x]*bian[j].h; flag&#x3D;1; &#125; &#125; if(flag&#x3D;&#x3D;0) return 0; &#125; for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(d[bian[j].y]&lt;d[bian[j].x]*bian[j].h) &#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n) &#123; char a[100]; double hui; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; d[i]&#x3D;1; &#x2F;&#x2F;d[i]&#x3D;0; scanf(&quot;%s&quot;,a); y[a]&#x3D;i; &#125; cin&gt;&gt;m; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; scanf(&quot;%s%lf&quot;,a,&amp;hui); bian[i].x&#x3D;y[a]; bian[i].h&#x3D;hui; scanf(&quot;%s&quot;,a); bian[i].y&#x3D;y[a]; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;c++&lt;&lt;&quot;: &quot;; if(Bellman()) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Bellman","slug":"ACM/Bellman","permalink":"https://donghuangzhong.github.io/categories/ACM/Bellman/"}],"tags":[{"name":"正环","slug":"正环","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E7%8E%AF/"}]},{"title":"POJ-3660-Cow Contest","slug":"POJ-3660-Cow-Contest","date":"2020-03-07T09:41:21.000Z","updated":"2020-03-07T09:59:15.242Z","comments":true,"path":"2020/03/07/POJ-3660-Cow-Contest/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/07/POJ-3660-Cow-Contest/","excerpt":"技巧：map[i][j]=map[i][j]||(map[i][k]&amp;&amp;map[k][j]);利用逻辑短路，如果map[i][i]==1说明i到j已经存在通路，直接返回1,否则判断map[i][k]&amp;&amp;map[k][j]==1，可达为1,不可达为0。","text":"技巧：map[i][j]=map[i][j]||(map[i][k]&amp;&amp;map[k][j]);利用逻辑短路，如果map[i][i]==1说明i到j已经存在通路，直接返回1,否则判断map[i][k]&amp;&amp;map[k][j]==1，可达为1,不可达为0。 题目牛比赛 时限： 1000MS 内存限制： 65536K 提交总数： 20550 接受的： 11394 描述Ñ（1≤ ñ ≤100）牛，方便地编号为1 .. Ñ，正在参与编程竞赛。众所周知，有些母牛的编码要好于其他母牛。每头母牛都有一定的恒定技能等级，这在竞争者中是独一无二的。 比赛分几个头对头进行，每回合在两头母牛之间进行。如果牛阿具有更大的技能水平比牛乙（1≤ 甲 ≤ Ñ ; 1≤ 乙 ≤ Ñ ; 甲 ≠ 乙），然后牛甲总是打牛乙。 农夫约翰试图按技能水平对母牛进行排名。给定一个列表的结果中号*（1≤ *中号 ≤4500）二牛回合，确定奶牛他们的职级从结果可以精确地确定的数量。可以保证回合的结果不会矛盾。 输入值第1行：两个以空格分隔的整数：N和*M第2行*。M +1：每行包含两个以空格分隔的整数，这些整数描述单个选手的竞争者和结果（第一个整数A是获胜者）一轮比赛：A和B 输出量*第1行：一个整数，代表可以确定其等级的母牛的数量 样本输入1234565 54 34 23 21 22 5 样本输出12 题目大意给出m个胜负关系对n个点进行排名，第一行输入n,m。剩下m行输入a,b。表示a胜过b。求通过胜负关系能确定几个点的名次。 算法用图(bool型，1表示可达，0表示不可达)的知识，Floyd算法，得到全图的可达关系，要判断第i个点能不能判断名次，去决议该点的入度和出度和是否为n-1。由于题目的输入必须有逻辑，即不能2胜1同时1胜2,所以map[i][j]与map[j][i]不能同时为1，并且不存在环(1-&gt;2-&gt;3-&gt;1)，所以map[i][i]必为0，所以可以用if(map[j][i]||map[i][j]) z++;统计次数 优化后bool图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;#define N 101int n,m;bool map[N][N];void floyd()&#123; for(int k&#x3D;1;k&lt;&#x3D;n;k++) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; map[i][j]&#x3D;map[i][j]||(map[i][k]&amp;&amp;map[k][j]); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n&gt;&gt;m; memset(map,0,sizeof(0)); for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; map[a][b]&#x3D;1; &#125; floyd(); int s&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int z&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(map[j][i]||map[i][j]) &#123; z++; &#125; &#125; if(z&#x3D;&#x3D;n-1) s++; &#125; cout&lt;&lt;s&lt;&lt;endl; return 0;&#125; 传统Floyd12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;#define N 101#define MAX 0x3f3f3f3fint map[N][N],n,m;void floyd()&#123; for(int k&#x3D;1;k&lt;&#x3D;n;k++) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(map[i][k]+map[k][j]&lt;map[i][j]) &#123; map[i][j]&#x3D;map[i][k]+map[k][j]; &#125; &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n&gt;&gt;m; for(int i&#x3D;0;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) map[i][j]&#x3D;MAX; &#125; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; map[a][b]&#x3D;1; &#125; floyd(); int z&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int l&#x3D;0; int q&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(map[j][i]!&#x3D;MAX) &#123; l++; &#125; if(map[i][j]!&#x3D;MAX) q++; &#125; if(l+q&#x3D;&#x3D;n-1) z++; &#125; cout&lt;&lt;z&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Floyd","slug":"ACM/Floyd","permalink":"https://donghuangzhong.github.io/categories/ACM/Floyd/"}],"tags":[{"name":"排名","slug":"排名","permalink":"https://donghuangzhong.github.io/tags/%E6%8E%92%E5%90%8D/"},{"name":"逻辑路径","slug":"逻辑路径","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E8%B7%AF%E5%BE%84/"}]},{"title":"POJ-1502-MPI Maelstrom","slug":"POJ-1502-MPI-Maelstrom","date":"2020-03-07T04:24:19.000Z","updated":"2020-03-07T04:36:35.248Z","comments":true,"path":"2020/03/07/POJ-1502-MPI-Maelstrom/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/07/POJ-1502-MPI-Maelstrom/","excerpt":"atoi(char *)把字符串转换成整形，还有一个string参数的方法是stoi但是在帮助文档里搜不到，但可以用s.c_str()将string转换成char *,当然也可用字符数组，但是我觉得字符数组有长度限制不大好。dij算法中邻接矩阵map[i][i]不用管，只需d[起点]=0，因为不可能访问到d[i][i]。","text":"atoi(char *)把字符串转换成整形，还有一个string参数的方法是stoi但是在帮助文档里搜不到，但可以用s.c_str()将string转换成char *,当然也可用字符数组，但是我觉得字符数组有长度限制不大好。dij算法中邻接矩阵map[i][i]不用管，只需d[起点]=0，因为不可能访问到d[i][i]。 题目MPI大漩涡 时限： 1000MS 内存限制： 10000K 提交总数： 15467 接受： 9422 描述BIT最近接受了他们的新超级计算机的交付，该超级计算机是具有分层通信子系统的32处理器Apollo Odyssey分布式共享内存计算机。Valentine McKee的研究顾问Jack Swigert要求她对新系统进行基准测试。瓦伦丁对斯维格特说：由于阿波罗是一台分布式共享存储机器，因此存储访问和通信时间并不统一。&#39;&#39;共享同一内存子系统的处理器之间的通信速度很快，但是不在同一子系统上的处理器之间的通信速度却较慢。阿波罗与我们实验室中的机器之间的通讯速度还慢一些。”“ 阿波罗的消息传递接口（MPI）的端口如何工作？”斯维格特问。 不太好，&#39;&#39;瓦伦丁回答。要将消息从一个处理器广播到所有其他n-1个处理器，它们只是执行一系列n-1发送。这确实使事情序列化并破坏了性能 .````有什么可以解决的吗？’’ 是的，&#39;&#39;情人微笑。有。一旦第一个处理器将消息发送到另一个，这两个处理器就可以同时将消息发送到另外两个主机。然后将有四个可以发送的主机，以此类推 .````啊，所以您可以像二叉树一样进行广播！’’ ``不是真正的二叉树-我们应该利用我们网络的某些特殊功能。我们拥有的接口卡允许每个处理器同时将消息发送到与其连接的任意数量的其他处理器。但是，消息不一定要同时到达目的地-涉及通信成本。总的来说，我们需要考虑网络拓扑中每个链接的通信成本，并做出相应的计划以最大程度地减少广播所需的总时间。’’ 输入值输入将描述连接n个处理器的网络的拓扑。输入的第一行将是n，即处理器的数量，因此1 &lt;= n &lt;=100 。其余的输入定义邻接矩阵A。邻接矩阵是正方形，大小为nx n。它的每个条目都是整数或字符x。A（i，j）的值表示直接从节点i向节点j发送消息的开销。A（i，j）的x值表示无法将消息直接从节点i发送到节点j。 请注意，对于节点向其自身发送消息的不需要网络通信，因此对于1 &lt;= i &lt;= n，A（i，i）= 0。另外，您可能会假定网络是无向的（消息可以以相同的开销在任一方向上传播），因此A（i，j）= A（j，i）。因此，将仅提供A的（严格）下部三角形部分上的条目。 程序的输入将是A的下部三角形部分。也就是说，输入的第二行将包含一个条目A（2,1）。下一行将包含两个条目A（3,1）和A（3,2），依此类推。 输出量您的程序应输出从第一个处理器向所有其他处理器广播消息所需的最短通信时间。 样本输入1234555030 5100 20 5010 xx 10 样本输出135 题目大意第一行输入点的数量，剩下输入邻接矩阵(双向边)的下三角，x表示不可达 算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAX 0x3f3f3f3fusing namespace std;int d[101],n;int map[101][101];bool v[101];void dij()&#123; int index; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; v[i]&#x3D;0; d[i]&#x3D;map[1][i]; &#125; v[1]&#x3D;1; d[1]&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; int minn&#x3D;MAX; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(v[j]&#x3D;&#x3D;0&amp;&amp;d[j]&lt;minn) &#123; minn&#x3D;d[j]; index&#x3D;j; &#125; &#125; v[index]&#x3D;1; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(v[j]&#x3D;&#x3D;0&amp;&amp;(d[j]&gt;d[index]+map[index][j])) &#123; d[j]&#x3D;d[index]+map[index][j]; &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; &#x2F;&#x2F;map[i][i]&#x3D;0; for(int j&#x3D;1;j&lt;i;j++) &#123; string s; cin&gt;&gt;s; if(s&#x3D;&#x3D;&quot;x&quot;) map[i][j]&#x3D;map[j][i]&#x3D;MAX; else map[i][j]&#x3D;map[j][i]&#x3D;atoi(s.c_str()); &#125; &#125; dij(); int maxx&#x3D;-1; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(d[i]&gt;maxx) &#123; maxx&#x3D;d[i]; &#125; &#125; cout&lt;&lt;maxx&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"最短路径","slug":"最短路径","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"POJ-3259-Wormholes","slug":"POJ-3259-Wormholes","date":"2020-03-07T01:17:58.264Z","updated":"2020-03-07T01:25:28.982Z","comments":true,"path":"2020/03/07/POJ-3259-Wormholes/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/07/POJ-3259-Wormholes/","excerpt":"负环，注意输入时输入的是正数，要变成负数存起来。这样可能两点之间存在三条边，但bellman对边没有要求，也可以只留两条边，但我觉得没有必要，还得搜索更改。","text":"负环，注意输入时输入的是正数，要变成负数存起来。这样可能两点之间存在三条边，但bellman对边没有要求，也可以只留两条边，但我觉得没有必要，还得搜索更改。 题目虫洞 时限： 2000MS 内存限制： 65536K 提交总数： 79083 接受： 29365 描述在探索他的许多农场时，农夫约翰发现了许多惊人的虫洞。虫洞非常特殊，因为它是一条单向路径，可在您进入虫洞之前将您送至目的地！每个FJ的农场包括Ñ（1≤ ñ ≤500）字段方便地编号为1 .. Ñ，中号*（1≤ *中号 ≤2500）的路径，和w ^*（1≤ *w ^ ≤200）虫洞。 由于FJ是一位狂热的时空旅行爱好者，因此他希望做到以下几点：从某个领域开始，经过一些路径和虫洞，并在他初次离开之前的某个时间返回开始领域。也许他将能够见到自己：）。 为了帮助FJ找出这是否可行与否，他将与完整的地图供你˚F*（1≤ *˚F ≤5）他的农场。路径行驶时间不会超过10,000秒，虫洞也不会使FJ的返回时间超过10,000秒。 输入值第1行：一个整数，˚F。F服务器场说明如下。每个服务器场的第1行：三个空格分隔的整数：N，M和W第2行。每个服务器场的M +1：三个以空格分隔的数字（S，E，T），分别描述：双向路径在S和E之间需要经过T秒。两个字段可能通过一条以上的路径连接。线中号 2 .. 中号 + w ^每个场的1：三个空间分隔的数字（S，E，T）分别描述：从S到E的单向路径，也将旅行者向后移动T秒。 输出量第1行。F：对于每个农场，如果FJ可以实现其目标，则输出“ YES”，否则输出“ NO”（不包括引号）。 样本输入1234567891023 3 11 2 21 3 42 3 13 1 33 2 11 2 32 3 43 1 8 样本输出12没有是 题目大意第一行输入三个正整数，代表点的个数，双向正边数，单向负边数。下面每行输入三个数，起点，终点，花费的时间(注意输入负边时也是正数，需要变成负数存起来)。 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;struct R&#123; int start,end,time;&#125; r[5201];int d[501];int n,m,w;bool bellman()&#123; memset(d,0x3f,sizeof(d)); d[1]&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;2*m+w;j++) &#123; if(d[r[j].end]&gt;d[r[j].start]+r[j].time) &#123; d[r[j].end]&#x3D;d[r[j].start]+r[j].time; &#125; &#125; &#125; for(int j&#x3D;1;j&lt;&#x3D;2*m+w;j++) &#123; if(d[r[j].end]&gt;d[r[j].start]+r[j].time) &#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;w; for(int i&#x3D;1;i&lt;&#x3D;2*m;i+&#x3D;2) &#123; cin&gt;&gt;r[i].start&gt;&gt;r[i].end&gt;&gt;r[i].time; r[i+1].start&#x3D;r[i].end; r[i+1].end&#x3D;r[i].start; r[i+1].time&#x3D;r[i].time; &#125; for(int i&#x3D;2*m+1;i&lt;&#x3D;2*m+w;i++) &#123; int tt; cin&gt;&gt;r[i].start&gt;&gt;r[i].end&gt;&gt;tt; r[i].time&#x3D;-tt; &#125; if(bellman()) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Bellman","slug":"ACM/Bellman","permalink":"https://donghuangzhong.github.io/categories/ACM/Bellman/"}],"tags":[{"name":"负环","slug":"负环","permalink":"https://donghuangzhong.github.io/tags/%E8%B4%9F%E7%8E%AF/"}]},{"title":"POJ-1860-Currency Exchange","slug":"POJ-1860-Currency-Exchange","date":"2020-03-07T00:24:06.000Z","updated":"2020-03-07T01:25:15.626Z","comments":true,"path":"2020/03/07/POJ-1860-Currency-Exchange/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/07/POJ-1860-Currency-Exchange/","excerpt":"dij算法不能处理负边，因为如果有负边就不能确定最小的那个是最优解了。Bellman-Ford可以处理负边，但在结束之前都不是最优解，并且可以处理闭环，因为i次循环可以算出走i步的最优解，所以必须循环n-1次，才能得到最优解，如果要判断是不是有环，需要再循环一次，如果最终的结果有被更改，则代表有环。正负环的初始化不同。","text":"dij算法不能处理负边，因为如果有负边就不能确定最小的那个是最优解了。Bellman-Ford可以处理负边，但在结束之前都不是最优解，并且可以处理闭环，因为i次循环可以算出走i步的最优解，所以必须循环n-1次，才能得到最优解，如果要判断是不是有环，需要再循环一次，如果最终的结果有被更改，则代表有环。正负环的初始化不同。 题目货币兑换 时限： 1000MS 内存限制： 30000K 提交总数： 44848 接受： 17312 描述我们城市有几个货币兑换点。让我们假设每个点专门研究两种特定货币，并且仅使用这些货币执行兑换操作。同一对货币可能有多个要点。每个点都有自己的汇率，A到B的汇率是您获得1A时B的数量。此外，每个兑换点都有一定的佣金，您必须为兑换操作支付的总金额。佣金始终以原始货币收取。例如，如果您想在兑换点将100美元兑换成俄罗斯卢布，汇率为29.75，佣金为0.39，您将获得（100-0.39）* 29.75 = 2963.3975RUR。您肯定知道我们城市可以处理N种不同的货币。让我们为每种货币分配从1到N的唯一整数。然后可以用6个数字描述每个兑换点：整数A和B-​​兑换的货币数量，以及实际R AB，C AB，R BA和C BA-分别将A兑换为B和B兑换为A时的汇率和佣金。尼克拥有货币S的钱，并且想知道在进行一些兑换操作后，他是否可以以某种方式增加其资本。当然，他希望最后用S货币来存钱。帮助他回答这个难题。尼克在进行操作时必须始终拥有非负数的资金。 输入值输入的第一行包含四个数字：N-货币数量，M-兑换点数量，S-Nick拥有的货币数量，V-他拥有的货币单位数量。接下来的M行每行包含6个数字-相应交换点的描述-按上面指定的顺序进行。数字用一个或多个空格分隔。1 &lt;= S &lt;= N &lt;= 100，1 &lt;= M &lt;= 100，V是实数，0 &lt;= V &lt;= 10 3。对于每个点的汇率和佣金是真实的，与小数点后至多两个数字，10给出-2 &lt;=速率&lt;= 10 2，0 &lt;=佣金&lt;= 10 2。如果在此序列中不使用任何交换点以上，则将交换操作的某些序列称为简单序列。您可以假定在任何简单的交换操作序列的末尾和开始处，总和的数值之比小于10 4。 输出量如果Nick可以增加他的财富，则输出YES，否则输出NO到输出文件。 样本输入1233 2 1 20.01 2 1.00 1.00 1.00 1.002 3 1.10 1.00 1.10 1.00 样本输出1是 题目描述第一行输入n,m,s,v分别表示货币的种数，货币转换的方式数，自己拥有的货币的种类，自己拥有货币的数量；接下来m行输入a,b,c,d,e,f表示a向b转换的汇率是c,手续费是d,b向a转换的汇率e,手续费是f.计算方式:（a-d）*c 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int n,m,t;double s,d[101];struct &#123; int a,b; double huilv,tax;&#125; bian[201];bool bellman_ford()&#123; memset(d,0,sizeof(d)); d[t]&#x3D;s; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;2*m;j++) &#123; if(d[bian[j].b]&lt;(d[bian[j].a]-bian[j].tax)*bian[j].huilv) &#123; d[bian[j].b]&#x3D;(d[bian[j].a]-bian[j].tax)*bian[j].huilv; &#125; &#125; &#125; for(int j&#x3D;1;j&lt;&#x3D;2*m;j++) &#123; if(d[bian[j].b]&lt;(d[bian[j].a]-bian[j].tax)*bian[j].huilv) &#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;s; for(int i&#x3D;1;i&lt;&#x3D;2*m;i+&#x3D;2) &#123; cin&gt;&gt;bian[i].a&gt;&gt;bian[i].b&gt;&gt;bian[i].huilv&gt;&gt;bian[i].tax&gt;&gt;bian[i+1].huilv&gt;&gt;bian[i+1].tax; bian[i+1].a&#x3D;bian[i].b; bian[i+1].b&#x3D;bian[i].a; &#125; if(bellman_ford()) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"Bellman","slug":"ACM/Bellman","permalink":"https://donghuangzhong.github.io/categories/ACM/Bellman/"}],"tags":[{"name":"正环","slug":"正环","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E7%8E%AF/"}]},{"title":"POJ-3268-Silver Cow Party","slug":"POJ-3268-Silver-Cow-Party","date":"2020-03-06T03:44:08.000Z","updated":"2020-03-06T03:56:45.407Z","comments":true,"path":"2020/03/06/POJ-3268-Silver-Cow-Party/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/06/POJ-3268-Silver-Cow-Party/","excerpt":"上来一看觉得这个题很简单，写出来测试结果也对，一提交，超时。于是我又把cin改成scanf,cin比scanf慢太多了，结果还是超时。这就不是细节问题了，是算法本身的问题，后来把矩阵翻转了一下就可以解决，复杂度从n^3变成n^2，这样一想刚开始的算法太愚蠢了！","text":"上来一看觉得这个题很简单，写出来测试结果也对，一提交，超时。于是我又把cin改成scanf,cin比scanf慢太多了，结果还是超时。这就不是细节问题了，是算法本身的问题，后来把矩阵翻转了一下就可以解决，复杂度从n^3变成n^2，这样一想刚开始的算法太愚蠢了！ 题目银牛党 时限： 2000MS 内存限制： 65536K 提交总数： 38727 接受： 17305 描述从每一个牛ñ农场（1≤ ñ ≤1000）方便地编号为1 .. ñ是要参加大牛党在农场＃举行X（1≤ X ≤ ñ）。共中号*（1≤ *中号 ≤100,000）农场单向（单向道路所连接对;道路我需要Ť 我*（1≤ *Ť 我 ≤100）的时间到横动单元。 每头母牛都必须走到聚会上，聚会结束后，要回到自己的农场。每头母牛都是懒惰的，因此选择了最短时间的最佳路线。由于道路是单向的，所以母牛的回程路线可能与原先到达聚会的路线有所不同。 在所有奶牛中，奶牛步行去聚会和返回所花费的最长时间是多少？ 输入值分别三空格隔开的整数，：1线Ñ，中号，和X线2 .. 中号 1：线我 1描述了道路我有三个空格隔开的整数：甲我，乙我和Ť 我。所描述的道路从农场A i到农场B i延伸，需要经过T i个时间单位。 输出量第1行：一个整数：任何一头母牛必须行走的最长时间。 样本输入1234567894 8 21 2 41 3 21 4 72 1 12 3 53 1 23 4 44 2 3 样本输出110 题目大意输出三个数，n,m,x。n代表点的个数，m代表有向边的个数，x代表集会地点，下面m行:x,y,s。表示x点到y点的有向边的长度是s。要求输出某个点到x,再从x回家的最长距离 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 1001#define MAX 0x3f3f3f3fusing namespace std;int n,m,x,map[N][N],d[N],v[N],bd[N];void dij(int start)&#123; int index,minn; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; v[i]&#x3D;0; d[i]&#x3D;map[start][i]; &#125; v[start]&#x3D;1; for(int k&#x3D;2;k&lt;&#x3D;n;k++) &#123; minn&#x3D;MAX; for(int i&#x3D;1;i&lt;&#x3D;n;i++) if(v[i]&#x3D;&#x3D;0&amp;&amp;d[i]&lt;minn) &#123; minn&#x3D;d[i]; index&#x3D;i; &#125; v[index]&#x3D;1; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(v[i]&#x3D;&#x3D;0&amp;&amp;d[i]&gt;d[index]+map[index][i]) &#123; d[i]&#x3D;d[index]+map[index][i]; &#125; &#125; &#125; &#x2F;&#x2F;cout&lt;&lt;d[end]&lt;&lt;endl;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin&gt;&gt;n&gt;&gt;m&gt;&gt;x; &#x2F;&#x2F;memset(map,0x3f,sizeof(map)); for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;n;j++) map[i][j]&#x3D;MAX; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; cin&gt;&gt;map[x][y]; &#125; dij(x); for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; bd[i]&#x3D;d[i]; for(int j&#x3D;i+1;j&lt;&#x3D;n;j++) &#123; int t&#x3D;map[i][j]; map[i][j]&#x3D;map[j][i]; map[j][i]&#x3D;t; &#125; &#125; dij(x); int jieguo&#x3D;-1; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(i!&#x3D;x&amp;&amp;d[i]!&#x3D;MAX&amp;&amp;bd[i]!&#x3D;MAX&amp;&amp;d[i]+bd[i]&gt;jieguo) jieguo&#x3D;d[i]+bd[i]; &#125; cout&lt;&lt;jieguo&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"有向图绕圈","slug":"有向图绕圈","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%89%E5%90%91%E5%9B%BE%E7%BB%95%E5%9C%88/"},{"name":"翻转矩阵","slug":"翻转矩阵","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5/"}]},{"title":"POJ-1797-Heavy Transportation","slug":"POJ-1797-Heavy-Transportation","date":"2020-03-06T00:57:10.000Z","updated":"2020-03-06T01:17:59.272Z","comments":true,"path":"2020/03/06/POJ-1797-Heavy-Transportation/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/06/POJ-1797-Heavy-Transportation/","excerpt":"dij用途还是很广的，稍微分析一下可行性就可以。可行性主要表现在两部分，第一部分筛选最优解，第二部分更新当前状态。只要这两点可行就可以。注意不能图省事两个循环同时计算和求最优解。","text":"dij用途还是很广的，稍微分析一下可行性就可以。可行性主要表现在两部分，第一部分筛选最优解，第二部分更新当前状态。只要这两点可行就可以。注意不能图省事两个循环同时计算和求最优解。 题目重型运输 时限： 3000MS 内存限制： 30000K 提交总数： 66100 接受： 16246 描述背景雨果重工很高兴。Cargolifter项目崩溃后，他现在可以扩展业务。但是他需要一个聪明的人，告诉他从客户建造巨型钢起重机的地方到所有街道都可以承载重量的地方是否真的有办法。幸运的是，他已经制定了一个计划，包括所有街道，桥梁和所有允许的重量。不幸的是，他不知道如何找到最大重量来告诉客户起重机的重量。但是你当然知道。 问题系统会为您提供城市规划，由交叉口之间的街道（权重限制）描述，该街道编号为1到n。您的任务是找到从1号交叉口（Hugo的位置）到n号交叉口（客户的位置）可以运输的最大重量。您可以假设至少有一条路径。所有街道均可双向行驶。 输入值第一行包含方案（城市计划）的数量。对于每个城市，第一行给出的是路口交叉口数量n（1 &lt;= n &lt;= 1000）和街道数量m。接下来的m行包含整数的三元组，这些整数指定了道路的起点和终点交叉点以及允许的最大权重，该权重为正且不大于1000000。每对交叉点之间最多有一条街道。 输出量每个方案的输出都以包含“方案#i：”的行开头，其中i是从1开始的方案编号。然后打印一行，其中包含Hugo可以运输给客户的最大允许重量。用空白行终止方案的输出。 样本输入123451个3 31 2 31 3 42 3 5 样本输出12方案1：4 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int map[1001][1001];int d[1001];bool v[1001];int q&#x3D;1;int n,index,m,maxx;void dij()&#123; int i,j; for(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; v[i]&#x3D;0; d[i]&#x3D;map[1][i]; &#125; v[1]&#x3D;1; while(v[n]!&#x3D;1) &#123; maxx&#x3D;-1; for(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(v[i]&#x3D;&#x3D;0&amp;&amp;d[i]&gt;maxx) &#123; maxx&#x3D;d[i]; index&#x3D;i; &#125; &#125; v[index]&#x3D;1; for(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int tt&#x3D;map[index][i]&lt;d[index]?map[index][i]:d[index]; if(v[i]&#x3D;&#x3D;0&amp;&amp;(d[i]&lt;tt)) &#123; d[i]&#x3D;tt; &#125; &#125; &#125; printf(&quot;Scenario #%d:\\n%d\\n\\n&quot;,q++,d[n]);&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; map[i][j]&#x3D;0; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; int a,b,w; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w); map[a][b]&#x3D;map[b][a]&#x3D;w; &#125; dij(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"最大最小距离","slug":"最大最小距离","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"}]},{"title":"POJ-2253-Frogger","slug":"POJ-2253-Frogger","date":"2020-03-05T07:16:38.000Z","updated":"2020-03-05T07:49:10.697Z","comments":true,"path":"2020/03/05/POJ-2253-Frogger/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/05/POJ-2253-Frogger/","excerpt":"跟dij算法的可行性一样，分为两个集合，一个是处理完的集合a(a中存在起点s),一个是待处理的集合b，取b中所求量(一般为最短型，可以是总路径，也可以是组内路径)最小的那个点c，那么s到c的最优解就能够确定下来，c的上一个点p，要么在a中，要么在b中，在b中不可能，因为b中除了c点别的点都要比c大(我们之前的取得C是最小的)，所以p点只能在a中。如果a中只有起点s，那么s到c的最小值就是s到c的距离，把c加入a集合，同时更新b集合中的点到s的距离，这样就能保证每次保留的都是b集合中每一个点到a集合的距离，再取最小值……","text":"跟dij算法的可行性一样，分为两个集合，一个是处理完的集合a(a中存在起点s),一个是待处理的集合b，取b中所求量(一般为最短型，可以是总路径，也可以是组内路径)最小的那个点c，那么s到c的最优解就能够确定下来，c的上一个点p，要么在a中，要么在b中，在b中不可能，因为b中除了c点别的点都要比c大(我们之前的取得C是最小的)，所以p点只能在a中。如果a中只有起点s，那么s到c的最小值就是s到c的距离，把c加入a集合，同时更新b集合中的点到s的距离，这样就能保证每次保留的都是b集合中每一个点到a集合的距离，再取最小值…… 题目蛙人 时限： 1000MS 内存限制： 65536K 提交总数： 77942 接受： 23692 描述弗雷迪·青蛙坐在湖中间的一块石头上。突然，他注意到坐在另一块石头上的菲奥娜·青蛙。他计划去探望她，但由于水很脏，到处都是游客的防晒霜，他想避免游泳，而是跳跳来到达她。不幸的是，菲奥娜的石头不在他的跳跃范围内。因此，弗雷迪（Freddy）考虑使用其他石头作为中间停靠点，并通过几次小跳的顺序到达她。为了执行给定的跳跃序列，青蛙的跳跃范围显然必须至少与序列中发生的最长跳跃一样长。因此，将两块石头之间的青蛙距离（人类也称为最小最大距离）定义为两块石头之间所有可能路径上的最小必要跳跃范围。 您将获得弗雷迪石头，菲奥娜石头和湖中所有其他石头的坐标。您的工作是计算Freddy和Fiona的石头之间的青蛙距离。 输入值输入将包含一个或多个测试用例。每个测试用例的第一行将包含结石数量n（2 &lt;= n &lt;= 200）。接下来的n条线分别包含两个整数xi，yi（0 &lt;= xi，yi &lt;= 1000），它们表示石头#i的坐标。第1块石头是弗雷迪的石头，第2块石头是菲奥娜的石头，其他n-2块石头未被占用。每个测试用例后面都有一个空白行。输入以n的零（0）值终止。 输出量对于每个测试用例，打印一行“ Scenario #x”和一行“ Frog Distance = y”，其中x替换为测试用例编号（从1开始编号），y替换为适当的实数，打印到三位小数。在每个测试用例之后，甚至在最后一个测试用例之后，都应留一个空白行。 样本输入123456789102 0 0 3 4 3 17 4 19 4 18 5 0 样本输出12345方案＃1 青蛙距离&#x3D; 5.000 方案＃2 青蛙距离&#x3D; 1.414 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int n,MAX&#x3D;0x3f3f3f3f;int x[201];int y[201];double d[201];bool v[201];double map[201][201];int index;int q&#x3D;1;double minn;void dij()&#123; memset(v,0,sizeof(v)); d[1]&#x3D;0; v[1]&#x3D;1; int mubiao&#x3D;1; while(v[2]!&#x3D;1) &#123; minn&#x3D;MAX; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(v[i]&#x3D;&#x3D;0) &#123; if(max(d[mubiao],map[mubiao][i])&lt;d[i]) &#123; d[i]&#x3D;max(d[mubiao],map[mubiao][i]); &#125; if(d[i]&lt;minn) &#123; minn&#x3D;d[i]; index&#x3D;i; &#125; &#125; &#125; v[index]&#x3D;1; mubiao&#x3D;index; &#125; printf(&quot;Scenario #%d\\nFrog Distance &#x3D; %.3f\\n\\n&quot;,q++,d[2]); &#x2F;&#x2F;printf(&quot;%.3f\\n&quot;,d[2]);&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;n&amp;&amp;n) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; cin&gt;&gt;x[i]&gt;&gt;y[i]; &#125; &#x2F;&#x2F;memset(map,0,sizeof(map)); for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; map[i][i]&#x3D;0; d[i]&#x3D;MAX; for(int j&#x3D;1;j&lt;&#x3D;i-1;j++) &#123; map[i][j]&#x3D;map[j][i]&#x3D;sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])); &#125; &#125; dij(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"组内最短路径","slug":"组内最短路径","permalink":"https://donghuangzhong.github.io/tags/%E7%BB%84%E5%86%85%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"POJ-2387-Til the Cows Come Home","slug":"POJ-2387-Til-the-Cows-Come-Home","date":"2020-03-05T00:46:24.000Z","updated":"2020-03-05T08:51:12.523Z","comments":true,"path":"2020/03/05/POJ-2387-Til-the-Cows-Come-Home/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/05/POJ-2387-Til-the-Cows-Come-Home/","excerpt":"dijkstra算法，非简单可达路径不要用DFS；如果要输出路径保存在标志数组中，递归输出；变与不变的情况最好不用三目运算符","text":"dijkstra算法，非简单可达路径不要用DFS；如果要输出路径保存在标志数组中，递归输出；变与不变的情况最好不用三目运算符 题目http://poj.org/problem?id=2387 直到母牛回家 时限： 1000MS 内存限制： 65536K 提交总数： 100676 接受的： 32539 描述贝西（Bessie）在野外，想回到谷仓，以便在农夫约翰（Johner John）叫醒她早晨挤奶之前尽可能多地入睡。贝西需要美睡，所以她想尽快回来。 农夫约翰的田地中有N（2 &lt;= N &lt;= 1000）个地标，唯一编号为1..N。地标1是谷仓；Bessie整日站立的苹果树丛是地标N。奶牛使用地标之间长度各不相同的T（1 &lt;= T &lt;= 2000）双向奶牛场在田间旅行。贝西对自己的导航能力不抱有信心，因此，从开始到结束，她始终处在步道上。 给定地标之间的路径，确定Bessie返回谷仓必须行走的最小距离。可以保证存在这样的路由。 输入值*第1行：两个整数：T和N *第2..T + 1行：每行将一个轨迹描述为三个以空格分隔的整数。前两个整数是小径在其间行进的地标。第三个整数是路径的长度，范围为1..100。 输出量*第1行：一个整数，Bessie从地标N到地标1所必须经过的最小距离。 样本输入1234565 51 2 202 3 303 4 204 5 201 5 100 样本输出190 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int N[1001];bool v[1001];int map[1001][1001];int n,x,index,mubiao; int MAX&#x3D;0x3f3f3f3f;void dij()&#123; N[x]&#x3D;0; v[x]&#x3D;1; int mubiao&#x3D;x; while(v[1]!&#x3D;1) &#123; int min&#x3D;MAX; for(int i&#x3D;1;i&lt;&#x3D;x;i++) &#123; if(v[i]&#x3D;&#x3D;0) &#123; int t&#x3D;N[mubiao]+map[mubiao][i]; if(N[i]&gt;t) N[i]&#x3D;t; if(N[i]&lt;min)&#123; min&#x3D;N[i]; index&#x3D;i; &#125; &#125; &#125; v[index]&#x3D;1; mubiao&#x3D;index; &#125; cout&lt;&lt;N[1]&lt;&lt;endl;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;n&gt;&gt;x) &#123; &#x2F;&#x2F;memset(map,0x3f,sizeof(map)); &#x2F;&#x2F;memset(v,0,sizeof(v)); &#x2F;&#x2F;memset(N,0x3f,sizeof(N)); for(int i&#x3D;1;i&lt;&#x3D;x;i++) &#123; N[i]&#x3D;MAX; v[i]&#x3D;0; for(int j&#x3D;1;j&lt;&#x3D;x;j++) &#123; map[i][j]&#x3D;MAX; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int j,k,dd; cin&gt;&gt;j&gt;&gt;k; cin&gt;&gt;dd; if(dd&lt;map[j][k]) &#123; map[j][k]&#x3D;dd; map[k][j]&#x3D;dd; &#125; &#125; dij(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"}],"tags":[{"name":"最短路径","slug":"最短路径","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"HDU-2102-A计划","slug":"HDU-2102-A计划","date":"2020-03-03T02:39:56.000Z","updated":"2020-03-03T02:49:20.495Z","comments":true,"path":"2020/03/03/HDU-2102-A计划/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/03/HDU-2102-A%E8%AE%A1%E5%88%92/","excerpt":"两层迷宫，‘#’代表瞬时传送装置，如果传送后是墙则撞死，如果传送后是‘#’，则一直在传送，必须考虑这两种情况。","text":"两层迷宫，‘#’代表瞬时传送装置，如果传送后是墙则撞死，如果传送后是‘#’，则一直在传送，必须考虑这两种情况。 题目A计划\\Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 38233 Accepted Submission(s): 9470** Problem Description 可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用*表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。 Input 输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小NM（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前NM表示迷宫的第一层的布置情况，后N*M表示迷宫第二层的布置情况。 Output 如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。 Sample Input 1234567891011121315 5 14S*#*..#........****....#...*.P#.*..***.....*.*.#.. Sample Output 1YES 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;struct Point&#123; int x,y,z;&#125; a,b;int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;int m,n,t,zx,zy,zz;char map[2][10][10];int v[2][10][10];void bfs()&#123; memset(v,0,sizeof(v)); v[0][0][0]&#x3D;1; a.x&#x3D;0;a.y&#x3D;0;a.z&#x3D;0; queue&lt;Point&gt; q; q.push(a); while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x; b.y&#x3D;a.y+dir[i][0]; b.z&#x3D;a.z+dir[i][1]; if(b.y&gt;&#x3D;0&amp;&amp;b.y&lt;m&amp;&amp;b.z&gt;&#x3D;0&amp;&amp;b.z&lt;n&amp;&amp;map[b.x][b.y][b.z]!&#x3D;&#39;*&#39;&amp;&amp;v[b.x][b.y][b.z]&#x3D;&#x3D;0) &#123; v[b.x][b.y][b.z]&#x3D;v[a.x][a.y][a.z]+1; if(map[b.x][b.y][b.z]&#x3D;&#x3D;&#39;#&#39;) &#123; int tt&#x3D;v[b.x][b.y][b.z]; b.x&#x3D;(b.x&#x3D;&#x3D;1?0:1); if(map[b.x][b.y][b.z]&#x3D;&#x3D;&#39;*&#39;||map[b.x][b.y][b.z]&#x3D;&#x3D;&#39;#&#39;) continue; v[b.x][b.y][b.z]&#x3D;tt; &#125; if(v[b.x][b.y][b.z]-1&gt;t)&#123;cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;return;&#125; if(map[b.x][b.y][b.z]&#x3D;&#x3D;&#39;P&#39;) &#123;cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; return;&#125; q.push(b); &#125; &#125; &#125; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int c; cin&gt;&gt;c; while(c--)&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;t; for(int k&#x3D;0;k&lt;2;k++) for(int i&#x3D;0;i&lt;m;i++) for(int j&#x3D;0;j&lt;n;j++) cin&gt;&gt;map[k][i][j]; bfs(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"易错题","slug":"易错题","permalink":"https://donghuangzhong.github.io/tags/%E6%98%93%E9%94%99%E9%A2%98/"},{"name":"标志数组做记录","slug":"标志数组做记录","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%81%9A%E8%AE%B0%E5%BD%95/"}]},{"title":"HDU-2181-哈密顿绕行问题","slug":"HDU-2181-哈密顿绕行问题","date":"2020-03-03T00:35:19.000Z","updated":"2020-03-03T00:42:31.992Z","comments":true,"path":"2020/03/03/HDU-2181-哈密顿绕行问题/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/03/HDU-2181-%E5%93%88%E5%AF%86%E9%A1%BF%E7%BB%95%E8%A1%8C%E9%97%AE%E9%A2%98/","excerpt":"DFS遍历所有可能性","text":"DFS遍历所有可能性 题目哈密顿绕行世界问题\\Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 10731 Accepted Submission(s): 6191** Problem Description 一个规则的实心十二面体，它的 20个顶点标出世界著名的20个城市，你从一个城市出发经过每个城市刚好一次后回到出发的城市。 Input 前20行的第i行有3个数,表示与第i个城市相邻的3个城市.第20行以后每行有1个数m,m&lt;=20,m&gt;=1.m=0退出. Output 输出从第m个城市出发经过每个城市1次又回到m的所有路线,如有多条路线,按字典序输出,每行1条路线.每行首先输出是第几条路线.然后个一个: 后列出经过的城市.参看Sample output Sample Input 123456789101112131415161718192021222 5 201 3 122 4 103 5 81 4 65 7 196 8 174 7 98 10 163 9 1110 12 152 11 1312 14 2013 15 1811 14 169 15 177 16 1814 17 196 18 201 13 1950 Sample Output 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601: 5 1 2 3 4 8 7 17 18 14 15 16 9 10 11 12 13 20 19 6 52: 5 1 2 3 4 8 9 10 11 12 13 20 19 18 14 15 16 17 7 6 53: 5 1 2 3 10 9 16 17 18 14 15 11 12 13 20 19 6 7 8 4 54: 5 1 2 3 10 11 12 13 20 19 6 7 17 18 14 15 16 9 8 4 55: 5 1 2 12 11 10 3 4 8 9 16 15 14 13 20 19 18 17 7 6 56: 5 1 2 12 11 15 14 13 20 19 18 17 16 9 10 3 4 8 7 6 57: 5 1 2 12 11 15 16 9 10 3 4 8 7 17 18 14 13 20 19 6 58: 5 1 2 12 11 15 16 17 18 14 13 20 19 6 7 8 9 10 3 4 59: 5 1 2 12 13 20 19 6 7 8 9 16 17 18 14 15 11 10 3 4 510: 5 1 2 12 13 20 19 18 14 15 11 10 3 4 8 9 16 17 7 6 511: 5 1 20 13 12 2 3 4 8 7 17 16 9 10 11 15 14 18 19 6 512: 5 1 20 13 12 2 3 10 11 15 14 18 19 6 7 17 16 9 8 4 513: 5 1 20 13 14 15 11 12 2 3 10 9 16 17 18 19 6 7 8 4 514: 5 1 20 13 14 15 16 9 10 11 12 2 3 4 8 7 17 18 19 6 515: 5 1 20 13 14 15 16 17 18 19 6 7 8 9 10 11 12 2 3 4 516: 5 1 20 13 14 18 19 6 7 17 16 15 11 12 2 3 10 9 8 4 517: 5 1 20 19 6 7 8 9 10 11 15 16 17 18 14 13 12 2 3 4 518: 5 1 20 19 6 7 17 18 14 13 12 2 3 10 11 15 16 9 8 4 519: 5 1 20 19 18 14 13 12 2 3 4 8 9 10 11 15 16 17 7 6 520: 5 1 20 19 18 17 16 9 10 11 15 14 13 12 2 3 4 8 7 6 521: 5 4 3 2 1 20 13 12 11 10 9 8 7 17 16 15 14 18 19 6 522: 5 4 3 2 1 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 523: 5 4 3 2 12 11 10 9 8 7 6 19 18 17 16 15 14 13 20 1 524: 5 4 3 2 12 13 14 18 17 16 15 11 10 9 8 7 6 19 20 1 525: 5 4 3 10 9 8 7 6 19 20 13 14 18 17 16 15 11 12 2 1 526: 5 4 3 10 9 8 7 17 16 15 11 12 2 1 20 13 14 18 19 6 527: 5 4 3 10 11 12 2 1 20 13 14 15 16 9 8 7 17 18 19 6 528: 5 4 3 10 11 15 14 13 12 2 1 20 19 18 17 16 9 8 7 6 529: 5 4 3 10 11 15 14 18 17 16 9 8 7 6 19 20 13 12 2 1 530: 5 4 3 10 11 15 16 9 8 7 17 18 14 13 12 2 1 20 19 6 531: 5 4 8 7 6 19 18 17 16 9 10 3 2 12 11 15 14 13 20 1 532: 5 4 8 7 6 19 20 13 12 11 15 14 18 17 16 9 10 3 2 1 533: 5 4 8 7 17 16 9 10 3 2 1 20 13 12 11 15 14 18 19 6 534: 5 4 8 7 17 18 14 13 12 11 15 16 9 10 3 2 1 20 19 6 535: 5 4 8 9 10 3 2 1 20 19 18 14 13 12 11 15 16 17 7 6 536: 5 4 8 9 10 3 2 12 11 15 16 17 7 6 19 18 14 13 20 1 537: 5 4 8 9 16 15 11 10 3 2 12 13 14 18 17 7 6 19 20 1 538: 5 4 8 9 16 15 14 13 12 11 10 3 2 1 20 19 18 17 7 6 539: 5 4 8 9 16 15 14 18 17 7 6 19 20 13 12 11 10 3 2 1 540: 5 4 8 9 16 17 7 6 19 18 14 15 11 10 3 2 12 13 20 1 541: 5 6 7 8 4 3 2 12 13 14 15 11 10 9 16 17 18 19 20 1 542: 5 6 7 8 4 3 10 9 16 17 18 19 20 13 14 15 11 12 2 1 543: 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 544: 5 6 7 8 9 16 17 18 19 20 1 2 12 13 14 15 11 10 3 4 545: 5 6 7 17 16 9 8 4 3 10 11 15 14 18 19 20 13 12 2 1 546: 5 6 7 17 16 15 11 10 9 8 4 3 2 12 13 14 18 19 20 1 547: 5 6 7 17 16 15 11 12 13 14 18 19 20 1 2 3 10 9 8 4 548: 5 6 7 17 16 15 14 18 19 20 13 12 11 10 9 8 4 3 2 1 549: 5 6 7 17 18 19 20 1 2 3 10 11 12 13 14 15 16 9 8 4 550: 5 6 7 17 18 19 20 13 14 15 16 9 8 4 3 10 11 12 2 1 551: 5 6 19 18 14 13 20 1 2 12 11 15 16 17 7 8 9 10 3 4 552: 5 6 19 18 14 15 11 10 9 16 17 7 8 4 3 2 12 13 20 1 553: 5 6 19 18 14 15 11 12 13 20 1 2 3 10 9 16 17 7 8 4 554: 5 6 19 18 14 15 16 17 7 8 9 10 11 12 13 20 1 2 3 4 555: 5 6 19 18 17 7 8 4 3 2 12 11 10 9 16 15 14 13 20 1 556: 5 6 19 18 17 7 8 9 16 15 14 13 20 1 2 12 11 10 3 4 557: 5 6 19 20 1 2 3 10 9 16 15 11 12 13 14 18 17 7 8 4 558: 5 6 19 20 1 2 12 13 14 18 17 7 8 9 16 15 11 10 3 4 559: 5 6 19 20 13 12 11 10 9 16 15 14 18 17 7 8 4 3 2 1 560: 5 6 19 20 13 14 18 17 7 8 4 3 10 9 16 15 11 12 2 1 5 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int nn,Case;bool v[21];int l[21];struct Point&#123; int xianglin[3];&#125; map[21];void dfs(int n)&#123; if(n&#x3D;&#x3D;21)&#123; for(int i&#x3D;0;i&lt;3;i++) &#123; if(map[l[n-1]].xianglin[i]&#x3D;&#x3D;nn) &#123; cout&lt;&lt;Case++&lt;&lt;&quot;: &quot;; for(int j&#x3D;1;j&lt;21;j++) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;l[j]; &#125; cout&lt;&lt;&quot; &quot;&lt;&lt;l[1]; cout&lt;&lt;endl; &#125; &#125; return; &#125; for(int i&#x3D;0;i&lt;3;i++) &#123; if(v[map[l[n-1]].xianglin[i]]&#x3D;&#x3D;0) &#123; v[map[l[n-1]].xianglin[i]]&#x3D;1; l[n]&#x3D;map[l[n-1]].xianglin[i]; dfs(n+1); v[map[l[n-1]].xianglin[i]]&#x3D;0; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); for(int i &#x3D; 1; i &lt; 21; i++) &#123; cin&gt;&gt;map[i].xianglin[0]&gt;&gt;map[i].xianglin[1]&gt;&gt;map[i].xianglin[2]; &#125; while(cin&gt;&gt;nn&amp;&amp;nn)&#123; Case&#x3D;1; memset(v,0,sizeof(v)); v[nn]&#x3D;1; l[1]&#x3D;nn; dfs(2); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DFS","slug":"ACM/DFS","permalink":"https://donghuangzhong.github.io/categories/ACM/DFS/"}],"tags":[{"name":"遍历所有可能性","slug":"遍历所有可能性","permalink":"https://donghuangzhong.github.io/tags/%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E6%80%A7/"}]},{"title":"HDU-2612","slug":"HDU-2612","date":"2020-03-02T01:47:16.000Z","updated":"2020-03-02T01:58:36.944Z","comments":true,"path":"2020/03/02/HDU-2612/","link":"","permalink":"https://donghuangzhong.github.io/2020/03/02/HDU-2612/","excerpt":"两个标志数组，两次BFS，不是双BFS，双BFS应该是双入口BFS，是一次BFS，两个入口而已，UVA-11624这才是双入口BFS。二维数组对应的函数形参必须声明第二维，并且不能对传进函数的形参用memset,因为sizeof(数组)不对，这样只能自行指定memset的大小了。","text":"两个标志数组，两次BFS，不是双BFS，双BFS应该是双入口BFS，是一次BFS，两个入口而已，UVA-11624这才是双入口BFS。二维数组对应的函数形参必须声明第二维，并且不能对传进函数的形参用memset,因为sizeof(数组)不对，这样只能自行指定memset的大小了。 问题想办法\\时间限制：3000/1000 MS（Java /其他）内存限制：32768/32768 K（Java /其他）总提交数量：35622接受提交数量：11329** 问题描述 终于在杭州经过一年的学习，一分飞终于到了宁波。离开宁波一年后，一分飞有很多人见面。特别是好朋友Merceki。Yifenfei的家在乡下，而Merceki的家在城市中心。因此，易芬菲与Merceki安排了在肯德基会面。宁波有很多肯德基，他们想选择一种让总时间最短的肯德基。现在给您一张宁波地图，yifenfei和Merceki都可以通过成本11分钟左右上下移动到相邻的道路。 输入值 输入包含多个测试用例。每个测试用例包括前两个整数n，m。（2 &lt;= n，m &lt;= 200）。接下来的n行，每行包含m个字符。“ Y”表示一分钱的初始职位。“ M”表示Merceki的初始位置。‘＃’禁止道路；‘。’ 路。‘@’KCF 输出量 对于每个测试用例输出，yifenfei和Merceki到达肯德基之一的最短总时间。您可以肯定总是有一个肯德基可以让他们见面。 样本输入 123456789101112131415164 4Y。＃@....。＃..@ .. M4 4Y。＃@....。＃..@＃。M5 5Y .. @。。＃...。＃...@ .. M。＃...＃ 样本输出 123668866 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;char map[201][201];int v1[201][201];int v2[201][201];int m,n,minn;int dir[4][2]&#x3D;&#123;0,1,1,0,0,-1,-1,0&#125;;struct Point&#123; int x,y;&#125; a,b,y,M;void bfs(int x,int y,int v[201][201])&#123; memset(v,0,4*201*201); a.x&#x3D;x;a.y&#x3D;y; queue&lt;Point&gt; q; q.push(a); v[x][y]&#x3D;1; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(b.x&gt;&#x3D;0&amp;&amp;b.x&lt;m&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;n&amp;&amp;map[b.x][b.y]!&#x3D;&#39;#&#39;&amp;&amp;v[b.x][b.y]&#x3D;&#x3D;0) &#123; v[b.x][b.y]&#x3D;v[a.x][a.y]+1; q.push(b); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;m&gt;&gt;n) &#123; for(int i&#x3D;0;i&lt;m;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]&#x3D;&#x3D;&#39;Y&#39;) &#123; y.x&#x3D;i;y.y&#x3D;j; &#125; if(map[i][j]&#x3D;&#x3D;&#39;M&#39;) &#123; M.x&#x3D;i;M.y&#x3D;j; &#125; &#125; &#125; bfs(y.x,y.y,v1); bfs(M.x,M.y,v2); minn&#x3D;1000000; for(int i&#x3D;0;i&lt;m;i++) &#123; for(int j&#x3D;0;j&lt;n;j++) &#123; if(map[i][j]&#x3D;&#x3D;&#39;@&#39;&amp;&amp;v1[i][j]&amp;&amp;v2[i][j]) &#123; v2[i][j]+&#x3D;v1[i][j]-2; if(v2[i][j]&lt;minn) &#123; minn&#x3D;v2[i][j]; &#125; &#125; &#125;&#125; cout&lt;&lt;minn*11&lt;&lt;endl; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"两次BFS","slug":"两次BFS","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%A4%E6%AC%A1BFS/"},{"name":"函数数组形参","slug":"函数数组形参","permalink":"https://donghuangzhong.github.io/tags/%E5%87%BD%E6%95%B0%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82/"}]},{"title":"HDU-1495","slug":"HDU-1495","date":"2020-02-29T09:43:05.000Z","updated":"2020-03-02T01:41:23.273Z","comments":true,"path":"2020/02/29/HDU-1495/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/29/HDU-1495/","excerpt":"搜索所有的状态，标志数组同时用于记录次数，最后减一，用i!=j的方式遍历倒法，用3-i-j得到剩余的被子杯子的可乐。网上有一份数论的做法，极为精简，以后再研究吧。路漫漫其修远兮！","text":"搜索所有的状态，标志数组同时用于记录次数，最后减一，用i!=j的方式遍历倒法，用3-i-j得到剩余的被子杯子的可乐。网上有一份数论的做法，极为精简，以后再研究吧。路漫漫其修远兮！ 题目非常可乐\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 36161 Accepted Submission(s): 14072** Problem Description 大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 Input 三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。 Output 如果能平分的话请输出最少要倒的次数，否则输出”NO”。 Sample Input 1237 4 34 1 30 0 0 Sample Output 12NO3 算法刚开始状态为0,0,s。之后模拟所有倒法共有6种，能倒的前提是本瓶子有水，被倒的瓶子有空闲容量。根据这两个的大小倒之后可能有两个状态，本瓶子空，被倒瓶子水增加；本瓶子非空，被盗瓶子满。得到倒之后的状态，判断是否到达过这个状态，没有则步数加一…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int m,n,s;int v[101][101][101];int r[3];struct S&#123; int c[3];&#125; a,b;void bfs()&#123; a.c[0]&#x3D;0; a.c[1]&#x3D;0; a.c[2]&#x3D;s; v[0][0][s]&#x3D;1; queue&lt;S&gt; q; q.push(a); while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;3;i++) &#123; for(int j&#x3D;0;j&lt;3;j++) &#123; if(i!&#x3D;j) &#123; if(a.c[i]&gt;0&amp;&amp;r[j]-a.c[j]&gt;0) &#123; if(a.c[i]&gt;&#x3D;r[j]-a.c[j]) &#123;b.c[j]&#x3D;r[j]; b.c[i]&#x3D;a.c[i]-r[j]+a.c[j]; b.c[3-i-j]&#x3D;a.c[3-i-j]; &#125; else &#123; b.c[i]&#x3D;0; b.c[j]&#x3D;a.c[j]+a.c[i]; b.c[3-i-j]&#x3D;a.c[3-i-j]; &#125; if(v[b.c[0]][b.c[1]][b.c[2]]&#x3D;&#x3D;0) &#123; v[b.c[0]][b.c[1]][b.c[2]]&#x3D;v[a.c[0]][a.c[1]][a.c[2]]+1; if((b.c[0]&#x3D;&#x3D;s&#x2F;2&amp;&amp;b.c[1]&#x3D;&#x3D;s&#x2F;2)||(b.c[1]&#x3D;&#x3D;s&#x2F;2&amp;&amp;b.c[2]&#x3D;&#x3D;s&#x2F;2)||(b.c[0]&#x3D;&#x3D;s&#x2F;2&amp;&amp;b.c[2]&#x3D;&#x3D;s&#x2F;2)) &#123;cout&lt;&lt;v[b.c[0]][b.c[1]][b.c[2]]-1&lt;&lt;endl; return; &#125; q.push(b); &#125; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;s&gt;&gt;n&gt;&gt;m&amp;&amp;m&amp;&amp;n&amp;&amp;s) &#123; if(s%2 &#x3D;&#x3D; 1)&#123; printf(&quot;NO\\n&quot;); continue; &#125; memset(v,0,sizeof(v)); r[0]&#x3D;m; r[1]&#x3D;n; r[2]&#x3D;s; bfs(); &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"倒水","slug":"倒水","permalink":"https://donghuangzhong.github.io/tags/%E5%80%92%E6%B0%B4/"},{"name":"数论","slug":"数论","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"HDU-1241","slug":"HDU-1241","date":"2020-02-23T11:57:05.000Z","updated":"2020-02-23T11:59:40.268Z","comments":true,"path":"2020/02/23/HDU-1241/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/23/HDU-1241/","excerpt":"简单BFS，找到一个入队点将所有可达的区域置为不可达","text":"简单BFS，找到一个入队点将所有可达的区域置为不可达 题目油藏\\时间限制：2000/1000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）提交总数：58896接受提交：33745** 问题描述 GeoSurvComp地质勘测公司负责检测地下油藏。GeoSurvComp一次处理一个大矩形区域的土地，并创建一个将土地划分为多个正方形图的网格。然后，它使用传感设备分别分析每个地块，以确定该地块是否包含油。包含油的地块称为矿穴。如果两个凹坑相邻，则它们是同一油藏的一部分。积油可能很大，可能包含许多凹穴。您的工作是确定网格中包含多少种不同的油藏。 输入值 输入文件包含一个或多个网格。每个网格均以包含m和n的行开始，网格中的行和列数为m和n，并用单个空格分隔。如果m = 0，则表示输入结束；否则，输入0。否则为1 &lt;= m &lt;= 100和1 &lt;= n &lt;=100。紧随其后的是m行，每行n个字符（不计算行尾字符）。每个字符对应一个地块，要么是代表无油的“ *”，要么是代表油囊的“ @”。 输出量 对于每个网格，输出不同的油藏数量。如果两个不同的油藏在水平，垂直或对角线上相邻，则它们是同一油藏的一部分。积油最多可容纳100个口袋。 样本输入 1234567891011121314151 1 * 3 5 * @ * @ * ** @ ** * @ * @ * 1 8 @@ **** @ * 5 5 **** @ * @@ * @ * @ ** @ @@@ * @ @@ ** @ 0 0 样本输出 12340 1 2 2 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int dir[8][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1,1,1,-1,-1,1,-1,-1,1&#125;;char map[101][101]; struct Point&#123; int x,y;&#125; a,b;int h,l;void bfs(int x,int y)&#123; queue&lt;Point&gt; q; a.x&#x3D;x; a.y&#x3D;y; q.push(a); map[x][y]&#x3D;&#39;*&#39;; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;8;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(b.x&gt;&#x3D;0&amp;&amp;b.x&lt;h&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;l&amp;&amp;map[b.x][b.y]&#x3D;&#x3D;&#39;@&#39;) &#123; map[b.x][b.y]&#x3D;&#39;*&#39;; q.push(b); &#125; &#125; &#125; &#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;h&gt;&gt;l&amp;&amp;h&amp;&amp;l) &#123; int sum&#x3D;0; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; cin&gt;&gt;map[i][j]; &#125; &#125; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; if(map[i][j]&#x3D;&#x3D;&#39;@&#39;) &#123; bfs(i,j); sum++; &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"},{"name":"图的连通区域","slug":"图的连通区域","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%8C%BA%E5%9F%9F/"}]},{"title":"迷宫问题","slug":"迷宫问题","date":"2020-02-23T10:16:02.000Z","updated":"2020-02-23T10:20:59.846Z","comments":true,"path":"2020/02/23/迷宫问题/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/23/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/","excerpt":"每个节点的去向有很多，不变保存，每个点的来源只有一个，方便保存，但是是逆序的，最后要递归输出","text":"每个节点的去向有很多，不变保存，每个点的来源只有一个，方便保存，但是是逆序的，最后要递归输出 题目迷宫问题定义一个二维数组： 1234567int maze[5][5] &#x3D; &#123; 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,&#125;; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 Input 一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。 Output 左上角到右下角的最短路径，格式如样例所示。 Sample Input123450 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0 Sample Output123456789(0, 0)(1, 0)(2, 0)(2, 1)(2, 2)(2, 3)(2, 4)(3, 4)(4, 4) 算法用另外一个和map一样大小的数组保存该点的上一个点的坐标，然后递归输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std; int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;struct Point&#123; int x; int y;&#125; a,b,point[5][5];int map[5][5];void printxy(int x,int y)&#123; if(x&#x3D;&#x3D;-1&amp;&amp;y&#x3D;&#x3D;-1) return ; printxy(point[x][y].x,point[x][y].y); cout&lt;&lt;&quot;(&quot;&lt;&lt;x&lt;&lt;&quot;, &quot;&lt;&lt;y&lt;&lt;&quot;)&quot;&lt;&lt;endl;&#125;void bfs()&#123; queue&lt;Point&gt; q; a.x&#x3D;0; a.y&#x3D;0; q.push(a); map[0][0]&#x3D;1; point[0][0].x&#x3D;-1; point[0][0].y&#x3D;-1; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(b.x&gt;&#x3D;0&amp;&amp;b.x&lt;5&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;5&amp;&amp;map[b.x][b.y]&#x3D;&#x3D;0) &#123; map[b.x][b.y]&#x3D;1; point[b.x][b.y].x&#x3D;a.x; point[b.x][b.y].y&#x3D;a.y; if(b.x&#x3D;&#x3D;4&amp;&amp;b.y&#x3D;&#x3D;4) &#123; printxy(4,4); &#125; q.push(b); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); for(int i&#x3D;0;i&lt;5;i++) &#123; for(int j&#x3D;0;j&lt;5;j++) &#123; cin&gt;&gt;map[i][j]; &#125; &#125; bfs(); return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"输出路径","slug":"输出路径","permalink":"https://donghuangzhong.github.io/tags/%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84/"}]},{"title":"UVA-11624","slug":"UVA-11624","date":"2020-02-23T04:24:43.000Z","updated":"2020-02-23T06:09:58.176Z","comments":true,"path":"2020/02/23/UVA-11624/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/23/UVA-11624/","excerpt":"一个BFS，多个入口，char的表示范围[0,127]，本来可以不用标志数组的，节省空间，但奈何char表示不了比较大的数","text":"一个BFS，多个入口，char的表示范围[0,127]，本来可以不用标志数组的，节省空间，但奈何char表示不了比较大的数 题目火场逃生一个矩阵中有一个人，用J表示，可以向上下左右走。有多个起火点，用F表示。#表示墙，.表示人可以行走的地方。要求是逃出这个矩阵即可，输出逃出这个矩阵的最短时间，如果不能逃出这个矩阵输出IMPOSSIBEL Sample Input1234567891024 4#### #JF# #..# #..# 3 3 ### #J. #.F Sample Output123 IMPOSSIBLE 算法单个BFS火场逃生是一个连续的过程，同时有火的蔓延和人的移动。但可以将这个连续的过程分割，比如人先走一步，火再蔓延一步，人再走一步，火再蔓延一步······。可是既然是同时发生的，谁先谁后呢？肯定是人先火后了，因为这样不会改变的火场逃生的结果。不然火先的话，假设火和人差一步，火先的话人就死了，火场逃生的结果就不符合事实。人先火后的话问题就变得简单起来了，因为人要先行，所以人必须先入队(同时将该点的J，改变为K)，然后才是各个火种的入队。进入循环，取队首，队首出队，判断这个队首是火(火的话就是’F‘)还是人(&gt;=’K’)，如果是人，判断走完下一步是否走出矩阵，如果走出，则直接保存一下时间(这个时间的基数为’K‘，最后要减去’K‘)然后return，否则将这个点可达的’.’置为队首加一(没错，这是一个字符数组，但char和int在[0,127]互通,这也是为什么失败的原因)，可达点入队；如果是火，则将火的可达点(不是火并且不是墙)置为F，可达点入队……循环往复 失败原因：char能表示的int为[0,127]，再加上基数为’K‘，能表示的时间就更短了，无奈溢出。。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;int h,l,startx,starty,firex,firey,mintime;int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;char map[1001][1001];using namespace std;struct Point&#123; int x; int y;&#125; a,b;queue&lt;Point&gt; q;void bfs()&#123; mintime&#x3D;0; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(map[a.x][a.y]&gt;&#x3D;&#39;K&#39;) &#123; if(b.x&lt;0||b.x&gt;&#x3D;h||b.y&lt;0||b.y&gt;&#x3D;l) &#123; mintime&#x3D;map[a.x][a.y]+1-&#39;K&#39;; return ; &#125; else if(map[b.x][b.y]&#x3D;&#x3D;&#39;.&#39;) &#123; map[b.x][b.y]&#x3D;map[a.x][a.y]+1; q.push(b); &#125; &#125; if(map[a.x][a.y]&#x3D;&#x3D;&#39;F&#39;&amp;&amp;b.x&gt;&#x3D;0&amp;&amp;b.x&lt;h&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;l&amp;&amp;map[b.x][b.y]!&#x3D;&#39;F&#39;&amp;&amp;map[b.x][b.y]!&#x3D;&#39;#&#39;) &#123; map[b.x][b.y]&#x3D;&#39;F&#39;; q.push(b); &#125; &#125; &#125; &#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; while(n--) &#123; while(!q.empty()) q.pop(); cin&gt;&gt;h&gt;&gt;l; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]&#x3D;&#x3D;&#39;J&#39;) &#123; startx&#x3D;i; starty&#x3D;j; a.x&#x3D;startx; a.y&#x3D;starty; map[a.x][a.y]&#x3D;&#39;K&#39;; q.push(a); &#125; &#125; &#125; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; if(map[i][j]&#x3D;&#x3D;&#39;F&#39;) &#123; firex&#x3D;i; firey&#x3D;j; a.x&#x3D;firex; a.y&#x3D;firey; q.push(a); &#125; &#125; &#125; bfs(); if(mintime&#x3D;&#x3D;0) cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl; else cout&lt;&lt;mintime&lt;&lt;endl; &#125; return 0; &#125; 这个在UVA上有debug功能，这个算法通过了所有的测试，但还是WA了，追求完美是每个人的向往，我看到这个题发现地图，标志数组，记录时间的数组可以共用一个，所以写出了上面的代码。知道失败的原因就好改了，记录时间的数组少不了。同时我也将标志数组和记录时间的数组共用一个(这是我的习惯，可以去看看我其他的BFS，其实大部分都是可以共用的)，于是有了下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;int h,l,mintime;int dir[4][2]&#x3D;&#123;1,0,-1,0,0,1,0,-1&#125;;char map[1001][1001];int v[1001][1001];using namespace std;struct Point&#123; int x; int y;&#125; a,b;queue&lt;Point&gt; q;void bfs()&#123; while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;4;i++) &#123; b.x&#x3D;a.x+dir[i][0]; b.y&#x3D;a.y+dir[i][1]; if(map[a.x][a.y]&#x3D;&#x3D;&#39;.&#39;) &#123; if(b.x&lt;0||b.x&gt;&#x3D;h||b.y&lt;0||b.y&gt;&#x3D;l) &#123; mintime&#x3D;v[a.x][a.y]+1-1; return ; &#125; else if(map[b.x][b.y]&#x3D;&#x3D;&#39;.&#39;&amp;&amp;v[b.x][b.y]&#x3D;&#x3D;0) &#123; v[b.x][b.y]&#x3D;v[a.x][a.y]+1; q.push(b); &#125; &#125; if(map[a.x][a.y]&#x3D;&#x3D;&#39;F&#39;&amp;&amp;b.x&gt;&#x3D;0&amp;&amp;b.x&lt;h&amp;&amp;b.y&gt;&#x3D;0&amp;&amp;b.y&lt;l&amp;&amp;map[b.x][b.y]!&#x3D;&#39;F&#39;&amp;&amp;map[b.x][b.y]!&#x3D;&#39;#&#39;) &#123; map[b.x][b.y]&#x3D;&#39;F&#39;; q.push(b); &#125; &#125; &#125; &#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; while(n--) &#123; mintime&#x3D;0; memset(v,0,sizeof(v)); while(!q.empty()) q.pop(); cin&gt;&gt;h&gt;&gt;l; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]&#x3D;&#x3D;&#39;J&#39;) &#123; a.x&#x3D;i; a.y&#x3D;j; v[a.x][a.y]&#x3D;1; map[a.x][a.y]&#x3D;&#39;.&#39;; q.push(a); &#125; &#125; &#125; for(int i&#x3D;0;i&lt;h;i++) &#123; for(int j&#x3D;0;j&lt;l;j++) &#123; if(map[i][j]&#x3D;&#x3D;&#39;F&#39;) &#123; a.x&#x3D;i; a.y&#x3D;j; q.push(a); &#125; &#125; &#125; bfs(); if(mintime&#x3D;&#x3D;0) cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl; else cout&lt;&lt;mintime&lt;&lt;endl; &#125; return 0; &#125; 双BFS这也是一个方法，分为火的BFS和人的BFS，先算火的BFS，记录火到达每一个点的时间，然后再算人的BFS，加一个条件，人必须要比火先到才能走下一步，不过我没写代码","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"妙用标志数组","slug":"妙用标志数组","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"},{"name":"多入口BFS","slug":"多入口BFS","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%9A%E5%85%A5%E5%8F%A3BFS/"},{"name":"火场逃生","slug":"火场逃生","permalink":"https://donghuangzhong.github.io/tags/%E7%81%AB%E5%9C%BA%E9%80%83%E7%94%9F/"}]},{"title":"POJ-3126","slug":"POJ-3126","date":"2020-02-22T08:07:26.000Z","updated":"2020-02-22T08:30:17.283Z","comments":true,"path":"2020/02/22/POJ-3126/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/22/POJ-3126/","excerpt":"4位数素数共1061个，如果m个条件，其中固定a个条件成立，b个条件不成立，a+b=m，则可以列出这些条件，令它们的和为a","text":"4位数素数共1061个，如果m个条件，其中固定a个条件成立，b个条件不成立，a+b=m，则可以列出这些条件，令它们的和为a 题目主要路径 时限： 1000MS 内存限制： 65536K 提交总数： 37988 接受： 20286 就是给两个四位数素数a,b，每次只能变化a中个位十位百位千位其中的一位，问经过多少次变化可以a可以变成b 1033173337333739377987798179 该解决方案的成本为6磅。请注意，在步骤2中粘贴的数字1不能在最后一步中重复使用-必须购买新的1。 输入值 一行带有正数：测试用例的数量（最多100个）。然后，对于每个测试用例，用两个数字用空格分隔的一行。这两个数字都是四位数的质数（无前导零）。 输出量 每种情况下一行，或者用数字表示最低费用，或者包含“不可能”一词。 样本输入 123431033 81791373 80171033 1033 样本输出 123670 算法对素数进行打表，利用标志数组记录步数(基数为1，最终结果-1)，利用逻辑相加保证只有一位变化，比如找相比于a只有一位变化的数字，遍历素数数组p，(p[i]%10==g)+(p[i]/10%10==s)+(p[i]/100%10==ba)+(p[i]/1000==qi))==3就能保证只有一位发生变化，其中g,s,ba,qi分别为a的个，十，百，千位。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;using namespace std;int a,b,minn&#x3D;1000000;int p[1062];int pp[1062];void bfs(int k)&#123; pp[k]&#x3D;1; queue&lt;int&gt; q; q.push(k); while(!q.empty()) &#123; int w&#x3D;q.front(); q.pop(); int g,s,ba,qi; g&#x3D;p[w]%10; s&#x3D;p[w]&#x2F;10%10; ba&#x3D;p[w]&#x2F;100%10; qi&#x3D;p[w]&#x2F;1000; for(int i&#x3D;1;i&lt;1062;i++) &#123; if(((p[i]%10&#x3D;&#x3D;g)+(p[i]&#x2F;10%10&#x3D;&#x3D;s)+(p[i]&#x2F;100%10&#x3D;&#x3D;ba)+(p[i]&#x2F;1000&#x3D;&#x3D;qi))&#x3D;&#x3D;3&amp;&amp;pp[i]&#x3D;&#x3D;0) &#123; pp[i]&#x3D;pp[w]+1; if(p[i]&#x3D;&#x3D;b) &#123; cout&lt;&lt;pp[i]-1&lt;&lt;endl; return; &#125; q.push(i); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int qq&#x3D;0,j; for(int i&#x3D;1000;i&lt;&#x3D;9999;i++) &#123; int sq&#x3D;sqrt(i); for(j&#x3D;2;j&lt;&#x3D;sq;j++) &#123; if(i%j&#x3D;&#x3D;0) break; &#125; if(j&lt;&#x3D;sq) continue; qq++; &#x2F;&#x2F;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl; p[qq]&#x3D;i; &#125; int n; cin&gt;&gt;n; while(n--) &#123; int r; cin&gt;&gt;a&gt;&gt;b; if(a&#x3D;&#x3D;b) &#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; memset(pp,0,sizeof(pp)); for(r&#x3D;1;r&lt;1062;r++) if(p[r]&#x3D;&#x3D;a) &#123; break; &#125; pp[r]&#x3D;1; bfs(r); &#x2F;&#x2F; cout&lt;&lt;minn-1&lt;&lt;endl; &#x2F;&#x2F;cout&lt;&lt;1&#x3D;&#x3D;1+ &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"标志数组妙用","slug":"标志数组妙用","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/"},{"name":"素数打表","slug":"素数打表","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A0%E6%95%B0%E6%89%93%E8%A1%A8/"},{"name":"逻辑相加妙用","slug":"逻辑相加妙用","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E7%9B%B8%E5%8A%A0%E5%A6%99%E7%94%A8/"}]},{"title":"POJ-1426","slug":"POJ-1426","date":"2020-02-21T10:20:08.000Z","updated":"2020-02-21T11:38:04.800Z","comments":true,"path":"2020/02/21/POJ-1426/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/21/POJ-1426/","excerpt":"代码是从网上抄下来的，我之前想过这个思路，但是被我否决了，否决的原因有两点，1.无法判断从小到大的每一种01组合对n取余是不是0？2.题目中说解的长度不超过100位，我无法判断解的最短长度的最大值。虽然AC了，但是网上的答案还是没有解决第二个问题，不知道他们是怎么确定答案在32位数以内","text":"代码是从网上抄下来的，我之前想过这个思路，但是被我否决了，否决的原因有两点，1.无法判断从小到大的每一种01组合对n取余是不是0？2.题目中说解的长度不超过100位，我无法判断解的最短长度的最大值。虽然AC了，但是网上的答案还是没有解决第二个问题，不知道他们是怎么确定答案在32位数以内 题目寻找多重 时限： 1000MS 内存限制： 10000K 提交总数： 56332 接受： 23292 特别法官 描述 给定正整数n，编写一个程序以找出n的非零倍数m，其十进制表示形式仅包含数字0和1。您可以假定n不大于200，并且对应的m包含不超过100十进制数字。 输入值 输入文件可能包含多个测试用例。每行包含一个值n（1 &lt;= n &lt;= 200）。包含零的行将终止输入。 输出量 对于输入中n的每个值，打印一行包含m的对应值。m的十进制表示形式不能超过100个数字。如果给定值n有多个解，则其中任何一个都是可接受的。 样本输入 123426190 样本输出 12310100100100100100100111111111111111111 算法具体步骤就是二进制枚举，将一个整形的二进制表示十进制,注意是表示不是转换，例如11(二进制)=3(十进制)，这是转换，3(十进制)=11(二进制)表示为11(十进制)，这是表示。一个整形表示的范围为0(2^31-1)，也就是二进制000,001,010,011,100111(这只是3位，应该是31位)，这些01串正是从小到大的遍历。","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"二进制","slug":"ACM/二进制","permalink":"https://donghuangzhong.github.io/categories/ACM/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}],"tags":[{"name":"同余定理","slug":"同余定理","permalink":"https://donghuangzhong.github.io/tags/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/"},{"name":"二进制表示十进制","slug":"二进制表示十进制","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%8D%81%E8%BF%9B%E5%88%B6/"}]},{"title":"POJ-3279","slug":"POJ-3279","date":"2020-02-20T10:30:53.000Z","updated":"2020-02-20T11:00:47.764Z","comments":true,"path":"2020/02/20/POJ-3279/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/20/POJ-3279/","excerpt":"本来想DFS的，但是复杂度太高了。第一次遇到这种开关类问题，关键就是要找唯一点，比如本题，要翻转一个色块有5种选择，砍掉四个，只留下最下面的一个选择。这样如果此色块为黑色，则下面的色块必须翻转；为白则必须不翻转","text":"本来想DFS的，但是复杂度太高了。第一次遇到这种开关类问题，关键就是要找唯一点，比如本题，要翻转一个色块有5种选择，砍掉四个，只留下最下面的一个选择。这样如果此色块为黑色，则下面的色块必须翻转；为白则必须不翻转 题目翻板 时限： 2000MS 内存限制： 65536K 提交总数： 25631 接受的： 9075 描述 农夫约翰知道，一头知识上满意的母牛是一头快乐的母牛，它将提供更多的牛奶。他已安排一个聪明的活动中，他们操纵奶牛中号 × Ñ栅格（1≤ 中号 ≤15; 1≤ ñ ≤15）正方形瓷砖，其中的每一个着色为黑色的一侧和白色的另一侧。 就像人们猜测的那样，当翻转单个白色图块时，它会变为黑色。翻转单个黑色图块时，它将变为白色。母牛在翻转砖块时会得到奖励，因此每块砖块的白色侧面都朝上。但是，母牛的蹄子相当大，当他们尝试翻转特定的瓷砖时，它们也会翻转所有相邻的瓷砖（与翻转的瓷砖共享完整边缘的瓷砖）。由于翻转很累，奶牛希望尽量减少翻转次数。 帮助奶牛确定所需的最小翻转次数，以及达到该最小翻转的位置。如果有多种方法可以以最小的翻转次数来完成任务，则当将其视为字符串时，以输出中词典顺序最少的方式返回。如果无法完成任务，请用“ IMPOSSIBLE”一词打印一行。 输入值 第1行：两个以空格分隔的整数：M和N第2行。M +1：第i +1行描述了网格第i行的颜色（从左到右），其中N个以空格分隔的整数，黑色和1为黑色。 0代表白色 输出量 第1 .. M行：每行包含N个以空格分隔的整数，每个整数指定翻转该特定位置的次数。 样本输入 123454 41 0 0 10 1 1 00 1 1 01 0 0 1 样本输出 12340 0 0 01 0 0 11 0 0 10 0 0 0 算法该游戏不受步骤的影响，没有翻转的先后顺序，因为某一个色块被翻转的总和跟翻转的顺序没有关系，总和不变，颜色就不变，所以对于一个色块翻转两次没有意义。假设现在已经知道最优解的第一行要翻转哪几个色块(指的是中心色块，不是周围被翻转的四个)，那么将这几个色块根据规则翻转后，对于第一行的黑色块，它下面的色块(第二行)必须被翻转，因为对于这个黑色块而言，能够改变它颜色的邻居四个中只有下面的能翻转(上面没有色块，左右色块不能翻转，因为你已经将最优解中第一行的的翻转色块翻转完了)；同理第一行白色块下面必须不能翻转，这样就能确定第二行色块的翻转情况，将第二行翻转后，又回到第一行最优解翻转后的情况….。重复这个过程。所以如果知道第一行的翻转情况，就能知道整体的翻转情况。现在的问题是我们不知道最优解第一行的翻转情况，那么就需要枚举了，枚举第一行的翻转情况(最多2^n)，取最优即可，需要注意的是如果最后一行翻转后还有黑色，则此种第一行的分布不能得出解，因为最后一行没有能改变的选择了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;using namespace std;int c,k,sum,minn;bool qipan[16][16],zturn[16][16],turn[16][16]; int lujing[5][2]&#x3D;&#123;0,0,0,1,0,-1,1,0,-1,0&#125;;bool getcolor(int a,int b)&#123; int turn_sum&#x3D;qipan[a][b]; for(int i&#x3D;0;i&lt;5;i++) &#123; int x&#x3D;a+lujing[i][0]; int y&#x3D;b+lujing[i][1]; if(x&gt;&#x3D;0&amp;&amp;x&lt;c&amp;&amp;y&gt;&#x3D;0&amp;&amp;y&lt;k) turn_sum+&#x3D;turn[x][y]; &#125; return turn_sum%2;&#125;void cal()&#123; for(int q&#x3D;1;q&lt;c;q++) for(int w&#x3D;0;w&lt;k;w++) &#123; if(getcolor(q-1,w)) &#123; turn[q][w]&#x3D;1; sum++; if(sum&gt;&#x3D;minn) return; &#125; &#125; for(int e&#x3D;0;e&lt;k;e++) if(getcolor(c-1,e)) return ; if(sum&lt;minn) &#123; minn&#x3D;sum; memcpy(zturn,turn,sizeof(turn)); &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;c&gt;&gt;k) &#123; for(int i&#x3D;0;i&lt;c;i++) for(int j&#x3D;0;j&lt;k;j++) cin&gt;&gt;qipan[i][j]; minn&#x3D;0x3f3f3f3f; for(int i&#x3D;0;i&lt;1&lt;&lt;k;i++) &#123; sum&#x3D;0; memset(turn,0,sizeof(turn)); for(int j&#x3D;0;j&lt;k;j++) &#123; turn[0][k-1-j]&#x3D;(i&gt;&gt;j)&amp;1; if(turn[0][k-1-j]&#x3D;&#x3D;1) sum++; &#125; cal(); &#125; if(minn&#x3D;&#x3D;0x3f3f3f3f) cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl; else &#123; for(int i&#x3D;0;i&lt;c;i++) &#123; for(int j&#x3D;0;j&lt;k;j++) cout&lt;&lt;zturn[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; &#125; &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"开关","slug":"ACM/开关","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%BC%80%E5%85%B3/"}],"tags":[{"name":"翻转游戏","slug":"翻转游戏","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E6%B8%B8%E6%88%8F/"}]},{"title":"HDU-2717 POJ-3278","slug":"HDU-2717-POJ-3278","date":"2020-02-19T10:36:00.000Z","updated":"2020-02-20T01:23:37.830Z","comments":true,"path":"2020/02/19/HDU-2717-POJ-3278/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/19/HDU-2717-POJ-3278/","excerpt":"太坑了，题中没有标明有多个测试用例，如果只输入一次，POJ可以通过，HDU必需用while(cin&gt;&gt;n&gt;&gt;k),并且POJ有一个测试用例是起点和终点一起，所以bfs的开始就要判断起点和终点是否相同，每一次入队前都要判断起点和终点是否相同，如果为了省代码出队判断是否为终点，牺牲了太多时间(多处理了太多点)，我非常不推荐","text":"太坑了，题中没有标明有多个测试用例，如果只输入一次，POJ可以通过，HDU必需用while(cin&gt;&gt;n&gt;&gt;k),并且POJ有一个测试用例是起点和终点一起，所以bfs的开始就要判断起点和终点是否相同，每一次入队前都要判断起点和终点是否相同，如果为了省代码出队判断是否为终点，牺牲了太多时间(多处理了太多点)，我非常不推荐 题目赶上那头牛\\时间限制：5000/2000 MS（Java /其他）内存限制：32768/32768 K（Java /其他）总计提交：28511已接受提交：7809** 问题描述 农夫约翰已被告知一头逃犯的位置，并希望立即抓住她。他从数字线上的点N（0≤N≤100,000）开始，而母牛在同一数字线上的点K（0≤K≤100,000）。农夫约翰有两种运输方式：步行和传送。 *行走：FJ可以在一分钟内从任意点X移至点X-1或X + 1。*传送：FJ可以在一分钟内从任意点X移至点2×X。 如果没有意识到它的追捕能力的母牛完全没有动弹，那么农夫约翰要花多长时间？ 输入值 第1行：两个以空格分隔的整数：N和K 输出量 第1行：最短的时间（以分钟为单位），农夫John赶上了逃亡的母牛。 样本输入 15 17 样本输出 1234暗示农夫约翰到达逃亡者牛的最快方法是沿着以下路径移动：5-10-9-18-17，这需要4分钟。 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;using namespace std;int n,k;int zhou[100001];int a,b;bool judge(int w)&#123; if(w&gt;&#x3D;0&amp;&amp;w&lt;&#x3D;100000&amp;&amp;zhou[w]&#x3D;&#x3D;0) return 1; return 0;&#125;void bfs()&#123; if(n&#x3D;&#x3D;k)&#123; cout&lt;&lt;0&lt;&lt;endl; return ; &#125; memset(zhou,0,sizeof(zhou)); zhou[n]&#x3D;1; queue&lt;int&gt; q; q.push(n); while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;3;i++) &#123; if(i&#x3D;&#x3D;0) b&#x3D;a-1; else if(i&#x3D;&#x3D;1) b&#x3D;a+1; else b&#x3D;2*a; &#x2F;&#x2F;if(b&lt;0||b&gt;100000) continue; &#x2F;&#x2F; if(zhou[b]&#x3D;&#x3D;0) if(judge(b)) &#123; zhou[b]&#x3D;zhou[a]+1; if(b&#x3D;&#x3D;k) &#123; cout&lt;&lt;zhou[b]-1&lt;&lt;endl; return ; &#125; q.push(b); &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;n&gt;&gt;k) &#123; if(k&lt;&#x3D;n) cout&lt;&lt;n-k&lt;&lt;endl; else bfs(); &#125; return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"标志数组妙用","slug":"标志数组妙用","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/"}]},{"title":"POJ-2251","slug":"POJ-2251","date":"2020-02-19T04:08:39.000Z","updated":"2020-02-19T04:24:48.079Z","comments":true,"path":"2020/02/19/POJ-2251/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/19/POJ-2251/","excerpt":"无论是BFS还是DFS都需要一个标志数组来防止无意义的重复路径访问，并不是只能访问一次，有些迷宫会有加血或者加时间的设定。但有些仅仅是简单的只能访问一次，这样只能用到数组的01两个状态，如果有别的属性值(例如时间等)也可以放到标志数组中(前提是不能有乘除运算)，但是如果这样设定，起点初始化为被访问过，置1，这样有些时间就整体提升了1，所以在最后要减去1。","text":"无论是BFS还是DFS都需要一个标志数组来防止无意义的重复路径访问，并不是只能访问一次，有些迷宫会有加血或者加时间的设定。但有些仅仅是简单的只能访问一次，这样只能用到数组的01两个状态，如果有别的属性值(例如时间等)也可以放到标志数组中(前提是不能有乘除运算)，但是如果这样设定，起点初始化为被访问过，置1，这样有些时间就整体提升了1，所以在最后要减去1。 题目Dungeon Master Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 68475 Accepted: 24773 Description You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. Is an escape possible? If yes, how long will it take? Input The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).L is the number of levels making up the dungeon.R and C are the number of rows and columns making up the plan of each level.Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C. Output Each maze generates one line of output. If it is possible to reach the exit, print a line of the form Escaped in x minute(s). where x is replaced by the shortest time it takes to escape.If it is not possible to escape, print the line Trapped! Sample Input 123456789101112131415161718192021223 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0 Sample Output 12Escaped in 11 minute(s).Trapped! 算法这个题也可以不将起点置1，这样起点就可以访问两次(访问第二次后就不能再次访问)，对本题没有什么影响，因为本题的起点终点一定不会重合，但我实在不提倡这种做法 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;queue&gt;using namespace std;char migong[31][31][31];int visit[31][31][31];int l,r,c;struct Point&#123; int x,y,z;&#125; qi,zhong,a,b;int lujing[6][3]&#x3D;&#123;1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1&#125;;void bfs()&#123; queue&lt;Point&gt; q; a&#x3D;qi; if(a.x&#x3D;&#x3D;zhong.x&amp;&amp;a.y&#x3D;&#x3D;zhong.y&amp;&amp;a.z&#x3D;&#x3D;zhong.z) &#123;cout&lt;&lt;&quot;Escaped in 0 minute(s).&quot;&lt;&lt;endl;return ; &#125; memset(visit,0,sizeof(visit)); visit[a.x][a.y][a.z]&#x3D;1; q.push(a); while(!q.empty()) &#123; a&#x3D;q.front(); q.pop(); for(int i&#x3D;0;i&lt;6;i++) &#123; b.x&#x3D;a.x+lujing[i][0]; b.y&#x3D;a.y+lujing[i][1]; b.z&#x3D;a.z+lujing[i][2]; if(b.x&gt;&#x3D;1&amp;&amp;b.x&lt;&#x3D;l&amp;&amp;b.y&gt;&#x3D;1&amp;&amp;b.y&lt;&#x3D;r&amp;&amp;b.z&gt;&#x3D;1&amp;&amp;b.z&lt;&#x3D;c&amp;&amp;migong[b.x][b.y][b.z]!&#x3D;&#39;#&#39;&amp;&amp;visit[b.x][b.y][b.z]&#x3D;&#x3D;0) &#123; visit[b.x][b.y][b.z]&#x3D;visit[a.x][a.y][a.z]+1; if(b.x&#x3D;&#x3D;zhong.x&amp;&amp;b.y&#x3D;&#x3D;zhong.y&amp;&amp;b.z&#x3D;&#x3D;zhong.z)&#123; cout&lt;&lt;&quot;Escaped in &quot;&lt;&lt;visit[b.x][b.y][b.z]-1&lt;&lt;&quot; minute(s).&quot;&lt;&lt;endl;return ; &#125; q.push(b); &#125; &#125;​ &#125; cout&lt;&lt;&quot;Trapped!&quot;&lt;&lt;endl;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;l&gt;&gt;r&gt;&gt;c&amp;&amp;l&amp;&amp;r&amp;&amp;c) &#123; for(int i&#x3D;1;i&lt;&#x3D;l;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;r;j++) &#123; for(int k&#x3D;1;k&lt;&#x3D;c;k++) &#123; cin&gt;&gt;migong[i][j][k]; if(migong[i][j][k]&#x3D;&#x3D;&#39;E&#39;)&#123; zhong.x&#x3D;i;zhong.y&#x3D;j;zhong.z&#x3D;k; &#125; if(migong[i][j][k]&#x3D;&#x3D;&#39;S&#39;)&#123; qi.x&#x3D;i;qi.y&#x3D;j;qi.z&#x3D;k; &#125;​ &#125; &#125; &#125; bfs(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"}],"tags":[{"name":"妙用标志数组","slug":"妙用标志数组","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"}]},{"title":"POJ-1312","slug":"POJ-1312","date":"2020-02-18T08:19:28.000Z","updated":"2020-02-18T08:37:19.056Z","comments":true,"path":"2020/02/18/POJ-1312/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/18/POJ-1312/","excerpt":"此问题只要求不在同一行和同一列，新奇的标志数组，难点：每次递归范围的确定","text":"此问题只要求不在同一行和同一列，新奇的标志数组，难点：每次递归范围的确定 题目棋盘问题 Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 94015 Accepted: 42955 Description 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 Input 输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 Output 对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 Sample Input 1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output 1221 算法棋盘上不一定放多少棋子，不一定每一行都有棋子(相对于全排列)，所以每次递归的范围为上一个棋子的下一行开始一直到棋盘的最后，因此行一定不重复，所以标志数组只需表示某列有没有棋子，即lie[i]=0。同时需要用到上一个棋子的行数，可以选择保留整个点(这样可以输出所有可能的情况)，也可以选择只保留上一个点的x坐标(这样不方便输出每一种情况) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;char qipan[9][9];bool lie[9];int n,sum,k;struct Point&#123; int x; int y;&#125; point[9];bool judge(int x,int y,int n)&#123; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; if(point[i].x&#x3D;&#x3D;x||point[i].y&#x3D;&#x3D;y) return 0; &#125; return 1;&#125;void dfs(int nn)&#123; if(nn&#x3D;&#x3D;k+1) &#123; sum++; return ; &#125; for(int i&#x3D;point[nn-1].x+1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++) &#123; if(qipan[i][j]&#x3D;&#x3D;&#39;#&#39;&amp;&amp;lie[j]&#x3D;&#x3D;0&amp;&amp;judge(i,j,nn-1)) &#123; lie[j]&#x3D;1; point[nn].x&#x3D;i; point[nn].y&#x3D;j; dfs(nn+1); lie[j]&#x3D;0; &#125; &#125; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); while(cin&gt;&gt;n&gt;&gt;k&amp;&amp;n!&#x3D;-1&amp;&amp;k!&#x3D;-1) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;n;j++) cin&gt;&gt;qipan[i][j]; memset(lie,0,sizeof(lie)); memset(point,0,sizeof(point)); sum&#x3D;0; dfs(1); cout&lt;&lt;sum&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DFS","slug":"ACM/DFS","permalink":"https://donghuangzhong.github.io/categories/ACM/DFS/"}],"tags":[{"name":"八皇后简化版","slug":"八皇后简化版","permalink":"https://donghuangzhong.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%80%E5%8C%96%E7%89%88/"},{"name":"特殊标志数组","slug":"特殊标志数组","permalink":"https://donghuangzhong.github.io/tags/%E7%89%B9%E6%AE%8A%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"},{"name":"递归范围","slug":"递归范围","permalink":"https://donghuangzhong.github.io/tags/%E9%80%92%E5%BD%92%E8%8C%83%E5%9B%B4/"}]},{"title":"HDU-1016","slug":"HDU-1016","date":"2020-02-17T10:12:58.000Z","updated":"2020-02-17T10:54:37.869Z","comments":true,"path":"2020/02/17/HDU-1016/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/HDU-1016/","excerpt":"典型的DFS数据类问题，介绍一个快速打表素数的方法","text":"典型的DFS数据类问题，介绍一个快速打表素数的方法 题目素环问题\\时间限制：4000/2000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）提交总数：82346接受提交：33935** 问题描述 圆环由n个圆组成，如图所示。将自然数1、2，…，n分别放入每个圆，并且两个相邻圆中的数字总和应为质数。 注意：第一个圆的数目应始终为1。 输入值 n（0 &lt;n &lt;20）。 输出量 输出格式如下所示。每一行代表环中从顺时针和逆时针1开始的一系列圆圈编号。数字顺序必须满足上述要求。按字典顺序打印解决方案。 您将编写一个完成上述过程的程序。 在每种情况下都打印空白行。 样本输入 1268 样本输出 123456789情况1：1 4 3 2 5 61 6 5 2 3 4情况2：1 2 3 8 5 6 7 41 2 5 8 3 4 7 61 4 7 6 5 8 3 21 6 7 4 3 8 5 2 算法快速打表素数(0~n)利用memset置0(对字节操作，不能置1的)，0代表是素数，如果i是素数，则2i~ni都不是素数，只要将素数的倍数们都标记为非素数即可,需要注意的是它们的表示与我们通常的认知相反，用法:!sushu[i] 12345bool sushu[45]&#x3D;&#123;0&#125;;for(int i&#x3D;2;i&lt;8;i++)&#x2F;&#x2F;此处的8&#x3D;sqrt(45)+1 if(!sushu[i]) for(int j&#x3D;i*i;j&lt;45;j+&#x3D;i) sushu[j]&#x3D;1; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;int n;int flag[21];int b[21];int sum;bool sushu[45]&#x3D;&#123;0&#125;;bool judge(int a)&#123; return !sushu[a];&#125;void dfs2(int q)&#123; if(q&#x3D;&#x3D;1) &#123; flag[1]&#x3D;1; b[1]&#x3D;1; dfs2(2); return ; &#125; if(q&#x3D;&#x3D;n+1) &#123; if(judge(b[q-1]+1)) &#123; sum++; for(int k&#x3D;1;k&lt;&#x3D;n;k++) &#123; cout&lt;&lt;b[k]; if(k!&#x3D;n) cout&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(flag[i]&#x3D;&#x3D;0&amp;&amp;judge(b[q-1]+i)) &#123; flag[i]&#x3D;1; b[q]&#x3D;i; dfs2(q+1); flag[i]&#x3D;0; &#125; &#125; &#125; int main()&#123; for(int i&#x3D;2;i&lt;8;i++) if(!sushu[i]) for(int j&#x3D;i*i;j&lt;45;j+&#x3D;i) sushu[j]&#x3D;1; int ca&#x3D;1; while(cin&gt;&gt;n) &#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;ca++&lt;&lt;&quot;:&quot;&lt;&lt;endl; sum&#x3D;0; memset(flag,0,sizeof(flag)); dfs2(1); &#x2F;&#x2F;cout&lt;&lt;&quot;种数&quot;&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;endl; &#125;&#125; &#x2F;*void dfs(int nn,int ln)&#123; if(nn&#x3D;&#x3D;1) &#123; b[nn]&#x3D;1; flag[1]&#x3D;1; dfs(2,1); return ; &#125; if(nn&#x3D;&#x3D;n+1) &#123; if(judge(1+ln)) &#123; sum++; for(int k&#x3D;1;k&lt;&#x3D;n;k++) &#123; cout&lt;&lt;b[k]; if(k!&#x3D;n) cout&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return ; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(flag[i]&#x3D;&#x3D;0&amp;&amp;judge(ln+i)) &#123; flag[i]&#x3D;1; b[nn]&#x3D;i; dfs(nn+1,i); flag[i]&#x3D;0; &#125; &#125;&#125;*&#x2F; presentation error输出的最后一个数字后面不应该有空格","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DFS","slug":"ACM/DFS","permalink":"https://donghuangzhong.github.io/categories/ACM/DFS/"}],"tags":[{"name":"素数环","slug":"素数环","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A0%E6%95%B0%E7%8E%AF/"},{"name":"回溯","slug":"回溯","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"PTA-L1-006","slug":"PTA-L1-006","date":"2020-02-17T07:00:35.000Z","updated":"2020-02-17T10:12:40.142Z","comments":true,"path":"2020/02/17/PTA-L1-006/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/PTA-L1-006/","excerpt":"给一个数，求这个数的最长连续因数","text":"给一个数，求这个数的最长连续因数 题目L1-006 连续因子 (20分) 一个正整数 N 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数 N，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。 输入格式：输入在一行中给出一个正整数 N（1&lt;N&lt;231）。 输出格式：首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按 因子1*因子2*……*因子k 的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。 输入样例：1630 输出样例：1235*6*7 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main() &#123; int N, temp; int count &#x3D; 0, maxcount &#x3D; 0, start &#x3D; 0; cin &gt;&gt; N; for (int i &#x3D; 2; i &lt;&#x3D; sqrt(N) ; i++) &#123; temp &#x3D; N; count &#x3D; 0; int j &#x3D; i; while (temp%j&#x3D;&#x3D;0) &#123; temp &#x2F;&#x3D; j++; count++; &#125; if (count &gt; maxcount) &#123; maxcount &#x3D; count; start &#x3D; i; &#125; &#125; if (maxcount) &#123; cout &lt;&lt; maxcount &lt;&lt; endl; for (int i &#x3D; start; i &lt; start+maxcount; i++) &#123; if(i!&#x3D;start)cout&lt;&lt;&quot;*&quot;; cout&lt;&lt;i; &#125; &#125; else cout &lt;&lt;&quot;1&quot;&lt;&lt;endl&lt;&lt; N; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"因数","slug":"ACM/因数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%9B%A0%E6%95%B0/"}],"tags":[{"name":"最长连续因数","slug":"最长连续因数","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%9B%A0%E6%95%B0/"},{"name":"按序列累除","slug":"按序列累除","permalink":"https://donghuangzhong.github.io/tags/%E6%8C%89%E5%BA%8F%E5%88%97%E7%B4%AF%E9%99%A4/"}]},{"title":"pintia-L1-005","slug":"pintia-L1-005","date":"2020-02-17T02:03:38.000Z","updated":"2020-02-17T02:07:56.034Z","comments":true,"path":"2020/02/17/pintia-L1-005/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/pintia-L1-005/","excerpt":"简单字典问题","text":"简单字典问题 题目L1-005 考试座位号 (15分) 每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。 输入格式：输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 16 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。 考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。 输出格式：对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。 输入样例：123456743310120150912233 2 43310120150912119 4 13310120150912126 1 33310120150912002 3 223 4 输出样例：123310120150912002 23310120150912119 1 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;struct student&#123; string xuehao; int shiji; int kszwh;&#125; st[1001];int num[1001];int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; for(int i&#x3D;0;i&lt;n;i++) cin&gt;&gt;st[i].xuehao&gt;&gt;st[i].shiji&gt;&gt;st[i].kszwh; int nn; cin&gt;&gt;nn; for(int i&#x3D;0;i&lt;n;i++) &#123; int nnn; cin&gt;&gt;nnn; for(int j&#x3D;0;j&lt;n;j++) &#123; if(st[j].shiji&#x3D;&#x3D;nnn) &#123; num[i]&#x3D;j; break; &#125; &#125; &#125; for(int i&#x3D;0;i&lt;nn;i++) cout&lt;&lt;st[num[i]].xuehao&lt;&lt;&quot; &quot;&lt;&lt;st[num[i]].kszwh&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"map","slug":"map","permalink":"https://donghuangzhong.github.io/tags/map/"},{"name":"字典","slug":"字典","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E5%85%B8/"}]},{"title":"pintia-L1-004","slug":"pintia-L1-004","date":"2020-02-17T01:47:27.000Z","updated":"2020-02-17T02:06:09.565Z","comments":true,"path":"2020/02/17/pintia-L1-004/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/pintia-L1-004/","excerpt":"给华氏温度求摄氏温度","text":"给华氏温度求摄氏温度 题目L1-004 计算摄氏温度 (5分) 给定一个华氏温度F，本题要求编写程序，计算对应的摄氏温度C。计算公式：C=5×(F−32)/9。题目保证输入与输出均在整型范围内。 输入格式:输入在一行中给出一个华氏温度。 输出格式:在一行中按照格式“Celsius = C”输出对应的摄氏温度C的整数值。 输入样例:1150 输出样例:1Celsius &#x3D; 65 代码1234567891011#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;&quot;Celsius &#x3D; &quot;&lt;&lt;(int)(5*(n-32)&#x2F;9)&lt;&lt;endl; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"摄氏华氏温度转换","slug":"摄氏华氏温度转换","permalink":"https://donghuangzhong.github.io/tags/%E6%91%84%E6%B0%8F%E5%8D%8E%E6%B0%8F%E6%B8%A9%E5%BA%A6%E8%BD%AC%E6%8D%A2/"}]},{"title":"pintia-L1-003","slug":"pintia-L1-003","date":"2020-02-17T00:28:10.000Z","updated":"2020-02-17T02:06:01.928Z","comments":true,"path":"2020/02/17/pintia-L1-003/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/pintia-L1-003/","excerpt":"统计字数的个数","text":"统计字数的个数 题目L1-003 个位数统计 (15分) 给定一个 k 位整数 N=dk−110k−1+⋯+d1101+d0 (0≤di*≤9, *i=0,⋯,k−1, d*k−1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 *N=100311，则有 2 个 0，3 个 1，和 1 个 3。 输入格式：每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。 输出格式：对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。 输入样例：1100311 输出样例：1230:21:33:1 代码1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; char ch[1001];int a[10]&#x3D;&#123;0&#125;;cin&gt;&gt;ch;int lenth&#x3D;strlen(ch);while(lenth--)&#123; for(int i&#x3D;0;i&lt;&#x3D;9;i++) if((ch[lenth]-&#39;0&#39;)&#x3D;&#x3D;i) a[i]++;&#125;for(int i&#x3D;0;i&lt;&#x3D;9;i++)&#123; if(a[i]) cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;a[i]&lt;&lt;endl;&#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"统计数字的个数","slug":"统计数字的个数","permalink":"https://donghuangzhong.github.io/tags/%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%AA%E6%95%B0/"}]},{"title":"pintia-L1-002","slug":"pintia-L1-002","date":"2020-02-17T00:27:46.000Z","updated":"2020-02-17T02:04:26.454Z","comments":true,"path":"2020/02/17/pintia-L1-002/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/17/pintia-L1-002/","excerpt":"公式求n,两个循环打印","text":"公式求n,两个循环打印 题目L1-002 打印沙漏 (20分) 本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 12345***** *** * ******** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式:输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。 输出格式:首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。 输入样例:119 * 输出样例:123456***** *** * ********2 代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n; char ch; cin&gt;&gt;n&gt;&gt;ch; int nn&#x3D;(int)sqrt((n+1)&#x2F;2); for(int i&#x3D;nn;i&gt;&#x3D;1;i--) &#123; int k&#x3D;nn-i; while(k--) cout&lt;&lt;&quot; &quot;; k&#x3D;2*i-1; while(k--) cout&lt;&lt;ch; cout&lt;&lt;endl; &#125; for(int i&#x3D;2;i&lt;&#x3D;nn;i++) &#123; int k&#x3D;nn-i; while(k--) cout&lt;&lt;&quot; &quot;; k&#x3D;2*i-1; while(k--) cout&lt;&lt;ch; cout&lt;&lt;endl; &#125; int c&#x3D;n-2*nn*nn+1; &#x2F;&#x2F;if(c) cout&lt;&lt;c;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"沙漏","slug":"沙漏","permalink":"https://donghuangzhong.github.io/tags/%E6%B2%99%E6%BC%8F/"},{"name":"等差数列","slug":"等差数列","permalink":"https://donghuangzhong.github.io/tags/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/"}]},{"title":"HDU-1008","slug":"HDU-1008","date":"2020-02-16T09:46:41.000Z","updated":"2020-02-16T10:00:36.521Z","comments":true,"path":"2020/02/16/HDU-1008/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/16/HDU-1008/","excerpt":"给出楼层，计算电梯的运行时间","text":"给出楼层，计算电梯的运行时间 题目电梯\\时间限制：2000/1000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）总提交数量：100638接受提交数量：54525** 问题描述 我们城市最高的建筑物只有一部电梯。请求列表由N个正数组成。数字按指定顺序表示电梯将停在的楼层。将电梯上移一层需要6秒钟，而将一层下移则需要4秒钟。电梯将在每个站点停留5秒钟。 对于给定的请求列表，您将计算完成列表上的请求所花费的总时间。电梯在开始时位于0楼，并且在满足请求后不必返回一楼。 输入值 有多个测试用例。每个案例包含一个正整数N，后跟N个正数。输入中的所有数字均小于100。N = 0的测试用例表示输入结束。该测试用例将不被处理。 输出量 将每个测试用例的总时间打印在一行上。 样本输入 1231 23 2 3 10 样本输出 121741 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n,floor,lfloor; while(cin&gt;&gt;n&amp;&amp;n) &#123; int time&#x3D;0; lfloor&#x3D;0; while(n--) &#123; cin&gt;&gt;floor; if(floor&gt;lfloor) time+&#x3D;6*(floor-lfloor); else time+&#x3D;4*(lfloor-floor); lfloor&#x3D;floor; time+&#x3D;5; &#125; cout&lt;&lt;time&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"电梯","slug":"电梯","permalink":"https://donghuangzhong.github.io/tags/%E7%94%B5%E6%A2%AF/"}]},{"title":"dotcpp-1004","slug":"dotcpp-1004","date":"2020-02-16T07:59:20.000Z","updated":"2020-02-16T08:03:02.178Z","comments":true,"path":"2020/02/16/dotcpp-1004/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/16/dotcpp-1004/","excerpt":"第一年一头成年母牛，每年生一小牛，小牛四年后才成年，求第N年的牛的个数","text":"第一年一头成年母牛，每年生一小牛，小牛四年后才成年，求第N年的牛的个数 题目题目描述 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ 输入 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 输出 对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。 样例输入 12342450 样例输出 123246 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; &#x2F;&#x2F;freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); int n; int a[56]; a[1]&#x3D;1; a[2]&#x3D;2; a[3]&#x3D;3; a[4]&#x3D;4; for(int i&#x3D;5;i&lt;56;i++) &#123; a[i]&#x3D;a[i-1]+a[i-3]; &#125; while(cin&gt;&gt;n&amp;&amp;n) &#123; cout&lt;&lt;a[n]&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://donghuangzhong.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"},{"name":"兔子问题","slug":"兔子问题","permalink":"https://donghuangzhong.github.io/tags/%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98/"}]},{"title":"HDU-1006","slug":"HDU-1006","date":"2020-02-14T03:10:09.000Z","updated":"2020-02-14T04:00:58.166Z","comments":true,"path":"2020/02/14/HDU-1006/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/14/HDU-1006/","excerpt":"一般我们的思维都是先找第一段符合题目的解，然后找第二段第三段，从而理解题目和找出规律。但对于有些题目，规律甚至第一段的解都非常难找，但如果我们知道解位于一个临界集合中，我们就可以不用去找这个解，转而寻找这个临界集合(因为寻找解非常复杂，寻找临界集合却比较容易)，前提是可以把解从临界集合中分离出来(一般是临界集合的最值)。这样我们就可以避开寻找解这个非常复杂的过程，简化题目。","text":"一般我们的思维都是先找第一段符合题目的解，然后找第二段第三段，从而理解题目和找出规律。但对于有些题目，规律甚至第一段的解都非常难找，但如果我们知道解位于一个临界集合中，我们就可以不用去找这个解，转而寻找这个临界集合(因为寻找解非常复杂，寻找临界集合却比较容易)，前提是可以把解从临界集合中分离出来(一般是临界集合的最值)。这样我们就可以避开寻找解这个非常复杂的过程，简化题目。 题目滴答和滴答\\时间限制：2000/1000 MS（Java /其他）内存限制：65536/32768 K（Java /其他）提交总计：26354接受提交：7208** 问题描述 时钟的三只指针每秒旋转一次，并且每天相遇很多次。最后，他们对此感到无聊，并且每个人都希望远离其他两个人。如果一只手与其余任何一只手至少有D度，那它就是快乐的。您要计算一天中所有双手都开心的时间。 输入值 输入包含许多测试用例。他们每个人都有一条单行，其实数D在0和120之间（含0和120）。输入以-1的D终止。 输出量 对于每个D，用一行打印一天中所有手牌都高兴的时间百分比，精确到小数点后3位。 样本输入 1234012090-1 样本输出 123100.0000.0006.251 算法为什么暴力遍历每一秒不行因为本题对精度有非常高的要求，这个表应该是静音表(扫秒表)，不会发出滴答滴答的声音，并且要用到角速度，因为只有这样才能满足精度要求 分析本题如果仔细思考求解的话，整个过程是非常复杂的，因为你不知道每一小段开始时究竟是那两个针到达临界值。既然这样那就求临界集合，将分针和时针从重合到再次重合看做一个大周期，将分针和表针从重合到再次重合看做一个周期，将时针和秒针从重合到再次重合看做一个小周期。一共有三个针，C32共有三种可能，也就是说每一小段的开始时刻必然在临界开始集合(分-时=n,秒-时=n,秒-分=n)中，并且是临界开始集合的最大值，而每一小段的结束必然存在于临界结束集合(分-时=360-n,秒-时=360-n,秒-分=360-n)中，并且是临界结束集合的最小值。这样只求两个临界集合就行了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;double max(double a,double b,double c)&#123; double max=a&gt;b?a:b; return max&gt;c?max:c;&#125;double min(double a,double b,double c)&#123; double min=a&lt;b?a:b; return min&lt;c?min:c;&#125;int main()&#123; freopen(\"input.txt\", \"r\", stdin);double n;while(cin&gt;&gt;n&amp;&amp;n!=-1)&#123; double maxx=12*60*60; double shij=30.0/60/60; double fenj=6/60.0; double miaoj=6/1.0; double sfx=fenj-shij; double smx=miaoj-shij; double fmx=miaoj-fenj; double sfz=360/sfx; double sfn=n/sfx; double sf_n=(360-n)/sfx; double fmz=360/fmx; double fmn=n/fmx; double fm_n=(360-n)/fmx; double smz=360/smx; double smn=n/smx; double sm_n=(360-n)/smx; double shichang=0; for(double i=0;i&lt;=maxx;i+=sfz) &#123; for(double j=0;j&lt;=maxx;j+=fmz) &#123; if(j+fm_n&lt;i+sfn) continue; if(i+sf_n&lt;j+fmn) break; for(double k=0;k&lt;=maxx;k+=smz) &#123; if(k+sm_n&lt;i+sfn||k+sm_n&lt;j+fmn) continue; if(j+fm_n&lt;k+smn||i+sf_n&lt;k+smn) break; double kaishi=max(i+sfn,j+fmn,k+smn); double jieshu=min(i+sf_n,j+fm_n,k+sm_n); if(jieshu&gt;kaishi) shichang+=jieshu-kaishi; &#125; &#125; &#125; printf(\"%.3f\\n\",100.0*shichang/maxx); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"盲集合求交","slug":"ACM/盲集合求交","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%9B%B2%E9%9B%86%E5%90%88%E6%B1%82%E4%BA%A4/"}],"tags":[{"name":"临界最优","slug":"临界最优","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%B4%E7%95%8C%E6%9C%80%E4%BC%98/"},{"name":"屏蔽细节","slug":"屏蔽细节","permalink":"https://donghuangzhong.github.io/tags/%E5%B1%8F%E8%94%BD%E7%BB%86%E8%8A%82/"}]},{"title":"HDU-1005","slug":"HDU-1005","date":"2020-02-09T04:33:27.000Z","updated":"2020-02-09T05:45:39.499Z","comments":true,"path":"2020/02/09/HDU-1005/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/09/HDU-1005/","excerpt":"这个题大家第一次应该都是超时吧，这个题网上流传的%49或者%48都是错误的，大家反而觉得他们解释的逻辑很对，我也是服了，这么一份错答案竟然能够横扫CSDN！能够在网络上横行！HDUOJ也真是水！后台数据太水了！！！","text":"这个题大家第一次应该都是超时吧，这个题网上流传的%49或者%48都是错误的，大家反而觉得他们解释的逻辑很对，我也是服了，这么一份错答案竟然能够横扫CSDN！能够在网络上横行！HDUOJ也真是水！后台数据太水了！！！ 题目Number Sequence\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 234505 Accepted Submission(s): 59544** Problem Description A number sequence is defined as follows: f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7. Given A, B, and n, you are to calculate the value of f(n). Input The input consists of multiple test cases. Each test case contains 3 integers A, B and n on a single line (1 &lt;= A, B &lt;= 1000, 1 &lt;= n &lt;= 100,000,000). Three zeros signal the end of input and this test case is not to be processed. Output For each test case, print the value of f(n) on a single line. Sample Input 1231 1 31 2 100 0 0 Sample Output 1225 代码算法这个确实要用到循环节，公式为f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7由前两项推出第三项，所以如果出现连续两项相同，后面的也完全相同，对7取余，结果为0~6，一项有7种可能，将连续两项(2n+1,2n+2)看做一个循环节，则循环节共有7*7=49种可能，所以根据抽屉原理，前50个循环节内，必然存在两个一样的循环节，第一个循环节后的序列为周期序列，整个序列不一定是周期序列。例如序列:3、4项分别和13、14项相同，则从第3项开始，这个序列才是周期序列，整个序列不一定是周期序列。所以算出前100项，找出两个相同循环节(位置分别为a,b)，周期t=b-a，则从a开始，这个序列为周期序列，n&lt;=a，则直接输出，n&gt;a，则输出第(n-a)%t+a项 测试数据如果取余49是正确的，那么就是说第50项一定为1。写代码的不觉得荒谬吗！测试数据1 5 50，自己去测试吧，可以用你们超时代码(超时代码的结果一定是正确的，只是时间太长)的测试结果和网上所谓取余49的代码的结果对比 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); int a,b,n,y,t,kaishi; int jieguo[101]; jieguo[1]=jieguo[2]=1; while((cin&gt;&gt;a&amp;&amp;cin&gt;&gt;b&amp;&amp;cin&gt;&gt;n)&amp;&amp;!(a==0&amp;&amp;b==0&amp;&amp;n==0)) &#123; for(int i=3;i&lt;=100;i++) jieguo[i]=(a*jieguo[i-1]+b*jieguo[i-2])%7; t=-1; for(int i=1;i&lt;=99;i+=2) &#123; if(t!=-1) break; for(int j=i+2;j&lt;=99;j+=2) &#123; if(jieguo[i]==jieguo[j]&amp;&amp;jieguo[i+1]==jieguo[j+1]) &#123; t=j-i; kaishi=i; break; &#125; &#125; &#125; if(n&lt;=kaishi) cout&lt;&lt;jieguo[n]&lt;&lt;endl; else cout&lt;&lt;jieguo[(n-kaishi)%t+kaishi]&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"大数动态周期","slug":"ACM/大数动态周期","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0%E5%8A%A8%E6%80%81%E5%91%A8%E6%9C%9F/"}],"tags":[{"name":"斐波那契取余版","slug":"斐波那契取余版","permalink":"https://donghuangzhong.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%8F%96%E4%BD%99%E7%89%88/"},{"name":"动态周期","slug":"动态周期","permalink":"https://donghuangzhong.github.io/tags/%E5%8A%A8%E6%80%81%E5%91%A8%E6%9C%9F/"}]},{"title":"HUD-1004","slug":"HUD-1004","date":"2020-02-07T09:38:59.000Z","updated":"2020-02-07T09:48:03.437Z","comments":true,"path":"2020/02/07/HUD-1004/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/07/HUD-1004/","excerpt":"我在本题没有用map,因为一开始没有过map,用的话还得去查怎么使用，我的算法是统计每一个颜色出现的次数，取最大值的下标，存在的问题是可能超时。但令我不解的是C++显示编译错误，G++ AC。while(cin&gt;&gt;n&amp;&amp;n)","text":"我在本题没有用map,因为一开始没有过map,用的话还得去查怎么使用，我的算法是统计每一个颜色出现的次数，取最大值的下标，存在的问题是可能超时。但令我不解的是C++显示编译错误，G++ AC。while(cin&gt;&gt;n&amp;&amp;n) 问题Let the Balloon Rise\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 175113 Accepted Submission(s): 69765** Problem Description Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges’ favorite time is guessing the most popular problem. When the contest is over, they will count the balloons of each color and find the result. This year, they decide to leave this lovely job to you. Input Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 1000) – the total number of balloons distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case letters. A test case with N = 0 terminates the input and this test case is not to be processed. Output For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a unique solution for each test case. Sample Input 12345678910115greenredblueredred3pinkorangepink0 Sample Output 12redpink 代码(G++下AC，C++下编译错误)1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; freopen(\"input.txt\", \"r\", stdin); string color[1000]; int n,max; int xiabiao; while(cin&gt;&gt;n&amp;&amp;n) &#123; max=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;color[i]; &#125; for(int j=0;j&lt;n;j++) &#123; int num=0; for(int k=0;k&lt;n;k++) &#123; if(color[j]==color[k]) num++; &#125; if(num&gt;max)&#123; xiabiao=j; max=num; &#125; &#125; cout&lt;&lt;color[xiabiao]&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"字典","slug":"ACM/字典","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E5%85%B8/"}],"tags":[{"name":"map","slug":"map","permalink":"https://donghuangzhong.github.io/tags/map/"},{"name":"字典","slug":"字典","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E5%85%B8/"}]},{"title":"HDU-1003","slug":"HDU-1003","date":"2020-02-07T08:06:14.000Z","updated":"2020-04-01T04:17:51.696Z","comments":true,"path":"2020/02/07/HDU-1003/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/07/HDU-1003/","excerpt":"这个问题作者都描述错了，应该是如果有多个结果，输出end最靠后，start最靠前的那个结果。这个和1002质量都不行，原来和1002是同一个作者","text":"这个问题作者都描述错了，应该是如果有多个结果，输出end最靠后，start最靠前的那个结果。这个和1002质量都不行，原来和1002是同一个作者 题目Max Sum\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 344830 Accepted Submission(s): 82002** Problem Description Given a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000). Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases. Sample Input 12325 6 -1 5 4 -77 0 6 -1 1 -6 7 -5 Sample Output 12345Case 1:14 1 4Case 2:7 1 6 代码:验证作者描述错误的序列:-100 5 5 -100 1 -1 10 -100 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); int t; cin&gt;&gt;t; for(int i=1;i&lt;=t;i++)&#123; int n,max,kaishi,jieshu,shuzi; max=0; int maxmax=-1; int maxkaishi,maxjieshu; cin&gt;&gt;n; kaishi=1; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;shuzi; if(max&gt;=0)&#123; max+=shuzi; jieshu=j; &#125; else &#123; max=shuzi; kaishi=j; jieshu=j; &#125; if(max&gt;=maxmax)&#123; maxmax=max; maxkaishi=kaishi; maxjieshu=jieshu; &#125; &#125; cout&lt;&lt;\"Case \"&lt;&lt;i&lt;&lt;\":\"&lt;&lt;endl&lt;&lt;maxmax&lt;&lt;\" \"&lt;&lt;maxkaishi&lt;&lt;\" \"&lt;&lt;maxjieshu&lt;&lt;endl; if(i!=t)cout&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"}],"tags":[{"name":"最大连续子序列","slug":"最大连续子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"}]},{"title":"HDU-1002","slug":"HDU-1002","date":"2020-02-06T10:50:21.000Z","updated":"2020-02-07T04:48:36.242Z","comments":true,"path":"2020/02/06/HDU-1002/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/06/HDU-1002/","excerpt":"此题在杭电oj上有问题，AC了也不一定代表可以正确，还有dev-cpp5.4.0这个环境，结束时自动输出一行换行","text":"此题在杭电oj上有问题，AC了也不一定代表可以正确，还有dev-cpp5.4.0这个环境，结束时自动输出一行换行 题目A + B Problem II\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 514958 Accepted Submission(s): 98584** Problem Description I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000. Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line is the an equation “A + B = Sum”, Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases. Sample Input 12321 2112233445566778899 998877665544332211 Sample Output 1234Case 1:1 + 2 &#x3D; 3Case 2: 步骤代码1：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); int n,ai,ci,j,sum,jinwei; char a[1000]; char c[1000]; char he[1000]; cin&gt;&gt;n; for(int k=1;k&lt;=n;k++) &#123; cout&lt;&lt;\"Case \"&lt;&lt;k&lt;&lt;\":\"&lt;&lt;endl; cin&gt;&gt;a&gt;&gt;c; cout&lt;&lt;a&lt;&lt;\" + \"&lt;&lt;c&lt;&lt;\" = \"; ai=strlen(a)-1; ci=strlen(c)-1; jinwei=0; int hei=0; while(ai&gt;=0&amp;&amp;ci&gt;=0) &#123; sum=a[ai]-'0'+c[ci]-'0'+jinwei; he[hei++]=sum%10+'0'; jinwei=sum&gt;=10?1:0; ai--; ci--; &#125; while(ai&gt;=0) &#123; sum=a[ai]-'0'+jinwei; he[hei++]=sum%10+'0'; jinwei=sum&gt;=10?1:0; ai--; &#125; while(ci&gt;=0)&#123; sum=c[ci]-'0'+jinwei; he[hei++]=sum%10+'0'; jinwei=sum&gt;=10?1:0; ci--; &#125; hei--; if(jinwei!=0) cout&lt;&lt;jinwei; while(hei&gt;=0) cout&lt;&lt;he[hei--]; cout&lt;&lt;endl; if(k!=n) cout&lt;&lt;endl;&#125;&#125; 错误的AC代码(未考虑进位，结果错误，但还是AC了，输出1+9=0)：由此可见，杭电oj部分题目的后台测试还是不太准确 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); int n,b,d; cin&gt;&gt;n; char a[1000]; char c[1000]; //cin&gt;&gt;n; for(int k=1;k&lt;=n;k++) &#123; cout&lt;&lt;\"Case \"&lt;&lt;k&lt;&lt;\":\"&lt;&lt;endl; cin&gt;&gt;a&gt;&gt;c; cout&lt;&lt;a&lt;&lt;\" + \"&lt;&lt;c&lt;&lt;\" = \"; int j; for(j=0;j&lt;1000;j++) if(a[j]=='\\0') break; b=j; for(j=0;j&lt;1000;j++) if(c[j]=='\\0') break; d=j; //cout&lt;&lt;b&lt;&lt;d; int min=b; if(min&gt;d) min=d; int jinwei=0; int sum; for(int i=1;i&lt;=min;i++)&#123; sum=a[b-i]-'0'+c[d-i]-'0'+jinwei; c[d-i]=sum%10+'0'; //cout&lt;&lt;c[d-i]&lt;&lt;\"\"; jinwei=sum/10; &#125; //cout&lt;&lt;endl; if(min==b) &#123; c[d-min-1]+=jinwei; cout&lt;&lt;c; cout&lt;&lt;endl; &#125; else&#123; a[b-min-1]+=jinwei; for(int i=0;i&lt;=b-min-1;i++) cout&lt;&lt;a[i]; for(int i=d-min;i&lt;=d-1;i++) cout&lt;&lt;c[i]; cout&lt;&lt;endl; &#125;if(k!=n) cout&lt;&lt;endl;&#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"大数","slug":"ACM/大数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0/"}],"tags":[{"name":"大数","slug":"大数","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0/"},{"name":"大数加法","slug":"大数加法","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95/"}]},{"title":"HDU-1001","slug":"HDU-1001","date":"2020-02-06T01:59:33.000Z","updated":"2020-02-06T02:57:26.129Z","comments":true,"path":"2020/02/06/HDU-1001/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/06/HDU-1001/","excerpt":"这个题的平均通过比率大约为0.25(20200206)，平均提交四次才能通过。确实有一个大陷阱，这道题需要我们了解C语言的基本知识和计算机中的运算过程。","text":"这个题的平均通过比率大约为0.25(20200206)，平均提交四次才能通过。确实有一个大陷阱，这道题需要我们了解C语言的基本知识和计算机中的运算过程。 题目Sum Problem \\Time Limit: 1000/500 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 677426 Accepted Submission(s): 170938** Problem Description Hey, welcome to HDOJ(Hangzhou Dianzi University Online Judge). In this problem, your task is to calculate SUM(n) = 1 + 2 + 3 + … + n. Input The input will consist of a series of integers n, one integer per line. Output For each case, output SUM(n) in one line, followed by a blank line. You may assume the result will be in the range of 32-bit signed integer. Sample Input 121100 Sample Output 12315050 C语言中IO和运算过程例如cin&gt;&gt;a;在屏幕上输入5然后点回车，存储过程为将5的补码存到a对应的地址，然后对这个补码进行运算。 例如2*a+1先计算2*a存到一个地方b，然后运算b+1。运算过程为一步一步的，每一步都保存结果，这样就导致了在运算过程中可能导致临时的结果溢出，例如本题中计算1+2+3+···+N有好多种算法(循环累加和公式法)，我们都会下意识的用比较简单的n*(n+1)/2，题目中告诉我们n*(n+1)/2在有符号整形的范围之内，但是计算n*(n+1)的时候要保存一个临时结果，这个结果是有可能比有符号整形大的，所以最终结果不准确。 解决方法调整运算顺序将增大运算和减小运算交错排布将n*(n+1)/2调整为n/2*(n+1)(n为偶数)或(n+1)/2*n(n+1为偶数) 12345678910111213#include &lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std; int main()&#123; int a; while(cin&gt;&gt;a)&#123; if(a%2==0) cout&lt;&lt;a/2*(a+1)&lt;&lt;endl&lt;&lt;endl; else cout&lt;&lt;(a+1)/2*a&lt;&lt;endl&lt;&lt;endl; &#125; return 0;&#125; 消除运算过程中的减小运算(将公式法改为累加法)1234567891011121314#include &lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std; int main()&#123; int a; while(cin&gt;&gt;a) &#123; int sum=0; for(int i=1;i&lt;=a;i++) sum+=i; cout&lt;&lt;sum&lt;&lt;endl&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"易错题","slug":"ACM/易错题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%98%93%E9%94%99%E9%A2%98/"}],"tags":[{"name":"大数陷阱","slug":"大数陷阱","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%99%B7%E9%98%B1/"},{"name":"代数式最大化部分溢出","slug":"代数式最大化部分溢出","permalink":"https://donghuangzhong.github.io/tags/%E4%BB%A3%E6%95%B0%E5%BC%8F%E6%9C%80%E5%A4%A7%E5%8C%96%E9%83%A8%E5%88%86%E6%BA%A2%E5%87%BA/"},{"name":"补码","slug":"补码","permalink":"https://donghuangzhong.github.io/tags/%E8%A1%A5%E7%A0%81/"},{"name":"计算机中运算过程","slug":"计算机中运算过程","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B/"}]},{"title":"HDU-1000","slug":"HDU-1000","date":"2020-02-05T01:17:01.000Z","updated":"2020-02-05T03:18:13.166Z","comments":true,"path":"2020/02/05/HDU-1000/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/05/HDU-1000/","excerpt":"C语言中EOF，C++中EOF，用input.txt代替手工输入，提高解题的测试速度","text":"C语言中EOF，C++中EOF，用input.txt代替手工输入，提高解题的测试速度 题目 A + B Problem Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 944642 Accepted Submission(s): 281848 Problem Description Calculate A + B. Input Each line will contain two integers A and B. Process to end of file. Output For each case, output A + B in one line. Sample Input 11 1 Sample Output 12 C语言EOF 1while(scanf(\"%d%d\",&amp;a,&amp;b)!=EOF) C++EOF 1while(cin&gt;&gt;a&gt;&gt;b)&#123; 用input.txt代替手工输入 在源程序文件(.c、.cpp)的同级目录新建intut.txt文件，里面模拟手工输入的数据 在源程序中main()函数开始处添加代码(要添加#include&lt;stdio.h&gt;头文件)，！！！提交代码前一定要注释掉这行代码 12345#include&lt;stdio.h&gt;int main()&#123; freopen(\"input.txt\", \"r\", stdin);&#125; 本题AC代码： 1234567891011#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; freopen(\"input.txt\", \"r\", stdin); int a,b; while(cin&gt;&gt;a&gt;&gt;b)&#123; cout&lt;&lt;a+b&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"}],"tags":[{"name":"EOF","slug":"EOF","permalink":"https://donghuangzhong.github.io/tags/EOF/"},{"name":"C++文件代替手工输入","slug":"C-文件代替手工输入","permalink":"https://donghuangzhong.github.io/tags/C-%E6%96%87%E4%BB%B6%E4%BB%A3%E6%9B%BF%E6%89%8B%E5%B7%A5%E8%BE%93%E5%85%A5/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-03T04:41:43.819Z","updated":"2020-02-03T04:58:24.929Z","comments":true,"path":"2020/02/03/hello-world/","link":"","permalink":"https://donghuangzhong.github.io/2020/02/03/hello-world/","excerpt":"使用方法","text":"使用方法 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/categories/hexo/"}],"tags":[]},{"title":"ACM-BFS","slug":"ACM-BFS","date":"2019-08-31T06:45:05.000Z","updated":"2020-02-03T04:02:29.707Z","comments":true,"path":"2019/08/31/ACM-BFS/","link":"","permalink":"https://donghuangzhong.github.io/2019/08/31/ACM-BFS/","excerpt":"摘要","text":"摘要 1.BFS的作用：遍历图找到与步长强相关的属性的最优解（也可以附带路径）2.原理起点入队，起点出队，从出队点开始下一步可以到达（符合条件）的所有点入队，队首再出队，从出队点开始下一步可以到达（符合条件）的所有点入队……。总之，步长为n的所有符合条件的点依次批量入队（n=0,1,2……），所以最先访问即步长最短，与步长相关的例如路径长度，消耗的时间最短，即最先访问即最优！ 3.判断是否可以回头(不可随意重复访问标志的设立) 传统01：不可重复访问 如果图中存在能量补充点、时间重置点等等是可以回头的，可以回头的条件是剩余的能量或时间要大于上一次来到这个点时的剩余能量或时间 4.初始化 三个数组 地图数组（一般二维，可三维）：存放墙，可走点，能量补充点、时间充值点 路径变换数组（s[走法种类数][维度]）：通常加法变换，也可以写成乘法矩阵变换 随意访问的数组（跟地图数组一个格式的结构体）：存标志量(传统01，上次到此点剩余能量时间)、路径量(这个点的上一个点的坐标）、其他想随时访问的属性 队列节点结构体 含x,y和仅终点访问的属性 3.实现方式（按常用程度排序） C自带队列 缺点：无法随意访问队列中任意节点，所以如果想要随时访问一个属性，此属性可以存在随意访问数组中 优点：书写简介方便 头文件：#include &lt;queue&gt; 定义代码：queue&lt;node&gt; q; node:可以是结构体，一般含有x,y和仅终点访问的属性 通用代码： 12345678910111213141516171819202122232425262728293031323334353637void dfs()&#123; queue&lt;node&gt; q; node a,b;//a:起点、当前节点、出队点;b:下一节点 …………//初始化a …………/*初始化其他的不可计算量（不可通过上一节点计算的，比如上一次到达这个节点的剩余的时间或者能量） 用lasttime[][],memset(lastime,0,sizeof(lasttime))*/ …………//设置a点不可计算量 if(…………)&#123;…………;return;&#125;//判断起点是不是最优解 q.push(a); while(!q.empty()) &#123; a=q.front(); q.pop(); if(…………)//当前节点必须可以走下一步，比如能量没用完，时间还有 //有些时候规定到达终点时间为0不算，要&gt;1 &#123; for(i=0;i&lt;4;++i)//向题目中规定的方向走 &#123; b.x=a.x+s[i][0];//s数组存储变换矩阵,s[变幻种类][维度] b.y=a.y+s[i][1];//当然也可以写成乘法那种矩阵 if()//判断是不是越界、和走到墙壁位置（如果是传统01标志现在就可以判断） &#123; …………//计算b if(…………)&#123;&#125;//判断是不是能量补充点、时间重置点等等 else&#123;&#125;//如果不是要消耗能量和时间 if(能量和剩余时间&lt;=上一次到达此点的能量和时间)&#123;…………;continue;&#125; //非01标志判断可不可以重复访问 if()&#123;return;&#125;//判断是不是终点，如果自定义队列求路径可以放在入队之后 …………//更新不可计算量（包括01标志） q.push(b); &#125; &#125; &#125; &#125; …………//输出不能到达终点&#125; 自定义队列（需要知道程序需要的最大队列节点数） 自己写队列，不释放入队节点，只移动队首下标。所以可以随意访问队列中任意元素，在求解路径中只需要在队列的结构体中添加一个上一个节点的下标的属性就可以 优点：方便求解路径 队列元素结构：struct point{int x,y,s;};s代表来源点的下标 队列结构：struct p{point pp[1000];int t,w;};其中t表示队列的头，w表示队列的尾 push():d.pp[d.w++]=a; !empty():d.w!=d.t front()&amp;pop():a=d.pp[d.t++]; 递归（没什么意义，还是用的队列） 就是原函数初始化在外面，while()循环体单独写成BFS函数，用!q.empty()判断是否运行此函数 dfs()1234567891011121314151617181920212223242526272829303132333435363738394041424344void dfs()&#123; a&#x3D;q.front(); q.pop(); if(…………)&#x2F;&#x2F;当前节点必须可以走下一步，比如能量没用完，时间还有 &#x2F;&#x2F;有些时候规定到达终点时间为0不算，要&gt;1 &#123; for(i&#x3D;0;i&lt;4;++i)&#x2F;&#x2F;向题目中规定的方向走 &#123; b.x&#x3D;a.x+s[i][0];&#x2F;&#x2F;s数组存储变换矩阵,s[变幻种类][维度] b.y&#x3D;a.y+s[i][1];&#x2F;&#x2F;当然也可以写成乘法那种矩阵 if()&#x2F;&#x2F;判断是不是越界、和走到墙壁位置（如果是传统01标志现在就可以判断） &#123; …………&#x2F;&#x2F;计算b if(…………)&#123;&#125;&#x2F;&#x2F;判断是不是能量补充点、时间重置点等等 else&#123;&#125;&#x2F;&#x2F;如果不是要消耗能量和时间 if(能量和剩余时间&lt;&#x3D;上一次到达此点的能量和时间)&#123;…………;continue;&#125; &#x2F;&#x2F;非01标志判断可不可以重复访问 if()&#123;return;&#125;&#x2F;&#x2F;判断是不是终点，如果自定义队列求路径可以放在入队之后 …………&#x2F;&#x2F;更新不可计算量（包括01标志） q.push(b); &#125; &#125; &#125; if(!q.empty()) dfs(); else …………;&#x2F;&#x2F;输出不能到达终点&#125;queue&lt;node&gt; q;node a,b;&#x2F;&#x2F;a:起点、当前节点、出队点;b:下一节点int main()&#123; …………&#x2F;&#x2F;初始化a …………&#x2F;*初始化其他的不可计算量（不可通过上一节点计算的，比如上一次到达这个节点的剩余的时间或者能量） 用lasttime[][],memset(lastime,0,sizeof(lasttime))*&#x2F; …………&#x2F;&#x2F;设置a点不可计算量 if(…………)&#123;…………;return;&#125;&#x2F;&#x2F;判断起点是不是最优解 q.push(a); if(!q.empty()) dfs(); &#125; 4. 路径打印因为一个点的来源只有一个，但一个点的去处可能有好多点，所以在存储路径的时候一般存储这个点的上一个点，但这样就出现了一个问题，打印路径的时候是倒着的，一般有两种方法解决这个问题，其实是一种 初始化 起点的前一个点的参数设置为-1，自带队列：a[0][0].x=a[0][0].y=-1;自定义：a.s=-1; 递归（隐式调用栈） c自带队列 12345678void print(int x,int y或者int n)&#x2F;&#x2F;注意参数是-，null-0-0-0-&#123;if(x&#x3D;&#x3D;-1&amp;&amp;y&#x3D;&#x3D;-1或者s&#x3D;&#x3D;-1) return ; print(a[x][y].x,a[x][y].y或者p.a[n].s); cout&lt;&lt;x&lt;&lt;y或者cout&lt;&lt;p.a[n].x&lt;&lt;p.a[n].y; &#125; 显式用栈:没什么意义，写起来不方便","categories":[{"name":"工具","slug":"工具","permalink":"https://donghuangzhong.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://donghuangzhong.github.io/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"https://donghuangzhong.github.io/tags/DFS/"}]}],"categories":[{"name":"sublime","slug":"sublime","permalink":"https://donghuangzhong.github.io/categories/sublime/"},{"name":"js","slug":"sublime/js","permalink":"https://donghuangzhong.github.io/categories/sublime/js/"},{"name":"js","slug":"js","permalink":"https://donghuangzhong.github.io/categories/js/"},{"name":"常用js","slug":"js/常用js","permalink":"https://donghuangzhong.github.io/categories/js/%E5%B8%B8%E7%94%A8js/"},{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/categories/java/"},{"name":"idea","slug":"java/idea","permalink":"https://donghuangzhong.github.io/categories/java/idea/"},{"name":"spring","slug":"java/spring","permalink":"https://donghuangzhong.github.io/categories/java/spring/"},{"name":"SQL","slug":"java/SQL","permalink":"https://donghuangzhong.github.io/categories/java/SQL/"},{"name":"web相关","slug":"java/web相关","permalink":"https://donghuangzhong.github.io/categories/java/web%E7%9B%B8%E5%85%B3/"},{"name":"maven","slug":"java/maven","permalink":"https://donghuangzhong.github.io/categories/java/maven/"},{"name":"目标检测","slug":"目标检测","permalink":"https://donghuangzhong.github.io/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"Linux","slug":"Linux","permalink":"https://donghuangzhong.github.io/categories/Linux/"},{"name":"python","slug":"python","permalink":"https://donghuangzhong.github.io/categories/python/"},{"name":"深度学习","slug":"深度学习","permalink":"https://donghuangzhong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"TersorFlow","slug":"TersorFlow","permalink":"https://donghuangzhong.github.io/categories/TersorFlow/"},{"name":"Hexo","slug":"Hexo","permalink":"https://donghuangzhong.github.io/categories/Hexo/"},{"name":"VM","slug":"VM","permalink":"https://donghuangzhong.github.io/categories/VM/"},{"name":"category1","slug":"category1","permalink":"https://donghuangzhong.github.io/categories/category1/"},{"name":"category2","slug":"category1/category2","permalink":"https://donghuangzhong.github.io/categories/category1/category2/"},{"name":"tools","slug":"java/tools","permalink":"https://donghuangzhong.github.io/categories/java/tools/"},{"name":"配置文件","slug":"java/配置文件","permalink":"https://donghuangzhong.github.io/categories/java/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"name":"个人博客","slug":"个人博客","permalink":"https://donghuangzhong.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"博客搭建","slug":"个人博客/博客搭建","permalink":"https://donghuangzhong.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://donghuangzhong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"多边形填充","slug":"计算机图形学/多边形填充","permalink":"https://donghuangzhong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%A1%AB%E5%85%85/"},{"name":"ACM","slug":"ACM","permalink":"https://donghuangzhong.github.io/categories/ACM/"},{"name":"category2","slug":"ACM/category2","permalink":"https://donghuangzhong.github.io/categories/ACM/category2/"},{"name":"DP","slug":"ACM/DP","permalink":"https://donghuangzhong.github.io/categories/ACM/DP/"},{"name":"水题","slug":"ACM/水题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%B0%B4%E9%A2%98/"},{"name":"逻辑","slug":"ACM/逻辑","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%BB%E8%BE%91/"},{"name":"字符串","slug":"ACM/字符串","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"双向链表","slug":"ACM/双向链表","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"贪心","slug":"ACM/贪心","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%B4%AA%E5%BF%83/"},{"name":"快速幂","slug":"ACM/快速幂","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"爬虫","slug":"python/爬虫","permalink":"https://donghuangzhong.github.io/categories/python/%E7%88%AC%E8%99%AB/"},{"name":"RMQ","slug":"ACM/RMQ","permalink":"https://donghuangzhong.github.io/categories/ACM/RMQ/"},{"name":"tools","slug":"tools","permalink":"https://donghuangzhong.github.io/categories/tools/"},{"name":"C++","slug":"tools/C","permalink":"https://donghuangzhong.github.io/categories/tools/C/"},{"name":"解题报告","slug":"ACM/解题报告","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"高级dfs","slug":"ACM/高级dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%AB%98%E7%BA%A7dfs/"},{"name":"dfs","slug":"ACM/dfs","permalink":"https://donghuangzhong.github.io/categories/ACM/dfs/"},{"name":"回文","slug":"ACM/回文","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%9B%9E%E6%96%87/"},{"name":"进制","slug":"ACM/进制","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%BF%9B%E5%88%B6/"},{"name":"矩阵乘法","slug":"ACM/矩阵乘法","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"},{"name":"线段交","slug":"ACM/线段交","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%BA%BF%E6%AE%B5%E4%BA%A4/"},{"name":"质因数","slug":"ACM/质因数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E8%B4%A8%E5%9B%A0%E6%95%B0/"},{"name":"递归","slug":"ACM/递归","permalink":"https://donghuangzhong.github.io/categories/ACM/%E9%80%92%E5%BD%92/"},{"name":"Huffuman","slug":"ACM/Huffuman","permalink":"https://donghuangzhong.github.io/categories/ACM/Huffuman/"},{"name":"大数","slug":"ACM/大数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0/"},{"name":"SPFA","slug":"ACM/SPFA","permalink":"https://donghuangzhong.github.io/categories/ACM/SPFA/"},{"name":"Bellman","slug":"ACM/Bellman","permalink":"https://donghuangzhong.github.io/categories/ACM/Bellman/"},{"name":"Floyd","slug":"ACM/Floyd","permalink":"https://donghuangzhong.github.io/categories/ACM/Floyd/"},{"name":"dij","slug":"ACM/dij","permalink":"https://donghuangzhong.github.io/categories/ACM/dij/"},{"name":"BFS","slug":"ACM/BFS","permalink":"https://donghuangzhong.github.io/categories/ACM/BFS/"},{"name":"DFS","slug":"ACM/DFS","permalink":"https://donghuangzhong.github.io/categories/ACM/DFS/"},{"name":"二进制","slug":"ACM/二进制","permalink":"https://donghuangzhong.github.io/categories/ACM/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"开关","slug":"ACM/开关","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%BC%80%E5%85%B3/"},{"name":"因数","slug":"ACM/因数","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%9B%A0%E6%95%B0/"},{"name":"盲集合求交","slug":"ACM/盲集合求交","permalink":"https://donghuangzhong.github.io/categories/ACM/%E7%9B%B2%E9%9B%86%E5%90%88%E6%B1%82%E4%BA%A4/"},{"name":"大数动态周期","slug":"ACM/大数动态周期","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%A4%A7%E6%95%B0%E5%8A%A8%E6%80%81%E5%91%A8%E6%9C%9F/"},{"name":"字典","slug":"ACM/字典","permalink":"https://donghuangzhong.github.io/categories/ACM/%E5%AD%97%E5%85%B8/"},{"name":"易错题","slug":"ACM/易错题","permalink":"https://donghuangzhong.github.io/categories/ACM/%E6%98%93%E9%94%99%E9%A2%98/"},{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/categories/hexo/"},{"name":"工具","slug":"工具","permalink":"https://donghuangzhong.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"js","slug":"js","permalink":"https://donghuangzhong.github.io/tags/js/"},{"name":"sublime","slug":"sublime","permalink":"https://donghuangzhong.github.io/tags/sublime/"},{"name":"java","slug":"java","permalink":"https://donghuangzhong.github.io/tags/java/"},{"name":"idea","slug":"idea","permalink":"https://donghuangzhong.github.io/tags/idea/"},{"name":"spring","slug":"spring","permalink":"https://donghuangzhong.github.io/tags/spring/"},{"name":"spring_boot","slug":"spring-boot","permalink":"https://donghuangzhong.github.io/tags/spring-boot/"},{"name":"redis","slug":"redis","permalink":"https://donghuangzhong.github.io/tags/redis/"},{"name":"cookie","slug":"cookie","permalink":"https://donghuangzhong.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"https://donghuangzhong.github.io/tags/session/"},{"name":"response","slug":"response","permalink":"https://donghuangzhong.github.io/tags/response/"},{"name":"web","slug":"web","permalink":"https://donghuangzhong.github.io/tags/web/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://donghuangzhong.github.io/tags/Mybatis/"},{"name":"mybatis","slug":"mybatis","permalink":"https://donghuangzhong.github.io/tags/mybatis/"},{"name":"springmvc","slug":"springmvc","permalink":"https://donghuangzhong.github.io/tags/springmvc/"},{"name":"tag1","slug":"tag1","permalink":"https://donghuangzhong.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://donghuangzhong.github.io/tags/tag2/"},{"name":"spring+web","slug":"spring-web","permalink":"https://donghuangzhong.github.io/tags/spring-web/"},{"name":"maven","slug":"maven","permalink":"https://donghuangzhong.github.io/tags/maven/"},{"name":"jdbctemplate","slug":"jdbctemplate","permalink":"https://donghuangzhong.github.io/tags/jdbctemplate/"},{"name":"目标检测","slug":"目标检测","permalink":"https://donghuangzhong.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"WSL","slug":"WSL","permalink":"https://donghuangzhong.github.io/tags/WSL/"},{"name":"pandas","slug":"pandas","permalink":"https://donghuangzhong.github.io/tags/pandas/"},{"name":"numpy","slug":"numpy","permalink":"https://donghuangzhong.github.io/tags/numpy/"},{"name":"pyplot","slug":"pyplot","permalink":"https://donghuangzhong.github.io/tags/pyplot/"},{"name":"EL&JSTL","slug":"EL-JSTL","permalink":"https://donghuangzhong.github.io/tags/EL-JSTL/"},{"name":"_keras","slug":"keras","permalink":"https://donghuangzhong.github.io/tags/keras/"},{"name":"AlexNet","slug":"AlexNet","permalink":"https://donghuangzhong.github.io/tags/AlexNet/"},{"name":"jupyter","slug":"jupyter","permalink":"https://donghuangzhong.github.io/tags/jupyter/"},{"name":"GeForce940MX","slug":"GeForce940MX","permalink":"https://donghuangzhong.github.io/tags/GeForce940MX/"},{"name":"图片","slug":"图片","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%BE%E7%89%87/"},{"name":"数据库连接池","slug":"数据库连接池","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"name":"SpringTemplate","slug":"SpringTemplate","permalink":"https://donghuangzhong.github.io/tags/SpringTemplate/"},{"name":"VM","slug":"VM","permalink":"https://donghuangzhong.github.io/tags/VM/"},{"name":"共享文件","slug":"共享文件","permalink":"https://donghuangzhong.github.io/tags/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/"},{"name":"Java","slug":"Java","permalink":"https://donghuangzhong.github.io/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://donghuangzhong.github.io/tags/JDBC/"},{"name":"MySql","slug":"MySql","permalink":"https://donghuangzhong.github.io/tags/MySql/"},{"name":"Properties","slug":"Properties","permalink":"https://donghuangzhong.github.io/tags/Properties/"},{"name":"hexo","slug":"hexo","permalink":"https://donghuangzhong.github.io/tags/hexo/"},{"name":"github_pages","slug":"github-pages","permalink":"https://donghuangzhong.github.io/tags/github-pages/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"MFC","slug":"MFC","permalink":"https://donghuangzhong.github.io/tags/MFC/"},{"name":"W","slug":"W","permalink":"https://donghuangzhong.github.io/tags/W/"},{"name":"设状态","slug":"设状态","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%BE%E7%8A%B6%E6%80%81/"},{"name":"记忆化dfs","slug":"记忆化dfs","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96dfs/"},{"name":"滚动数组","slug":"滚动数组","permalink":"https://donghuangzhong.github.io/tags/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"},{"name":"二分查找(大小于)","slug":"二分查找-大小于","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%A4%A7%E5%B0%8F%E4%BA%8E/"},{"name":"最长公共子序列","slug":"最长公共子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"最长上升子序列","slug":"最长上升子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"最长(非)单调子序列","slug":"最长-非-单调子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF-%E9%9D%9E-%E5%8D%95%E8%B0%83%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"Dilworth定理","slug":"Dilworth定理","permalink":"https://donghuangzhong.github.io/tags/Dilworth%E5%AE%9A%E7%90%86/"},{"name":"简单DP","slug":"简单DP","permalink":"https://donghuangzhong.github.io/tags/%E7%AE%80%E5%8D%95DP/"},{"name":"高阶01背包","slug":"高阶01背包","permalink":"https://donghuangzhong.github.io/tags/%E9%AB%98%E9%98%B601%E8%83%8C%E5%8C%85/"},{"name":"无限背包","slug":"无限背包","permalink":"https://donghuangzhong.github.io/tags/%E6%97%A0%E9%99%90%E8%83%8C%E5%8C%85/"},{"name":"01可不满背包","slug":"01可不满背包","permalink":"https://donghuangzhong.github.io/tags/01%E5%8F%AF%E4%B8%8D%E6%BB%A1%E8%83%8C%E5%8C%85/"},{"name":"食物链","slug":"食物链","permalink":"https://donghuangzhong.github.io/tags/%E9%A3%9F%E7%89%A9%E9%93%BE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://donghuangzhong.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"记忆化递归","slug":"记忆化递归","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92/"},{"name":"邻接表","slug":"邻接表","permalink":"https://donghuangzhong.github.io/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"},{"name":"优先队列","slug":"优先队列","permalink":"https://donghuangzhong.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"vector","slug":"vector","permalink":"https://donghuangzhong.github.io/tags/vector/"},{"name":"正向DP","slug":"正向DP","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E5%90%91DP/"},{"name":"数塔","slug":"数塔","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E5%A1%94/"},{"name":"正反向思考","slug":"正反向思考","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E5%8F%8D%E5%90%91%E6%80%9D%E8%80%83/"},{"name":"转移方程的构造","slug":"转移方程的构造","permalink":"https://donghuangzhong.github.io/tags/%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E7%9A%84%E6%9E%84%E9%80%A0/"},{"name":"极度优化","slug":"极度优化","permalink":"https://donghuangzhong.github.io/tags/%E6%9E%81%E5%BA%A6%E4%BC%98%E5%8C%96/"},{"name":"多数组DP","slug":"多数组DP","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%9A%E6%95%B0%E7%BB%84DP/"},{"name":"背包","slug":"背包","permalink":"https://donghuangzhong.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"水题","slug":"水题","permalink":"https://donghuangzhong.github.io/tags/%E6%B0%B4%E9%A2%98/"},{"name":"字母","slug":"字母","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E6%AF%8D/"},{"name":"双向链表","slug":"双向链表","permalink":"https://donghuangzhong.github.io/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"索引表","slug":"索引表","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A2%E5%BC%95%E8%A1%A8/"},{"name":"整除2","slug":"整除2","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B4%E9%99%A42/"},{"name":"字符串比较","slug":"字符串比较","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"},{"name":"大数陷阱","slug":"大数陷阱","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%99%B7%E9%98%B1/"},{"name":"溢出陷阱","slug":"溢出陷阱","permalink":"https://donghuangzhong.github.io/tags/%E6%BA%A2%E5%87%BA%E9%99%B7%E9%98%B1/"},{"name":"贪心","slug":"贪心","permalink":"https://donghuangzhong.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数据规模","slug":"数据规模","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1/"},{"name":"二进制优化","slug":"二进制优化","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"},{"name":"wallpapers","slug":"wallpapers","permalink":"https://donghuangzhong.github.io/tags/wallpapers/"},{"name":"壁纸","slug":"壁纸","permalink":"https://donghuangzhong.github.io/tags/%E5%A3%81%E7%BA%B8/"},{"name":"ST","slug":"ST","permalink":"https://donghuangzhong.github.io/tags/ST/"},{"name":"STL","slug":"STL","permalink":"https://donghuangzhong.github.io/tags/STL/"},{"name":"蓝桥杯2020模拟赛","slug":"蓝桥杯2020模拟赛","permalink":"https://donghuangzhong.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"编码","slug":"编码","permalink":"https://donghuangzhong.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"动态二进制","slug":"动态二进制","permalink":"https://donghuangzhong.github.io/tags/%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"高级dfs","slug":"高级dfs","permalink":"https://donghuangzhong.github.io/tags/%E9%AB%98%E7%BA%A7dfs/"},{"name":"判断条件的先后","slug":"判断条件的先后","permalink":"https://donghuangzhong.github.io/tags/%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%88%E5%90%8E/"},{"name":"移动成回文最短","slug":"移动成回文最短","permalink":"https://donghuangzhong.github.io/tags/%E7%A7%BB%E5%8A%A8%E6%88%90%E5%9B%9E%E6%96%87%E6%9C%80%E7%9F%AD/"},{"name":"读数字","slug":"读数字","permalink":"https://donghuangzhong.github.io/tags/%E8%AF%BB%E6%95%B0%E5%AD%97/"},{"name":"妙用下标和","slug":"妙用下标和","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E4%B8%8B%E6%A0%87%E5%92%8C/"},{"name":"n维交","slug":"n维交","permalink":"https://donghuangzhong.github.io/tags/n%E7%BB%B4%E4%BA%A4/"},{"name":"分解质因数","slug":"分解质因数","permalink":"https://donghuangzhong.github.io/tags/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/"},{"name":"逻辑","slug":"逻辑","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"泛型编程","slug":"泛型编程","permalink":"https://donghuangzhong.github.io/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"},{"name":"函数模板","slug":"函数模板","permalink":"https://donghuangzhong.github.io/tags/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"},{"name":"龟兔赛跑","slug":"龟兔赛跑","permalink":"https://donghuangzhong.github.io/tags/%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91/"},{"name":"回形取数","slug":"回形取数","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/"},{"name":"字符串数组","slug":"字符串数组","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84/"},{"name":"八皇后问题","slug":"八皇后问题","permalink":"https://donghuangzhong.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"name":"黑白子","slug":"黑白子","permalink":"https://donghuangzhong.github.io/tags/%E9%BB%91%E7%99%BD%E5%AD%90/"},{"name":"两个最小值","slug":"两个最小值","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%A4%E4%B8%AA%E6%9C%80%E5%B0%8F%E5%80%BC/"},{"name":"大数阶乘","slug":"大数阶乘","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/"},{"name":"翻转边","slug":"翻转边","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E8%BE%B9/"},{"name":"来回总和最短","slug":"来回总和最短","permalink":"https://donghuangzhong.github.io/tags/%E6%9D%A5%E5%9B%9E%E6%80%BB%E5%92%8C%E6%9C%80%E7%9F%AD/"},{"name":"正环","slug":"正环","permalink":"https://donghuangzhong.github.io/tags/%E6%AD%A3%E7%8E%AF/"},{"name":"排名","slug":"排名","permalink":"https://donghuangzhong.github.io/tags/%E6%8E%92%E5%90%8D/"},{"name":"逻辑路径","slug":"逻辑路径","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E8%B7%AF%E5%BE%84/"},{"name":"最短路径","slug":"最短路径","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"负环","slug":"负环","permalink":"https://donghuangzhong.github.io/tags/%E8%B4%9F%E7%8E%AF/"},{"name":"有向图绕圈","slug":"有向图绕圈","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%89%E5%90%91%E5%9B%BE%E7%BB%95%E5%9C%88/"},{"name":"翻转矩阵","slug":"翻转矩阵","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5/"},{"name":"最大最小距离","slug":"最大最小距离","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"},{"name":"组内最短路径","slug":"组内最短路径","permalink":"https://donghuangzhong.github.io/tags/%E7%BB%84%E5%86%85%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"易错题","slug":"易错题","permalink":"https://donghuangzhong.github.io/tags/%E6%98%93%E9%94%99%E9%A2%98/"},{"name":"标志数组做记录","slug":"标志数组做记录","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%81%9A%E8%AE%B0%E5%BD%95/"},{"name":"遍历所有可能性","slug":"遍历所有可能性","permalink":"https://donghuangzhong.github.io/tags/%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E6%80%A7/"},{"name":"两次BFS","slug":"两次BFS","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%A4%E6%AC%A1BFS/"},{"name":"函数数组形参","slug":"函数数组形参","permalink":"https://donghuangzhong.github.io/tags/%E5%87%BD%E6%95%B0%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82/"},{"name":"倒水","slug":"倒水","permalink":"https://donghuangzhong.github.io/tags/%E5%80%92%E6%B0%B4/"},{"name":"数论","slug":"数论","permalink":"https://donghuangzhong.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"图的连通区域","slug":"图的连通区域","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%8C%BA%E5%9F%9F/"},{"name":"输出路径","slug":"输出路径","permalink":"https://donghuangzhong.github.io/tags/%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84/"},{"name":"妙用标志数组","slug":"妙用标志数组","permalink":"https://donghuangzhong.github.io/tags/%E5%A6%99%E7%94%A8%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"},{"name":"多入口BFS","slug":"多入口BFS","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%9A%E5%85%A5%E5%8F%A3BFS/"},{"name":"火场逃生","slug":"火场逃生","permalink":"https://donghuangzhong.github.io/tags/%E7%81%AB%E5%9C%BA%E9%80%83%E7%94%9F/"},{"name":"标志数组妙用","slug":"标志数组妙用","permalink":"https://donghuangzhong.github.io/tags/%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/"},{"name":"素数打表","slug":"素数打表","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A0%E6%95%B0%E6%89%93%E8%A1%A8/"},{"name":"逻辑相加妙用","slug":"逻辑相加妙用","permalink":"https://donghuangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E7%9B%B8%E5%8A%A0%E5%A6%99%E7%94%A8/"},{"name":"同余定理","slug":"同余定理","permalink":"https://donghuangzhong.github.io/tags/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/"},{"name":"二进制表示十进制","slug":"二进制表示十进制","permalink":"https://donghuangzhong.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%8D%81%E8%BF%9B%E5%88%B6/"},{"name":"翻转游戏","slug":"翻转游戏","permalink":"https://donghuangzhong.github.io/tags/%E7%BF%BB%E8%BD%AC%E6%B8%B8%E6%88%8F/"},{"name":"八皇后简化版","slug":"八皇后简化版","permalink":"https://donghuangzhong.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%80%E5%8C%96%E7%89%88/"},{"name":"特殊标志数组","slug":"特殊标志数组","permalink":"https://donghuangzhong.github.io/tags/%E7%89%B9%E6%AE%8A%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84/"},{"name":"递归范围","slug":"递归范围","permalink":"https://donghuangzhong.github.io/tags/%E9%80%92%E5%BD%92%E8%8C%83%E5%9B%B4/"},{"name":"素数环","slug":"素数环","permalink":"https://donghuangzhong.github.io/tags/%E7%B4%A0%E6%95%B0%E7%8E%AF/"},{"name":"回溯","slug":"回溯","permalink":"https://donghuangzhong.github.io/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"最长连续因数","slug":"最长连续因数","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%9B%A0%E6%95%B0/"},{"name":"按序列累除","slug":"按序列累除","permalink":"https://donghuangzhong.github.io/tags/%E6%8C%89%E5%BA%8F%E5%88%97%E7%B4%AF%E9%99%A4/"},{"name":"map","slug":"map","permalink":"https://donghuangzhong.github.io/tags/map/"},{"name":"字典","slug":"字典","permalink":"https://donghuangzhong.github.io/tags/%E5%AD%97%E5%85%B8/"},{"name":"摄氏华氏温度转换","slug":"摄氏华氏温度转换","permalink":"https://donghuangzhong.github.io/tags/%E6%91%84%E6%B0%8F%E5%8D%8E%E6%B0%8F%E6%B8%A9%E5%BA%A6%E8%BD%AC%E6%8D%A2/"},{"name":"统计数字的个数","slug":"统计数字的个数","permalink":"https://donghuangzhong.github.io/tags/%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"name":"沙漏","slug":"沙漏","permalink":"https://donghuangzhong.github.io/tags/%E6%B2%99%E6%BC%8F/"},{"name":"等差数列","slug":"等差数列","permalink":"https://donghuangzhong.github.io/tags/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/"},{"name":"电梯","slug":"电梯","permalink":"https://donghuangzhong.github.io/tags/%E7%94%B5%E6%A2%AF/"},{"name":"斐波那契","slug":"斐波那契","permalink":"https://donghuangzhong.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"},{"name":"兔子问题","slug":"兔子问题","permalink":"https://donghuangzhong.github.io/tags/%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98/"},{"name":"临界最优","slug":"临界最优","permalink":"https://donghuangzhong.github.io/tags/%E4%B8%B4%E7%95%8C%E6%9C%80%E4%BC%98/"},{"name":"屏蔽细节","slug":"屏蔽细节","permalink":"https://donghuangzhong.github.io/tags/%E5%B1%8F%E8%94%BD%E7%BB%86%E8%8A%82/"},{"name":"斐波那契取余版","slug":"斐波那契取余版","permalink":"https://donghuangzhong.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%8F%96%E4%BD%99%E7%89%88/"},{"name":"动态周期","slug":"动态周期","permalink":"https://donghuangzhong.github.io/tags/%E5%8A%A8%E6%80%81%E5%91%A8%E6%9C%9F/"},{"name":"最大连续子序列","slug":"最大连续子序列","permalink":"https://donghuangzhong.github.io/tags/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"大数","slug":"大数","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0/"},{"name":"大数加法","slug":"大数加法","permalink":"https://donghuangzhong.github.io/tags/%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95/"},{"name":"代数式最大化部分溢出","slug":"代数式最大化部分溢出","permalink":"https://donghuangzhong.github.io/tags/%E4%BB%A3%E6%95%B0%E5%BC%8F%E6%9C%80%E5%A4%A7%E5%8C%96%E9%83%A8%E5%88%86%E6%BA%A2%E5%87%BA/"},{"name":"补码","slug":"补码","permalink":"https://donghuangzhong.github.io/tags/%E8%A1%A5%E7%A0%81/"},{"name":"计算机中运算过程","slug":"计算机中运算过程","permalink":"https://donghuangzhong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B/"},{"name":"EOF","slug":"EOF","permalink":"https://donghuangzhong.github.io/tags/EOF/"},{"name":"C++文件代替手工输入","slug":"C-文件代替手工输入","permalink":"https://donghuangzhong.github.io/tags/C-%E6%96%87%E4%BB%B6%E4%BB%A3%E6%9B%BF%E6%89%8B%E5%B7%A5%E8%BE%93%E5%85%A5/"},{"name":"BFS","slug":"BFS","permalink":"https://donghuangzhong.github.io/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"https://donghuangzhong.github.io/tags/DFS/"}]}